[{"content":" 这是一个注意事项 解密 已加密，请输入密码 访问 ","date":"2024-03-21","tags":["公告"],"title":"公告","url":"/post/2024/03/notice/"},{"content":" 在普通拍卖中，人们总是倾向于压低自己的实际心理价位，生怕出价太高导致利润太少，或出价太低导致拿不到商品。\n二价拍卖又叫维克里拍卖、第二价格密封拍卖、二价拍卖、第二高价格拍卖，由维克里提出。这个理论的应用并不广泛，曾经在谷歌广告有大量的应用，但是由于投资回报率太低就放弃了。即便没有规模性应用，但不可否认其在诚实报价的研究方面有着重要的作用。\n下文统称为 “二价拍卖”。\n从拍卖过程说起 想象一下，你正在参与一场拍卖会。拍卖品是一件明代青花瓷器，每位参与者都会收到一张投标单，在上面写下愿意支付的价格。但这里有个规则：获胜者虽然是出价最高的人，但他只需要支付第二高的价格。在这场拍卖中，张三认为这件青花瓷值 10 万元，于是写下这个数字；李四觉得值 12 万元，也如实写下；而王五则出价 8 万元。最终，李四会以 10 万元（张三的出价）获得这件瓷器，尽管他原本愿意支付 12 万元。\n为什么我们需要二价拍卖？ 让我们回到传统拍卖会场景：一件珍贵的玉器正在竞拍，拍卖师不断抬高价格。现场的竞买者们面临着一个困境：如果出价太高，可能会付出超出物品实际价值的代价；如果出价太低，又可能错失心仪的藏品。\n这种情况下，人们往往会采取保守策略。想象一位收藏家，他心里认为一件文物值100万元，但担心竞争激烈，可能最终要支付120万才能得到，于是在竞价时故意压低出价到80万，希望能用更低的价格拿下。当所有人都这样做时，市场就无法反映物品的真实价值。\n二价拍卖巧妙地解决了这个问题。通过让获胜者支付第二高的价格，这种机制创造了一个重要的心理安全网：你的出价仅决定是否能够得到物品，而不直接决定你需要支付的金额。\n例如，在拍卖行中，一幅画正在进行二价拍卖。参与竞拍的有三位收藏家：\n老张是一位资深收藏家，经过仔细评估后认为这幅画值得85万元 小李是一家画廊的老板，基于市场行情，判断这幅画值90万元 老王是这位画家作品的忠实收藏者，愿意出价100万元 在传统拍卖中，这三位可能都会下调自己的出价，期望利益最大化。但在二价拍卖中，他们都选择如实报价。最终，老王以90万元（小李的出价）获得了这幅画。这个结果既确保了画作归于最珍视它的收藏家，又避免了过度竞价带来的市场扭曲。\neBay 的故事 eBay 在在线艺术品拍卖领域已经积累了不少经验。2022 年 10 月，该公司联合 150 家北美实体拍卖行，正式推出艺术品拍卖专区。据 eBay 网络市集总裁 Devin Wenig 介绍，新平台获得了全球用户的热烈响应，多件高价拍品成功成交，其中埃尔维斯·皮礼士利（Elvis Presley）的首张唱片就以 30 万美元的价格售出。\n在这个平台上，采用了一种独特的拍卖机制：最高出价者获得拍品，但只需支付第二高的价格。这看似违反直觉的规则，实际上是经济学家威廉·维克里精心设计的方案 —— 第二价格密封拍卖，这种方案在一定程度上解决了传统拍卖的困境。\n传统拍卖的困境 想象一下北京798艺术区的一场小型艺术品拍卖会。一位收藏家王先生正在考虑竞拍一幅当代艺术作品，他内心认为这幅画值 15 万元。但在传统的第一价格拍卖中，他面临着一个两难困境：\n如果他如实出价 15 万，万一其他人都出价较低（比如最高只到 12 万），他就要多付 3 万元。 如果他战略性地压低出价到 13 万，可能会错失这幅他真心喜欢的作品。 这种情况在艺术品市场非常普遍。拍卖师经常观察到，参与者们往往不愿表达真实的心理价位，导致市场信息不透明，资源配置效率低下。\n拍卖有哪些种类？ 从拍卖的基本类型来看，主要可分为英式拍卖、荷兰式拍卖和密封拍卖三类。其中密封拍卖又可细分为第一价格密封拍卖和第二价格密封拍卖（维克里拍卖）。\n英式拍卖采用递增价格机制，从保留价格起拍，买家依次加价竞标。每轮加价必须高于上一轮报价的最小增量。当无人继续加价时，最高出价者获得标的物。这种方式最为常见，尤其适用于艺术品、古董等独特物品的交易。其优势在于价格发现功能强、信息充分公开，但也容易出现恶意竞价、哄抬价格的问题。\n荷兰式拍卖则采用递减价格机制，从高价开始，价格逐步下调，直到第一个接受当前价格的买家出现并成交。这种方式特别适用于鲜花、农产品等需要快速处理的商品。其优势是交易效率高、时间成本低，但可能因买家观望导致实际成交价偏离市场价值。\n密封拍卖中，买家同时提交密封报价。第一价格密封拍卖要求最高价者按自己的报价支付，而第二价格拍卖（第二价格密封拍卖、维克里拍卖）则要求最高价者按第二高的报价支付。二价拍卖因其独特的激励机制，能有效避免投标人战略性压低报价，促使其报出真实估值。\n之所以取名 “维克里”，是为了纪念 William Vickrey，他对拍卖的开创性研究帮助他获得了 1996 年的诺贝尔经济学奖。\n二价拍卖的运作方式 二价拍卖通过一个简单的规则改变了这一切。想象一下下方的拍卖会：\n三位收藏家对一件青花瓷器进行密封竞价：\n张先生出价 80 万元 李先生出价 65 万元 王先生出价 50 万元 按照二价拍卖规则：\n张先生以最高价胜出，获得这件青花瓷器 他只需支付第二高的价格：65万元 其他竞买者无需支付任何费用 既然是使用第二价格购买，那么竞拍者虚报价格有好处吗？\n答案是，竞拍者虚报价格是没有任何好处的，原因如下：\n假设某竞买者对藏品的心理价位是 70 万元(即他愿意支付的最高价格)，但他故意报价 100 万元：\n如果其他竞买者的最高出价低于 70 万元： 他以真实心理价位 70 万元出价就能中标，而且支付金额（第二高价）相同 报 100 万元没有任何额外收益 如果其他竞买者出价在 70～100 万元之间： 他会中标，但要支付超出自己心理价位的金额 这种情况下他会亏损，因为要支付超出自己愿付金额的价格 如果其他竞买者出价超过 100 万元： 无论他报 70 万还是 100 万都不会中标 抬高出价没有任何意义 同样地，竞买者也没有动机报低价：\n如果报价低于真实愿付价格，可能错失以合适价格（第二高价）获得心仪拍品的机会 即便中标，支付的金额仍是第二高价，与自己的出价无关 因此，在这种机制下，每个竞买者的最优策略就是诚实报出自己的真实估值：\n报高了可能导致亏损 报低了可能错失机会 只有如实报价才能最大化自己的利益 这就是二价拍卖的巧妙之处 —— 通过切断出价与支付价格的直接关联，\n这个机制的精妙之处在于，它切断了\u0026quot;出价\u0026quot;和\u0026quot;实际支付\u0026quot;之间的直接联系。它创造了一个激励相容的机制，使得参与者自然而然地选择诚实出价 —— 参与者们知道自己最终支付的是他人的出价，没有动机去歪曲自己的真实估值。\n维克里的洞察 维克里在研究中将国际通行的拍卖方式分为四种类型：英格兰式拍卖（English auction）、荷兰式拍卖（Holland auction）、第一价格拍卖（First-price auction）和第二价格拍卖（Second-price auction）。在这些类型中，维克里重点研究了第二价格拍卖，也被称为二级密封价格拍卖或维克里拍卖。\n在二价拍卖制度下，竞拍采用密封投票方式进行，出价最高者获得拍卖物，但只需支付第二高的价格。这种机制的独特之处在于它能够激励参与者揭示真实意愿：\n如果竞买者出价高于自己实际愿意支付的价格，就可能因其他人相似行为而不得不承担损失。 如果出价低于真实意愿，则可能失去以理想价格获得物品的机会。 因此，在这种拍卖制度中，按照真实支付意愿出价成为一种\u0026quot;优胜\u0026quot;策略——无论其他竞争对手如何行事，这都是参与者的最佳选择。这种机制具有两个重要特征：\n激励相容性：促使竞买人\u0026quot;说真话\u0026quot;，即按真实支付意愿出价 帕累托效率：确保拍卖品最终由支付意愿最高的竞买人获得 维克里的研究挑战了传统经济学观点。此前认为信息不对称会导致市场均衡无效率，但维克里证明，关键在于拍卖规则是否能有效引导参与者展示真实支付意愿。他认为拍卖是一种具有重要实践意义的市场交易制度，通过系统性的规则来决定资源配置和出清价格。\n在比较分析四种拍卖方式的基础上，维克里提出了\u0026quot;收益等价定理\u0026quot;。他特别研究了单物品拍卖机制，指出在英式拍卖中，竞买人的最优策略是持续竞价直至达到自身估价。最终，估价最高的竞买人将以接近次高估价的价格获得拍卖品，这一结果也实现了帕累托效率。\n想象你正在参加一场古董家具拍卖会。在传统拍卖中，如果你认为一张明式圈椅值 50 万元，你可能会犹豫是否要出这个价，因为担心最终要付出这么多。但在二价拍卖中，你可以大胆地写下 50 万，因为你知道：\n如果其他人的出价都低于你，你只需支付第二高的价格 如果有人出价高于你，你本来也不会得到这件家具 如果你刻意压低出价，反而可能与心仪的物品失之交臂 帕累托效率与诚实报价 在现实拍卖中，拍卖方通常无法获知投标人的真实估值（心理价位）。这种信息不对称的情况下，如何实现帕累托效率呢？我们先明确：帕累托效率意味着商品应该由估值最高的人获得，确保资源得到最优配置。\n让我们从英式拍卖开始分析：假设有一件商品，两位投标人的真实估值分别是 100 元和 80 元，最小加价幅度为 5 元。在竞价过程中，估值较低的投标人（80 元）不会超过自己的估值出价，而估值较高的投标人（100 元）只需出价 85 元（第二高估值加上最小加价幅度）就能获得商品。这种机制下，商品最终会被估值最高的人获得，似乎实现了帕累托效率，但存在投标人之间相互影响的问题。\n二价拍卖通过创新的支付规则解决了这个问题：最高出价者获得商品，但按第二高的出价支付。这个设计的精妙之处在于消除了投标人之间的策略性影响。我们用一个双人投标模型来分析：\n设两位投标人的真实估值分别为 v1 和 v2，出价为 b1 和 b2。投标人 1 的期望收益可表示为： $$P(b1≥b2) × (v1-b2) $$ 其中 $$P(b1≥b2)$$ 为投标人 1 赢得拍卖的概率，$$(v1-b2)$$ 为其获得的剩余价值。\n分析投标人 1 的最优策略：\n当 v1\u0026gt;b2 时，为最大化中标概率，最优出价应为 v1 当 v1\u0026lt;b2 时，为避免超出估值中标，最优出价同样是 v1 分析最优策略可知，无论 v1 是大于还是小于 b2，投标人的最优选择都是诚实报价（出价等于真实估值）。这自然实现了帕累托效率。\n这表明在二价拍卖中，诚实报价（出价等于真实估值）是每个投标人的最优策略，从而自然实现帕累托效率。\n而在考虑利润最大化时，情况会更复杂。以下面的例子说明： 假设两个投标人的估值只可能是 10 元或 100 元，概率各为 1/2，最小加价为 1 元。在四种可能的估值组合\n(10,10)\n(10,100)\n(100,10)\n(100,100)\n英式拍卖的最终成交价分别为 10、11、11、100 元，拍卖方的期望收益为 33 元。\n通过设置保留价格可以提高期望收益。例如，将保留价格设为 100 元时，拍卖方的期望收益可达 75 元（成交概率为 3/4）。但这会导致部分有效交易无法达成，违背帕累托效率。因此，只有保留价格为 0 时，才能实现真正的帕累托效率。这也说明了为什么商品若未被估值最高者获得，总是存在后续交易的可能：双方可以在两个估值之间找到一个价格进行交易，实现双赢。\n二价拍卖的创新之处在于，它通过规则设计消除了投标人之间的策略性影响，使得诚实报价成为最优选择。\n什么是好的拍卖机制设计？ 拍卖机制的优劣评估需要建立在严谨的理论模型基础上，而不是主观臆测。以二价拍卖为例，其优越性是通过机制设计理论得到了科学论证。这种基于模型的分析方法不仅适用于商业规则的制定，也适用于各类经济机制和政策的设计，因为良好的制度设计有助于在社会效率和公平之间取得平衡。\n让我们通过一个具体的拍卖场景来分析：假设有一件商品要拍卖，n 个投标人对该商品的估值分别为 p1、p2\u0026hellip;pn。为简化分析，我们设定卖方的保留价格为 0。在这种情况下，如何设计一个既能实现社会效率又能让参与各方满意的拍卖机制呢？\n从机制设计的角度看，我们通常关注两个核心目标：帕累托效率和利润最大化。利润最大化的含义直观明确，即使拍卖方获得最大收益。而帕累托效率则体现为资源的最优配置：确保商品最终由出价最高的投标人获得，从而实现物尽其用。\n为了理解资源配置效率的重要性，让我们考虑一个反例：假设估值最高的投标人 1（估值为 p1）未能得到商品，而估值较低的投标人 2（估值为 p2）获得了商品。这种情况下，资源配置并未达到最优状态，因为投标人 1 对商品的估值更高，商品在其手中能产生更大的社会价值。如果允许后续交易，投标人 2 可以以一个介于 p1 和 p2 之间的价格将商品转售给投标人 1。虽然这种交易能使双方获益（投标人 2 获得超过其估值的收益，投标人 1 以低于其估值的价格得到商品），但它暴露了拍卖机制的缺陷：商品未能直接配置给估值最高的投标人，导致资源配置的低效。\n因此，一个优秀的拍卖机制应当避免这种低效的资源配置。具体而言，最优的拍卖机制应满足以下两个条件：\n帕累托效率：商品直接售予估值最高的投标人，确保资源的最优配置。 利润最大化：成交价格尽可能接近最高估值，从而使拍卖方的收益最大化。 通过这样的设计，拍卖机制不仅能够实现社会效率，还能在公平性和经济效益之间取得平衡。\n效用分析 社会心理学的角度 在传统的实时竞价广告系统中,广告主们能够看到竞争对手的出价。这种透明度表面上看起来很公平，但实际上往往导致非理性的竞价行为。比如张三看到竞争对手为黄金广告位出价 8万/天，即使自己对这个位置的实际估值只有 6万，也可能出于竞争心理追加到 9万。这种从众效应不仅推高了广告成本,还容易造成广告主的决策疲劳和后悔。\n而在采用第二价格机制的程序化广告购买（RTB）系统中，广告主只需要提交自己的最高心理价位。假设有三家广告主竞争同一个优质广告位，他们根据自己的营销预算和预期转化效果分别报价 7万、5万 和 4万。最终出价 7万 的广告主会以 5万 （第二高价）获得这个位置。这种机制巧妙地降低了广告主的心理负担 —— 他们不需要揣测竞争对手的策略，只需要诚实地反映自己的真实预期价值。\n从社会认同的角度看，第二价格机制也更容易被接受。获胜的广告主不会感觉自己 “吃亏”，因为他实际支付的金额是由市场其他参与者共同决定的“公允价格”。同时，失利的广告主也不会感到沮丧，因为他们确实是按照自己的真实估值参与竞争的。这种机制还能有效避免 “赢者诅咒” —— 在传统竞价中，过度竞争可能导致中标价格超出广告位的实际价值。\n特别值得注意的是这种机制对群体动力学的积极影响。它将广告主们从 “你死我活” 的竞争对手转变为独立的理性决策者。每个广告主都在为自己的营销目标负责,而不是为了打压竞争对手。这种良性的竞争环境有助于建立更健康的广告生态系统。\n行为经济学的角度 想象一个场景：一个节目的广告位正在进行拍卖。多家品牌广告主参与竞价，其中包括张三、李四和王五。\n从有限理性与决策简化的角度来看，传统拍卖要求广告主不断权衡竞争对手可能的出价以及自己的最优策略，这个过程极其复杂。而在二价拍卖中，广告主只需要根据这个广告位对自己品牌的实际价值来出价即可。比如张三评估这个时段的广告价值是 100 万元，它就可以直接出价 100 万，而不用担心是否出价过高。\n关于损失规避，假设张三最终以 80 万元（第二高价）获得了广告位。虽然它出价 100 万，但实际只需支付 80 万，这种机制很好地缓解了广告主对 “成本过高” 的担忧。即使最终没有得到广告位，也不会产生因出价过高导致的损失。\n在禀赋效应方面，广告主往往会对自己品牌的广告效果产生过高评估。二价拍卖通过市场机制来确定最终支付价格，避免了单个广告主的主观估值偏差。例如李四可能会高估其品牌影响力，但最终支付价格将由其他广告主的估值来决定。\n从框架效应看，这种机制将广告位竞拍从 “你死我活” 的竞争转变为一个价值发现的过程。广告主不是在玩 “以高价击败对手” 的游戏，而是在思考 “这个广告位对我的品牌价值如何”。\n在过度自信方面，一些新兴品牌可能会对广告效果抱有过高期望。二价拍卖通过市场反馈机制，帮助他们逐步建立更准确的价值判断。如果一个新品牌盲目出价远高于市场水平，虽然可能赢得广告位，但支付的价格仍将由市场决定，避免了过度自信带来的损失。\n这种拍卖机制也很好地解决了市场效率问题。它能确保广告位最终由最需要、最有效益的品牌获得，同时价格又维持在一个合理水平，促进了广告资源的优化配置。\n二级价格拍卖机制的局限性 二级价格拍卖主要是两个方面的不足：\n收入考虑 对卖家而言，第二价格机制可能带来收入的不确定性。比如，在一场拍卖中，最高价是 100 万，而第二高价只有 60 万，这种差距会让卖家感到不安。解决方案是设置合理的底价，在保护卖家利益的同时维持机制的优势。 操纵风险 存在竞买者串通或卖家方虚假竞价的可能。这需要通过严格的资格审查和监管来防范。 二级价格拍卖比一级价格拍卖对卖家而言风险更大 在买家们的估值独立同分布且风险中性的情况下，二级价格拍卖比一级价格拍卖对卖家而言风险更大。\n假设有一幅油画要拍卖，几位买家希望将其买回家欣赏。他们对油画的估值完全基于个人偏好，与其他买家的估值无关。买家们知道这幅油画的市场价值可能在0到500万元之间，但具体值多少并不确定。（假设买家风险中性，估值独立同分布）\n二级价格拍卖：在这种拍卖中，买家会直接按照自己对油画的真实估值出价，因为最终支付的价格是第二高的出价，而非自己的出价。因此，买家没有动机压低出价。此时，买家的出价分布会在0到500万元之间。 一级价格拍卖：在这种拍卖中，买家需要支付自己的出价。为了避免支付过高，买家会策略性地压低出价，出价通常会低于自己的真实估值。因此，买家的出价分布会在0到一个小于500万元的数值之间。 根据收益等价原理，在买家风险中性和估值独立同分布的假设下，一级价格拍卖和二级价格拍卖的期望收益是相同的。然而，二级价格拍卖的收益波动性更大，因为买家出价更接近真实估值，导致卖家的实际收益可能偏离期望值更远。相比之下，一级价格拍卖中买家压低出价，卖家的收益更加稳定。\n因此，如果卖家是风险厌恶型的，即更倾向于稳定的收益而非高波动性，那么一级价格拍卖是更优的选择。从数学上看，二级价格拍卖的收益分布是均值保留展形，即其期望收益与一级价格拍卖相同，但方差更大。\n一级价格拍卖对卖家收益更高 在买家们的价值独立同分布，且风险厌恶的情况下，一级价格拍卖对卖家收益更高。\n一级价格拍卖的规则决定了买家的策略：如果出价较低，获胜时的收益会更高，但获胜的概率也会降低。相反，如果出价较高，获胜的概率会增加，但收益会减少。\n例如，一个投机者可能会选择出价极低（比如1块钱），期望其他买家不感兴趣，从而以极低成本获胜。然而，这种行为风险极高，因为获胜概率极低。\n另一方面，风险厌恶的买家倾向于出价较高。他们更注重获胜的确定性，而不是最大化收益。对他们来说，即使收益减少，只要能确保获胜，也比冒险出低价更有吸引力。\n而在二级价格拍卖中，买家的出价策略与风险偏好无关，所有买家都会按照自己的真实估值出价。因此，二级价格拍卖不会区分“投机者”和“风险厌恶者”。\n对于卖家而言，如果参与拍卖的买家大多是风险厌恶型（例如稳打稳扎的投资者），一级价格拍卖会更有利。因为风险厌恶的买家倾向于出价较高，从而推高成交价格，增加卖家的收益。相比之下，二级价格拍卖的成交价格更接近买家的真实估值，对卖家的收益提升有限。\n因此，在买家普遍风险厌恶的情况下，卖家应优先选择一级价格拍卖。\n二价拍卖与升价拍卖的等价性 在买家们的价值独立同分布的情况下，二价拍卖与升价拍卖的等价性。\n升价拍卖是一种动态拍卖形式，其特点是价格逐步上升，买家根据自身估值决定是否继续参与。当价格上升到某个买家的心理价位时，该买家会选择退出，而最后剩下的买家获胜，并支付前一个退出者所接受的价格。\n例如，在电视上常见的拍卖场景中，拍卖师逐步提高价格，买家依次喊价（如“50万”“60万”），直到只剩下一位买家。这种拍卖形式可以建模为升价拍卖。\n在买家们的价值独立同分布的假设下，升价拍卖与二价拍卖是等价的。具体来说：\n在升价拍卖中，价格逐步上升，买家会在价格达到其心理价位时退出，因为继续参与可能导致亏损。 获胜者支付的价格是最后一个退出者的报价，即第二高的价格。 在二价拍卖中，获胜者同样支付第二高的报价。 因此，在特定假设下，升价拍卖与二价拍卖的结果是一致的。这一等价性表明，升价拍卖在现实中广泛应用的现象并非偶然，而是由其与二价拍卖的内在一致性所支撑。\n二价拍卖收益比升价拍卖低 在买家价值关联的情况下，二价拍卖收益比升价拍卖低。\n现在我们来考虑一个拍卖场景：几家公司竞拍一片海域的油田。每家公司都进行了勘测，并对油田的潜在价值进行了评估。由于油田的实际储油量是固定的，各公司的勘测结果虽然可能存在差异，但总体上具有相关性。例如，如果一家公司勘测到油田储油量较高，其他公司勘测到的储油量也可能较高。这种相关性被称为“关联价值”。\n在关联价值的情况下，二价拍卖（即维克里拍卖，出价最高者以第二高价成交）的收益往往会低于升价拍卖（即英式拍卖，价格逐步上升直至只剩一位买家）。这是因为在二价拍卖中，买家倾向于以接近其真实估值的价格出价，而升价拍卖则可能通过竞争将价格推高至接近最高估值。\n数学上可以证明，在关联价值的假设下，升价拍卖能够更好地激发买家的竞争心理，从而推高最终成交价格，而二价拍卖则由于缺乏这种竞争机制，导致收益较低。因此，在关联价值的情况下，升价拍卖的收益通常高于二价拍卖。\n二价拍卖中卖家有造假的动机 在我们的讨论中，卖家似乎是一个严格执行拍卖规则、毫无私心的人。然而，实际上卖家也有私心，毕竟拍卖藏品的目的是为了赚钱。\n由于特殊的原因，拍卖转为线上进行。首先考虑的是线上二价拍卖。王总觉得这幅画非常好，毫不犹豫地输入了 500 万，他认为这幅画值 500 万，并且他知道自己不需要支付 500 万。结果公布后，王总果然赢了，收到的账单是 499 万。王总很高兴，发现第二高价是一个叫 Jack 的美国人，他出价 499 万。王总开心地让秘书把钱打了过去。然而，卖家更高兴，为什么呢？实际上，Jack 的出价是 300 万，但卖家估计王总一辈子也不会遇到地球另一边的 Jack，更不会知道 Jack 在这场拍卖中的出价。所以卖家为了实现利益最大，有动机调整第二价格。\n王总对此有意见吗？他乐在其中，以为自己险胜了 Jack 。Jack 对此有意见吗？他当然没有，因为他知道自己出价 300 万，肯定输了。这个卖家的造假行为，根本没人发现，也没人在意，而他自己却多了 199 万的收入。\n因此，二价拍卖存在卖家造假的动机，这使得它不可信。\n那么一级价格拍卖呢？现在考虑的是线上一级价格拍卖。王总觉得这幅画非常好，他认为这幅画值 500 万，但他肯定不会出价 500 万，因为出价 500 万和赢不赢是一样的。“那我出价 400 万吧。”结果公布后，王总赢了，发现第二高价是一个叫 Jack 的美国人，他出价 200 万。\n卖家在这种情况下能造假吗？不能，因为在一级价格拍卖中，赢家需要支付自己的出价。王总出价 400 万，卖家只能收取 400 万，不能收取 499 万。如果王总收到 499 万的账单，他肯定会报警。\n因此，一级价格拍卖是可信的。\n二价拍卖在多物品拍卖中的计算复杂度较高 在买家数量多、商品数量大以及存在复杂约束的情况下，二价拍卖在多物品拍卖中的计算复杂度较高。\n这是因为在多物品二价拍卖中，需要考虑所有可能的物品分配方案，并为每个买家计算其对不同物品组合的估值。同时，还需要解决一个复杂的优化问题来确定最优分配方案和支付价格。具体来说，计算最优分配需要求解一个整数规划问题，而计算支付价格则需要为每个中标者重新求解一次没有该买家参与时的优化问题。随着买家数量和物品数量的增加，可能的分配方案会呈指数级增长，这使得精确计算变得极其困难。\n在单物品拍卖中，二价拍卖机制相对简单直观 —— 最高出价者获得物品，但只需支付第二高的出价金额。然而，当拍卖涉及多个物品时，计算最优分配和支付价格的复杂度会呈指数级增长。\n让我们通过在线广告拍卖的场景来具体说明。假设一个广告平台需要在一个网页上分配 3 个广告位置。有 5 个广告商参与竞价，每个广告商对不同位置组合都有不同的估值。例如，广告商 A。可能愿意为顶部横幅出价 100 元，但如果同时获得侧边栏位置，其总估值可能会增加到 140 元而不是 200 元,这反映了边际效用递减的特点。\n为了确定最优分配，平台需要考虑所有可能的分配方案。对于 3 个位置和 5 个广告商，需要评估的组合数量已经相当可观。此外，在确定每个广告商应支付的二价金额时，还需要通过反事实分析计算：如果没有某个中标的广告商参与，其他广告商的最优分配方案会是什么样。这个过程需要重复进行多次计算。\n随着物品数量和竞价者数量的增加，这种组合爆炸会使得精确计算变得极其困难。在实际的大规模广告系统中，往往需要采用启发式算法或近似算法来在合理时间内得到可接受的解决方案,而不是追求完全精确的二价机制。\n参考 最后一刻竞标和结束第二价拍卖的规则：来自互联网上的eBay和Amazon拍卖的证据 ↗ ebay 第二高价拍卖，ebay 第二分类价格 ↗ “第一价格密封拍卖” 和 “第二价格密封拍卖” 在互联网广告生态中的运作模式 ↗ 好好的二价拍卖，为什么谷歌等一众Adx逐步转向一价？ ↗ 维克里拍卖（Vickrey auction）为什么得不到广泛应用？ ↗ 看懂维克里拍卖，也就看懂了此次诺奖 ↗ 刘双舟：威廉•维克里对拍卖经济学的贡献 ↗ ","date":"2025-02-06","tags":["拍卖"],"title":"二价拍卖：如何让诚实报价成为最佳选择？","url":"/post/2025/02/second_price_auction/"},{"content":" 注：\n这里只讨论被作为产品品牌传播的名称，对于腾讯、米哈游这样的名称不讨论，原因有两点：\n一是幸存者偏差，这类名称在同一时期可能有很多，但是大多数都没能传播开来，而现存的只是幸存者。\n二是他们是企业名不是产品名，这些名称不是传播的，比如别人问你在用什么软件聊天的时候，你会说“我用 QQ”，而不会说“我用腾讯 QQ”。\n一、为什么需要一个好名字？ 名字不仅是品牌和标签，更是传播效率，在品牌命名的时候名称一定是一个关键点。\n案例：一个人名字是林芪（qi），另一个人的名字是林茂，谁的名字更容易被记住？\n两个简单的层面：\n记忆成本：“芪”这个字虽算不上生僻，但也是不常用汉字。你会有个认知“噢，这个名字很特别”，所以我能记住，但是当你尝试复现的时候，无非是把那一块在脑海里模糊的东西变得更模糊了。芪这个字能组的词非常少。所以你很难通过其他的词去记住这个名字。或者通过更多的信息去记住这个字，对记忆的负担非常大。\n传播成本：你会如何介绍自己？别人会如何介绍你？“芪是芪苓的芪”，“啊？麒麟？”在多数情况下，你甚至没法在输入法中快捷地输入这个名字。\n这是个真实的案例，我几年前有一个老师的名字就是 “x芪x”，后来在登记的时候，由于工作人员没法输入这个字，就改成了 “x茂x”。这何尝不是一种悲剧呢？\n通过这两个层面算是完成了一个品牌传播的流程，但是要取一个好的名字，远不是用小学生词典组词那么简单，况且以上的解释还是比较片面的。\n但是这并不是说给人取名的文章。言归正传，如何给你的品牌取名？\n从库里肖夫效应说起 苏联电影工作者库里肖夫在十九岁的时候发现一种电影现象：\n他给一个演员的特写镜头分别在后面接上三种不同的内容。结果是观众在看的时候，根据后面出现的那个镜头的内容来断定那个特写镜头中的人的情绪。\n图源：IB FILM STUDIES\n比如后面接的是一个欢乐的的场面，于是观众觉得那人的脸上露出了笑容。如果接的是一个悲伤的内容的镜头，则观众会觉得那个特写中的人脸是悲伤的。从心理学来说，这是观众把他自己的感觉投射到那个人的脸上。其实那几个不同性质的例子里的特写镜头是一样的，是同样的镜头后面接了不同内容的镜头。观众认为那个特写镜头中的人的表情变了。\n这就是库里肖夫效应，这对品牌名有什么启示吗？\n不要随便用英文简写，特别是可能含有负面解释的时候，例如：TCL、HTC、BYD，消费者永远只会选择最便捷的记忆方式，而不会在意品牌的愿景。但是消费者会如何记住你的品牌呢？答案是使用不那么优雅的描述，所以很多时候一个不明所以的品牌使用容易记忆的昵称的时候往往是比较通俗甚至粗俗的。这种可能存在的负面信息对品牌来说是一种伤害。\n名称背后的含义是否符合品牌自身定位和当地文化背景，比如：运动品牌 mizuno 中文名“美津侬”、服装品牌 PlayBoy 中文名“花花公子”，审计咨询机构KPMG中文名叫“毕马威”、雪碧刚进入中国时的“势必利”、女装品牌 Girdear 的中文名哥弟。这样的名称，在消费者脑海中产生的画面和品牌态度是有较大冲突的，这样的形象也必定不是品牌方愿意接受的。\n那么为什么名称解释的改变会导致消费者态度的改变呢？\n菲利普·津巴教授在《态度改变与社会影响》的「自我辩解心理学：认知不协调理论」部分同样提到：当人们的态度与行为或环境信息不一致时，人们会改变行为或修正态度，从而改变对世界的看法。\n这不难理解，举个例子，医生给你开了一副药，比较苦：\n医生建议你喝药后喝点水。 医生建议你喝药后吃颗糖。 哪个药更苦？相信你也会认为“喝药后吃颗糖”的药更苦。为什么呢？因为使其达到一致。即：药更苦（负面预期）所以需要吃更甜的东西（正面奖励）。否则就不用。所以你会相信需要吃糖的药更苦。\n预期和奖励往往越是呈现反比，越能达到想要的效果。为什么呢？因为做对的事情不需要奖励，如果有奖励，那么一定是因为这件事本身就不好 —— 认知和行为的不一致会让我们修正其一。\n所以当消费者认为品牌传递的信息是负面的时候，消费者会修正自己的行为或者修正自己之前的评价以匹配目前的状态。\n再举一个例子，蒙牛和安佳，那个品牌名称对你的画面更强一点？\n我相信是蒙牛，这是个本土化的描述，而安佳是新西兰的品牌。想到蒙牛的时候你是不是可以想到一头牛呢？它俯下头在湖边饮水，而它的背后的阳光被白云遮住，蓝天和绿茵形成了一幅美丽的画面。这就是库里肖夫效应。\n这警示我们，在取名字的时候一定不能脱离情景，你的名字在普遍情景下是什么含义？是否会对别人的态度造成影响？这很重要。\n记忆成本 史玉柱说：“一个名字如果不上口，不容易记，往往就要花上几十倍的广告力度才能达到让别人记得住的效果。”\n“广告狂人”叶茂中在《冲突》一书中提到：\n决定品牌名能否解决传播冲突的关键：\n第一是好记，\n第二是好记，\n第三还是好记。\n\u0026hellip;\u0026hellip;\n又熟悉又有形象感的品牌名，自然是最能解决传播冲突的品牌名。\n不约而同，小马宋老师在文章中提到：\n名字最基本的功能是要让人记住，其他的意义都是在记住基础上才能有的。\n华与华在《华与华方法》中也同样提到：\n检验好名字的 3 个标准\n1.命名的第一原则是低成本\n要传达成本低，传播成本低，理解低成本，使用成本低，营销成本低的名字。\n2.命名的本质，第二在召唤性、指令性。\n命名要传递价值,传递购买理由，召唤顾客。如果名字本身能传达价值,召唤顾客,就能降低传播成本，降低消费者选择成本。\n3.命名必须是听觉词语\n因为传播是口语现象,是听觉行为。不仅要一看就明白,关键要一听就明白。\n借用华与华和小马宋同样提到的一个案例：\n“兰德酷路泽”还是“陆地巡洋舰”？\n关键在于哪个名字的记忆成本更低，答案自然就是“陆地巡洋舰”。\n在 SEO（搜索引擎优化）中，这同样重要，一个名字好不好往往就决定你会不会被点击。不同的是，SEO 常常是用户主动搜索，而实体品牌往往是品牌被展示。\n回到品牌命名，如何测试你的名字是否好记呢，小马宋的方法是：电话测试和输入法测试。\n电话测试法就是打电话告诉对方你的品牌名字，然后看对方能不能写下来，如果他能直接正确的写出来，那这个名字就非常好非常容易传播和记忆。对方想写下来，需要问你的东西越多，就说明这个名字越不好记忆。\n搜狗输入法测试。如果一个名字使用输入法更容易输入，那它让消费者找到它更加方便。简单来说，在没有提前云存储的情况下，搜狗输入法一次性打出来的名字才是更好的名字。比如苹果手机，就是个好名字，但第一次输入魅族或者一加手机，就略微有点复杂；酷派手机，输入就更加复杂。像章光 101 这种品牌，它中间还需要切换输入法；而有些更奇葩的名字，甚至普通输入法都打不出来，我就不再举例子了。\n其实个人还认为建议加上 SEO 的部分（小马宋老师曾经也做过 SEO）：\n一个名字被搜索的频率长期处于热榜，能说明这个名字对应的需求比较旺盛。我们可以反推，如果一个产品的需求旺盛，那么它的搜索关键字也会比较活跃，应该加以关注。 品牌名称不应该只专注于故事，还要着眼于你的消费者如何记忆和传播。\n这里有一个案例，来自叶茂中老师的《冲突》一书：\n著名的奢侈品牌 Yves Saint Laurent，大多数女孩并不会称呼他的全名或者中文名“圣罗兰”，而是叫它“杨树林（YSL）”，当消费者无法快速理解和记忆品牌名称的时候，他们就会以自己的理解去记忆。\n有时候在名称上想创意的时候就想到用生僻字，看不懂的就是“差异化”。\n实际上，这不但让用户看不懂，还增加了记忆和传播成本，让人描述名称的时候很难一句话说明白，相对于那些两个字就能知道品牌是做什么的、名称怎么写的品牌，复杂的品牌就吃了很多亏。\n比如“犇鱻羴”，你怎么介绍？\n“犇””就是三个牛组成，读bēn，鱻就是三个鱼，读……“\n这样介绍起来费劲不说，记忆成本还高得可怕。你的品牌也会失去了很多潜在的用户。即便你的菜是顶级的。\n记忆成本的降低可以带来传播效率的提高。\n传播效率 总的来说就是如何给别人描述。对于简单信息，记忆的难度越低，那么输出的难度也就越低。不难理解，每一个名称都是有意义的。\n前百度和滴滴的产品经理俞军老师在《俞军产品方法论》中提到：“用户不是人，而是需求的集合”，品牌名称对于消费者来说也是同样的，消费者可以通过品牌名称了解这个品牌，进而匹配自己的需求，这种情况是最好的，比如“淘宝”“去哪儿”“微信”“三只松鼠”“奔驰”。现在又存在一个问题，即：信息的压缩能力。\n你可能遇到过这样的情况，你问别人问题的时候，发觉答非所问，但是你换一个更详细或者易懂的描述，对方就能理解了。这个换之前和换之后的词，就是对信息压缩能力的改变。从传播的角度来说，信息的压缩能力越强，名称的传播效率就越高。注意这里是传播效率不是传播概率。\n有一家做餐饮的品牌叫做俏江南，你可以想象一下这个品牌是做什么菜系的，比如：川菜、湘菜、粤菜、闽菜、苏菜、浙菜、徽菜和鲁菜。\n你很可能猜不对，首先是这个名称所传达的信息无外乎江浙一带的菜系，这是这个名称所压缩的信息，问题就出在这里，它做的是川菜。想吃川菜的人看见这名字不会进去，想吃江浙菜的进去之后发现是川菜，消费者会混乱，只有做大量的营销传播，才能让消费者知道这是一家川菜，大大增加了营销成本。\n品牌名称和产品相关是建议的，至少不要牛头不对马嘴。\n传播概率 为什么标题党总是能获得更高的点击率？\n这其实是信息熵的问题，这是这一部分主要说明的。\n信息熵是一个物理学和信息论中的概念，用于描述某个系统或信源中包含的信息量的大小或不确定性的程度。在信息论中，熵是一个随机变量的平均信息量，表示在一组离散概率分布中随机选择一个元素所得到的平均信息量。信息熵越高，意味着信息的不确定性越大，反之则越小。\n比如，“太阳从西边升起了”，这句话的信息熵很高，因为太阳通常情况都是从东边升起，但是从东边升起是极不可能的，它会需要更多的信息才能解释“太阳为什么从西边升起”。\n而”太阳从东边升起了“，这句话的信息熵很低，因为这个现象太常规了，根本没有必要解释。\n例如：旅游品牌 “飞猪”、Dior 旗下的香水 “毒药”、做单词记忆的品牌“不背单词”，它们的信息熵是不是很高？\n这样的名称从传播概率的角度来说是很好的案例。这样的名字来自于叶茂中老师的《冲突》一书中「逆时针取名」所提到的方法。\n情景反馈 1921 年 white elephant 开始生产电池，畅销全国，八十年代国门打开，但是国外的消费者怎么都不肯买。同样是八十年代，日产有一款车叫蓝鸟，在广东地区死活卖不出去。\n为什么？\n在英语语境下，white elephant 有累赘的意思，而广东部分地区，蓝鸟读音普遍有不雅之意，这就是语境对品牌名称及其品牌价值的冲击。\n在考虑一个名字的时候不仅要考虑名字本身在本土的寓意，更要考虑名称在目标市场的寓意。\n我们在宣传自己品牌的时候，往往会因为对自己的价值观和愿景的长期信念而误以为品牌本身就包含了它；而消费者往往是因为品牌的行为对品牌进行价值定义，正如《态度改变与社会影响》在「自我觉知与自我归因」中提到的：我们是我们行为的产物。\n二、品牌名的历史演变 回想百年前的小农经济，人和人之间的关系很近，抬头不见低头见，谁家干什么，几乎都知根知底，自己有什么需求酒找那个人就好了。哪怕是现在，较为落后的农村地区，也一样保持着这种比较稳定的人际关系。那时候不会有一个打铁的张老头说：“我要做个张铁匠品牌”。而是有一个人打铁的技术很好，又懂顾客需求，找他打铁的人越来越多，别人为了方便叫他，而不是叫 “村头那个门口有一个石狮子的人家”，于是给他取了个名字 —— “张铁匠”，这就是最初的品牌。现在的吴裕泰、内联升、王麻子都是这样的方式来的。\n还有一种就是区域性的品类，这种产品在当地不算出名，但是在更大的范围比较起来就很好，比如西湖龙井、德州扒鸡、中宁枸杞、阳澄湖大闸蟹。这算区域性的优势品类，严格还说，这不是品牌，毕竟在垄断的情况下它才有机会成为品牌。\n这个阶段的品牌是口碑演化的结果，而不是被设计的。\n后来，有资源禀赋的人开个店，不满足于做好产品，更新去发扬一种精神，比如同仁堂意为“同修仁德，济世养生”，庆余堂取自“积善之家，必有余庆”。现在的老字号基本都是以上的方式保留下来的。包括我们说开个公司什么的都是资源禀赋的具像化。\n上世纪70、80年代，改革开放，品牌的取名方式开始出现转折，总的来说是两个方向的变化，一是发扬本土文化，二是追逐外来文化\n发扬本土文化，主要是往实现历史使命和家国情怀方向发展。比如中国、中华、东方等词汇和东风、解放、红旗这样的红色话语的品牌名。\n比如1987年成立的华为，1985年成立的中兴，1991年成立的格力，以及华润、万洲、世茂、华菱、华夏幸福等名字都是如此。\n追逐外来文化，主要是当时海外品牌大举进入中国市场，加之缺失的民族自信，影响了一代人的消费观念。\n一场跨越半世纪的中国品牌大突围 ↗ 可口可乐、肯德基、麦当劳进入一线城市，在普通人仅十几块钱工资时，一杯可乐卖4毛钱，去肯德基搓一顿无异于过年；\n日化品牌里联合利华、宝洁长驱直入；时尚潮流由皮尔卡丹、花花公子、鳄鱼等引领；家电领域，索尼、西门子、松下、LG等横扫千家万户……\n在很长一段时间，中国品牌虽然主场作战，却狼狈不堪。\n在很多人心目中，产品用上洋名就是大品牌、高品质、有面子的象征。包括现在，还有老一辈的人称呼火柴为“洋火”、称呼铁铲为“洋铲”、称呼铁钉为“洋钉”这些都是外来产品入侵本土文化的历史。\n于是开始有本土品牌开始包装自己，取一个“洋名”，听上去有档次，比如美特斯邦威、卡尔丹顿、拉夏贝尔、隆力奇、海尔；以及直接用英文做品牌名：TCL 的前身 TTK 家庭电器有限公司于 1981 年成立。\n但是这个时候能完全说是不自信吗，也不是，英文名在国际化方面确实是优势。\n在号称“中国现代公司元年”的1984年，张瑞敏当了青岛冰箱厂（海尔前身）的厂长，接过一个严重亏损、资不抵债的烂摊子。\n那时一台冰箱卖800元，超过工人两年的工资。76台不合格冰箱全被愤怒的张瑞敏用铁锤砸掉，全国轰动。\n这一锤，让质量为王的理念，从此生根发芽。\n1990年，海尔第一次向“制造强国”德国出口冰箱，结果有8000台滞留海关无法过检。\n张瑞敏请质检员揭去在场德国冰箱、海尔冰箱的商标，放到一起重新检验，结果海尔冰箱获得的优秀比“老师”利勃海尔还多。\n这一战后，海尔打入了一向以高标准、高质量闻名的欧洲市场，中国品牌在世界上有了名头。\n后来互联网出现，以前回到了最原始的状态，开始在传播上下功夫，“好记”成为标准。\n互联网品牌的命名方式有三种：\n一是用具象的物或动作命名：阿里巴巴、巨人、搜狗、虎牙、斗鱼、飞猪、盒马、小米、西瓜、瓜子、花椒、土豆等\n二是叠词：QQ、钉钉、当当、滴滴、人人、脉脉、陌陌、探探、转转、拼多多、货拉拉、哔哩哔哩等。\n三是口语化：去哪儿、好吃点、花呗、饭否、知乎、饿了么。\n这个阶段主要是迎合互联网用户 —— 无需说明，一触即达。\n这个阶段也是品牌最活跃的时候，层出不穷的品牌出现，很快简短的名称就不够用了，于是被迫朝着三个字、四个字，甚至五个字发展。同时命名也更聚焦于行业和产品特性。\n比如：三只松鼠、完美日记、元气森林、卤味研究所。\n如今的品牌命名更多朝着“品牌能给消费者带来什么”的方向命名，即视角开始从抽象的理想转到具象的消费者。\n三、什么是不好的名字 《孟子》说到：“君子不立危墙之下”，当我们决定创造一个名字的时候，我们没有办法创造一个一鸣惊人的名称，我们的目标不是好，而是不差。至于如何好，那是消费者、时代和运气的共同选择。\n不容易记住 我们取名的首要目的不是为了表达理想，而是为了让人记住，名字越长、使用的词汇越陌生、字越生僻，名字就不容易记忆。\n多数人们能记住的都是简短的朗朗上口的。\n需要切换输入法 打字不方便的，特别是有不同类型字符的，甚至是有特殊字符的，这样的名字从搜索的角度来说都是很不方便的。比如 “漾·19Club”，这样的名称在输入的时候需要切换输入法，对于用户来说是很麻烦的。\n中文、英文、数字和符号，任何组合都会影响到输入。用苹果手机的用户可能感受比较明显：打字的时候经常没有办法快速输入标点符号，导致表达受限。\n有生僻字 生僻字可谓是大忌，记忆和传播都是，更不要说理解了。\n比如“大龙燚（yi）”，这个名字很难认识，并且在输入的时候，往往不能直接选中，有时翻页都找不到 “燚” 字，特别是这个字的同音字还特别多。那么就意味着这个品牌在传播的时候需要费更大的精力。\n一个小学生都能理解的字词是最好的。我们通过听能识别的字也就是常用的三千字。有些新锐品牌为了追求标新立异而违背这个原则，往往要在传播上花费更大的精力。\n方言歧义 对于部分地区 HF、NL 不分，识别起来也会存在困难。\n比如“黄鹤楼”，对于部分方言来说，读起来就很费劲，更不要说听者明不明白了。\n字音差异 比如冬奥会雪容融没有冰墩墩火。单从名字上来讲，“墩”这个字虽然不好写，却是北方常用口语，比如胖胖的男孩就被称为“胖墩儿”。墩加上叠字效果，更让人联想到憨态可掬、天真可爱。而 “雪容融” 这个名字，为什么同样读“rong”，却要搞出来两个汉字、两种写法呢？打字多了一层麻烦，还很容易拼错，不如直接叫“雪融融”。\n使用谐音 这很容易想到，有时也能起到让人眼前一亮的效果，比如钟薛高、进京敢烤等。\n不过用谐音梗要注意，看它是否会增加传播成本，也就是别人能不能快速检索到你。\n罗振宇就曾说过，他最初给自己的公众号取名“罗辑思维”，后来发现这个名字有一定问题。比如很多人会搜索“逻辑思维”，平白浪费了流量；而且多数人在微信里打这四个字，会先用拼音打出来“逻辑思维”，然后将光标移到“逻”字后面将“逻”删除，再打一个“罗”字，别说打字，听起来就很麻烦。还有茶颜悦色、茶理宜世这些名字，就存在这样的问题。\n不用本国语言 比如在中国的品牌，用纯粹的英文，这样的名字消费人群同样限制了人群。\n比如 “一緒に寿喜烧” 即便是日本元素，也不建议这样命名，在搜索的时候非常困难。\n使用英文缩写时的歧义 比如朝天门火锅这个品牌，中文名还停不错，但是在设计 LOGO 的时候画蛇添足地加上了 “CTM” 这三个字母，实在是令人困惑。\n比亚迪的缩写 BYD，也有歧义，但是后来官方解释为 “build your dream”。\n意大利奢侈品牌 D\u0026amp;G 在辱华事件以前，中国市场里东北卖得最好。为什么呢？因为东北人认为“DG”两个字代表“大哥”。\n标致雪铁龙集团的新世代豪华品牌 DS，虽然在法国荣耀加身，备受法国政要欢迎，被誉为“总统座驾”，但在中国却遭遇了滑铁卢。这是因为 DS 法文全称为 Déesse，在法语中是“女神”之意，但在中国却变成了“屌丝”，\n滥俗名字词 小说家詹姆斯·斯科特·贝尔在《这样写出好故事》谈到小说创作中，有一个令人拍案的观点叫做：只展示，别说明。\n展示是呈现一幅画面和场景，让读者看到角色的动作与对话，从而自行推理故事情节，感受角色的个性和内心情绪，而不是直接说明角色内心发生了什么。\n贝尔举了一个例子 —— 写小说时，你可以描写：“马克瞪大眼睛，嘴巴张得老大，他试图呼吸，却吸不到气……”读者马上可以感受到角色的情绪，这比平铺直叙地说明“马克既震惊又害怕”好多了。\n取名字也是这样，不要试图通过品牌名称直接去说明产品的好，而是要让消费者感受好产品。\n取名时要少用美、好、优、品这些被用烂了的说明性词汇，诸如无印良品、小米有品、聚美优品、名创优品、凡客诚品，网易严选、顺丰优选、橙心优选、美团优选，完美中国、完美日记、丸美，这些名字实在是太多了。\n四、如何取一个好名字 一言以蔽之，好名字的基础是好记的名字，然后才是文化原型、品类属性、暗示映射、好听、好联想、好寓意、好玩、好延展等附加价值。\n名字是一个符号，在《华与华超级符号》中，首先是看有没有可以嫁接的文化，试图通过已有的事物让消费者记住你。下面就简述一下这些方法。\n通俗口语 比如“滴滴”“花呗”“饿了么”，这些名字经常会被说，容易理解，记忆成本很低，而传播效率又很高。\n这样的名称有两个特点：\n叠词：比如“拼多多” “货拉拉” “企查查” “转转” “旺旺”，这样的词有快速传播的特性。 口语：比如 “去哪儿” “扫呗”，这样的口语词具备快速记忆的特性。 语句：“交个朋友”“认养一头牛”，这样的语句没有过于口语化，但是仍然没有提高很多记忆成本。其实这样的名字就是动词+名词的组合，关于这样的技巧，后面再聊。 但是不要太语句，比如 2019 年 4 月，宝鸡一家网络公司因为公司名在网络上走红。这家公司号称中国名字最长的公司，企业名称足足有39 个字 —— 宝鸡有一群怀揣着梦想的少年相信在牛大叔的带领下会创造生命的奇迹网络科技有限公司。这样的名称很有创意，但是很难不想到国外的一个名叫 “Uvuvwevwevwe Onyetenvewve Ugwemubwem Ossas” 的人，这样的名字别说听，就是抄写也不容易记下来。一般来说两个字最好，不要超过五个字，一眼就能完全识别的状态是最好的。\n文化寄生 竞争战略之父 Michael Porter：“基于文化的优势是最根本的、最难以替代和模仿、最持久的和最核心的竞争优势”\n熊猫、长城、龙这些都是中国文化的标志性符号。这样的名字几乎都被注册了，如果非要用，也无非是添加更多的描述词。\n既然是符号，创始人本身也可以是符号，“Are You OK” “遥遥领先” “抽烟喝酒烫头” 会让你分别想到谁？\n这些就是符号本身，即：创始人有没有什么标签？\n比如罗永浩砸西门子劣质冰箱后命名的“锤子”科技，而后又因为“交个朋友”的口头禅，成立“交个朋友”科技。这样的名字是一种非常好的标签，更是一种可被描述的理想。\n五、取名的方法 符号心智 椰树 斑马 苹果 小米 这样的名字一般不会单独出现，而是会附带品类，不难理解，单名词作为品牌名，注册也是很难的。一般会加定语描述\n跨品类描述\n功夫恐龙\n瓜子二手车\n一只酸奶牛\n逆认知描述\n飞猪 三个爸爸 蓝月亮 网易考拉 不难发现这样的名称都是定语描述：xxx的xxx，然后只保留名词作为名称。\n行为复合 叫了只炸鸡 认养一头牛 交个朋友 淘宝 百词斩 这样的名称大多是动词+名词的组合，这种复合句最大的优势就是可以关联场景。其实像动名词的组合也是很好的，对于名词我们可能会生疏，但是对于动词就活灵活现。\n用户绑定 好孩子 太子奶 帮宝适 贝亲 将品牌名称和用户绑定在一起，这样的名称可以绑定用户的一个阶段。\n联想 泛化使命 华为 中兴 红旗 解放 这些品牌都是在当时的时代背景下诞生的，现在这样的名字较为罕见。\n模糊身份 红星美凯龙 元気森林 奈雪の茶 华伦天奴 马克华菲 这样的名称会有“洋品牌”的感觉，在市场上会获得一定的关注，但是也容易被反噬。\n产品品类 小罐茶 每日黑巧 七分甜 小仙炖 椰树 全棉时代 根据产品自身的功能取名是较为常见的，消费者可以通过产品名联想到品牌，相等于是用品牌名确立了一个品类，辨识度非常高，就像是看到“谭木匠”这样的名字，从名字听上去就专业。\n联想用途 立白 飘柔 汰渍 舒肤佳 佳洁士 通过产品用途确定品牌名称，这样的名字听上去就能感受到它是做什么的\n积极寓意 瑞幸 喜茶 福临门 完美日记 百事可乐 吉利 好利来 红双喜 消费者买东西，特别是送礼的时候，都希望有吉祥的寓意。但是不要矫枉过正，过于在乎文字的寓意，在取名时，搞得特别复杂，最后消费者记不住\nIP 塑造 康师傅 老干妈 王守义十三香 老妈兔头 沪上阿姨 王老吉 谭鸭血火锅 将品牌 IP 化，听上去历史感十足，在老字号品牌上比较常见，用户可以从名字感受到品牌的温度，即是专业，也是亲切。\n具象场景 农夫山泉 良品铺子 百果园 如家 三只松鼠 好名字能给消费者创造画面感，这样的名字也容易被记住，特别是在广告语的配合下，活灵活现。比如“农夫山泉” 你是不是也会感觉到山腰的一个农夫带着草帽，在农田里劳作的场景呢？\n传递情绪 百事可乐 可口可乐 爽歪歪 太太乐 积极的情绪的传播效率更高。\n宣扬理念 特步 keep 蔚来 得力 这样的名字有憧憬的空间。\n六、命名的深层追求 品类属性 从品牌名称就能知道这个产品是什么。\n比如“东鹏特饮”和“魔爪”，东鹏特饮停名字就知道是饮料，但是魔爪呢？实际上也是，但是在传播的过程中后者往往会需要更高的营销成本，才能和前者达到类似的消费者认知。\n其他类似的还有途牛、蚂蚁金服、货拉拉，零食有鸣等，从名字就可以确定产品是什么。\n暗示品质 小罐茶，这个名字就抓住了一个关键特征，茶叶用铝罐包装，充氮保鲜。当然小罐茶也有别的卖点，但是如果你要在品牌名中既体现小罐包装，又体现精选茶叶、大师制茶、送礼有面，那么还能想出来小罐茶这个名字吗？\n而最后为什么选择体现小罐呢？因为这个特征最直观，一目了然，小罐不仅代表了便捷的产品体验，而且体现了品牌的精致与品位。\n六个核桃，消费者很容易关联到补脑和核桃，还是六个核桃，这个名字一听就是品质高。\n七分甜，这个品牌则暗示低糖。\n暗示，是这个品牌和其他品牌差异的具体点，而这个点是通过那个唯一的词汇去表现的。这是精简信息后仍然保留的大量的想象空间。\n展示态度 比如“亚洲吃面公司”、“不方便面馆”和“超级植物有限公司”，初次听到这个名字的时候多少有点无厘头，但是你取看它们的产品的时候更能发现它们的态度非常明确，这算是品牌和理念的言行一致。\n一个比较知名的案例还有“太二酸菜鱼”，在曾经的官网它是这样描述自己的：全宇宙“第二”好吃的酸菜鱼，有全餐饮最霸道最奇葩的规矩： 不拼桌、不加位、不外卖，超过4个人还不接待，却每次排队都要2小时。\n设计延展 一个好名字当应该好设计延展。比如 LOGO 和文宣，作为具象物体命名的品牌，设计起来就比较容易，但是比较抽象的品牌名称就比较难了。\n比如华为，人们常常叫菊厂就是因为 LOGO 的设计。Paula Scher 为 IBM 创作的 LOGO 是字体设计，这都是从品牌文化去抽象的。\n七、参考： 怎么给品牌取个好名字？ ↗ 创业失败，可能是公司名字起得太烂？ ↗ 小马宋：普通人如何取一个营销学上的好名字？ ↗ 品牌名称：如何起一个好的品牌名？ ↗ 梳理近20年，国内品牌命名的流行趋势 ↗ 十年经验谈：为外国品牌起中文名那些事 ↗ 中国营销大变天，《超级符号原理》给我的启示 ↗ 研究完500+品牌名，我们发现了这11个规律（上） ↗ 研究完500+品牌名，我们发现了这11个规律（下） ↗ 品牌取名指南：这样取名字，能帮你减少50％以上的广告费用 ↗ 做品牌前先把名字取好｜8个品牌命名公式 ↗ ","date":"2025-01-30","tags":["取名","品牌名"],"title":"命名：如何取一个容易传播的名字","url":"/post/2025/01/how_to_choose_a_good_name/"},{"content":"简述 这是一款即时设计的插件，使用 ts/react 开发，代码是官方的，这里只是解析， GitHub 地址 ↗ 一、前置条件 即时设计客户端 https://js.design/download ↗ vscode https://code.visualstudio.com/Download ↗ code 快捷命令（可选）\nmacOS 系统快捷键：⌘ + ⇧ + P （command + shift + p）\nWindows/Linux 快捷键: Ctrl + Shift + P\n搜索安装 shell command\nnodejs/npm https://nodejs.org/en/download/ ↗ react npm install @types/react @types/react-dom 启用类型提示 在 vscode 按 Ctrl + Shift + b 开发即时设计类型提示\n效率工具 webpack 关于 webpack 的简介，可以查看 这篇文章 https://webpack.docschina.org/guides/getting-started/ ↗ # 安装 webpack npm install webpack webpack-cli --save-dev # 安装 TypeScript 编译器和 loader npm install --save-dev typescript ts-loader 开发依赖 开发依赖 (devDependencies)\n@jsdesigndeveloper/plugin-typings\n作用: 提供 jsd 插件开发的 TypeScript 类型定义。\n安装命令:\nnpm install --save-dev @jsdesigndeveloper/plugin-typings @types/node\n作用: 提供 Node.js 的类型定义，用于 TypeScript 开发。\n安装命令:\nnpm install --save-dev @types/node css-loader\n作用: 让 Webpack 能够处理 CSS 文件，并将其转换为 JavaScript 模块。\n安装命令:\nnpm install --save-dev css-loader html-webpack-inline-source-plugin\n作用: 将 JavaScript 和 CSS 文件内联到 HTML 文件中。\n安装命令:\nnpm install --save-dev html-webpack-inline-source-plugin html-webpack-plugin\n作用: 自动生成 HTML 文件，并将打包后的 JavaScript 和 CSS 文件注入到 HTML 中。\n安装命令:\nnpm install --save-dev html-webpack-plugin ts-loader\n作用: 让 Webpack 能够处理 TypeScript 文件，并将其转换为 JavaScript。\n安装命令:\nnpm install --save-dev ts-loader typescript\n作用: TypeScript 编译器，用于将 TypeScript 代码编译为 JavaScript。\n安装命令:\nnpm install --save-dev typescript url-loader**\n作用: 将文件（如图片、字体）转换为 Base64 编码的 URL，并内联到 JavaScript 或 CSS 中。\n安装命令:\nnpm install --save-dev url-loader webpack\n作用: 前端项目的模块打包工具，用于将 JavaScript、CSS、图片等资源打包成一个或多个文件。\n安装命令:\nnpm install --save-dev webpack webpack-cli\n作用: Webpack 的命令行工具，用于运行 Webpack 命令。\n安装命令:\nnpm install --save-dev webpack-cli 生产依赖 (dependencies)\n@types/react**\n作用: 提供 React 的类型定义，用于 TypeScript 开发。\n安装命令:\nnpm install @types/react @types/react-dom\n作用: 提供 React DOM 的类型定义，用于 TypeScript 开发。\n安装命令:\nnpm install @types/react-dom react\n作用: React 核心库，用于构建用户界面。\n安装命令:\nnpm install react react-dev-utils\n作用: 提供一些 React 开发工具，例如 Webpack 插件和实用函数。\n安装命令:\nnpm install react-dev-utils react-dom\n作用: 将 React 组件渲染到 DOM 中。\n安装命令:\nnpm install react-dom 二、开发示例 这是一个自动生成矩形的插件\n创建项目 在 即时设计 软件中，在菜单中，选择插件 \u0026gt;插件开发 \u0026gt; 创建新插件，输入插件名称，选择有交互插件。随即打开即时设计创建的这个插件文件。\n创建的文件结构如下：\nplugin ├── code.js ├── manifest.json ├── package.json └── ui.html 在 vscode 中打开创建的这个插件\ncode 插件名称，输入你自己创建的插件名称\n在项目根目录下生成 ts 配置文件\nnpx tsc --init 在项目根目录下创建 webpack 配置文件\ntouch webpack.config.js 现在文件中是空的，一会儿再加代码\n现在目录结构如下\nplugin ├── /src └── code.js ├── manifest.json ├── package.json ├── package-lock.json ├── webpack.config.js ├── tsconfig.json └── ui.html 处理插件逻辑 项目依赖文件： { \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;code.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@jsdesigndeveloper/plugin-typings\u0026#34;: \u0026#34;^1.0.12\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^16.7.1\u0026#34;, \u0026#34;css-loader\u0026#34;: \u0026#34;^6.2.0\u0026#34;, \u0026#34;html-webpack-inline-source-plugin\u0026#34;: \u0026#34;0.0.10\u0026#34;, \u0026#34;html-webpack-plugin\u0026#34;: \u0026#34;^5.3.2\u0026#34;, \u0026#34;style-loader\u0026#34;: \u0026#34;^3.2.1\u0026#34;, \u0026#34;ts-loader\u0026#34;: \u0026#34;^9.2.5\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.3.5\u0026#34;, \u0026#34;url-loader\u0026#34;: \u0026#34;^4.1.1\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;^5.51.1\u0026#34;, \u0026#34;webpack-cli\u0026#34;: \u0026#34;^4.10.0\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;@types/react\u0026#34;: \u0026#34;^19.0.8\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^19.0.3\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^19.0.0\u0026#34;, \u0026#34;react-dev-utils\u0026#34;: \u0026#34;^12.0.1\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^19.0.0\u0026#34; } } TS 配置文件 在 tsconfig.json 输入\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, // 编译后的代码将符合 ES6 (ES2015) 标准。 \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;, // 将 JSX 转换为 React.createElement 调用。 \u0026#34;noEmit\u0026#34;: false, //编译器会生成编译后的 JavaScript 文件。如果设置为 true，则只进行类型检查，不生成输出文件。 \u0026#34;typeRoots\u0026#34;: [ // 类型定义文件（.d.ts 文件）的查找路径 \u0026#34;./node_modules/@types\u0026#34;, \u0026#34;./node_modules/@jsdesigndeveloper\u0026#34; ] }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;] // 需要编译的文件或目录。 } webpack 配置文件 在 webpack.config.js 输入\nconst InlineChunkHtmlPlugin = require(\u0026#39;react-dev-utils/InlineChunkHtmlPlugin\u0026#39;); // 用于将 JavaScript 代码内联到 HTML 文件中。 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) //用于生成 HTML 文件，并自动注入打包后的 JavaScript 文件。 const path = require(\u0026#39;path\u0026#39;) // Node.js 的内置模块，用于处理文件路径。 const webpack = require(\u0026#39;webpack\u0026#39;) // Webpack 的核心模块。 module.exports = (env, argv) =\u0026gt; ({ // 导出配置 (环境，命令行参数) mode: argv.mode === \u0026#39;production\u0026#39; ? \u0026#39;production\u0026#39; : \u0026#39;development\u0026#39;, // 设置 Webpack 的构建模式： // This is necessary because jsDesign\u0026#39;s \u0026#39;eval\u0026#39; works differently than normal eval devtool: argv.mode === \u0026#39;production\u0026#39; ? false : \u0026#39;inline-source-map\u0026#39;, // 控制是否生成 source map，用于调试代码： entry: { // 定义项目的入口文件： ui: \u0026#39;./src/ui.tsx\u0026#39;, // UI 的入口 code: \u0026#39;./src/code.ts\u0026#39;, // 插件逻辑的入口 }, module: { rules: [ // 定义模块的加载规则： // Converts TypeScript code to JavaScript { test: /\\.tsx?$/, use: \u0026#39;ts-loader\u0026#39;, // 将 TypeScript 文件转换为 JavaScript。 exclude: /node_modules/ }, // Enables including CSS by doing \u0026#34;import \u0026#39;./file.css\u0026#39;\u0026#34; in your TypeScript code { test: /\\.css$/, use: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;], // 允许在 TypeScript 中导入 CSS 文件。 }, // Allows you to use \u0026#34;\u0026lt;%= require(\u0026#39;./file.svg\u0026#39;) %\u0026gt;\u0026#34; in your HTML code to get a data URI // { test: /\\.(png|jpg|gif|webp|svg|zip)$/, loader: [{ loader: \u0026#39;url-loader\u0026#39; }] } { test: /\\.svg/, type: \u0026#39;asset/inline\u0026#39; // 将 SVG 文件作为内联资源（Base64 编码）嵌入到代码中。 } ] }, // Webpack tries these extensions for you if you omit the extension like \u0026#34;import \u0026#39;./file\u0026#39;\u0026#34; resolve: { extensions: [\u0026#39;.tsx\u0026#39;, \u0026#39;.ts\u0026#39;, \u0026#39;.jsx\u0026#39;, \u0026#39;.js\u0026#39;] }, // 设置模块解析的扩展名。 output: { // 定义输出文件的配置： filename: \u0026#39;[name].js\u0026#39;, // 输出文件的名称，[name] 会被替换为入口名称（如 ui.js 和 code.js）。 path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), // 输出文件的目录，这里是项目根目录下的 dist 文件夹。 // Compile into a folder called \u0026#34;dist\u0026#34; }, // Tells Webpack to generate \u0026#34;ui.html\u0026#34; and to inline \u0026#34;ui.ts\u0026#34; into it plugins: [ // 配置 Webpack 插件： new webpack.DefinePlugin({ // 定义全局变量，这里用于修复 global 变量的缺失问题。 \u0026#39;global\u0026#39;: {} // 修复在开发者 VM 中运行时的全局变量错误 }), new HtmlWebpackPlugin({ // 根据模板 ./src/ui.html 生成 ui.html 文件，并自动注入 ui.js。 inject: \u0026#34;body\u0026#34;, template: \u0026#39;./src/ui.html\u0026#39;, filename: \u0026#39;ui.html\u0026#39;, chunks: [\u0026#39;ui\u0026#39;] }), new InlineChunkHtmlPlugin(HtmlWebpackPlugin, [/ui/]), // 将 ui.js 内联到 ui.html 中。 ], }) 插件逻辑文件 创建 src/code.ts 文件\njsDesign.showUI(__html__); // 显示插件的用户界面（UI）。__html__ 是一个特殊的变量，通常用于嵌入 HTML 内容。在这里，它表示插件的 UI 界面（通过 HtmlWebpackPlugin 生成的 ui.html 文件）。 jsDesign.ui.onmessage = (msg) =\u0026gt; { // 从 UI 发送过来的消息对象。 if (msg.type === \u0026#34;create-rectangles\u0026#34;) { // 消息的类型，用于区分不同的操作。 const nodes = []; // 创建矩形的逻辑 for (let i = 0; i \u0026lt; msg.count; i\u0026#43;\u0026#43;) { // 从 UI 传递过来的参数，表示需要创建的矩形数量。 const rect = jsDesign.createRectangle(); //创建一个矩形节点。 rect.x = i * 150; // 设置矩形的水平位置（每次递增 150，避免矩形重叠）。 rect.fills = [{ type: \u0026#34;SOLID\u0026#34;, color: { r: 0.8, g: 0.8, b: 0.8 } }]; // 置矩形的填充颜色（这里是浅灰色）。 jsDesign.currentPage.appendChild(rect); // 将矩形添加到当前页面。 nodes.push(rect); // 将创建的矩形节点保存到数组中。 } jsDesign.currentPage.selection = nodes; // 将创建的矩形设置为当前选中的对象。 jsDesign.viewport.scrollAndZoomIntoView(nodes); // 将视图滚动并缩放到适合查看所有矩形的位置。 } jsDesign.closePlugin(); // 在处理完消息后关闭插件。 }; ui 逻辑文件 src/ui.tsx\n// 通过 React 实现了一个简单的表单，允许用户输入矩形的数量并触发创建矩形的操作。 import * as React from \u0026#39;react\u0026#39; // React 核心库，用于构建组件。 import * as ReactDOM from \u0026#39;react-dom\u0026#39; // 用于将 React 组件渲染到 DOM 中。 import \u0026#39;./ui.css\u0026#39; // 引入样式文件，用于美化 UI。 declare function require(path: string): any // 这是一个 TypeScript 声明，用于告诉编译器 require 函数的存在。通常用于加载静态资源（如图片、字体等），但在这里并未实际使用。 class App extends React.Component { textbox: HTMLInputElement // 一个类属性，用于保存输入框的 DOM 元素引用。 countRef = (element: HTMLInputElement) =\u0026gt; { // 一个回调函数，用于绑定输入框的 DOM 元素。当输入框渲染完成后，会将其默认值设置为 5，并保存到 textbox 属性中。 if (element) element.value = \u0026#39;5\u0026#39; this.textbox = element } onCreate = () =\u0026gt; { // 点击“创建”按钮时触发的函数。 const count = parseInt(this.textbox.value, 10) // 从输入框中获取用户输入的值（矩形数量）。 parent.postMessage({ pluginMessage: { type: \u0026#39;create-rectangles\u0026#39;, count } }, \u0026#39;*\u0026#39;) // 向 JSD 插件主逻辑发送消息，消息类型为 create-rectangles，并传递 count 参数。 } onCancel = () =\u0026gt; { // 点击“取消”按钮时触发的函数。 parent.postMessage({ pluginMessage: { type: \u0026#39;cancel\u0026#39; } }, \u0026#39;*\u0026#39;) // 向 JSD 插件主逻辑发送消息，消息类型为 cancel。 } render() { // 渲染组件的 UI。 return \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;创建矩形\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;数量： \u0026lt;input ref={this.countRef} /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;create\u0026#34; onClick={this.onCreate}\u0026gt;创建\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.onCancel}\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } } //--- ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#39;react-page\u0026#39;)) // 将 App 组件渲染到 DOM 中，挂载到 id 为 react-page 的元素上。 //--- // 对于 React 18\u0026#43;，你需要使用 createRoot() 替换 ReactDOM.render()： // 替换如下 // import { createRoot as createReactRoot } from \u0026#39;react-dom/client\u0026#39;; // function createRoot(element: HTMLElement) { // return createReactRoot(element); // } // root.render(\u0026lt;App /\u0026gt;) 插件模板 webpack 会自动注入 js\nsrc/ui.html\n\u0026lt;div id=\u0026#34;react-page\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; mainfest.json jsd 插件识别文件 manifest.json 是 ssd 读取插件的配置文件，只改 main 和 ui\n{ \u0026#34;name\u0026#34;: \u0026#34;your_plugin_name\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;your_plugin_id\u0026#34;, \u0026#34;api\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;dist/code.js\u0026#34;, // code.js 的位置 \u0026#34;ui\u0026#34;: \u0026#34;dist/ui.html\u0026#34; // ui.js 的位置 } 三、构建插件 pnpm run build 四、在 jsd 中运行插件 在菜单中，选择插件 \u0026gt;插件开发 顶部会出现你创建的插件，如果没有，就在 通过 manifest 导入插件（通过即时设计创建的插件，会自动生成这个文件）\n现在插件的开发就结束了\n","date":"2025-01-24","tags":["插件"],"title":"即时设计插件开发","url":"/post/2025/01/jsdesign_plugin_dev/"},{"content":"==fds==\n一、简述 这是一个专注于编程的 Hugo 博客主题。\n参考了我此前为 Typora 开发的 Thompsgo 主题 ↗ 二、特性 1. 运行代码 支持的语言：\npython (wasm) lisp (JavaScript 实现的 Common Lisp (JSCL) 解释器) cpp (playground) rust (playground) go (playground) ts (TypeScript 的 JavaScript 实现) js (原生) 代码运行示例 Rust\nfn main() { println!(\u0026#34;Hello from Rust!\u0026#34;); } 运行 Go\npackage import \u0026#34;fmt\u0026#34; func main(){ fmt.print(\u0026#34;hello\u0026#34;) } 运行 Lisp\n(progn (format t \u0026#34;Hello from Lisp!\u0026#34;) \u0026#34;Hello from Lisp!\u0026#34;) 运行 Python\nprint(\u0026#34;test\u0026#34;) 运行 TypeScript\nconsole.log(\u0026#34;hello\u0026#34;) 运行 C++\n#include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;; return 0; } 运行 2. mermaid 图表 sequenceDiagram 张三-\u003e\u003e李四: 我是张三！ 李四--\u003e\u003e张三: 我是李四! 张三-)李四: 好的! 3. 数学公式 $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\ \\end{vmatrix} $$\n4. 效果 文字 彩色标签 抖音字 空心字 闪烁字 黑底字 彩虹字 隐藏文本 提示块 图片 单色 模糊 半透明 反色 圆角 边框 5. 多语言 参考 hugo 的多语言配置，默认使用路径语言参数（例如/en）\n6. 目录 在移动端支持折叠和展开，并支持目录标题跳转\n7. 搜索 使用模糊搜索库 fuse.js 实现搜索功能\n8. 博客统计 博客文章基础统计 标签云 热门文章 归档 9. 日/夜模式 参考 Hugo-Paper\n10. 评论 参考 Hugo-Paper\n11. 时间线 2021.1 ~ 2022.2 开发 dev 2022.4 ~ 2023.3 设计 des 12. 折叠菜单 I have keys but no locks. I have space but no room. You can enter but can't leave. What am I? A keyboard. 13. 嵌入 三、基本编辑 Markdown以下称作md\nThompsgo主题以下称作主题\nmermaid，一种编辑和渲染器，可以编辑并展示思维导图、流程图、序列图、甘特图等多种矢量图形的，typora可直接使用\n部分markdown不支持的样式比如带下划线文字或者 带颜色的文字可以通过html实现\n1. 基础语法 1.1 md语法 markdown语法-菜鸟教程 ↗ 如果不起作用请检查是否有空格或者尝试换行 $$ f(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d\\xi $$\n标题\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体样式\n斜体： *斜体文本* _斜体文本_ 粗体： **粗体文本** __粗体文本__ 斜粗体： ***粗斜体文本*** ___粗斜体文本___ 删除线： ~~BAIDU.COM~~ 示例\n斜体文本 粗体文本 粗斜体文本 BAIDU.COM\n分割线\n以下任意一种都可以 *** ***** --- ---------- 示例\n脚注\n[^要注明的文本] 您可以像这样创建脚注[^footnote]. - 示例 创建脚注格式类似这样 [^注]。 [^注]: 这是一个注释 5. 列表（可嵌套） ```markdown 普通列表 字符 空格 * 第一项 * 第二项 * 第三项 \u0026#43; 第一项 \u0026#43; 第二项 \u0026#43; 第三项 有序列表：数字 点 空格 1. 第一项 2. 第二项 3. 第三项 - 第一项 - 第二项 - 第三项 嵌套列表：数字/字符 点 空格 数字/字符 点 空格 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 示例 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 区块（引用）\n单层饮用：尖括号 空格 \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 嵌套饮用：尖括号 空格 尖括号 空格 \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套 复合使用： 区块中使用列表： \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; \u0026#43; 第一项 \u0026gt; \u0026#43; 第二项 \u0026gt; \u0026#43; 第三项 列表中使用区块 * 第一项 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 示例\n第一项 区块（引用）\n第二项 代码\n使用符号： ` `代码` 代码块： ```代码语言 代码 ``` 示例\n代码 链接\n[链接名称](链接地址) [菜鸟教程](https://www.runoob.com) 或者 \u0026lt;链接地址\u0026gt; \u0026lt;https://www.runoob.com\u0026gt; 示例\n菜鸟教程 ↗ https://www.runoob.com ↗ 图片\n图片地址可以是本地或网络地址 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;) 使用HTML标签指定图片高度和宽度 \u0026lt;img decoding=\u0026#34;async\u0026#34; src=\u0026#34;http://static.runoob.com/images/runoob-logo.png\u0026#34; width=\u0026#34;50%\u0026#34;\u0026gt; 示例\n表格\n| 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 示例 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 任务列表\n- [ ] 未完成 - [x] 完成 示例 未完成 完成 html支持\n\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt; 例如： \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;\u0026#43;\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;\u0026#43;\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt;重启 示例\nCtrl+Alt+Del重启\n转义\n\\ 反斜线 支持的符号 （这些符号在md中有意义，可以进行一些格式操作，反斜线可以让它们以文本显示） ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 \u0026#43; 加号 - 减号 . 英文句点 ! 感叹号 示例\n# - !\n公式\n支持 KaTeX ↗ 或者 MathJax ↗ 公式渲染器 $$ \\begin{Bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{Bmatrix} $$ 示例 $$ \\begin{Bmatrix} a \u0026amp; b \\ c \u0026amp; d \\end{Bmatrix} $$\n$$ \\begin{CD} A @\u0026gt;a\u0026gt;\u0026gt; B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} $$ $$ \\begin{CD} A @\u0026gt;a\u0026raquo; B \\ @VbVV @AAcA \\ C @= D \\end{CD} $$\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\ \\end{vmatrix} $$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\ \\end{vmatrix} $$\n$\\lim_{x \\to \\infty} \\exp(-x) = 0$ $\\lim_{x \\to \\infty} \\exp(-x) = 0$\n表情\n:smile: 示例 :smile:\n:tent:\n:hand:\n:camera:\n目录\n自动依据‘#’标签生成目录 [toc] YAML\nTypora 现在支持 YAML Front Matter 。 在文章顶部输入 --- 然后按 Enter 键将引入一个，或者从菜单中插入一个元数据块。 Typora支持 YAML\n这是一种编写元数据的数据序列化语言\n为什么使用\n我们来看markdown的#其实表示的是header，严格意义上来说是一级标题而不是文章标题title，放在论文里来说就是header 1可以是前言、方法、结果、讨论等，但不是论文的题目。如此一来我们就需要一个用来存放title的地方，这就是metadata的存在的意义，当然它不仅仅能容纳title，还可以加上author、keywords、abstract等信息1。这些数据可以在文件的详细信息里面看到。\n实际上YAML还可以保存用于脚本的变量，以实现各种导出时的特殊要求\n使用方法\n在文章顶部输入 --- 然后按 Enter 键将引入一个，或者从菜单中插入一个元数据块。 添加文章作者和关键字等信息 --- title: \u0026#34;This is the title: it contains a colon\u0026#34; author: - Author One - Author Two keywords: [nothing, nothingness] abstract: | This is the abstract. It consists of two paragraphs. --- 例如\n--- # 注释：导出的yaml设置 title: Thompsgo使用方法 author: 曹洋 creator: 曹洋 subject: Usage keywords: [使用方法、markdown、HTML、YAML] info: 这是一本关于thompsgo主题的手册，内含markdown、mermiad、html等语言和的基础语法。本主题由 @曹洋 开发，开源地址：https://github.io/caoyang2002 --- \u0026lt;!--注释：导出的html设置--\u0026gt; \u0026lt;meta title=\u0026#34;title\u0026#34; content=\u0026#34;${title}\u0026#34;\u0026gt; \u0026lt;meta info=\u0026#34;info\u0026#34; content=\u0026#34;${info}\u0026#34;\u0026gt; \u0026lt;meta author=\u0026#34;author\u0026#34; content=\u0026#34;${author}\u0026#34;\u0026gt; \u0026lt;div id=\u0026#39;_export_cover\u0026#39; style=\u0026#34;height:100vh;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#39;_export_title\u0026#39; style=\u0026#34;margin-top: 10%;text-align: center;font-size: 10rem;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#39;_export_info\u0026#39; style=\u0026#34;margin-top: 4%;text-align: center;font-size: 1.5rem;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p style=\u0026#34;margin-left:10%;font-size: 1.8rem\u0026#34;\u0026gt; \u0026amp;#128187; Mac专用 \u0026amp;#129412;\u0026lt;/p\u0026gt; \u0026lt;div id=\u0026#39;_export_author\u0026#39; style=\u0026#34;margin-left: 80%;font-size: 2.5rem;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var $cover = document.querySelector(\u0026#34;#_export_cover\u0026#34;); var title = document.querySelector(\u0026#34;meta[title=\u0026#39;title\u0026#39;]\u0026#34;).getAttribute(\u0026#34;content\u0026#34;); var info = document.querySelector(\u0026#34;meta[info=\u0026#39;info\u0026#39;]\u0026#34;).getAttribute(\u0026#34;content\u0026#34;); var author = document.querySelector(\u0026#34;meta[author=\u0026#39;author\u0026#39;]\u0026#34;).getAttribute(\u0026#34;content\u0026#34;); if(!title || title == \u0026#34;${title}\u0026#34; || !author || author == \u0026#34;${author}\u0026#34; || !info || info == \u0026#34;${info}\u0026#34;) { // no title author info $cover.remove(); } else { document.body.insertBefore($cover, document.body.childNodes[0]) $cover.querySelector(\u0026#34;#_export_title\u0026#34;).textContent = title; $cover.querySelector(\u0026#34;#_export_info\u0026#34;).textContent = info; $cover.querySelector(\u0026#34;#_export_author\u0026#34;).textContent = author; } \u0026lt;/script\u0026gt; 嵌入动画\n\u0026lt;iframe height=\u0026#39;265\u0026#39; scrolling=\u0026#39;no\u0026#39; title=\u0026#39;Fancy Animated SVG Menu\u0026#39; src=\u0026#39;http://codepen.io/jeangontijo/embed/OxVywj/?height=265\u0026amp;theme-id=0\u0026amp;default-tab=css,result\u0026amp;embed-version=2\u0026#39; frameborder=\u0026#39;no\u0026#39; allowtransparency=\u0026#39;true\u0026#39; allowfullscreen=\u0026#39;true\u0026#39; style=\u0026#39;width: 100%;\u0026#39;\u0026gt;\u0026lt;/iframe\u0026gt; 示例\n嵌入视频\n\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=12178417\u0026amp;bvid=BV1Ux411q7qd\u0026amp;cid=20076875\u0026amp;page=1\u0026#34; height=\u0026#34;770\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 嵌入音频\n\u0026lt;iframe frameborder=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; marginwidth=\u0026#34;0\u0026#34; marginheight=\u0026#34;0\u0026#34; width=330 height=450 src=\u0026#34;//music.163.com/outchain/player?type=0\u0026amp;id=2870133096\u0026amp;auto=1\u0026amp;height=430\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 示例 ","date":"2025-01-21","tags":[],"title":"Hugo-Focus 主题介绍","url":"/post/2025/01/hugo-focus-info/"},{"content":" 有时候独立开发者想做一个产品，总觉得缺个 UI/UX 设计师，但囊中羞涩，想了想自己八字挺硬，于是做起了设计。\n但是，你为什么觉得自己需要一个设计师？\n我认为这是作为一个独立项目开发者需要想明白的问题。\n有时候，甚至是大多数时候你都不需要设计师。\n相反你应该花更多的时间想想这个产品为什么而存在。但这不是一篇教你挖掘需求或者产品设计的文章。所有的方法都只是设计的见解。\n设计产品 当我们认为自己需要一个产品的时候，往往是因为觉得目前市面上的产品设计得不够好。为什么？\n不符本土的用户习惯？自己不喜欢？市场上的产品逻辑存在缺陷？无论如何，你此时一定有一个明确的目标，尽管它可能不符合市场实际需求。现在，你需要考虑的问题就是：\n设计什么？ 如何设计？ 大多数身兼产品经理的独立开发者总想找一个 UI/UX 设计师，实际上你可能还达不到要考虑设计的时候，你只需要想清楚你的产品是什么？定位是什么？你希望用户如何使用？这并不是逃避设计，而是清晰定义你的产品，以便实现你的设计。\n设计并不是一个高高在上的、超俗的艺术，相反设计是贴近生活的，它和所有人都很近，它是审美，是可能性，更是一种选择。\n我们需要明确的是，每个人对用户和产品之间关系的理解都不同。\n无论是我接触到的设计需求还是自己的产品，最棘手的问题无外乎这个产品是什么？你希望他像什么？\n有时候我会遇到个别需求方已经有明确对标的产品，可是对方总有绕不完的弯，又希望你创造出一个为他量身定制的产品，并且！他还希望有那个产品的交互体验。这个问题几乎是无解的，因为你哪怕多问两个“为什么”，对方就描述不清了。一般我遇到这个情况，都绝不反驳，直接去抄。\n做设计，怕的就是拿着答案找问题。人有一种对自己行为进行合理化的心理，作为设计师，你应该看更多的设计，为客户提供好的解决方案，如果各自认为自己的想法都是对的，那么都应该问对方几个为什么，直到你们找到意见出现分歧的根本问题。\n同样的，作为独立开发者，设计一个产品时，你最好写下你的需求细节，否则在设计的途中容易当初忘记为什么出发。\n假设 -\u0026gt; 实践 -\u0026gt; 反馈 我们有一个共识：好的东西就是需要要你付出成本的，比如时间成本、经济成本、社交成本等。\n做设计的时候也是如此，要承认自己的局限性。\n比如在设计的过程中，你认为有多个解决方案，但是你又无法直接对比出优劣，怎么办？此时要避免“全都要”的想法，而是回到根本问题，假设子问题，然后设计方案，此时可能仍然会有多个方案，你只需要选择一个方向，实现他，然后获取反馈。反馈中可能会有很多类似于“更快的马”的建议，根据反馈重新思考假设的子问题，直到出现“一辆车”的方案。\n如果没有反馈怎么办？放心，这往往不是因为你的产品好，而是产品“令人发指”。不要沮丧，优化产品，重新出发。\n设计的术 这一部分主要讲设计的方法（平面构成），如何设计一个非交互的纯视觉的页面。这些内容在 Zcool 上非常多，我在这里仅略微说明。平面构成的形式有：近似、重复、对比、渐变、分割、对称、平衡、肌理、错视、密集、发射、变异、特异、空间与矛盾空间，看不懂？这不重要，因为立体构成和色彩构成你更看不懂，有激动的小伙伴就要说了：“能不能说点我看得懂的？”\n好嘞！\n平面构成就是画面上的元素通过什么组织方式构成了这个平面作品。重点在构成，又有聪明的小伙伴要说了：“我知道这些，说点我不知道的”\n好嘞！\n画面都是由点线面构成的，\n那么问题来了，点线面是什么面？\n这是一个 “.” 这是一条线 “——“ 这是一个面 “▪️” 同理，\n这是一个点：▪️\n这是一条线： ▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️\n这是一个面：\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n一般说到这里，按照同行的规矩，就应该写这个：\n设计大帅班，不要9999，不要 8888，只要998！只要998 …\u0026hellip;\n哈哈，你知道的，我比较叛逆（瞎讲）\n在设计中，第一件事就是锻炼抽象能力，近似、重复、对比、渐变……，这些都是方法，设计就是将复杂形状的内容抽象简单成形状的点线面，然后使用这些方法进行表达。如何表达，就是经验了，锻炼这种能力只能多看、多练。\n以文字内容为例，当你疑惑文字内容太少想知道怎样能让画面变得丰富的时候，你不妨思考以下问题：\n文字在画面中的构图方式是否可以多样化？\n文字是否可以分组？\n文字是否可以添加内容的背景概述？\n是否可以添加为背景肌理？\n文字是否可以在可识别的情况下稍作修改？\n文字是否可以添加图片说明？\n文字一定是表意的吗？\n文字是否可以作为背景？ 文字是否可以成为设计元素？ 以上，都是在引导你处理画面的构成。\n总之有太多的方式可以让你的画面变得丰富，但是多就是好吗？\n这恐怕需要想想设计的目的是什么，为什么设计又叫视觉传达（视觉传达一般归纳为：“谁”、“把什么”、“向谁传达”、“效果、影响如何”四个程序）。\n我们经常看到有一些设计师写的文章，描述设计过程的时候，总是改了很多版以后，终于改出了一个几乎完美的版本，好像给人一种错觉 —— 改得越多越好，实际上不是这样的，改得越多只能说明对需求的过程很糟糕，设计师无法准确把握到需求的要点。\n以前我设计实习的时候，在一家小外包公司，做图总是比别人要慢，十几分钟做一个版本，然后就摸鱼，隔一两个小时去对一下需求，然后改一下，我交稿的时间总是卡在截止时间前不久，这样做的设计不会很差，也基本好不了，但是符合需求，“能跑就行”。设计师可能自己也不太行，但是这是少数，整天做设计的人，审美不会太差，而美的东西总是有吸引力的。\n如果你想改得少，又不想在产品构思阶段下功夫，你就会发现自己没什么可以设计的，然后看到什么新奇就像加到自己的设计上去，最后导致你的设计非常臃肿滥俗，尽管画面很丰富。这是糟糕设计的一种。\n常见的需求 LOGO 设计 LOGO 设计是很难的一个部分，为什么？\nLOGO 设计的不仅仅是一个 LOGO，而是整个项目对外的视觉，是一种调性。很多人能理解整容费用高，但是不能理解 LOGO 费用高，在我看来这是难以理解的，LOGO 和整容有什么区别？\n当你看到一个 LOGO 的时候，你不一定会想起他们的产品，但是一定会想起他们是做什么的，以及他们的调性。\n会 PS/AI 就可以做 LOGO 吗？从形式上来说，是的！作为独立开发者，不要想着找设计师做 LOGO，除非你有产品实力了，否则不要花太多成本做 LOGO。对于产品初期的 LOGO，你只需要想想是文字还是图形，然后确保你的 LOGO 容易被分辨，其他的都不要考虑了。LOGO 设计的价格一般都很高，如果你准备找一个 LOGO 设计，那么请准备好你至少一个月的工资作为 LOGO 设计的费用（实际LOGO 定价不是这样的，但是几千到几万都是正常的）。\n在一个项目的初期，LOGO 没有那么重要。\n一句话来说，LOGO 只是一个标识，这个标识压缩了你的产品理念和愿景。\n有时候这种绑定关系会自然产生，有聪明的小伙伴又要问了：“如何压缩理念和愿景？”这个是设计中的经验部分也是哲学部分，不存在唯一解，很难几百字解释清楚。或者\u0026hellip;\u0026hellip;你认为它好它就好。如果必须有标准，你不妨拿着你设计去问问其他人，“你觉得这个 LOGO 是什么公司用的？”\n实际上这并不准确，大多数公司的 LOGO 都不是这样被创造出来的。他们的创造过程可能在文化上的造诣更高，而不只是形状上的表现。\n有点激动的小伙伴就要问了：“那 LOGO 设计到底怎么做？”\n你希望如何呈现？文字还是图形？绝大多数项目都是图形 LOGO，那么你希望你的品牌是什么内涵？有什么动物或者植物能够代表这种内涵吗？或者喜欢什么？尝试把它画下来，使用 PS/AI 画下来，你也可以使用 Figma 或者即时设计画，随意。只要方便修改就行，唯一的建议是颜色少、无渐变，不仅是可识别性的问题，更是为了避免印刷工艺的限制。\nLOGO 设计，越简单越好。2013年Instagram品牌重塑的标志设计师 Mackey Saturday 表示，人们在设计标志时最常犯的错误之一就是把标志过于复杂。\n版式设计 排版是几乎所有场景都会遇到的！\n亲密性、对比、对齐、重复，看不懂？\n意思是不要劈腿出轨，不要没大没小的、不要乱停乱放、不要随地大小便。\n这里主要讲一下亲密性？\n我认为这是排版中最重要的部分，其他几项都比较容易理解，而亲密性是最容易犯的错误。说白了就是在特定的场景下，有一段给定的内容，其中什么文字和什么文字应该放在一起，比如在一个摄影展览的海报中，只能用以下关键词设计画面：\n“街头摄影大师分享”“马格南” “彩色摄影经典” “Alex Webb” “展览时间2012/12/12-2012/12/13”“国际摄影展” “中国成都站”\n这个海报放在哪里？街头还是商场？摄影展所在场馆门口的易拉宝还是墙上？或者只是在社交应用中传播？呈现场景是设计工作的基础。\n有些手快的小伙伴，转眼就把“马格南”和“街头摄影大师分享”放一起，emm…，他们相关，但是马格南全称是“马格南图片社”，这不重要，因为你应该不会犯这个错误。\n如果你有摄影经验，你应该知道 Alex Webb 是一个人名（好像没摄影经验应该也看得出来，这不重要），Alex Webb 是马格南著名摄影师之一，以彩色摄影著称。\n假设这个海报是面向大众的线上海报，那么主标题是什么？个人经验认为应该是“街头摄影大师分享”，它直接传达了在那个特定的时刻会发生什么。其次，应该也可以理解“Alex Webb” 两个关键字与“街头摄影大师分享”直接关联，所以他们的亲密度是最高的，其次是 “马格南”，从传播的角度考虑，这个名称是一个符号，这个名称压缩了很多信息，但是其他人可能比较难理解。然后是特点标签，例如“中国成都”和“国际摄影展”，它最后是时间地点。至于如何组织，画面，这就是经验问题了，你需要建立你的自信，哪怕是抄，你总要走出这一步。\n这个过程有点像写新闻标题：新闻中的五个要素 ―― 何时、何地、何人、何事、何因或为什么，简称五个“W”。后面再加上一个“H”，即怎样、如何，可理解为结果的意思。\n每项都有可能成为标题，关键是看哪一项更具有传播价值。如果传播的人物为社会所熟悉，在该新闻中特别重要，则应以“人”为先导。以此类推。\nUI/UX 设计 根本问题：你希望用户如何使用你的产品？\n产品好不好，UI/UX 的作用往往没有想象的那么重要，产品营销也不重要，那都是锦上添花的“术”，而产品本身的对用户的价值才是“道”。\n这里只简单讲一下设计中的 UI/UX，至于用户体验的内容暂且搁置。\n多数时候，UI设计多数时候都是经验为先，（审美也是一种经验）。\n至于页面中，应该使用圆形按钮还是方形按钮，输入框还是下划线，这不是很重要，并且它会随着设计的潮流变化而变化。使用你认为容易识别的方式，添加上去即可。或许现在你认为它不够新潮，但是过一段时间以后，它也许就成为了设计的标杆。这并不奇怪。\n最好的 UI/UX 学习就是抄，抄那些知名的产品。而创造就是排列组合。\n海报（宣传）设计 根本问题：你希望其他人如何获取到关键信息？\n你想要传达什么信息，特性？福利？或者其他精彩内容。总之，你有一个点想要传达，这个点就是你想传达的主题，这是整个海报最重要的地方。\n与之相关的是什么？时间？地点？人物？主题？全都有！你只需根据排版的原则进行设计即可。在设计中，设计的载体经常变化，但是设计的内核 —— 排版原则异常稳定的。\n作为初学者，可能会担心，这个黑色的背景行不行？灰色的字在设计中允许吗？彩色字体会更好吗？图形会不会太大了？画面会不会太空了，文字可以分割吗？\n其实这些都不重要，设计中没有任何一条规则告诉你不能做什么，所有的书都会告诉你各种最佳实践的建议。\n有时，规则只有在被打破的时候，你才能发现设计的精巧之处。\n常见的问题 为什么我的设计很空？\n“留白是一种艺术”，你要建立自信（不是，哈哈\n设计空不空不重要，重要的是：你想表达的重点有没有如期展示出来？需要有更多的信息提供吗？如果有表达出来，建议你不要动。有聪明的小伙伴就要说了：“我就是想做好一点”\n行，听你的！\n20世纪最伟大的战地摄影师罗伯特·卡帕说过：你拍得不够好，是因为你离得不够近。\n同样的，你设计不够好，是因为你形不够大。放大一点试试？或者用一些排版的技巧？\n好才做营销 知名战略营销专家小马宋说：“营销的营，首先是经营的营”。所有的增长问题都推诿到营销是不正确的。在做战略营销的时候，往往不是怎么写口号、怎么做包装、怎么打广告的问题，而是解决“客户不喜欢你的产品”的问题。\n不妨回到第一节，思考自己的产品解决了什么样的问题，你的方案优势是什么。\n好产品必然口口相传。\n个人见解 初学设计，你不必追求一鸣惊人，相反，你应该抄，大量地抄。创作的灵感会随着你抄的数量而涌现。\n如果你在创作的时候，觉得自己的配色上不太有感觉或者由于产品定位非常特殊，没有竞品参考，导致没有太多的设计思路，那么你应该更多地去看看 Zcool 或者 Behance，有时候，你做的不好往往是因为你想做好。这看上去是一句废话。确实。\n你做的不好，往往是因为，呈现的极端，一是什么都想要，认为这样可以给用户更好的体验，或者不知道要什么，没内容可写。这不可怕，可怕的是你觉得那些你能想到的东西都很重要，所以把他们都排在一起，并且表现的方式都是类似的，这就导致了问题 —— 你的用户不能定位到准确的信息。\n但是不要忘记，你不是一个设计师，因为设计师不需要看我这篇文章。你是一个独立开发者，是一个项目的负责人，你不应该花很多时间研究设计，好的设计不是需求端（用户）创造的，而是一种自顶向下的设计。\n100多年前，福特公司的创始人亨利·福特先生到处跑去问客户：“您需要一个什么样的更好的交通工具？”几乎所有人的答案都是：“我要一匹更快的马”。很多人听到这个答案，于是立马跑到马场去选马配种，以满足客户的需求。但是福特先生却没有立马往马场跑，而是接着往下问。\n福特：“你为什么需要一匹更快的马？”\n客户：“因为可以跑得更快！”\n福特：“你为什么需要跑得更快？”\n客户：“因为这样我就可以更早的到达目的地。”\n福特：“所以，你要一匹更快的马的真正用意是？”\n客户：“用更短的时间、更快地到达目的地！”\n你的用户往往会很好心地提供一些解决方案，但是那些只是解决问题的方案而不是问题所在。\n除此之外，如果你想成为一个设计师，那么你就不能只读设计。一个问题的解决过程往往不是单一领域的、定向研究的方式，正如温铁军教授所说，“当我们做批判的时候，希望能够跨学科，我们对问题的意识就能建立起来，而不是按照现在这个所谓学科给你的规范，去把他归到某个窄化的那个领域上去”，如果你遇到问题时，认为只有一个解决方案，那么你应该停下来，跳出你现在的问题框架，重新定义这个问题。\n推荐书籍 平面设计 《版式设计从入门到精通》这是一本全面的设计原理书籍，有点厚。\n《版式设计原理》这本书比上一本内容精简很多\n《平面设计原理》这部和上一本类似\n《超越平凡的平面设计：版式设计原理与应用》这一本设计理论和实践的书\n《超越 LOGO 设计：国际顶级平面设计师的成功法则》这是一本LOGO 设计入门的案例参考书籍\nUI/UX/UE 设计 《UX 最佳实践：提高用户体验影响力的艺术》这是一本用户体验的书，侧重于整体目标的实现。\n《以匠心，致设计》 这是关于如何从用户体验的角度思考产品设计的书\n《众妙之门：用户体验设计的秘密》 这是一本关于用户体验优化的小案例研究\n《众妙之门：抓住访客心理的网页设计》这是一本侧重心理学原理的 UI/UX 设计书籍\n《决胜UX：互联网产品用户体验策略》这是一本关于如何通过有效策略，实现产品目标的书。\n《UX 设计之道：以用户体验为中心的 web 设计》这本书比较全面得解析了用户体验设计在整个产品项目的生命周期的应用\n《见微知著：Web 用户体验解构》 这是一本关于网站 UX 设计的实践书籍，但是受限于这本书的出版时间，其案例比较老，所以 UI 看上去会比较过时。\n《用户体验要素：以用户为中心的产品设计》这本书比较全面的解析了产品设计，对于web 产品开发内容不够精专。\n《在你身边，为你设计》由多篇小文章组成，可以有一些灵感，单不够系统\n《破茧成蝶：用户体验设计师的成长之路》这本书主要将用户体验设计工作的门道\n其他类型 《提问》 这是一本关于如何重构问题找到最佳解决方案的书\n《定位》 这是一本风靡全球的营销书\n《营销笔记》这是一本关于营销的书籍，讲了 4P 理论中的产品和定价（渠道和推广在另一本书《卖货真相》）\n如果你学有余力，建议你读一些社会学和经济学，以及交叉学科的通识书籍和研究书籍。\n如果你真读完这些书，你真会发现，做一天和尚撞一天钟；做一天设计发一天疯。\n结语 我虽然是设计科班出身，但自己一般不做设计，除了手痒的时候。平时给团队提供设计/营销策略，可能这也只是我少数几篇设计/营销类文章之一了，内容不免粗糙，感谢阅读！\n欢迎留言，分享你做设计和产品的见解！\n","date":"2025-01-20","tags":["设计","开发"],"title":"作为独立开发者，你真的需要设计师吗？","url":"/post/2025/01/do_you_really_need_a_designer/"},{"content":" https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html ↗ 梦开始的地方 简单的 asm null.s\n.section __TEXT,__text .globl _main .p2align 2 _main: mov w0, #0 ret int main() { return 0; } as null.s -o null.o # 汇编 ld null.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o null # 链接（由于在 macOS 上不能创建静态链接的可执行文件，因此在链接时必须使用 -lSystem 动态链接上系统库。） ./null # 运行 # or clang null.s -o null # or gcc null.s -o null as 是 LLVM 的汇编器, lldb 是 LLVM 的调试器。 GCC 套件是 GNU 操作系统的一个部分，GNU 是开源的、社区驱动的。而 LLVM 项目也是开源的，现在主要是 Apple 在投资运行。因此，既然在 macOS 上，我就主要用的是 LLVM 系的工具。\nhello world hello.s\n.section __TEXT,__text ; 代码段声明 .globl _main ; 声明 main 函数对外可见 .p2align 2 ; 4字节对齐 _main: ; main 函数入口 ; 准备系统调用参数 mov x0, #1 ; stdout 文件描述符 adrp x1, message@PAGE ; 获取消息的页地址 add x1, x1, message@PAGEOFF ; 加上页内偏移 mov x2, #13 ; 消息长度 mov x16, #4 ; write 系统调用号 svc #0x80 ; 触发系统调用 ; 返回值设为 0 mov x0, #0 ; 返回值放入 x0 ret ; 返回 .section __DATA,__data ; 数据段声明 message: .ascii \u0026#34;Hello World!\\n\u0026#34; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 编译\nas hello.s -o hello.o ld hello.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o hello ./hello 参考 Using as ↗ OS X Assembler Reference ↗ [Armv8-A Instruction Set Architecture]( https://developer.arm.com/-/media/Arm ↗ Developer Community/PDF/Learn the Architecture/Armv8-A Instruction Set Architecture.pdf) Arm Architecture Reference Manual for A-profile architecture ↗ ARM Assembly Language ↗ Writing ARM64 Code for Apple Platforms ↗ ","date":"2025-01-18","tags":["编程"],"title":"mac 汇编笔记","url":"/post/2025/01/mac_assembly/"},{"content":"为什么需要闭包？ // 问题1：函数复用 // 没有闭包时，需要传入所有参数 fn add(x: i32, base: i32) -\u0026gt; i32 { x \u0026#43; base } // 有了闭包，可以部分应用 let base = 5; let add_five = |x| x \u0026#43; base; // 问题2：函数式编程需求 vec![1, 2, 3].iter().map(|x| x * 2); // 更简洁 vec![1, 2, 3].iter().map(multiply); // 需要单独定义函数 // 问题3：上下文捕获 // 没有闭包时很难处理 struct Context { value: i32 } let ctx = Context { value: 42 }; let use_context = || println!(\u0026#34;{}\u0026#34;, ctx.value); 闭包是什么？ 闭包是可以捕获其环境的匿名函数 它\u0026quot;封闭\u0026quot;了其定义时的环境，故称\u0026quot;闭包\u0026quot; 闭包 = 函数 + 环境 闭包的优势 // 1. 简洁的语法 let add = |a, b| a \u0026#43; b; // vs fn add(a: i32, b: i32) -\u0026gt; i32 // 2. 灵活的环境捕获 let multiplier = 2; let double = |x| x * multiplier; // 捕获 multiplier // 3. 支持函数式编程 let numbers: Vec\u0026lt;i32\u0026gt; = vec![1, 2, 3, 4, 5]; let even_numbers: Vec\u0026lt;i32\u0026gt; = numbers .into_iter() .filter(|x| x % 2 == 0) .collect(); 理解闭包 我用 Python 和 TypeScript 的概念来解释 Rust 的闭包：\nPython 风格理解： # Python 的 lambda lambda x: x \u0026#43; 1 # Python 的闭包 def outer(a): # 捕获外部变量 a def inner(x): return x \u0026#43; a return inner # 对应的 Rust 代码 |x| x \u0026#43; 1 let a = 1; let closure = |x| x \u0026#43; a; TypeScript 风格理解： // TypeScript 的箭头函数 const add = (x: number) =\u0026gt; x \u0026#43; 1; // 带类型标注的闭包 const multiply: (x: number) =\u0026gt; number = (x) =\u0026gt; x * 2; // 对应的 Rust 代码 let add = |x: i32| x \u0026#43; 1; let multiply: fn(i32) -\u0026gt; i32 = |x| x * 2; Rust 闭包的特殊之处： // 1. Rust 闭包有三种类型 // FnOnce - 获取所有权 let owns = |x| takes_ownership(x); // FnMut - 可变借用 let mut mutates = |x| mutates_value(x); // Fn - 不可变借用 let reads = |x| reads_value(x); // 2. 闭包会自动推断捕获方式 let mut val = 5; let mut closure = || { val \u0026#43;= 1; // 自动推断需要可变借用 println!(\u0026#34;{}\u0026#34;, val); }; 主要区别：\nRust 的闭包更关注内存安全和所有权 Python/TS 的闭包主要关注词法作用域 Rust 的闭包语法更简洁（使用 || 而不是 ()=\u0026gt;） Rust 的闭包有更严格的类型系统和借用规则 人们常说：\u0026ldquo;如果你理解 JavaScript/TypeScript 的箭头函数，就很容易理解 Rust 的闭包语法；如果你理解 Python 的 lambda 和闭包概念，就很容易理解 Rust 闭包的用途。\u0026rdquo;\n如何使用闭包 // 1. 基本语法 let closure = |params| body; // 2. 带类型标注 let closure = |x: i32| -\u0026gt; i32 { x \u0026#43; 1 }; // 3. 作为函数参数 fn apply\u0026lt;F\u0026gt;(f: F, x: i32) where F: Fn(i32) -\u0026gt; i32 { println!(\u0026#34;Result: {}\u0026#34;, f(x)); } // 4. 在迭代器中使用 let v = vec![1, 2, 3]; v.iter().map(|x| x * 2).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); 最佳实践 // 1. 选择合适的特征界定 // Fn - 不可变借用 fn call_closure\u0026lt;F\u0026gt;(closure: F) where F: Fn(i32) -\u0026gt; i32 { closure(1); } // FnMut - 可变借用 fn call_closure_mut\u0026lt;F\u0026gt;(mut closure: F) where F: FnMut(i32) -\u0026gt; i32 { closure(1); } // FnOnce - 获取所有权 fn call_closure_once\u0026lt;F\u0026gt;(closure: F) where F: FnOnce(i32) -\u0026gt; i32 { closure(1); } // 2. 避免过度捕获 let x = 1; let y = 2; // 好的做法 let closure = move |z| x \u0026#43; y \u0026#43; z; // 明确使用 move // 不好的做法 let closure = |z| x \u0026#43; y \u0026#43; z; // 隐式捕获 // 3. 保持闭包简洁 // 好的做法 let is_even = |x| x % 2 == 0; // 不好的做法 - 过于复杂 let complex = |x| { let mut result = x; for i in 0..10 { result \u0026#43;= i; } result % 2 == 0 }; // 4. 适当的错误处理 // 好的做法 let safe_divide = |x, y| { if y == 0 { None } else { Some(x / y) } }; // 5. 文档和类型标注 /// 计算一个数的平方 let square: fn(i32) -\u0026gt; i32 = |x| x * x; 常见用例 // 1. 回调函数 button.on_click(|| println!(\u0026#34;Clicked!\u0026#34;)); // 2. 自定义排序 let mut vec = vec![1, 5, 2]; vec.sort_by(|a, b| b.cmp(a)); // 降序排序 // 3. 惰性计算 let expensive_closure = || { // 复杂计算 compute_something_expensive() }; // 4. 配置和构建模式 let config = Config::new() .with_timeout(|c| c.timeout(Duration::from_secs(5))) .with_retry(|c| c.max_retries(3)); 掌握闭包可以让代码更简洁、更灵活，同时提高代码的可维护性和重用性。但要注意在使用时遵循最佳实践，以确保代码的清晰性和性能。\n","date":"2025-01-15","tags":["编程","rust"],"title":"简述 Rust 中的闭包","url":"/post/2025/01/rust_closure_brief/"},{"content":"引用：你的快递地址和包裹 想象这样一个场景：你在网上买了个漂亮的花瓶，快递公司需要把它送到你家。快递员需要知道两个信息：\n你家的地址（引用） 花瓶本身（值） 为什么我们需要引用？ 让我们看一个具体的问题：\nfn calculate_length(s: String) -\u0026gt; usize { s.len() } let s = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(s); println!(\u0026#34;{}\u0026#34;, s); // 编译错误！s 已经被转移了所有权 这就像你把花瓶（值）直接给了快递员（函数），花瓶就不再属于你了。但很多时候，我们只是想让快递员看看花瓶，而不是把它拿走。\n引用的本质是什么？ 引用就像是地址，它告诉我们值在哪里，但不拥有值本身。就像快递员拿着你家的地址，但房子依然是你的。\nfn calculate_length(s: \u0026amp;String) -\u0026gt; usize { // 借用花瓶 s.len() } let s = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s); // 给出地址 println!(\u0026#34;{}\u0026#34;, s); // 可以使用！因为我们只是借出去看看 引用的规则 1. 不可变引用 就像快递员只能看看你的花瓶，不能重新给它上色：\nfn modify(s: \u0026amp;String) { s.push_str(\u0026#34;world\u0026#34;); // 编译错误！不能修改借用的值 } 2. 可变引用 有时候我们确实需要让快递员修改花瓶（比如补个裂缝）：\nfn modify(s: \u0026amp;mut String) { s.push_str(\u0026#34;world\u0026#34;); // OK！可以修改 } let mut s = String::from(\u0026#34;hello\u0026#34;); modify(\u0026amp;mut s); 3. 引用的限制 就像一个花瓶同一时间：\n要么可以有多个人在看（多个不可变引用） 要么只能有一个人在修改（一个可变引用） 但不能同时发生 let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; // ok let r2 = \u0026amp;s; // ok let r3 = \u0026amp;mut s; // 编译错误！不能同时有可变和不可变引用 println!(\u0026#34;{}, {}\u0026#34;, r1, r2); 实战经验 使用引用的最佳实践： // 好的实践：使用引用避免不必要的所有权转移 fn process(data: \u0026amp;Vec\u0026lt;i32\u0026gt;) { // 处理数据但不需要所有权 } // 不好的实践：不必要的所有权转移 fn process(data: Vec\u0026lt;i32\u0026gt;) { // 获取了所有权但其实不需要 } 生命周期问题： fn danger() -\u0026gt; \u0026amp;String { // 编译错误！ let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s // s 要被销毁了，不能返回它的引用 } 这就像快递员记录了一个即将拆迁的房子的地址 —— 等他送货时，房子已经不在了。\n引用的方法论 所有权原则：\n值同时只能有一个所有者 引用不获取所有权，只是借用 借用规则：\n要么多个不可变引用 要么一个可变引用 引用必须总是有效的 实践指导：\n优先使用不可变引用 仅在必要时使用可变引用 注意引用的生命周期 通过这样的理解，Rust 的引用机制就不再神秘。它就像现实世界中的地址和借用概念，帮助我们安全高效地管理内存。记住：引用就是地址，借用就是临时使用权，这两个概念将帮助你更好地理解和使用 Rust 的引用系统。\n引用实践，看似简单实则暗藏玄机 在我们日常开发中，经常会遇到这样的问题：\n// 场景1：我想传递一个很大的数据结构 struct BigData { data: [u8; 1024 * 1024] // 1MB 数据 } fn process_data(data: BigData) { // 每次调用都要拷贝1MB？ // 处理数据 } // 场景2：多个地方需要读取同一个数据 let data = String::from(\u0026#34;hello\u0026#34;); let data2 = data; // data 的所有权被移动了 println!(\u0026#34;{}\u0026#34;, data); // 编译错误！ 这些问题归结为一个核心矛盾：我们既想高效地共享数据，又要保证内存安全。\n为什么传统方案不够好？ 让我们看看其他语言是怎么处理的：\nC/C++ 的指针方案 void process(Data* data) { data-\u0026gt;field = 100; // 随意修改 delete data; // 随意释放 data-\u0026gt;field = 200; // 使用已释放的内存！ } 问题：\n可能出现悬垂指针 可能重复释放 数据竞争随处可见 Java 的引用方案 void process(Data data) { // 安全但是： // 1. 需要GC，性能开销大 // 2. 没有解决并发修改的问题 } Go 的指针方案 func process(data *Data) { // 安全性好，但是： // 1. 没有生命周期控制 // 2. 并发安全需要额外机制 } Rust 的借用检查器：安全与性能的完美平衡 Rust 通过引用解决了这个问题：\n// 基本语法 let x = 5; let r = \u0026amp;x; // 不可变引用 let rm = \u0026amp;mut x; // 可变引用 // 引用规则 fn process(data: \u0026amp;BigData) { // 借用数据，无需拷贝 println!(\u0026#34;{:?}\u0026#34;, data); // data 会自动归还，无需手动释放 } 为什么这样设计？ 所有权系统保证了资源的正确管理： let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = \u0026amp;s1; // s1 仍然拥有所有权 println!(\u0026#34;{}, {}\u0026#34;, s1, s2); // 都可以使用 // s2 在这里自动失效 drop(s1); // 只有所有者负责清理 借用规则保证了内存安全： let mut data = String::from(\u0026#34;hello\u0026#34;); // 规则1：同一时刻，只能有多个不可变引用或一个可变引用 let r1 = \u0026amp;data; let r2 = \u0026amp;data; // OK：多个不可变引用 let rm = \u0026amp;mut data; // 错误！已经有不可变引用了 // 规则2：引用不能比它引用的数据存活更久 let r; { let x = 5; r = \u0026amp;x; // 错误：x 的生命周期太短 } println!(\u0026#34;{}\u0026#34;, r); 最佳实践 优先使用不可变引用： // 好的做法 fn process(data: \u0026amp;BigData) { // 只读访问 } // 不好的做法 fn process(data: \u0026amp;mut BigData) { // 除非真的需要修改 } 合理使用生命周期标注： // 当需要在结构体中存储引用时 struct Cache\u0026lt;\u0026#39;a\u0026gt; { data: \u0026amp;\u0026#39;a str } 避免复杂的引用关系： // 避免这样的代码 struct Node\u0026lt;\u0026#39;a\u0026gt; { next: Option\u0026lt;\u0026amp;\u0026#39;a mut Node\u0026lt;\u0026#39;a\u0026gt;\u0026gt; } 引用的威力：一些实际例子 高效的字符串处理： fn process_string(s: \u0026amp;str) { // 直接使用字符串切片，无需拷贝 } let string = String::from(\u0026#34;hello\u0026#34;); process_string(\u0026amp;string); // 借用而不是移动 集合的遍历： let vec = vec![1, 2, 3, 4, 5]; for item in \u0026amp;vec { // 借用遍历，无需获取所有权 println!(\u0026#34;{}\u0026#34;, item); } // vec 仍然可用 方法实现： impl MyStruct { fn get_data(\u0026amp;self) -\u0026gt; \u0026amp;str { // self 的引用 \u0026amp;self.data } } 关键思维模型 地址思维： 引用是地址，不是值本身\n借用思维： 临时使用权，不是所有权\n安全思维： 编译器确保所有借用都是安全的\n总结 Rust 的引用系统看似复杂，实则体现了以下核心原则：\n安全性：通过借用检查器在编译期防止常见的内存问题 性能：零成本抽象，运行时无额外开销 人体工程学：符合直觉的所有权和借用规则 掌握引用，你就掌握了 Rust 最核心的特性之一。它不仅能帮你写出更安全的代码，还能帮你获得更好的性能。记住：引用不是为了限制你，而是为了保护你。\n这就像是生活中的借用：你可以借别人的书看，但不能撕掉书页；可以同时借给多人看，但不能在有人看的时候去修改内容。这些规则不是限制，而是让所有人都能安全愉快地共享资源。\n","date":"2025-01-15","tags":["编程","rust"],"title":"Rust 中的引用","url":"/post/2025/01/rust_ref/"},{"content":"从一个常见问题说起 假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：\nlet numbers = vec![1, 2, 3, 4, 5]; // 如何优雅地复用过滤逻辑？ let even_numbers = ??? // 这里怎么写 let multiplied_numbers = ??? // 这里怎么写 闭包的本质 Rust 的闭包本质上是一种特殊的数据结构，它包含：\n函数逻辑 捕获的环境变量 让我们通过反编译来看闭包的真实面目：\n// 表面上的闭包 let multiplier = 2; let closure = |x| x * multiplier; // 编译器实际生成的结构（简化版） struct Closure { multiplier: i32, } impl Closure { fn call(\u0026amp;self, x: i32) -\u0026gt; i32 { x * self.multiplier } } 闭包的三种类型 通过具体案例来理解三种闭包 trait：\n// 1. FnOnce - 获取所有权 let vec = vec![1, 2, 3]; let consume = move || { // 使用 move 语义 // vec在这里被消费 println!(\u0026#34;Consumed: {:?}\u0026#34;, vec); }; consume(); // 只能调用一次 // 2. FnMut - 可变借用 let mut counter = 0; let mut increment = || { counter \u0026#43;= 1; // 修改捕获的变量 println!(\u0026#34;Counter: {}\u0026#34;, counter); }; increment(); // 可以多次调用 // 3. Fn - 不可变借用 let factor = 2; let multiply = |x| x * factor; // 仅读取 factor println!(\u0026#34;Result: {}\u0026#34;, multiply(5)); // factor 仍然可以在这里使用 理解闭包 假设你正在开发一个文件处理系统，需要对不同类型的文件执行不同的操作。你可能会写出这样的代码：\nfn process_files(files: Vec\u0026lt;String\u0026gt;) { for file in files { if file.ends_with(\u0026#34;.txt\u0026#34;) { process_text_file(file); } else if file.ends_with(\u0026#34;.json\u0026#34;) { process_json_file(file); } } } 这段代码虽然能工作，但如果要增加新的文件类型支持，就需要修改这个函数。如何让这个处理逻辑更灵活？这就是闭包可以发挥作用的地方。\n一、闭包的本质 1.1 从函数到闭包 先看一个基础示例：\n// 传统函数 fn add_one(x: i32) -\u0026gt; i32 { x \u0026#43; 1 } // 等价的闭包 let add_one = |x: i32| -\u0026gt; i32 { x \u0026#43; 1 }; 闭包实际上是一个可以捕获其环境的匿名函数。关键在于\u0026quot;捕获环境\u0026quot;这四个字：\nlet multiplier = 10; let multiply = |x| x * multiplier; // 捕获了外部变量multiplier println!(\u0026#34;Result: {}\u0026#34;, multiply(5)); // 输出：50 1.2 深入闭包特性 Rust的闭包有三个关键特征：\n类型推导 // 完整语法 let add_verbose = |x: i32| -\u0026gt; i32 { x \u0026#43; 1 }; // 简化语法（类型推导） let add_simple = |x| x \u0026#43; 1; 环境捕获 #[derive(Debug)] struct Counter { count: i32, } fn main() { let counter = Counter { count: 0 }; // 通过引用捕获 let print_count = || println!(\u0026#34;Count: {}\u0026#34;, counter.count); print_count(); // 可以访问counter } 所有权语义 let mut vector = vec![1, 2, 3]; // 通过可变引用捕获 let mut mutate_vec = || vector.push(4); mutate_vec(); println!(\u0026#34;Vector: {:?}\u0026#34;, vector); // [1, 2, 3, 4] 1.3 深入理解闭包捕获规则 闭包捕获变量遵循几个关键原则：\n最小权限原则： let name = String::from(\u0026#34;Alice\u0026#34;); let printer = || println!(\u0026#34;Name: {}\u0026#34;, name); // 只需不可变借用 let consumer = || name; // 需要所有权，编译器会报错 移动语义： let data = vec![1, 2, 3]; let closure = move || { // data 的所有权移入闭包 println!(\u0026#34;{:?}\u0026#34;, data); }; // 这里不能再使用 data 生命周期约束： let result: Option\u0026lt;Vec\u0026lt;i32\u0026gt;\u0026gt; = None; let mut processor = || { result.as_ref().map(|v| v.len()) }; 二、闭包的实现机制 2.1 Rust 中的闭包特征 Rust使用三个特征来实现闭包功能：\n// 1. FnOnce - 获取所有权并消费 let consume = || vector; consume(); // vector的所有权被转移 // 2. FnMut - 可变借用 let mut counter = 0; let mut add_to_counter = || counter \u0026#43;= 1; add_to_counter(); // counter被可变借用 // 3. Fn - 不可变借用 let value = String::from(\u0026#34;hello\u0026#34;); let print_value = || println!(\u0026#34;{}\u0026#34;, value); print_value(); // value被不可变借用 2.2 内存实现分析 看一个具体例子：\nfn main() { let external = String::from(\u0026#34;external data\u0026#34;); let closure = || { println!(\u0026#34;Using: {}\u0026#34;, external); }; closure(); } 这个闭包在编译时会被转换为类似这样的结构：\n// 编译器生成的等效代码 struct ClosureEnvironment { external: String, } impl Fn() for ClosureEnvironment { fn call(\u0026amp;self) { println!(\u0026#34;Using: {}\u0026#34;, self.external); } } 三、闭包示例 1. 自定义排序： let mut users = vec![ User { name: \u0026#34;Alice\u0026#34;, age: 30 }, User { name: \u0026#34;Bob\u0026#34;, age: 25 }, ]; users.sort_by_key(|u| u.age); // 按年龄排序 2. 惰性求值： struct Cached\u0026lt;T\u0026gt; where T: Fn(u32) -\u0026gt; u32, { calculation: T, value: Option\u0026lt;u32\u0026gt;, } impl\u0026lt;T\u0026gt; Cached\u0026lt;T\u0026gt; where T: Fn(u32) -\u0026gt; u32, { fn new(calculation: T) -\u0026gt; Cached\u0026lt;T\u0026gt; { Cached { calculation, value: None, } } fn value(\u0026amp;mut self, arg: u32) -\u0026gt; u32 { match self.value { Some(v) =\u0026gt; v, None =\u0026gt; { let v = (self.calculation)(arg); self.value = Some(v); v } } } } 3. 错误处理模式： let error_handler = |err| { log::error!(\u0026#34;Operation failed: {}\u0026#34;, err); // 返回默认值 Vec::new() }; let result = operation().unwrap_or_else(error_handler); 四、性能考虑 4.1 大小优化： // 编译器优化前 let large_data = vec![1; 1000]; let closure = move || large_data[0]; // 整个vec被移动 // 优化后 let large_data = vec![1; 1000]; let closure = move || \u0026amp;large_data[0]; // 只捕获引用 4.2 内联优化： // 通常会被内联优化 let multiply = |x| x * 2; let result = multiply(4); // 直接优化为 let result = 4 * 2; 五、常见陷阱 5.1 生命周期问题： fn create_closure() -\u0026gt; impl Fn(i32) -\u0026gt; i32 { let factor = 2; // 错误：factor的生命周期不够长 |x| x * factor } 5.2 可变性冲突： let mut data = vec![1, 2, 3]; let closure = || { // 错误：不能同时有可变和不可变借用 data.push(4); println!(\u0026#34;{:?}\u0026#34;, data); }; 通过这些具体的示例和分析，我们可以看到Rust闭包不仅是一个语法糖，更是一个强大的工具，它能够帮助我们写出更加灵活和高效的代码。理解其内部机制和使用规则，对于编写高质量的Rust程序至关重要。\n你可以从这个分析中看到，闭包的每个特性都有其实际的应用场景和性能影响。这不仅帮助我们理解\u0026quot;是什么\u0026quot;，更重要的是理解\u0026quot;为什么\u0026quot;和\u0026quot;怎么用\u0026quot;。\n六、实战应用 6.1 函数式迭代器 let numbers = vec![1, 2, 3, 4, 5]; // 链式调用示例 let sum: i32 = numbers.iter() .filter(|\u0026amp;x| x % 2 == 0) // 过滤偶数 .map(|\u0026amp;x| x * x) // 平方 .sum(); // 求和 println!(\u0026#34;Sum of squares of even numbers: {}\u0026#34;, sum); 6.2 自定义排序 #[derive(Debug)] struct Person { name: String, age: u32, } fn main() { let mut people = vec![ Person { name: String::from(\u0026#34;Alice\u0026#34;), age: 30 }, Person { name: String::from(\u0026#34;Bob\u0026#34;), age: 25 }, ]; // 使用闭包定义排序规则 people.sort_by_key(|p| p.age); println!(\u0026#34;Sorted by age: {:?}\u0026#34;, people); } 6.3 资源管理 struct Connection { port: u32, } impl Connection { fn new(port: u32) -\u0026gt; Connection { println!(\u0026#34;Opening connection on port {}\u0026#34;, port); Connection { port } } } impl Drop for Connection { fn drop(\u0026amp;mut self) { println!(\u0026#34;Closing connection on port {}\u0026#34;, self.port); } } fn with_connection\u0026lt;F\u0026gt;(port: u32, f: F) where F: FnOnce(\u0026amp;Connection) { let conn = Connection::new(port); f(\u0026amp;conn); // 连接会在这里自动关闭 } fn main() { with_connection(8080, |conn| { println!(\u0026#34;Using connection on port {}\u0026#34;, conn.port); }); } 七、性能和调试技巧 内联优化 #[inline] fn regular_function(x: i32) -\u0026gt; i32 { x \u0026#43; 1 } let closure = |x| x \u0026#43; 1; // 编译器通常会自动内联 大小优化 // 移动捕获而不是引用可能更高效 let value = String::from(\u0026#34;hello\u0026#34;); let closure = move || println!(\u0026#34;{}\u0026#34;, value); 通过这些实例和分析，我们可以看到Rust闭包不仅仅是一个语法特性，更是一套完整的系统设计。它结合了函数式编程的灵活性和Rust的安全性保证，为我们提供了强大的编程工具。\n这种设计告诉我们：语言特性的设计不是随意的，而是要考虑实用性、性能和安全性的平衡。Rust的闭包实现就很好地体现了这一点。\n","date":"2025-01-15","tags":["编程","rust"],"title":"rust 闭包","url":"/post/2025/01/rust_closure/"},{"content":"从一个实际问题开始 假设我们在写一个文件处理程序：\nfn read_config_file(path: \u0026amp;str) -\u0026gt; String { std::fs::read_to_string(path) // 这里会返回什么？ } 这段代码看似简单，但隐藏着两个基本问题：\n文件可能不存在 即使文件存在，读取过程也可能失败 这就是为什么 Rust 引入了 Result 和 Option。\nOption：处理\u0026quot;有\u0026quot;与\u0026quot;没有\u0026quot; Option 的本质 enum Option\u0026lt;T\u0026gt; { Some(T), // 有值 None, // 没有值 } 让我们看一个实际例子：\nfn find_user(id: u32) -\u0026gt; Option\u0026lt;User\u0026gt; { if id == 0 { None // 用户不存在 } else { Some(User { id, ... }) // 用户存在 } } // 使用方式 match find_user(1) { Some(user) =\u0026gt; println!(\u0026#34;Found user: {}\u0026#34;, user.name), None =\u0026gt; println!(\u0026#34;User not found\u0026#34;), } Option 的常用方法 let x: Option\u0026lt;i32\u0026gt; = Some(5); // 方法1：unwrap - 危险操作 let value1 = x.unwrap(); // 如果是 None 会 panic // 方法2：unwrap_or - 提供默认值 let value2 = x.unwrap_or(0); // None 时返回0 // 方法3：map - 变换内部值 let value3 = x.map(|n| n * 2); // Some(5) -\u0026gt; Some(10) // 方法4：and_then - 链式操作 let value4 = x.and_then(|n| if n \u0026gt; 0 { Some(n) } else { None }); Result：处理“成功”与“失败” Result 的本质 enum Result\u0026lt;T, E\u0026gt; { Ok(T), // 成功，包含值 T Err(E), // 错误，包含错误 E } 实际应用示例：\nfn divide(x: i32, y: i32) -\u0026gt; Result\u0026lt;i32, \u0026amp;\u0026#39;static str\u0026gt; { if y == 0 { Err(\u0026#34;division by zero\u0026#34;) } else { Ok(x / y) } } // 使用方式 match divide(10, 2) { Ok(result) =\u0026gt; println!(\u0026#34;Result: {}\u0026#34;, result), Err(e) =\u0026gt; println!(\u0026#34;Error: {}\u0026#34;, e), } Result 的进阶操作 使用 ? 运算符简化错误处理： fn read_config() -\u0026gt; Result\u0026lt;Config, std::io::Error\u0026gt; { let data = std::fs::read_to_string(\u0026#34;config.json\u0026#34;)?; // 自动返回错误，Rust 会自动将错误从当前函数传播到调用者 let config = serde_json::from_str(\u0026amp;data)?; // 链式错误处理，将多个可能失败的操作串联起来，形成一个“链”，任何一个操作失败都会导致整个链中断并返回错误。 Ok(config) } 组合多个 Result： fn complex_operation() -\u0026gt; Result\u0026lt;(), MyError\u0026gt; { let x = step1()?; let y = step2(x)?; step3(y)?; Ok(()) } 实际工程中的最佳实践 自定义错误类型： #[derive(Debug)] enum MyError { IoError(std::io::Error), ParseError(serde_json::Error), ValidationError(String), } impl From\u0026lt;std::io::Error\u0026gt; for MyError { fn from(err: std::io::Error) -\u0026gt; MyError { MyError::IoError(err) } } 结合 Option 和 Result： fn process_data(data: Option\u0026lt;\u0026amp;str\u0026gt;) -\u0026gt; Result\u0026lt;(), MyError\u0026gt; { let text = data.ok_or(MyError::ValidationError(\u0026#34;No data\u0026#34;.into()))?; // 进一步处理... Ok(()) } 错误传播模式： fn operation() -\u0026gt; Result\u0026lt;(), Error\u0026gt; { let mut file = File::open(\u0026#34;test.txt\u0026#34;).map_err(|e| { Error::new(\u0026#34;Failed to open file\u0026#34;, Some(Box::new(e))) })?; let mut content = String::new(); file.read_to_string(\u0026amp;mut content).map_err(|e| { Error::new(\u0026#34;Failed to read file\u0026#34;, Some(Box::new(e))) })?; Ok(()) } 性能考虑 Option 和 Result 都是零开销抽象 编译器可以优化 match 模式匹配 ?运算符不会引入额外开销 常见误区 过度使用 unwrap()： // 不好的做法 let value = some_option.unwrap(); // 如果错误，会 Panic // 好的做法 let value = some_option.ok_or(\u0026#34;meaningful error message\u0026#34;)?; // 如果错误，会使用（默认值） 忽略错误类型： // 不好的做法 type Result\u0026lt;T\u0026gt; = std::result::Result\u0026lt;T, Box\u0026lt;dyn Error\u0026gt;\u0026gt;; // 好的做法 type Result\u0026lt;T\u0026gt; = std::result::Result\u0026lt;T, MyError\u0026gt;; 不恰当的 None 使用： // 不好的做法 fn get_user_name(id: u32) -\u0026gt; Option\u0026lt;String\u0026gt; { if id == 0 { None // 这里应该用 Result 表达错误 } else { Some(\u0026#34;name\u0026#34;.to_string()) } } 通过这样的设计，Rust 强制我们在编译时就处理所有可能的错误情况，使得程序更加健壮。Option 和 Result 不仅是类型，更是一种编程思维的体现。\n深入理解 Rust 的错误处理机制 如上，你可能写过这样的代码：\nlet file = File::open(\u0026#34;config.json\u0026#34;); let content = read_to_string(file); process_config(content); 这段代码看似简单，但隐藏着几个关键问题：\n文件可能不存在 文件内容可能无法读取 内容可能不是有效的配置 这就是为什么 Rust 引入了 Result 和 Option 来处理这些情况。\nResult 的实际使用 示例 fn read_config_file(path: \u0026amp;str) -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let file = match File::open(path) { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; return Err(error), }; let mut content = String::new(); match file.read_to_string(\u0026amp;mut content) { Ok(_) =\u0026gt; Ok(content), Err(error) =\u0026gt; Err(error), } } // 使用方式 match read_config_file(\u0026#34;config.json\u0026#34;) { Ok(content) =\u0026gt; println!(\u0026#34;配置内容: {}\u0026#34;, content), Err(error) =\u0026gt; println!(\u0026#34;读取失败: {}\u0026#34;, error), } Result 的常用方法 // 使用?运算符简化错误传播 fn read_config() -\u0026gt; Result\u0026lt;Config, io::Error\u0026gt; { let content = File::open(\u0026#34;config.json\u0026#34;)?.read_to_string()?; Ok(Config::from_str(\u0026amp;content)?) } // unwrap - 成功则返回值，失败则panic let content = file.read_to_string().unwrap(); // expect - 类似unwrap，但可以自定义panic消息 let content = file.read_to_string().expect(\u0026#34;无法读取配置文件\u0026#34;); // unwrap_or - 提供默认值 let content = file.read_to_string().unwrap_or(String::from(\u0026#34;默认配置\u0026#34;)); // unwrap_or_else - 提供默认值的闭包 let content = file.read_to_string().unwrap_or_else(|_| { println!(\u0026#34;使用默认配置\u0026#34;); String::from(\u0026#34;默认配置\u0026#34;) }); Option 实战 示例 fn find_user(id: u64) -\u0026gt; Option\u0026lt;User\u0026gt; { if id == 0 { return None; } Some(User { id, name: \u0026#34;John\u0026#34;.to_string() }) } // 链式处理 let user_name = find_user(1) .map(|user| user.name) .unwrap_or_else(|| \u0026#34;Unknown\u0026#34;.to_string()); Option 的进阶用法 // 组合多个Option fn get_user_settings(user_id: u64) -\u0026gt; Option\u0026lt;Settings\u0026gt; { let user = find_user(user_id)?; let preferences = user.get_preferences()?; Some(Settings::new(preferences)) } // 处理复杂逻辑 match find_user(1) { Some(user) if user.is_admin =\u0026gt; { println!(\u0026#34;找到管理员用户\u0026#34;); } Some(user) =\u0026gt; { println!(\u0026#34;找到普通用户\u0026#34;); } None =\u0026gt; { println!(\u0026#34;未找到用户\u0026#34;); } } Result 和 Option 的组合使用 实际开发中，我们经常需要同时处理这两种情况：\nfn process_user_data(user_id: u64) -\u0026gt; Result\u0026lt;Option\u0026lt;UserData\u0026gt;, Error\u0026gt; { let user = match find_user(user_id) { Some(user) =\u0026gt; user, None =\u0026gt; return Ok(None), // 用户不存在，但这不是错误 }; match user.process_data() { Ok(data) =\u0026gt; Ok(Some(data)), Err(e) =\u0026gt; Err(e), // 处理数据时出错 } } // 使用?简化版本 fn process_user_data_simple(user_id: u64) -\u0026gt; Result\u0026lt;Option\u0026lt;UserData\u0026gt;, Error\u0026gt; { Ok(Some(find_user(user_id)?.process_data()?)) } 最佳实践 错误处理策略 // 不好的做法：滥用unwrap let data = risky_operation().unwrap(); // 可能panic // 好的做法：proper error handling let data = match risky_operation() { Ok(data) =\u0026gt; data, Err(e) =\u0026gt; { log::error!(\u0026#34;操作失败: {}\u0026#34;, e); return Err(e.into()); } }; 自定义错误类型 #[derive(Debug)] enum AppError { IoError(io::Error), ConfigError(String), UserError { id: u64, message: String }, } impl From\u0026lt;io::Error\u0026gt; for AppError { fn from(error: io::Error) -\u0026gt; Self { AppError::IoError(error) } } 合理使用组合器 // 使用map_err转换错误类型 let config = read_config() .map_err(|e| AppError::ConfigError(e.to_string()))?; // 使用and_then链式处理 let processed_data = find_user(1) .and_then(|user| user.get_data()) .and_then(|data| process_data(data)); 总结启示 Result 和 Option 是 Rust 的核心类型，掌握它们对于写出可靠的 Rust 程序至关重要。 合理使用这些类型可以让代码更加健壮和可维护。 注意区分什么时候使用 Result（表示可能的错误），什么时候使用 Option（表示可能的缺失）。 通过这种方式处理错误和可选值，我们可以在编译时就发现很多潜在的问题，而不是在运行时才遇到意外情况。这正是Rust的设计理念：在编译时发现问题总比在运行时崩溃要好。\n你在实际项目中是如何处理错误和空值的？欢迎分享你的经验。\n","date":"2025-01-15","tags":["编程","rust"],"title":"深入解释 Rust 中的 Result 和 Option 这两个核心类型","url":"/post/2025/01/rust_result_option/"},{"content":"在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：\n使用 web_sys 和 wasm_bindgen 进行浏览器 API 调用： use wasm_bindgen::prelude::*; use web_sys::{console, window}; pub fn move_test(name: \u0026amp;str) { // 控制台打印 console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!(\u0026#34;move test: {}\u0026#34;, name))); // 使用 console.warn console::warn_1(\u0026amp;JsValue::from_str(\u0026#34;This is a warning\u0026#34;)); // 使用 console.error console::error_1(\u0026amp;JsValue::from_str(\u0026#34;This is an error\u0026#34;)); // 浏览器 alert if let Some(window) = window() { window .alert_with_message(\u0026amp;format!(\u0026#34;Hello, {}!\u0026#34;, name)) .expect(\u0026#34;alert failed\u0026#34;); } // 确认对话框 if let Some(window) = window() { if window .confirm_with_message(\u0026#34;Do you want to continue?\u0026#34;) .expect(\u0026#34;confirm failed\u0026#34;) { console::log_1(\u0026amp;JsValue::from_str(\u0026#34;User clicked OK\u0026#34;)); } else { console::log_1(\u0026amp;JsValue::from_str(\u0026#34;User clicked Cancel\u0026#34;)); } } } 在 Cargo.toml 中需要添加必要的依赖： [dependencies] wasm-bindgen = \u0026#34;0.2\u0026#34; web-sys = { version = \u0026#34;0.3\u0026#34;, features = [ \u0026#34;console\u0026#34;, \u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;HtmlElement\u0026#34;, \u0026#34;Node\u0026#34;, \u0026#34;Location\u0026#34; ]} 如果需要格式化打印，可以使用 console::log! 宏： use web_sys::console; // 需要引入宏 #[macro_export] macro_rules! console_log { ($($t:tt)*) =\u0026gt; (console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!($($t)*)))) } pub fn move_test(name: \u0026amp;str) { console_log!(\u0026#34;Testing move with name: {}\u0026#34;, name); } 操作 DOM 示例： use wasm_bindgen::prelude::*; use web_sys::{Document, Element, HtmlElement, window}; pub fn move_test(name: \u0026amp;str) { // 获取 document let window = window().expect(\u0026#34;no global window exists\u0026#34;); let document = window.document().expect(\u0026#34;no document exists\u0026#34;); // 创建新元素 if let Some(div) = document.get_element_by_id(\u0026#34;test-input\u0026#34;) { // 修改输入框的值 if let Some(input) = div.dyn_ref::\u0026lt;HtmlElement\u0026gt;() { input.set_inner_text(\u0026amp;format!(\u0026#34;New value: {}\u0026#34;, name)); } } // 创建新元素 let new_div = document.create_element(\u0026#34;div\u0026#34;).unwrap(); new_div.set_text_content(Some(\u0026amp;format!(\u0026#34;Hello {}\u0026#34;, name))); // 添加到 body if let Some(body) = document.body() { body.append_child(\u0026amp;new_div).unwrap(); } } 处理错误和 Result： pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { // 使用 ? 运算符处理错误 let window = window().ok_or(\u0026#34;no global window exists\u0026#34;)?; let document = window.document().ok_or(\u0026#34;no document exists\u0026#34;)?; // 处理可能的错误 match document.get_element_by_id(\u0026#34;test-input\u0026#34;) { Some(element) =\u0026gt; { console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!(\u0026#34;Found element: {}\u0026#34;, name))); Ok(()) }, None =\u0026gt; Err(JsValue::from_str(\u0026#34;Element not found\u0026#34;)) } } 使用本地存储： use web_sys::Storage; pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { let window = window().ok_or(\u0026#34;no global window exists\u0026#34;)?; // 获取 localStorage if let Some(storage) = window.local_storage()? { // 存储数据 storage.set_item(\u0026#34;user_name\u0026#34;, name)?; // 读取数据 if let Ok(Some(saved_name)) = storage.get_item(\u0026#34;user_name\u0026#34;) { console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!(\u0026#34;Saved name: {}\u0026#34;, saved_name))); } } Ok(()) } 记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 \u0026ldquo;Storage\u0026rdquo; feature：\nweb-sys = { version = \u0026#34;0.3\u0026#34;, features = [ \u0026#34;console\u0026#34;, \u0026#34;Window\u0026#34;, \u0026#34;Storage\u0026#34;, // ... 其他需要的 features ]} 这些示例展示了在 Rust WASM 中如何与浏览器进行交互的基本方法。你可以根据需要组合使用这些功能。\n以下是 Rust WebAssembly 开发的最佳实践建议：\n错误处理 use wasm_bindgen::prelude::*; use web_sys::console; // 定义自定义错误类型 #[derive(Debug)] pub enum WasmError { JsError(String), CustomError(String) } // 实现错误转换 impl From\u0026lt;WasmError\u0026gt; for JsValue { fn from(error: WasmError) -\u0026gt; Self { JsValue::from_str(\u0026amp;format!(\u0026#34;{:?}\u0026#34;, error)) } } // 使用 Result 处理错误 pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), WasmError\u0026gt; { // 优雅处理错误 if name.is_empty() { return Err(WasmError::CustomError(\u0026#34;Name cannot be empty\u0026#34;.into())); } // 记录日志 console::log_1(\u0026amp;format!(\u0026#34;Processing: {}\u0026#34;, name).into()); Ok(()) } 性能优化 use wasm_bindgen::prelude::*; use std::rc::Rc; use std::cell::RefCell; // 使用 Rc 和 RefCell 来共享数据 struct State { count: i32, data: Vec\u0026lt;String\u0026gt; } #[wasm_bindgen] pub struct App { state: Rc\u0026lt;RefCell\u0026lt;State\u0026gt;\u0026gt; } #[wasm_bindgen] impl App { // 尽量减少 JS/Rust 边界调用 pub fn batch_operation(\u0026amp;self, items: \u0026amp;[JsValue]) -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { let mut state = self.state.borrow_mut(); // 批量处理 for item in items { // 处理逻辑 } Ok(()) } } 模块化设计 // lib.rs mod utils; mod components; mod types; use utils::logging; use components::button; use types::custom_types; // 清晰的模块结构 pub fn initialize() { logging::setup_logging(); button::register_components(); } 日志和调试 #[macro_export] macro_rules! console_log { ($($t:tt)*) =\u0026gt; { web_sys::console::log_1(\u0026amp;format!($($t)*).into()) } } #[macro_export] macro_rules! console_error { ($($t:tt)*) =\u0026gt; { web_sys::console::error_1(\u0026amp;format!($($t)*).into()) } } // 使用 pub fn debug_operation(data: \u0026amp;str) { console_log!(\u0026#34;Starting operation with: {}\u0026#34;, data); // ... 操作代码 console_log!(\u0026#34;Operation completed\u0026#34;); } 内存管理 #[wasm_bindgen] pub struct LargeData { // 使用 Vec\u0026lt;u8\u0026gt; 而不是 String 处理二进制数据 buffer: Vec\u0026lt;u8\u0026gt;, } impl Drop for LargeData { fn drop(\u0026amp;mut self) { // 清理资源 self.buffer.clear(); } } 异步操作处理 use wasm_bindgen_futures::JsFuture; use web_sys::{Request, RequestInit, Response}; // 异步函数处理 pub async fn fetch_data(url: \u0026amp;str) -\u0026gt; Result\u0026lt;JsValue, JsValue\u0026gt; { let mut opts = RequestInit::new(); opts.method(\u0026#34;GET\u0026#34;); let request = Request::new_with_str_and_init(url, \u0026amp;opts)?; let window = web_sys::window().unwrap(); let resp_value = JsFuture::from(window.fetch_with_request(\u0026amp;request)).await?; let resp: Response = resp_value.dyn_into().unwrap(); JsFuture::from(resp.json()?).await } 测试策略 #[cfg(test)] mod tests { use super::*; use wasm_bindgen_test::*; wasm_bindgen_test_configure!(run_in_browser); #[wasm_bindgen_test] fn test_basic_functionality() { // 浏览器环境测试 let result = move_test(\u0026#34;test\u0026#34;); assert!(result.is_ok()); } } 构建优化 # Cargo.toml [package] name = \u0026#34;wasm-project\u0026#34; version = \u0026#34;0.1.0\u0026#34; [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [profile.release] lto = true opt-level = \u0026#39;z\u0026#39; codegen-units = 1 类型安全 use serde::{Serialize, Deserialize}; #[derive(Serialize, Deserialize)] pub struct UserData { name: String, age: u32, } #[wasm_bindgen] impl UserData { // 提供类型安全的接口 pub fn new(name: \u0026amp;str, age: u32) -\u0026gt; Result\u0026lt;UserData, JsValue\u0026gt; { if name.is_empty() { return Err(\u0026#34;Name cannot be empty\u0026#34;.into()); } Ok(UserData { name: name.to_string(), age, }) } } 文档注释 /// Performs a move test operation /// /// # Arguments /// /// * `name` - The name to test with /// /// # Returns /// /// * `Result\u0026lt;(), WasmError\u0026gt;` - Ok if successful, Err with error details if failed /// /// # Examples /// /// ``` /// let result = move_test(\u0026#34;test\u0026#34;); /// assert!(result.is_ok()); /// ``` #[wasm_bindgen] pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), WasmError\u0026gt; { // 实现代码 } ","date":"2025-01-15","tags":["编程","wasm"],"title":"Wasm 打印输出和浏览器特性等最佳实践","url":"/post/2025/01/wasm_print/"},{"content":"参考： 中文文档 https://hugo.opendocs.io/getting-started/quick-start/ ↗ 博客：\nhttps://blog.gujiakai.top/2023/03/hugo-theme-development-diary ↗ https://juejin.cn/post/7151253414427492382 ↗ 一个简单的 Hugo 主题 创建一个空的网站模版 hugo new site demo 这会在当前目录创建一个名为 demo 的目录，然后初始化 hugo 的目录结构，\n创建一个空的主题模版 cd demo hugo new theme hugo-zero 得到输出信息：\nCreating theme at /hugo/demo/themes/hugo-zero 一开始的目录结构如下图所示：\nhugo-zero（hugo主题） ├── archetypes（hugo主题文章模板） ├── layouts（hugo主题布局文件） ├── static（hugo主题的静态文件） ├── LICENSE（hugo主题的许可证信息） └── themes.toml（hugo主题的元数据信息） 其中，重点关注layouts文件夹。剩余的文件可以慢慢补充。\nlayouts 文件夹的目录结构如下图所示：\nlayouts ├── _default（默认页面布局文件夹） │ ├── baseof.html（所有页面的基底模板） │ ├── list.html（列表页面的模板文件） │ └── single.html（单页面的模板文件） ├── partials（部分页面布局文件夹） │ ├── head.html（网页头部） │ ├── header.html（网页的主导航栏） │ └── footer.html（网页的页脚信息） ├── 404.html（网站的404错误页面） └── index.html（网站的主页） 在 config.toml 里添加一行： theme = \u0026#34;hugo-zero\u0026#34; 这样就可以加载主题 hugo-zero了，运行看看有没有报错：\nhugo server 如果配置有问题会显示出错误信息，一切正常的话，能看到下面的输出：\n| EN \u0026#43;------------------\u0026#43;----\u0026#43; Pages | 3 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 5 ms Watching for changes in /tmp/demo/{archetypes,content,data,layouts,static,themes} Watching for config changes in /tmp/demo/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl\u0026#43;C to stop 用浏览器访问 http://localhost:1313/ 看到一个空页面，这个时候什么内容都还没有。\nindex.html 是首页，single.html 是文章页面。 baseof.html 所有页面的模版，每个页面都是基于这个页面进行扩展。 css 目录用来放样式文件。 head.html用来定义部分的内容，加载 CSS 样式文件就在这里添加。 footer.html一般用来展示版权信息。 header.html显示在顶部，展示网站名称。\n使用 创建网站 # 创建 demo 网站 hugo new site demo # 进入网站文件夹 cd demo 添加主题 # 初始化 git 仓库 git init # 添加 git 子模块（主题） git submodule add https://github.com/caoyang2002/hugo-zero.git themes/hugo-zero 在 config.toml 里添加一行： theme = \u0026#34;hugo-zero\u0026#34; 创建文章 创建 post_name.md 文章\nhugo new content/posts/post_name.md 生成 post_name.md 文件并添加元信息\n\u0026#43;\u0026#43;\u0026#43; date = \u0026#39;2025-01-03T11:11:07\u0026#43;08:00\u0026#39; draft = true title = \u0026#39;Post_name\u0026#39; \u0026#43;\u0026#43;\u0026#43; 启动 # 不包含草稿内容 hugo server # 包含草稿内容 hugo server -D 访问 http://localhost:1313/\n","date":"2025-01-03","tags":["hugo"],"title":"Hugo 主题创建方法及简单说明","url":"/post/2025/01/create_hugo_theme/"},{"content":"在 Go 项目架构中，有一些重要的设计原则和规则。我来详细说明：\n接口定义规则： // ✅ 正确：接口定义在使用方(调用方)包中 package handler type UserService interface { Create(ctx context.Context, user *User) error } // ❌ 错误：接口定义在实现方包中 package service type UserService interface { Create(ctx context.Context, user *User) error } 依赖方向： // ✅ 正确的依赖方向 handler -\u0026gt; service -\u0026gt; repository -\u0026gt; database // ❌ 错误：不应该出现反向依赖 service -\u0026gt; handler repository -\u0026gt; service 数据模型定义： // ✅ 正确：每层使用自己的数据模型 package handler type CreateUserRequest struct { // API层模型 Username string `json:\u0026#34;username\u0026#34;` } package service type UserDTO struct { // 业务层模型 ID uint64 Username string } package repository type UserDO struct { // 数据层模型 ID uint64 `gorm:\u0026#34;primaryKey\u0026#34;` Username string CreatedAt time.Time } // ❌ 错误：直接在所有层使用相同的模型 type User struct { ID uint64 `json:\u0026#34;id\u0026#34; gorm:\u0026#34;primaryKey\u0026#34;` Username string `json:\u0026#34;username\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` } 错误处理层级： // ✅ 正确：每层对错误进行适当包装 package repository func (r *UserRepo) Create(user *UserDO) error { return fmt.Errorf(\u0026#34;database error: %w\u0026#34;, err) } package service func (s *UserService) Create(user *UserDTO) error { return fmt.Errorf(\u0026#34;business error: %w\u0026#34;, err) } package handler func (h *UserHandler) Create(c *gin.Context) { if err := h.service.Create(user); err != nil { c.JSON(getErrorStatus(err), ErrorResponse{err.Error()}) return } } // ❌ 错误：直接暴露底层错误 if err := db.Create(\u0026amp;user).Error; err != nil { c.JSON(500, err.Error()) } 包的组织： ✅ 正确的包组织： project/ ├── api/ │ └── handler/ # HTTP 处理层 ├── internal/ │ ├── service/ # 业务逻辑层 │ ├── repository/ # 数据访问层 │ └── model/ # 内部数据模型 ├── pkg/ │ └── util/ # 公共工具函数 └── main.go ❌ 错误的包组织： project/ ├── handlers/ ├── services/ ├── models/ └── main.go 依赖注入： // ✅ 正确：通过构造函数注入依赖 func NewUserHandler(service UserService) *UserHandler { return \u0026amp;UserHandler{service: service} } // ❌ 错误：全局变量或直接初始化 var userService = \u0026amp;UserService{} 接口隔离： // ✅ 正确：小接口，职责单一 type UserReader interface { GetUser(id uint64) (*User, error) } type UserWriter interface { CreateUser(user *User) error } // ❌ 错误：大接口，职责过多 type UserService interface { GetUser(id uint64) (*User, error) CreateUser(user *User) error UpdateUser(user *User) error DeleteUser(id uint64) error ListUsers() ([]*User, error) SearchUsers(query string) ([]*User, error) } 配置管理： // ✅ 正确：集中管理配置 package config type Config struct { Server ServerConfig DB DatabaseConfig Redis RedisConfig } // ❌ 错误：分散的配置或硬编码 var serverPort = 8080 var dbConnection = \u0026#34;root:password@tcp(localhost:3306)/db\u0026#34; 上下文传递： // ✅ 正确：统一使用 context 传递请求上下文 func (h *Handler) Create(c *gin.Context) { ctx := c.Request.Context() err := h.service.Create(ctx, req) } // ❌ 错误：不传递上下文或使用不一致的上下文 func (h *Handler) Create(c *gin.Context) { err := h.service.Create(req) } 测试组织： // ✅ 正确：测试文件与源文件对应 package handler func TestUserHandler_Create(t *testing.T) { // 单元测试 } // ❌ 错误：测试代码与源码混合或测试覆盖不全 func TestAll(t *testing.T) { // 混合测试多个功能 } 遵循这些规则可以使代码：\n更容易理解和维护 更好的测试覆盖 更清晰的责任边界 更容易进行重构 更好的扩展性 同时也避免了常见的问题如：\n循环依赖 紧耦合 难以测试 难以维护 代码重复 是的，还有一些重要的设计规则和最佳实践：\n命名规范： // ✅ 正确：清晰的命名约定 type ( // Response 用于外部 API CreateUserResponse struct { UserID uint64 `json:\u0026#34;user_id\u0026#34;` } // DTO 用于服务层 UserDTO struct { ID uint64 } // DO 用于数据库层 UserDO struct { ID uint64 `gorm:\u0026#34;column:id\u0026#34;` } ) // ❌ 错误：命名不清晰或不一致 type ( UserResp struct {} UserData struct {} TUser struct {} ) 领域驱动的包组织： // ✅ 正确：按领域组织代码 project/ ├── user/ │ ├── handler.go │ ├── service.go │ └── repository.go ├── order/ │ ├── handler.go │ ├── service.go │ └── repository.go └── product/ ├── handler.go ├── service.go └── repository.go // ❌ 错误：按技术层级组织 project/ ├── handler/ │ ├── user.go │ ├── order.go │ └── product.go └── service/ ├── user.go ├── order.go └── product.go 错误处理： // ✅ 正确：定义领域错误类型 package errors type ErrorCode int const ( ErrNotFound ErrorCode = iota \u0026#43; 1 ErrInvalidInput ErrUnauthorized ) type Error struct { Code ErrorCode Message string Err error } // ❌ 错误：使用通用错误或字符串 if err != nil { return errors.New(\u0026#34;something went wrong\u0026#34;) } 中间件链管理： // ✅ 正确：中间件配置集中管理 func SetupMiddlewares(r *gin.Engine) { r.Use( middleware.Recovery(), middleware.Logger(), middleware.Trace(), middleware.Auth(), ) } // ❌ 错误：中间件分散配置 r.Use(middleware.Logger()) // ... 其他代码 r.Use(middleware.Auth()) 配置验证： // ✅ 正确：配置验证和默认值 type Config struct { Port int `validate:\u0026#34;required,min=1024,max=65535\u0026#34;` Timeout time.Duration `validate:\u0026#34;required,min=1s\u0026#34;` LogLevel string `validate:\u0026#34;oneof=debug info warn error\u0026#34;` } func (c *Config) Validate() error { return validator.Struct(c) } // ❌ 错误：无验证的配置 type Config struct { Port int Timeout time.Duration LogLevel string } 日志处理： // ✅ 正确：结构化日志，带上下文信息 func (s *service) CreateUser(ctx context.Context, user *User) error { logger := log.WithContext(ctx).With( \u0026#34;user_id\u0026#34;, user.ID, \u0026#34;action\u0026#34;, \u0026#34;create_user\u0026#34;, ) logger.Info(\u0026#34;creating user\u0026#34;) if err := s.repo.Create(user); err != nil { logger.Error(\u0026#34;failed to create user\u0026#34;, \u0026#34;error\u0026#34;, err) return err } return nil } // ❌ 错误：非结构化日志，信息不完整 log.Printf(\u0026#34;error: %v\u0026#34;, err) 事务处理： // ✅ 正确：统一的事务管理 type TxManager interface { WithTx(ctx context.Context, fn func(ctx context.Context) error) error } func (s *service) CreateOrder(ctx context.Context, order *Order) error { return s.txManager.WithTx(ctx, func(ctx context.Context) error { // 在事务中执行操作 if err := s.repo.Create(ctx, order); err != nil { return err } return s.eventRepo.Publish(ctx, \u0026#34;order_created\u0026#34;, order) }) } // ❌ 错误：手动事务管理 tx := db.Begin() if err := tx.Create(order).Error; err != nil { tx.Rollback() return err } tx.Commit() 缓存策略： // ✅ 正确：缓存抽象和策略 type Cache interface { Get(ctx context.Context, key string) (interface{}, error) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error } type UserService struct { repo Repository cache Cache } // ❌ 错误：直接使用缓存实现 func (s *service) GetUser(id string) (*User, error) { key := fmt.Sprintf(\u0026#34;user:%s\u0026#34;, id) if val, err := redis.Get(key).Result(); err == nil { // 处理缓存 } } 并发控制： // ✅ 正确：优雅的并发控制 func ProcessItems(items []Item) error { sem := make(chan struct{}, MaxConcurrent) errs := make(chan error, len(items)) for _, item := range items { sem \u0026lt;- struct{}{} // 获取信号量 go func(item Item) { defer func() { \u0026lt;-sem }() // 释放信号量 if err := processItem(item); err != nil { errs \u0026lt;- err } }(item) } // 等待所有 goroutine 完成 return errors.Join(errs...) } // ❌ 错误：无控制的并发 for _, item := range items { go processItem(item) } 优雅关闭： // ✅ 正确：优雅关闭服务 func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() go func() { sigCh := make(chan os.Signal, 1) signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-sigCh cancel() }() if err := server.Run(ctx); err != nil { log.Fatal(err) } } // ❌ 错误：直接退出 func main() { if err := server.Run(); err != nil { os.Exit(1) } } 这些规则和最佳实践能帮助你：\n提高代码质量和可维护性 减少 bug 和技术债务 提高团队协作效率 使系统更加健壮和可靠 便于扩展和重构 这个接口定义应该放在 handler 包中。原因如下：\n依赖关系:\nHandler 依赖 Service 接口应该由调用方(Handler)定义，而不是实现方(Service)定义 这样符合依赖倒置原则(DIP) 导入循环:\n如果接口定义在 service 包中，会导致包循环引用的问题： handler 包需要导入 service 包来使用数据结构 service 包需要导入 handler 包来实现接口 让我来展示正确的结构：\n这样组织代码的好处是：\n符合依赖倒置原则：\n高层模块(Handler)不依赖于低层模块(Service) 两者都依赖于抽象(接口) 抽象由调用方定义，不依赖于具体实现 避免循环依赖：\nHandler 定义接口和数据结构 Service 实现接口，使用 Handler 中定义的类型 Repository 层不需要知道上层的存在 清晰的依赖方向：\nHandler (定义接口) \u0026lt;- Service (实现接口) \u0026lt;- Repository 更好的测试性：\n可以轻松为 Handler 创建 Service 的 mock 接口和数据结构集中在一处，易于维护 更容易进行修改：\n如果需要修改接口，只需要修改 Handler 包 实现方(Service)会得到编译错误提示，确保实现完整性 是的，还有更多重要的设计规则和最佳实践：\n参数验证： // ✅ 正确：分层的参数验证 // handler 层：验证 API 参数格式 type CreateUserRequest struct { Username string `json:\u0026#34;username\u0026#34; binding:\u0026#34;required,min=3,max=32\u0026#34;` Email string `json:\u0026#34;email\u0026#34; binding:\u0026#34;required,email\u0026#34;` Age int `json:\u0026#34;age\u0026#34; binding:\u0026#34;required,gte=0,lte=150\u0026#34;` } // service 层：验证业务规则 func (s *UserService) Create(ctx context.Context, dto *UserDTO) error { if err := s.validateBusinessRules(ctx, dto); err != nil { return fmt.Errorf(\u0026#34;business validation failed: %w\u0026#34;, err) } // ... } // ❌ 错误：验证逻辑混乱或重复 if username == \u0026#34;\u0026#34; || len(username) \u0026lt; 3 { return errors.New(\u0026#34;invalid username\u0026#34;) } 模块化配置： // ✅ 正确：模块化的配置管理 type Config struct { HTTP HTTPConfig `mapstructure:\u0026#34;http\u0026#34;` Database DatabaseConfig `mapstructure:\u0026#34;database\u0026#34;` Cache CacheConfig `mapstructure:\u0026#34;cache\u0026#34;` } type HTTPConfig struct { Port int `mapstructure:\u0026#34;port\u0026#34; validate:\u0026#34;required\u0026#34;` ReadTimeout time.Duration `mapstructure:\u0026#34;read_timeout\u0026#34; validate:\u0026#34;required\u0026#34;` WriteTimeout time.Duration `mapstructure:\u0026#34;write_timeout\u0026#34; validate:\u0026#34;required\u0026#34;` } // ❌ 错误：平铺的配置结构 type Config struct { HTTPPort int HTTPReadTimeout time.Duration HTTPWriteTimeout time.Duration DBHost string DBPort int DBUser string // ... } 资源管理： // ✅ 正确：统一的资源管理器 type ResourceManager struct { db *gorm.DB redis *redis.Client es *elasticsearch.Client } func NewResourceManager() *ResourceManager { return \u0026amp;ResourceManager{ db: initDB(), redis: initRedis(), es: initElasticsearch(), } } func (rm *ResourceManager) Close() error { var errs []error if err := rm.db.Close(); err != nil { errs = append(errs, fmt.Errorf(\u0026#34;db close error: %w\u0026#34;, err)) } if err := rm.redis.Close(); err != nil { errs = append(errs, fmt.Errorf(\u0026#34;redis close error: %w\u0026#34;, err)) } return errors.Join(errs...) } // ❌ 错误：分散的资源管理 var ( db *gorm.DB redis *redis.Client ) 环境配置： // ✅ 正确：环境感知的配置 type Environment string const ( EnvDevelopment Environment = \u0026#34;development\u0026#34; EnvStaging Environment = \u0026#34;staging\u0026#34; EnvProduction Environment = \u0026#34;production\u0026#34; ) type Config struct { Env Environment `mapstructure:\u0026#34;env\u0026#34; validate:\u0026#34;required,oneof=development staging production\u0026#34;` } func (c *Config) IsDevelopment() bool { return c.Env == EnvDevelopment } func (c *Config) IsProduction() bool { return c.Env == EnvProduction } // ❌ 错误：硬编码的环境判断 if os.Getenv(\u0026#34;ENV\u0026#34;) == \u0026#34;prod\u0026#34; { // ... } 监控指标： // ✅ 正确：结构化的监控指标 const ( MetricRequestTotal = \u0026#34;http_requests_total\u0026#34; MetricRequestDuration = \u0026#34;http_request_duration_seconds\u0026#34; MetricDatabaseQueries = \u0026#34;database_queries_total\u0026#34; ) type Metrics interface { Counter(name string, labels map[string]string) float64 Histogram(name string, value float64, labels map[string]string) Gauge(name string, value float64, labels map[string]string) } // ❌ 错误：临时或非结构化的监控 log.Printf(\u0026#34;request took %v\u0026#34;, time.Since(start)) API 版本控制： // ✅ 正确：显式的 API 版本控制 func SetupRoutes(r *gin.Engine) { v1 := r.Group(\u0026#34;/api/v1\u0026#34;) { users := v1.Group(\u0026#34;/users\u0026#34;) users.POST(\u0026#34;/\u0026#34;, handler.CreateUserV1) } v2 := r.Group(\u0026#34;/api/v2\u0026#34;) { users := v2.Group(\u0026#34;/users\u0026#34;) users.POST(\u0026#34;/\u0026#34;, handler.CreateUserV2) } } // ❌ 错误：隐式或缺少版本控制 r.POST(\u0026#34;/api/users\u0026#34;, handler.CreateUser) 依赖注入容器： // ✅ 正确：使用依赖注入容器 type Container struct { services map[reflect.Type]interface{} mu sync.RWMutex } func (c *Container) Register(service interface{}) { c.mu.Lock() defer c.mu.Unlock() c.services[reflect.TypeOf(service)] = service } func (c *Container) Resolve(t reflect.Type) interface{} { c.mu.RLock() defer c.mu.RUnlock() return c.services[t] } // ❌ 错误：全局变量依赖 var ( userService *UserService orderService *OrderService ) 数据库迁移： // ✅ 正确：版本化的数据库迁移 type Migration struct { Version uint64 Description string UpSQL string DownSQL string } var migrations = []Migration{ { Version: 1, Description: \u0026#34;Create users table\u0026#34;, UpSQL: `CREATE TABLE users (...)`, DownSQL: `DROP TABLE users`, }, // ... } // ❌ 错误：手动或非版本化的迁移 func initDatabase() { db.Exec(\u0026#34;CREATE TABLE IF NOT EXISTS users (...)\u0026#34;) } 文档生成： // ✅ 正确：自动化的文档生成 // @Summary 创建用户 // @Description 创建新用户并返回用户ID // @Tags users // @Accept json // @Produce json // @Param user body CreateUserRequest true \u0026#34;用户信息\u0026#34; // @Success 200 {object} CreateUserResponse // @Router /api/v1/users [post] func (h *UserHandler) Create(c *gin.Context) { // ... } // ❌ 错误：手动维护或缺少文档 func (h *UserHandler) Create(c *gin.Context) { // TODO: add documentation } 测试数据工厂： // ✅ 正确：使用测试数据工厂 type UserFactory struct { faker *faker.Faker } func (f *UserFactory) MakeUser(opts ...UserOption) *User { user := \u0026amp;User{ Username: f.faker.Internet().UserName(), Email: f.faker.Internet().Email(), } for _, opt := range opts { opt(user) } return user } // ❌ 错误：硬编码测试数据 user := \u0026amp;User{ Username: \u0026#34;test_user\u0026#34;, Email: \u0026#34;test@example.com\u0026#34;, } 这些规则和最佳实践能帮助你：\n提高代码的可测试性 增强系统的可观测性 简化部署和运维 提高开发效率 减少潜在问题 建议根据项目的具体需求和团队情况，选择合适的规则来遵循。不必一次性实现所有规则，可以渐进式地改进。\n是的，还有更多高级的设计规则和最佳实践：\n限流器实现： // ✅ 正确：可配置的限流器 type RateLimiter struct { tokens chan struct{} refillInterval time.Duration } func NewRateLimiter(rate int, interval time.Duration) *RateLimiter { rl := \u0026amp;RateLimiter{ tokens: make(chan struct{}, rate), refillInterval: interval, } // 初始填充令牌 for i := 0; i \u0026lt; rate; i\u0026#43;\u0026#43; { rl.tokens \u0026lt;- struct{}{} } // 定期补充令牌 go rl.refill() return rl } // middleware 使用 func RateLimitMiddleware(rl *RateLimiter) gin.HandlerFunc { return func(c *gin.Context) { select { case \u0026lt;-rl.tokens: c.Next() default: c.JSON(429, gin.H{\u0026#34;error\u0026#34;: \u0026#34;too many requests\u0026#34;}) c.Abort() } } } // ❌ 错误：简单计数器限流 var ( count int mu sync.Mutex lastReset time.Time ) 重试策略： // ✅ 正确：可配置的重试策略 type RetryConfig struct { MaxRetries int BaseDelay time.Duration MaxDelay time.Duration Multiplier float64 ShouldRetry func(error) bool } func WithRetry(ctx context.Context, fn func() error, cfg RetryConfig) error { var lastErr error for attempt := 0; attempt \u0026lt; cfg.MaxRetries; attempt\u0026#43;\u0026#43; { if err := fn(); err != nil { if !cfg.ShouldRetry(err) { return err } lastErr = err delay := time.Duration(float64(cfg.BaseDelay) * math.Pow(cfg.Multiplier, float64(attempt))) if delay \u0026gt; cfg.MaxDelay { delay = cfg.MaxDelay } select { case \u0026lt;-ctx.Done(): return ctx.Err() case \u0026lt;-time.After(delay): continue } } return nil } return fmt.Errorf(\u0026#34;max retries exceeded: %w\u0026#34;, lastErr) } // ❌ 错误：硬编码重试逻辑 for i := 0; i \u0026lt; 3; i\u0026#43;\u0026#43; { if err := doSomething(); err == nil { break } time.Sleep(time.Second) } 工作池模式： // ✅ 正确：通用工作池实现 type Pool struct { tasks chan func() workers int wg sync.WaitGroup ctx context.Context cancel context.CancelFunc } func NewPool(workers int) *Pool { ctx, cancel := context.WithCancel(context.Background()) p := \u0026amp;Pool{ tasks: make(chan func()), workers: workers, ctx: ctx, cancel: cancel, } p.start() return p } func (p *Pool) start() { for i := 0; i \u0026lt; p.workers; i\u0026#43;\u0026#43; { p.wg.Add(1) go func() { defer p.wg.Done() for { select { case task, ok := \u0026lt;-p.tasks: if !ok { return } task() case \u0026lt;-p.ctx.Done(): return } } }() } } // ❌ 错误：为每个任务创建 goroutine for _, task := range tasks { go process(task) } 断路器模式： // ✅ 正确：断路器实现 type CircuitBreaker struct { mu sync.RWMutex failureCount int lastFailure time.Time state State threshold int timeout time.Duration } type State int const ( StateClosed State = iota StateHalfOpen StateOpen ) func (cb *CircuitBreaker) Execute(fn func() error) error { if !cb.allowRequest() { return ErrCircuitOpen } err := fn() cb.recordResult(err) return err } // ❌ 错误：无保护的外部调用 response, err := http.Get(url) 优雅降级： // ✅ 正确：降级策略 type Fallback struct { Primary func() (interface{}, error) Secondary func() (interface{}, error) Cache Cache } func (f *Fallback) Execute() (interface{}, error) { // 尝试主要实现 result, err := f.Primary() if err == nil { return result, nil } // 尝试缓存 if cached, err := f.Cache.Get(); err == nil { return cached, nil } // 使用备用实现 return f.Secondary() } // ❌ 错误：无降级处理 result, err := getPrimaryData() if err != nil { return err } 服务健康检查： // ✅ 正确：结构化的健康检查 type HealthChecker struct { checks map[string]HealthCheck } type HealthCheck func() error func (h *HealthChecker) AddCheck(name string, check HealthCheck) { h.checks[name] = check } func (h *HealthChecker) RunChecks() map[string]string { results := make(map[string]string) for name, check := range h.checks { if err := check(); err != nil { results[name] = fmt.Sprintf(\u0026#34;unhealthy: %v\u0026#34;, err) } else { results[name] = \u0026#34;healthy\u0026#34; } } return results } // ❌ 错误：简单的 ping 检查 func healthCheck(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;ok\u0026#34;)) } 应用指标收集： // ✅ 正确：结构化的指标收集 type Metrics struct { counters map[string]*atomic.Int64 histograms map[string]*metrics.Histogram mu sync.RWMutex } func (m *Metrics) RecordLatency(name string, duration time.Duration) { m.mu.RLock() histogram, exists := m.histograms[name] m.mu.RUnlock() if exists { histogram.Observe(duration.Seconds()) } } // ❌ 错误：简单日志记录 log.Printf(\u0026#34;operation took %v\u0026#34;, time.Since(start)) 链路追踪： // ✅ 正确：完整的链路追踪 type Tracer struct { spans map[string]*Span } type Span struct { TraceID string SpanID string ParentID string Operation string StartTime time.Time EndTime time.Time Attributes map[string]string } func (t *Tracer) StartSpan(ctx context.Context, op string) (*Span, context.Context) { parent := SpanFromContext(ctx) span := \u0026amp;Span{ TraceID: generateTraceID(), SpanID: generateSpanID(), Operation: op, StartTime: time.Now(), Attributes: make(map[string]string), } if parent != nil { span.ParentID = parent.SpanID } return span, ContextWithSpan(ctx, span) } // ❌ 错误：仅记录开始和结束 start := time.Now() defer func() { log.Printf(\u0026#34;operation took %v\u0026#34;, time.Since(start)) }() 这些高级模式可以帮助你：\n提高系统的可靠性 增强系统的弹性 改善系统的可观测性 优化性能 更好地处理异常情况 重要提示：\n这些模式应根据实际需求选择使用 不要过度设计 应该渐进式地引入这些模式 需要考虑维护成本 团队的技术能力要匹配 你还需要了解其他方面的内容吗？\n是的，让我继续分享一些高级设计模式和最佳实践：\n缓存策略模式： // ✅ 正确：可插拔的缓存策略 type CacheStrategy interface { Get(ctx context.Context, key string) (interface{}, error) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error Delete(ctx context.Context, key string) error } // 多级缓存策略 type MultiLevelCache struct { l1 CacheStrategy // 本地缓存 l2 CacheStrategy // Redis缓存 } func (m *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) { // 先查本地缓存 if val, err := m.l1.Get(ctx, key); err == nil { return val, nil } // 查Redis缓存 val, err := m.l2.Get(ctx, key) if err != nil { return nil, err } // 回填本地缓存 go m.l1.Set(ctx, key, val, time.Minute) return val, nil } // ❌ 错误：硬编码的缓存逻辑 if val, err := localCache.Get(key); err == nil { return val } return redisCache.Get(key) 数据库读写分离： // ✅ 正确：读写分离封装 type Database struct { master *gorm.DB slaves []*gorm.DB mu sync.RWMutex index uint64 // 用于轮询 } func (db *Database) Master() *gorm.DB { return db.master } func (db *Database) Slave() *gorm.DB { db.mu.RLock() defer db.mu.RUnlock() if len(db.slaves) == 0 { return db.master } // 轮询选择从库 index := atomic.AddUint64(\u0026amp;db.index, 1) return db.slaves[index%uint64(len(db.slaves))] } // 使用示例 func (r *UserRepo) Create(ctx context.Context, user *User) error { return r.db.Master().Create(user).Error } func (r *UserRepo) Find(ctx context.Context, id uint64) (*User, error) { var user User err := r.db.Slave().First(\u0026amp;user, id).Error return \u0026amp;user, err } // ❌ 错误：不区分读写的数据库操作 db.Create(user) db.First(\u0026amp;user) 消息队列封装： // ✅ 正确：抽象的消息队列接口 type MessageQueue interface { Publish(ctx context.Context, topic string, msg interface{}) error Subscribe(ctx context.Context, topic string, handler MessageHandler) error } type MessageHandler func(ctx context.Context, msg []byte) error // Kafka实现 type KafkaQueue struct { producer sarama.SyncProducer consumer sarama.ConsumerGroup } func (k *KafkaQueue) Publish(ctx context.Context, topic string, msg interface{}) error { data, err := json.Marshal(msg) if err != nil { return err } _, _, err = k.producer.SendMessage(\u0026amp;sarama.ProducerMessage{ Topic: topic, Value: sarama.ByteEncoder(data), }) return err } // ❌ 错误：直接使用消息队列客户端 producer.SendMessage(\u0026amp;sarama.ProducerMessage{...}) 分布式锁： // ✅ 正确：分布式锁接口和实现 type DistributedLock interface { Lock(ctx context.Context) error Unlock(ctx context.Context) error } // Redis实现 type RedisLock struct { client *redis.Client key string value string expires time.Duration } func (l *RedisLock) Lock(ctx context.Context) error { ok, err := l.client.SetNX(ctx, l.key, l.value, l.expires).Result() if err != nil { return err } if !ok { return ErrLockAcquireFailed } return nil } func (l *RedisLock) Unlock(ctx context.Context) error { script := ` if redis.call(\u0026#34;get\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;, KEYS[1]) else return 0 end ` return l.client.Eval(ctx, script, []string{l.key}, l.value).Err() } // ❌ 错误：简单的互斥锁 var mu sync.Mutex 业务规则引擎： // ✅ 正确：可配置的规则引擎 type Rule interface { Evaluate(ctx context.Context, facts map[string]interface{}) (bool, error) } type CompositeRule struct { rules []Rule operator string // \u0026#34;and\u0026#34; or \u0026#34;or\u0026#34; } func (c *CompositeRule) Evaluate(ctx context.Context, facts map[string]interface{}) (bool, error) { switch c.operator { case \u0026#34;and\u0026#34;: for _, rule := range c.rules { ok, err := rule.Evaluate(ctx, facts) if err != nil { return false, err } if !ok { return false, nil } } return true, nil case \u0026#34;or\u0026#34;: for _, rule := range c.rules { ok, err := rule.Evaluate(ctx, facts) if err != nil { return false, err } if ok { return true, nil } } return false, nil default: return false, fmt.Errorf(\u0026#34;unknown operator: %s\u0026#34;, c.operator) } } // ❌ 错误：硬编码的业务规则 if user.Age \u0026gt;= 18 \u0026amp;\u0026amp; user.Country == \u0026#34;CN\u0026#34; { // ... } 配置热更新： // ✅ 正确：支持热更新的配置 type DynamicConfig struct { mu sync.RWMutex current atomic.Value watch chan struct{} } func (c *DynamicConfig) Watch() { go func() { for { select { case \u0026lt;-c.watch: // 配置变更通知 if err := c.reload(); err != nil { log.Printf(\u0026#34;reload config error: %v\u0026#34;, err) } } } }() } func (c *DynamicConfig) reload() error { c.mu.Lock() defer c.mu.Unlock() // 加载新配置 newConfig, err := loadConfig() if err != nil { return err } // 原子更新 c.current.Store(newConfig) return nil } // ❌ 错误：静态配置 var config = loadConfig() 权限控制： // ✅ 正确：RBAC权限系统 type Permission string const ( PermissionUserCreate Permission = \u0026#34;user:create\u0026#34; PermissionUserRead Permission = \u0026#34;user:read\u0026#34; PermissionUserUpdate Permission = \u0026#34;user:update\u0026#34; PermissionUserDelete Permission = \u0026#34;user:delete\u0026#34; ) type RBAC struct { roles map[string][]Permission userRoles map[string][]string } func (r *RBAC) Can(userID string, perm Permission) bool { roles := r.userRoles[userID] for _, role := range roles { perms := r.roles[role] for _, p := range perms { if p == perm { return true } } } return false } // 中间件使用 func RequirePermission(perm Permission) gin.HandlerFunc { return func(c *gin.Context) { userID := GetUserID(c) if !rbac.Can(userID, perm) { c.AbortWithStatus(http.StatusForbidden) return } c.Next() } } // ❌ 错误：简单的角色检查 if user.Role != \u0026#34;admin\u0026#34; { return errors.New(\u0026#34;permission denied\u0026#34;) } 这些高级模式和最佳实践可以帮助你：\n实现更复杂的业务需求 提高系统的可扩展性 增强代码的可维护性 提升系统性能 更好地处理分布式场景 关键建议：\n根据实际需求选择合适的模式 避免过度设计 考虑团队的技术水平 注意维护成本 持续优化和改进 需要了解更多其他方面的内容吗？\n是的，让我们继续探讨更多高级设计模式和实践：\n领域事件处理： // ✅ 正确：领域事件处理 type DomainEvent interface { EventName() string OccurredAt() time.Time } type EventHandler interface { Handle(ctx context.Context, event DomainEvent) error } type EventBus struct { handlers map[string][]EventHandler mu sync.RWMutex } // 用户创建事件 type UserCreatedEvent struct { UserID uint64 Username string CreatedAt time.Time } func (e UserCreatedEvent) EventName() string { return \u0026#34;user.created\u0026#34; } // 事件处理器 type EmailNotifier struct { emailService EmailService } func (n *EmailNotifier) Handle(ctx context.Context, event DomainEvent) error { userCreated, ok := event.(*UserCreatedEvent) if !ok { return errors.New(\u0026#34;invalid event type\u0026#34;) } return n.emailService.SendWelcomeEmail(userCreated.UserID) } // 使用示例 func (s *UserService) Create(ctx context.Context, user *User) error { if err := s.repo.Create(ctx, user); err != nil { return err } // 发布领域事件 event := \u0026amp;UserCreatedEvent{ UserID: user.ID, Username: user.Username, CreatedAt: time.Now(), } return s.eventBus.Publish(ctx, event) } // ❌ 错误：直接在服务中处理副作用 func (s *UserService) Create(ctx context.Context, user *User) error { if err := s.repo.Create(ctx, user); err != nil { return err } s.emailService.SendWelcomeEmail(user.ID) // 紧耦合 return nil } 幂等性处理： // ✅ 正确：幂等性控制器 type IdempotencyKey string type IdempotencyControl struct { redis *redis.Client } func (ic *IdempotencyControl) Process( ctx context.Context, key IdempotencyKey, ttl time.Duration, fn func() error, ) error { // 使用 Redis 的 SETNX 实现幂等性检查 ok, err := ic.redis.SetNX(ctx, string(key), \u0026#34;processing\u0026#34;, ttl).Result() if err != nil { return fmt.Errorf(\u0026#34;idempotency check failed: %w\u0026#34;, err) } if !ok { return ErrDuplicateRequest } // 执行业务逻辑 if err := fn(); err != nil { // 业务执行失败，删除幂等键 ic.redis.Del(ctx, string(key)) return err } // 更新状态为已完成 return ic.redis.Set(ctx, string(key), \u0026#34;completed\u0026#34;, ttl).Err() } // 使用示例 func (s *PaymentService) ProcessPayment(ctx context.Context, req *PaymentRequest) error { key := IdempotencyKey(fmt.Sprintf(\u0026#34;payment:%s\u0026#34;, req.OrderID)) return s.idempotency.Process(ctx, key, 24*time.Hour, func() error { return s.processPaymentLogic(ctx, req) }) } // ❌ 错误：无幂等性控制 func (s *PaymentService) ProcessPayment(ctx context.Context, req *PaymentRequest) error { return s.processPaymentLogic(ctx, req) } 异步任务处理： // ✅ 正确：异步任务系统 type Task struct { ID string Type string Payload json.RawMessage Status TaskStatus Result json.RawMessage CreatedAt time.Time UpdatedAt time.Time } type TaskProcessor interface { Process(ctx context.Context, task *Task) error } type TaskQueue struct { processors map[string]TaskProcessor repo TaskRepository } func (q *TaskQueue) Submit(ctx context.Context, taskType string, payload interface{}) (*Task, error) { data, err := json.Marshal(payload) if err != nil { return nil, err } task := \u0026amp;Task{ ID: uuid.New().String(), Type: taskType, Payload: data, Status: TaskStatusPending, CreatedAt: time.Now(), } if err := q.repo.Save(ctx, task); err != nil { return nil, err } // 异步处理任务 go q.process(context.Background(), task) return task, nil } // 使用示例 type EmailTask struct { To string `json:\u0026#34;to\u0026#34;` Subject string `json:\u0026#34;subject\u0026#34;` Body string `json:\u0026#34;body\u0026#34;` } func (s *EmailService) SendAsync(ctx context.Context, to, subject, body string) (*Task, error) { task := \u0026amp;EmailTask{ To: to, Subject: subject, Body: body, } return s.taskQueue.Submit(ctx, \u0026#34;email\u0026#34;, task) } // ❌ 错误：直接在 goroutine 中处理 go sendEmail(to, subject, body) 审计日志： // ✅ 正确：审计日志系统 type AuditLog struct { ID uint64 UserID uint64 Action string Resource string ResourceID string Changes map[string]interface{} IP string UserAgent string CreatedAt time.Time } type AuditLogger struct { repo AuditLogRepository } func (l *AuditLogger) Log(ctx context.Context, event *AuditEvent) error { log := \u0026amp;AuditLog{ UserID: GetUserID(ctx), Action: event.Action, Resource: event.Resource, ResourceID: event.ResourceID, Changes: event.Changes, IP: GetClientIP(ctx), UserAgent: GetUserAgent(ctx), CreatedAt: time.Now(), } return l.repo.Create(ctx, log) } // 中间件使用 func AuditMiddleware(logger *AuditLogger) gin.HandlerFunc { return func(c *gin.Context) { // 记录请求前的状态 // ... c.Next() // 记录请求后的状态变化 event := \u0026amp;AuditEvent{ Action: c.Request.Method, Resource: c.Request.URL.Path, Changes: getChanges(c), } logger.Log(c, event) } } // ❌ 错误：简单的日志记录 log.Printf(\u0026#34;user %d modified resource %s\u0026#34;, userID, resourceID) API 版本控制和兼容性： // ✅ 正确：API 版本控制 type APIVersion string const ( APIVersionV1 APIVersion = \u0026#34;v1\u0026#34; APIVersionV2 APIVersion = \u0026#34;v2\u0026#34; ) // 请求结构体版本控制 type CreateUserRequestV1 struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } type CreateUserRequestV2 struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` PhoneNumber string `json:\u0026#34;phone_number\u0026#34;` // V2新增字段 } // 服务层版本控制 type UserService interface { CreateUserV1(ctx context.Context, req *CreateUserRequestV1) error CreateUserV2(ctx context.Context, req *CreateUserRequestV2) error } // 路由版本控制 func SetupRoutes(r *gin.Engine) { v1 := r.Group(\u0026#34;/api/v1\u0026#34;) { v1.POST(\u0026#34;/users\u0026#34;, handler.CreateUserV1) } v2 := r.Group(\u0026#34;/api/v2\u0026#34;) { v2.POST(\u0026#34;/users\u0026#34;, handler.CreateUserV2) } } // ❌ 错误：不兼容的API变更 type CreateUserRequest struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` // 直接修改已发布的API结构 PhoneNumber string `json:\u0026#34;phone_number\u0026#34;` } 这些设计模式和最佳实践适用于：\n大型复杂系统 微服务架构 高可用要求的系统 需要严格审计的系统 需要良好扩展性的系统 要点提示：\n根据实际需求选择合适的模式 在简单系统中避免过度设计 考虑团队的技术能力和维护成本 保持代码的可测试性 注重文档和注释的维护 需要了解更多其他方面的内容吗？\n这些最佳实践和设计模式来源于多个领域，我来整理一下来源和推荐阅读：\nGo 语言最佳实践来源： 书籍： 1. 《Go Programming Language》 - Alan A. A. Donovan, Brian W. Kernighan - Go 语言权威指南，基础语法和最佳实践 2. 《100 Go Mistakes and How to Avoid Them》 - Teiva Harsanyi - 详细介绍 Go 常见错误和避免方法 3. 《Concurrency in Go》 - Katherine Cox-Buday - Go 并发编程最佳实践 在线资源： 1. Go 官方文档和博客：https://golang.org/doc/ 2. Uber Go 风格指南：https://github.com/uber-go/guide 3. Go Code Review Comments：https://github.com/golang/go/wiki/CodeReviewComments 4. effective_go：https://golang.org/doc/effective_go 架构设计参考： 书籍： 1. 《Clean Architecture》 - Robert C. Martin - 架构设计原则和最佳实践 2. 《Designing Data-Intensive Applications》 - Martin Kleppmann - 分布式系统设计圣经 3. 《Domain-Driven Design》 - Eric Evans - 领域驱动设计 4. 《Building Microservices》 - Sam Newman - 微服务架构设计 在线资源： 1. Microsoft Azure Architecture Center：https://docs.microsoft.com/azure/architecture/ 2. AWS Architecture Center：https://aws.amazon.com/architecture/ 3. System Design Primer：https://github.com/donnemartin/system-design-primer 设计模式： 书籍： 1. 《Design Patterns》 - Gang of Four - 经典设计模式 2. 《Go Design Patterns》 - Mario Castro Contreras - Go 语言设计模式实现 3. 《Cloud Native Go》 - Matthew A. Titmus - 云原生 Go 应用设计模式 在线资源： 1. Go Patterns：https://github.com/tmrts/go-patterns 2. Cloud Native Patterns：https://www.cnpatterns.org/ 数据库和性能优化： 书籍： 1. 《High Performance MySQL》 - Baron Schwartz - MySQL 性能优化指南 2. 《Database Internals》 - Alex Petrov - 数据库内部原理 在线资源： 1. GORM 文档：https://gorm.io/docs/ 2. MySQL 官方文档：https://dev.mysql.com/doc/ 微服务和分布式系统： 书籍： 1. 《Microservices Patterns》 - Chris Richardson - 微服务设计模式 2. 《Site Reliability Engineering》 - Google - Google SRE 实践 在线资源： 1. Go Micro：https://go-micro.dev/ 2. Go Kit：https://gokit.io/ 安全最佳实践： 书籍： 1. 《Web Application Security》 - Andrew Hoffman - Web 应用安全指南 在线资源： 1. OWASP：https://owasp.org/ 2. Go Security Cheat Sheet：https://github.com/OWASP/CheatSheetSeries 测试和质量保证： 书籍： 1. 《Test-Driven Development with Go》 - Adelina Simion - Go TDD 实践 在线资源： 1. Go Testing：https://golang.org/pkg/testing/ 2. GoMock：https://github.com/golang/mock 持续学习资源： 1. Go Weekly：https://golangweekly.com/ 2. Go Time Podcast：https://changelog.com/gotime 3. Go Forum：https://forum.golangbridge.org/ 4. Reddit r/golang：https://www.reddit.com/r/golang/ 实践建议：\n循序渐进：\n从基础开始，逐步掌握高级概念 在实际项目中应用所学知识 社区参与：\n关注 Go 语言社区动态 参与开源项目 分享经验和学习心得 实践为主：\n多写代码，多做项目 复现和实现书中的示例 根据实际需求选择合适的模式 持续更新：\n关注新版本特性 学习新的最佳实践 保持对技术的热情 这些资源和建议可以帮助你：\n系统地学习 Go 开发 提高代码质量 掌握先进的架构设计 解决实际问题 持续进步 你对哪些方面特别感兴趣？我可以给出更具体的学习建议。\nGo 后端开发学习路线图 1. 基础架构 1.1 分层架构 Handler (API) 层\n参数验证 错误处理 响应封装 路由管理 API 文档 (Swagger) Service (业务) 层\n业务逻辑 事务管理 领域模型 数据转换 业务规则验证 Repository (数据) 层\n数据访问 ORM 使用 SQL 优化 缓存管理 数据模型 1.2 依赖管理 依赖注入原则 接口定义位置 依赖方向控制 循环依赖处理 模块化设计 1.3 配置管理 环境配置 配置分离 配置验证 敏感信息保护 热更新支持 2. 性能优化 2.1 并发控制 Goroutine 池 工作池模式 并发限制 竞态条件处理 上下文管理 2.2 数据库优化 连接池管理 读写分离 分库分表 索引优化 慢查询处理 2.3 缓存策略 多级缓存 缓存一致性 缓存穿透 缓存雪崩 缓存更新 3. 可靠性保障 3.1 错误处理 错误类型定义 错误包装 错误传播 错误恢复 错误监控 3.2 重试机制 退避策略 超时控制 熔断器模式 降级策略 限流控制 3.3 事务管理 本地事务 分布式事务 补偿事务 事务隔离级别 死锁处理 4. 安全性保障 4.1 认证授权 JWT 实现 OAuth2 集成 RBAC 权限 会话管理 权限校验 4.2 数据安全 加密解密 敏感数据处理 SQL 注入防护 XSS 防护 CSRF 防护 4.3 访问控制 限流 黑白名单 IP 控制 请求频率控制 资源隔离 5. 可观测性 5.1 日志管理 结构化日志 日志分级 日志轮转 审计日志 日志收集 5.2 监控指标 性能指标 业务指标 系统指标 告警策略 指标可视化 5.3 链路追踪 请求追踪 性能分析 调用链路 异常定位 性能瓶颈 6. 最佳实践 6.1 代码规范 项目结构 命名规范 注释规范 代码格式 最佳实践 6.2 设计模式 创建型模式 结构型模式 行为型模式 DDD 实践 微服务模式 6.3 测试规范 单元测试 集成测试 性能测试 压力测试 测试覆盖率 7. 工程化实践 7.1 CI/CD 自动构建 自动测试 自动部署 版本控制 环境管理 7.2 文档管理 API 文档 架构文档 运维文档 变更记录 使用指南 7.3 质量保障 代码审查 静态分析 性能分析 安全扫描 质量监控 8. 中间件使用 8.1 消息队列 Kafka RabbitMQ Redis Pub/Sub 消息幂等性 顺序保证 8.2 缓存中间件 Redis Memcached 本地缓存 分布式缓存 缓存策略 8.3 搜索引擎 Elasticsearch 全文搜索 数据同步 搜索优化 聚合分析 9. 微服务架构 9.1 服务治理 服务注册 服务发现 负载均衡 配置中心 服务网关 9.2 容器化 Docker Kubernetes 服务编排 资源管理 容器监控 9.3 高可用设计 服务容错 灾难恢复 数据备份 多活部署 自动扩缩容 10. 架构进阶 10.1 领域驱动设计 领域模型 限界上下文 聚合根 领域事件 CQRS 10.2 分布式系统 CAP 理论 一致性算法 分布式锁 分布式事务 分布式缓存 10.3 性能调优 系统调优 网络调优 数据库调优 应用调优 代码调优 让我总结一下在 Go 和 Rust 中常见的接口设计和依赖管理最佳实践：\nGo 语言接口设计原则：\n接口定义位置： // 接口应该由调用方定义，而不是实现方 caller/ -\u0026gt; 定义接口 service/ -\u0026gt; 实现接口 小接口原则： // 好的设计 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // 需要时可以组合 type ReadWriter interface { Reader Writer } 面向抽象编程： // Handler 依赖接口而不是具体实现 type Handler struct { service ServiceInterface // 好 // service *ConcreteService // 不好 } Rust 中的类似原则：\n特征(Trait)定义位置： // 在调用方 crate 中定义特征 mod caller { pub trait ImageService { fn upload(\u0026amp;self, image: Image) -\u0026gt; Result\u0026lt;(), Error\u0026gt;; } } // 在实现方 crate 中实现特征 mod service { use caller::ImageService; struct MyImageService; impl ImageService for MyImageService { fn upload(\u0026amp;self, image: Image) -\u0026gt; Result\u0026lt;(), Error\u0026gt; { // 实现 } } } 特征边界和泛型： // 使用特征边界而不是具体类型 struct Handler\u0026lt;S: ImageService\u0026gt; { service: S, } // 或者使用 impl Trait fn new_handler(service: impl ImageService) -\u0026gt; Handler\u0026lt;impl ImageService\u0026gt; { Handler { service } } 面向特征编程： // 好的设计 pub trait Repository { fn save(\u0026amp;self, data: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;(), Error\u0026gt;; } // 实现可以放在单独的模块 pub struct FileRepository; impl Repository for FileRepository { // 实现 } // 使用 Box\u0026lt;dyn Trait\u0026gt; 实现运行时多态 struct Service { repo: Box\u0026lt;dyn Repository\u0026gt;, } 依赖注入模式： // 使用构建器模式 pub struct ServiceBuilder\u0026lt;R\u0026gt; { repository: R, } impl\u0026lt;R: Repository\u0026gt; ServiceBuilder\u0026lt;R\u0026gt; { pub fn new(repository: R) -\u0026gt; Self { Self { repository } } pub fn build(self) -\u0026gt; Service\u0026lt;R\u0026gt; { Service { repository: self.repository, } } } 错误处理： // 定义域特定错误 #[derive(Debug, thiserror::Error)] pub enum ServiceError { #[error(\u0026#34;database error: {0}\u0026#34;)] Database(#[from] DbError), #[error(\u0026#34;validation error: {0}\u0026#34;)] Validation(String), } // 实现时使用 ? 运算符传播错误 impl ImageService for MyService { fn process(\u0026amp;self, data: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;(), ServiceError\u0026gt; { let validated = validate_data(data)?; self.repository.save(validated)?; Ok(()) } } 模块化和可见性： // 在 lib.rs 中定义公共 API pub mod api { pub trait Service { // 公共接口 } } // 内部实现保持私有 mod internal { use super::api::Service; pub(crate) struct ServiceImpl; impl Service for ServiceImpl { // 实现 } } 共同的设计原则：\n依赖倒置：\n高层模块不应该依赖低层模块 都应该依赖于抽象 单一职责：\n每个接口/特征应该只负责一个功能领域 避免大而全的接口/特征 接口隔离：\n客户端不应该依赖它不需要的接口 使用小而精确的接口/特征 显式依赖：\n通过构造函数/builder注入依赖 避免全局状态和隐式依赖 这些原则能帮助我们创建：\n松耦合的系统 易于测试的代码 可维护的项目结构 清晰的依赖关系 ","date":"2024-12-29","tags":["编程","go"],"title":"Go 最佳实践","url":"/post/2024/12/go/"},{"content":"决策瘫痪：选择太多反而寸步难行 现象解析 当面对过多选择时，人们会:\n耗费过多精力对比选项 担心做出错误决策 因认知负荷过重而放弃选择 即使做出选择也会感到不确定和焦虑 科学依据 果酱实验深度剖析 实验设计：\nA组：6种果酱，简单决策场景 B组：24种果酱，复杂决策场景 关键数据：\nA组购买率：30% B组购买率：3% 差距达10倍 认知机制：\ngraph TD A[大量选项] --\u003e B[信息过载] B --\u003e C[认知资源耗尽] C --\u003e D[决策质量下降] D --\u003e E[放弃决策] 神经科学解释 工作记忆负荷\n人脑同时只能处理5-9个信息单元 超出容量会触发认知疲劳 降低决策效率 决策成本计算\n大脑会权衡决策收益与认知成本 当成本过高时选择放弃 保护认知资源 实践应用 餐厅菜单优化 分类展示\n将菜品按类别清晰分组 每类控制在5-7个选项 突出特色推荐菜品 信息层级\n核心信息：菜名、价格 次要信息：配料、口味 辅助信息：图片、推荐度 推荐策略\ndef optimize_menu(): # 减少选项数量 limit_options_per_category(7) # 突出特色菜品 highlight_signature_dishes() # 简化描述 simplify_descriptions() 电商产品展示 筛选机制\n提供精准筛选条件 默认显示最相关选项 支持多维度排序 展示策略\n首页限展20个商品 相似商品合并展示 突出差异化特征 解决方案 商家视角 精简选项\n剔除重复性选项 保留特色产品 突出核心竞争力 引导决策\n设置默认推荐 提供选择建议 简化决策流程 消费者视角 决策简化\n设定决策标准 限定对比维度 控制选择时间 情绪管理\n接受\u0026quot;满意\u0026quot;选择 避免追求\u0026quot;最优\u0026quot; 降低决策压力 最佳实践 产品设计指南 // 选项数量控制 const OPTIMAL_OPTIONS = { initial_display: 7, // 首屏展示 max_per_category: 12, // 分类上限 featured_items: 3 // 推荐数量 }; // 信息展示策略 function displayStrategy(items) { return items .slice(0, OPTIMAL_OPTIONS.initial_display) .map(item =\u0026gt; ({ primary: item.name, secondary: item.price, details: item.description })); } 效果评估 转化指标\n决策时长 选择率 满意度 复购率 用户体验\n决策压力 选择信心 后悔程度 总之，在设计选择系统时，需要在丰富性和简单性之间找到平衡点，既满足用户多样化需求，又不至于造成决策瘫痪。关键是理解用户认知负荷的限制，通过合理的信息架构和交互设计，让决策过程更轻松自然。\n","date":"2024-12-29","tags":["营销"],"title":"营销","url":"/post/2024/12/decision_paralysis/"},{"content":"如何找资源 下载 盘搜 ↗ 盘搜搜 ↗ 大圣盘 ↗ TG机器人 ↗ 阿里搜 ↗ 一、我维护的其他站 Move 学习 move ↗ 二、编程相关内容 各种镜像收录 iframe src=\u0026ldquo; http://www.yishimei.cn/\" ↗ width=\u0026ldquo;100%\u0026rdquo; height=\u0026ldquo;600\u0026rdquo;\u0026gt;\nNPS: http://101.43.125.94:20002/ DS220j-SSH: http://101.43.125.94:20010/ DS220j-DSM: http://101.43.125.94:20011/\nWindows10: http://101.43.125.94:20020/\n","date":"2024-12-29","tags":["资源"],"title":"资源","url":"/post/2024/12/resource/"},{"content":" # 基础优化配置 enableGitInfo = true # 启用 Git 信息,可以显示文章的最后修改时间 hasCJKLanguage = true # 启用中日韩文字支持,能准确统计字数 summaryLength = 140 # 文章摘要长度 # SEO 优化 [params] keywords = [\u0026#34;博客\u0026#34;,\u0026#34;技术\u0026#34;,\u0026#34;编程\u0026#34;] # 网站关键词 description = \u0026#34;个人技术博客\u0026#34; # 网站描述 images = [\u0026#34;site-feature-image.jpg\u0026#34;] # 默认社交媒体分享图片 # 自定义 Open Graph 信息 [params.og] title = \u0026#34;我的博客\u0026#34; type = \u0026#34;website\u0026#34; images = [\u0026#34;og-image.jpg\u0026#34;] # 性能优化 [minify] disableCSS = false # 启用 CSS 压缩 disableHTML = false # 启用 HTML 压缩 disableJS = false # 启用 JS 压缩 disableJSON = false # 启用 JSON 压缩 minifyOutput = true # 压缩 HTML 输出 # 图片处理 [imaging] quality = 75 # JPEG 图片质量 resampleFilter = \u0026#34;Lanczos\u0026#34; # 图片重采样过滤器 anchor = \u0026#34;Smart\u0026#34; # 图片裁剪锚点 # 内容安全策略 [params.csp] childsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] fontsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;, \u0026#34;https://fonts.gstatic.com\u0026#34;, \u0026#34;https://cdn.jsdelivr.net\u0026#34;] formaction = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] framesrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] imgsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] objectsrc = [\u0026#34;\u0026#39;none\u0026#39;\u0026#34;] stylesrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;, \u0026#34;\u0026#39;unsafe-inline\u0026#39;\u0026#34;] scriptsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;, \u0026#34;\u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;\u0026#39;unsafe-eval\u0026#39;\u0026#34;] # 文章配置 [permalinks] posts = \u0026#34;/post/:year/:month/:slug/\u0026#34; # 自定义文章 URL 结构 # 自定义输出格式 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] # 支持 JSON API 输出 section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] term = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] # RSS 订阅配置 [params.rss] limit = 20 # RSS 文章数量限制 fullContent = true # RSS 包含完整文章内容 # 站内搜索配置 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;, \u0026#34;SearchIndex\u0026#34;] [outputFormats.SearchIndex] mediaType = \u0026#34;application/json\u0026#34; baseName = \u0026#34;searchindex\u0026#34; isPlainText = true notAlternative = true # 文章目录配置 [markup.tableOfContents] endLevel = 3 # 目录最大深度 ordered = false # 使用无序列表 startLevel = 2 # 目录开始层级 # 代码高亮配置 [markup.highlight] codeFences = true # 启用代码围栏 guessSyntax = true # 自动推测代码语言 lineNoStart = 1 # 起始行号 lineNos = true # 显示行号 lineNumbersInTable = true # 使用表格式行号 tabWidth = 4 # 制表符宽度 style = \u0026#34;monokai\u0026#34; # 代码高亮主题 一些重要的最佳实践建议：\n内容组织 content/ ├── posts/ # 博客文章 │ ├── tech/ # 技术文章 │ └── life/ # 生活随笔 ├── about/ # 关于页面 ├── projects/ # 项目展示 └── notes/ # 学习笔记 图片资源管理 static/ ├── images/ │ ├── posts/ # 文章配图 │ ├── avatars/ # 头像 │ └── icons/ # 图标 └── assets/ # 其他资源 文章 Front Matter 模板 --- title: \u0026#34;文章标题\u0026#34; date: 2024-03-21T15:04:05\u0026#43;08:00 lastmod: 2024-03-21T15:04:05\u0026#43;08:00 draft: false weight: 1 categories: [\u0026#34;分类\u0026#34;] tags: [\u0026#34;标签1\u0026#34;, \u0026#34;标签2\u0026#34;] author: \u0026#34;作者\u0026#34; description: \u0026#34;文章描述\u0026#34; featuredImage: \u0026#34;featured-image.jpg\u0026#34; toc: true # 是否显示目录 autoCollapseToc: true # 自动折叠目录 --- 安全性建议： 开启 HTTPS 配置适当的 CSP(Content Security Policy) 定期更新主题和依赖 使用 robots.txt 控制爬虫访问 实现基本的 DDoS 防护 性能优化： 使用 CDN 加速静态资源 开启图片懒加载 合理设置缓存策略 压缩静态资源 优化关键渲染路径 SEO 优化： 编写清晰的 robots.txt 创建 sitemap.xml 优化 meta 标签 实现结构化数据 使用规范的 URL 结构 确保移动端适配 备份策略： 使用 Git 进行版本控制 定期备份数据库 导出重要配置 多平台备份 以上配置和建议可以帮助你搭建一个更完善的 Hugo 博客站点。根据实际需求，你可以选择性地采用这些配置。记住定期维护和更新，确保站点的安全性和性能。\n","date":"2024-12-22","tags":["hugo"],"title":"hugo 配置","url":"/post/2024/12/about_hugo_config/"},{"content":"再见Hexo——从Hexo迁移至Hugo 16 年的时候，博客使用的虚拟主机需要做迁移，当时所使用的 Typecho 是一个依赖于数据库的 PHP 博客系统，数据导出过程很艰辛。彼时 Gihub Pages 正大火，我也就跟风转投了静态博客系统 Hexo 。七年过去了，博客还在，但折腾 Hexo 的人是越来越少了。如今我也要和 Hexo 说声再见，拥抱 Hugo 的怀抱了。\n为什么改用Hugo 依赖管理问题 在 静态博客的同步和备份方案 ↗ 一文中，我分享了基于 Github 和 iCloud 的同步备份方案，期望在保证数据安全的同时，写作环境可以在我的两台电脑上无缝切换。\n然而实际上，由于 Hexo 依赖于 Node.js ，庞大的 node_modules 并不能直接同步而是需要分别安装和更新，如果忘了运行 npm install -S ，那报错和渲染异常就是家常便饭的事。而 node-sass 这样的库还对 node 版本做了显式要求，导致如果哪台设备改了 nvm 中 node 的版本就会报错。但偏偏又有大量的主题和插件都依赖于 node-sass 。\n而 Hugo 是基于 Golang 的二进制程序，安装和升级都很简单。由于内置功能足够多，插件（模块）不再是必需的了，如果有需要，其也都是通过 go mod 管理，轻量而简洁。虽然大部分主题仍然依赖于 Node.js ，但那只是创建和修改主题时的事情，不会影响到写作流程。\n诚然，这并不能算作 Hexo 本身的问题，但由于底层的技术选型，导致 Hexo 必然和各类主题及插件的耦合较为严重。在三方组件实现和依赖复杂的情况下，整体的复杂度也就必然会成倍地上涨。\n网页生成速度 Hexo 裸安装后的网页生成速度并不算不可接受，和 Hugo 比起来也就几秒到十几秒的差异，没有网上传得那么夸张。但多加了几个像 hexo-all-minifier ↗ 这样生命周期靠后的插件后，生成速度确实会肉眼可见地下降。而 Hugo 的网页生成速度则非常稳定，总是保持在秒级别甚至毫秒级别，因此也可以真正意义上地实现本地实时预览。\nHugo的特性 Hugo 对 org-mode 、pandoc 等提供了原生支持，轻度使用体验也不错（深度使用也会遇到坑）。虽然 Hexo 等也可以通过安装插件和转换器等方式来实现，但这又会回到上面的依赖复杂的问题之中。此外，Hugo 的 shortcode ↗ 功能也非常强大，如果不考虑 md 文件的通用性，那结合 shortcodes 可以轻松实现很多本需要依赖于插件（模块）才能做到的功能。\n快速上手 首先安装 Hugo 并创建站点，以 macOS 系统为例：\n1 2 brew install hugo # For macOS hugo new site sample 这里需要注意的是，如果此前系统中已经安装过旧版本的 Go ，那有可能需要升级后才能使用 homebrew 完成安装。随后选一个喜欢的主题拉取到 /themes 目录，以 even 主题为例：\n1 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 主题通常会带有示例配置文件 config.toml ，将其复制到站点的根目录下覆盖默认配置文件，并完成相应配置后，运行 hugo new post/test.md 新建文章，随后运行 hugo server -D 即可查看站点。对于存量的文章，需要将其复制到主题 /content/ 目录下，其中文章类的需要按主题的设计来放置于具体目录，如 even 主题使用 post 目录，则需要将文章复制到 /content/posts 目录下，重新执行上面的命令就能在站点里看到文章了。\n如果运行命令时报错，则可能是存量文章的 front matter 格式有不符合 Hugo 要求的情况，此时需要按 官方文档 ↗ 进行修改适配。\n写作习惯的变化 整体写作习惯其实和 Hexo 的体验差别不大。不过 Hugo 提供了比 Hexo 更丰富的 front matter 默认配置，同时还支持 org-mode 等玩法，所以写作方式上的可玩性会更高些。\n主题自定义方式的变化 与 Hexo 主题的完全前端实现不同，Hugo 的主题使用了 Go 的模板语言，有点类似于 PHP 和 JSP ，并向主题暴露了一系列的全局变量和函数，所以其实主题和 Hugo 或 Golang 还是有一定的耦合的。\n不过这也使得我们可以通过自定义模板覆盖主题默认模板的方式，来既实现自己的需求，又能最低限度地避免修改主题源代码导致的升级困难。但很多主题没有提供关键位置的钩子模板（也可以说是接口），导致我们经常需要拷贝一部分主题的源代码到自定义模板中，这又对主题的升级造成了一定的影响，可以说是有得必有失了。\n向前兼容 迁移工作的一个核心要求就是尽量避免引入 breaking change 。首先要保证存量页面的链接不发生变化，以避免出现 404 的情况。其次要尽量对此前在 Hexo 中使用的各项功能进行支持。\n永久链接格式兼容 在 Hexo 中，通常有以下三种 URL 永久链接路径格式：\n日期前缀+英文别称或文件名：/2021/07/06/a-better-hexo-theme-even/ 固定前缀+英文别称或文件名：/posts/slidev-tutorial/ 使用了 abbrlink 等插件生成 CRC/Hash 值作为路径：/posts/8ccq01298/ 而 Hugo 默认的永久链接格式为 /{{ 文章目录 }}/{{ 文章文件名 }} ，和上面第二种比较相似但又有所不同。那么我们该如何实现兼容呢？\n首先我们要了解 Hugo 可以在根目录的 config.toml 中对永久链接进行自定义配置，例如：\n1 2 [permalinks] '/' = \u0026quot;/posts/:slug\u0026quot; 因此我们只需要针对不同情况，对该配置进行自定义即可。\n日期前缀+英文别称或文件名：仿照 Hexo 的日期格式，将值配置为 /:year/:month/:day/:title/ 。 固定前缀+英文别称或文件名：将值改为 /posts/:title 即可。 Hugo front matter 中的 slug 变量表示自定义别名，所以如果此前在 Hexo 使用了自定义的变量，只要仿照此前的配置将 title 改为 slug 即可，例如 /posts/:title 。 使用 abbrlink 等插件生成的 CRC/Hash 值作为路径：Hugo 似乎没有 abbrlink 这类插件，不过我们可以仿照 这篇文章 ↗ ，在默认内容模板 archetypes/default.md ，再将其中的 slug 配置为一段具备哈希或 CRC 功能的表达式即可。不过存量文章可能需要通过 front-matter 中的 url 变量进行完整路径的显式声明，不然如果表达式的处理结果和 Hexo 中的不同，那链接可就变了。 上面说明了 permalinks 的值，那 key 该如何配置呢？与 Hexo 不同，Hugo 中永久链接的固定前缀（对应上文的情况 2 和情况 3）是根据目录位置生成的，该位置的选择又与主题有关。有的主题使用的是 /content/post/ 目录，有的主题使用的又是 /content/posts 目录，同时这个路径在很多主题的实现中是写死的。因此如果此前你在 Hexo 中所使用的固定前缀和所选 Hugo 主题的不同（如 /articles/），那就会造成链接发生变化的问题。\n所以我们需要在 permalinks 配置的 key 上做些文章，把主题所用的路径做一层指定映射，保证最终的路径以我们期望的前缀输出。以主题使用 /content/post/ 作为内容目录、原 Hexo 文章的永久链接格式为 /posts/:slug 为例，对 permalinks 进行以下配置即可：\n1 2 [permalinks] post = \u0026quot;/posts/:slug\u0026quot; 另外，对于此前在 Hexo 中配置了 html 后缀等情况，可以开启 Hugo 的 Ugly URLs 来实现兼容，细节可以参考 官方文档 ↗ 。\n归档页面路径链接的兼容 前一节提到了主题对内容目录路径的选择可能是不同的，而这也会影响到归档页面的路径。在 Hugo 的大部分主题中，如果主题使用 /content/post/ 作为内容目录，那归档页面路径则默认为 /post/ 且不支持配置。而我们在 Hexo 中通常会使用 /archives/ 作为归档页面的路径，如何才能保持不变呢？\n虽然绝大部分主题（也可能是所有）都没有此项配置，但我们可以通过自定义一套模板和页面的方式来绕过主题的限制。以 even 主题的模板和 CSS 样式为例，在 /layouts/_default/ 目录下新建 archives.html 模板，随后填充以下内容，用于按年分组遍历所有文章，并在原主题的框架下输出文章标题列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 {{- define \u0026quot;title\u0026quot; }}{{ T \u0026quot;archive\u0026quot; }} - {{ .Site.Title }}{{ end -}} {{- define \u0026quot;content\u0026quot; }} {{ $pageList := (where .Site.RegularPages \u0026quot;Type\u0026quot; \u0026quot;post\u0026quot;) }} \u0026lt;section id=\u0026quot;archive\u0026quot; class=\u0026quot;archive\u0026quot;\u0026gt; {{- if .Site.Params.showArchiveCount }} \u0026lt;div class=\u0026quot;archive-title\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;archive-post-counter\u0026quot;\u0026gt; {{ T \u0026quot;archiveCounter\u0026quot; (len $pageList) }} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} {{ range ($pageList.GroupByDate \u0026quot;2006\u0026quot;) }} \u0026lt;div class=\u0026quot;collection-title\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;archive-year\u0026quot;\u0026gt;{{ .Key }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026quot;archive-list\u0026quot;\u0026gt; {{ range (where .Pages \u0026quot;Type\u0026quot; \u0026quot;post\u0026quot;) }} \u0026lt;div class=\u0026quot;archive-post\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;archive-post-time\u0026quot;\u0026gt; {{ .PublishDate.Format \u0026quot;01-02\u0026quot; }} \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;archive-post-title\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;{{ .RelPermalink }}\u0026quot; class=\u0026quot;archive-post-link\u0026quot;\u0026gt; {{ .Title }} \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; {{ end }} \u0026lt;/section\u0026gt; {{ end }} 随后在 /content/ 目录下新建 archives.md 页面，将 type 指定为刚刚定义的 archives ：\n1 2 3 4 5 6 7 8 --- title: \u0026quot;归档\u0026quot; layout: \u0026quot;archives\u0026quot; url: \u0026quot;/archives/\u0026quot; comment: false hidden: true type: archives --- 这时我们就已经可以通过访问 /archives/ 路径来进入到归档页面了，接下来只要在 config.toml 中再将导航栏中的对应按钮指定为预期链接即可。\n1 2 3 4 5 [[menu.main]] name = \u0026quot;归档\u0026quot; weight = 20 identifier = \u0026quot;archives\u0026quot; url = \u0026quot;/archives/\u0026quot; 上文这种实现的效果和很多主题的归档页面相比，主要区别在于单页面内罗列了所有文章，即缺少分页。由于大部分主题的分页逻辑和其内部的其他模板耦合较为严重，同时 Hugo 的分页相关变量被限制不能用于自定义模板之中，所以如果希望自定义的归档页能支持分类，则可能需要对 Hugo 的原生逻辑进行包装即额外实现一套分页能力才行。这里不做展开讲述。\n友情链接和自我介绍 和 Hexo 一样，Hugo 也没有直接支持友情链接和自我介绍这类常用页面。在实现上我们要么在 /content/ 目录下自定义页面也就是在页面内维护内容，要么如归档页面一般，通过自定义模板的方式来加载 config.toml 中的配置。两种实现都比较简单，我也更倾向于前者，毕竟这些是低频修改页面，是否可配置区别都不大。\n标签和分类的中英文问题 在 Hexo 中，我们通常会在 _config.yml 中配置标签和分类的中英文映射，这样我们在 front matter 中可以使用任意语言标识标签和分类，但生成后两者的 URI 都是英文。然而在 Hugo 中却没有这类简易设置，也许我们可以通过修改主题和永久链接的方式来间接支持，但估计成本较高。所以如果对 URI 有强迫症的读者，还是建议把存量文章的标签和分类改为英文。而如果对此没有特殊需求，那使用中文也可。除了 URL 的分享可读性可能较差外，在 2022 年的今天其实已经不会影响搜索引擎的 SEO 效果了。\n支持Git与VPS部署 不知为何 Hugo 官方没有直接支持使用 Git 搭配 Git Hooks 部署站点，对于我这种把博客部署在 VPS 的用户给出的建议方案是 rsync 。其实 rsync 方案是完全可行且成本不高的，不过本着尽量兼容的原则我还是决定在部署时执行以下 shell 脚本来通过 Git 推送生成的 /public/ 目录至 VPS ，而 VPS 上的 Git 库和 Git Hooks 配置则无需改动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #! /bin/bash rm -rf ./public hugo rm -rf ./.deploy_git mkdir .deploy_git cp -r public/* ./.deploy_git cd .deploy_git git init --initial-branch=master git add -A git commit -m 'Deploy commit.' --quiet git push -u foo@bar-server:/var/blog.git HEAD:master --force cd .. rm -rf ./.deploy_git 兼容Hexo的RSS形式 使用 Hexo 时博客的 RSS 是全文输出，而换到 Hugo 后 RSS 却变为了输出摘要。作为一个重度 RSS 用户，我自然是深知拉取到的文章还要二次跳转到浏览器才能看原文的体验有多差，所以还是要让 RSS 的表现和此前一致才行。\nHugo 的 RSS 是基于默认 RSS 模板生成的，所以我们只要重新定义一个模板并改为全文输出即可。 Hugo 的默认实现 ↗ 中，决定输出内容的是如下这行代码：\n| 1 | \u0026lt;description\u0026gt;{{ .Summary | html }}\u0026lt;/description\u0026gt; | | \u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | | |\n我们只需要在 /layouts/ 目录新建 index.rss.xml 覆盖默认模版并将原实现拷贝至其中，接着把代码中的 {{ .Summary | html }} 替换为代表全文内容的表达式 {{ .Content | html }} 即可：\n| 1 | \u0026lt;description\u0026gt;{{ .Content | html }}\u0026lt;/description\u0026gt; | | \u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | | |\neven主题迁移 由于此前一直在使用 修改过的 Hexo even 主题 ↗ ，为保证前端效果不变，所以主题方面也采用了 Hugo 下的 even 主题，因此会有很多主题层面的额外适配工作。\n自定义导航栏 此前使用 Hexo 下 even 主题时自定义了一个用于引导用户的导航栏，那么如何在 Hugo 的 even 主题中实现兼容呢？\n首先我们在 /layouts/partials/header/ 下新建 top-nav.html 模板，按需填充内容，如增加 Newsletter 、Telegram Channel 等引导：\n1 2 3 4 5 6 7 8 9 10 11 12 13 {{- if .Site.Params.enableTopNav }} \u0026lt;div class=\u0026quot;top-nav\u0026quot;\u0026gt; {{- if .Site.Params.revue.enabled -}} \u0026lt;a href=\u0026quot;{{ .Site.Params.revue.home }}\u0026quot; href=\u0026quot;_blank\u0026quot; class=\u0026quot;top-nav-button\u0026quot;\u0026gt;Newsletter\u0026lt;/a\u0026gt; {{- end -}} {{- if .Site.Params.telegram.enabled -}} \u0026lt;a href=\u0026quot;{{ .Site.Params.telegram.link }}\u0026quot; href=\u0026quot;_blank\u0026quot; class=\u0026quot;top-nav-button\u0026quot;\u0026gt;电报频道\u0026lt;/a\u0026gt; {{- end -}} {{- if .Site.Params.wxOfficialAccount.enabled -}} \u0026lt;a href=\u0026quot;{{ .Site.Params.wxOfficialAccount.url }}\u0026quot; href=\u0026quot;_blank\u0026quot; class=\u0026quot;top-nav-button\u0026quot;\u0026gt;微信公众号\u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; {{- end -}} 随后我们需要找个位置引入该模板。受 even 主题实现的限制，我们需要将该模板放置于 header 块之后才能最低成本地保留原布局。因此我们只有一个选择，那就是将 baseof.html 这个基础模板进行覆盖。拷贝原模板内容至 /layouts/_default/baseof.html 中，并在 header 块之后、main 块之前引入此前定义的 top-nav.html ：\n1 2 3 4 5 6 7 8 9 10 11 12 ... \u0026lt;div class=\u0026quot;container\u0026quot; id=\u0026quot;mobile-panel\u0026quot;\u0026gt; {{ if not .Params.hideHeaderAndFooter -}} \u0026lt;header id=\u0026quot;header\u0026quot; class=\u0026quot;header\u0026quot;\u0026gt; {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;/header\u0026gt; {{- end }} {{- partial \u0026quot;header/top-nav.html\u0026quot; . -}} \u0026lt;main id=\u0026quot;main\u0026quot; class=\u0026quot;main\u0026quot;\u0026gt; ... 最后在 config.toml 中完成相关参数配置即可：\n1 2 3 4 5 6 7 8 9 10 11 [params.wxOfficialAccount] enabled = true url = \u0026quot;\u0026quot; [params.telegram] enabled = true link = \u0026quot;\u0026quot; [params.revue] enabled = true home = \u0026quot;\u0026quot; 支持umami访问统计 博客之前一直按「 使用Nginx将请求转发至Google Analytics实现后端统计 ↗ 」一文的方式来实现请求统计。但这个方式的问题在于，由于不要求加载 JS ，很多非真实流量（主要为 RSS 阅读器的抓取）也会被统计进来。后来看到「 搭建 umami 收集个人网站统计数据 ↗ 」这篇文章，便也用 umami 搭建了一个轻量的统计能力。\neven 主题自然没有对 umami 进行原生支持，我们需要做的是先找到一个包含 head 的模版并在 \u0026lt;head/\u0026gt; 标签中添加以下内容：\n| 1 2 3 | {{- if (in (slice (getenv \u0026quot;HUGO_ENV\u0026quot;) hugo.Environment) \u0026quot;production\u0026quot;) | and .Site.Params.umami.enabled -}} \u0026lt;script async defer data-website-id=\u0026quot;{{ .Site.Params.umami.id }}\u0026quot; src=\u0026quot;{{ .Site.Params.umami.js }}\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; {{- end -}} | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | | |\n然后在配置中完成定义即可：\n1 2 3 4 [params.umami] enabled = true id = \u0026quot;\u0026quot; # umami 统计 id js = \u0026quot;\u0026quot; # umami 的 JS 地址 由于 even 主题没有提供可以直接拓展 \u0026lt;head/\u0026gt; 标签的模板，我的选择是将代码加到此前不得不重写的 baseof.html 中。不得不说，这个实现很丑陋，但成本确实也是最低的。\n此外，为了避免本地启动时 umami 将本地请求也进行了统计并将 Referrer 识别为 localhost ，上文的实现中对环境做了判断，即正式生成站点时才会引入 JS 依赖来上报 umami ，本地运行则不引入。\n自定义文章末尾页脚 此前在 Hexo 的 even 下我也对文章末尾进行了自定义。对于 Hugo 的 even 主题，改造成本最低的方式为重写 /layouts/partials/post/copyright.html 模板。\n首先要和此前展现形式对齐的是「原文链接」。even 主题本身只支持将 Markdown 原文件地址作为文章链接，所以我们需要在该模板中仿照 lionToMarkDown 部分添加以下内容：\n1 2 3 4 5 6 {{ if $.Site.Params.copyrightLink -}} \u0026lt;p class=\u0026quot;copyright-item\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;item-title\u0026quot;\u0026gt;文章链接\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;item-content\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;link-to-markdown\u0026quot; href=\u0026quot;{{ .Permalink }}\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;{{ .Permalink }}\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; {{- end }} 因为暂时没有国际化需要所以文案是固定的中文，如果想更灵活些也可以仿照原实现中的 Markdown link 来做 i18n 。\n随后只要在 copyright.html 的最后引入我们自定义的文末模板即可：\n1 {{- partial \u0026quot;post/post-footer.html\u0026quot; . -}} utterances适配 even 主题本身是支持 utterances 的，但用于生成 issue 的唯一标识参数被主题写死为了 issue-term=\u0026quot;pathname\u0026quot; 即根据 URI 路径生成，并没有暴露配置。而我在使用 Hexo 时该参数的值是 issueTerm=\u0026quot;title\u0026quot; 即根据文章标题生成，不进行适配的话会丢失存量评论。\n所以我们需要在 /layouts/partials/ 目录下新建 comments.html 覆盖主题原实现。顺便地，我们可以把另一个参数 label 也改为可配置的，这样一来，生成的 Github issues 便可以自动加上 utterances 标签方便分类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {{ if and .IsPage (ne .Params.comment false) -}} \u0026lt;!-- utterances --\u0026gt; {{- if .Site.Params.utterances.owner}} \u0026lt;script src=\u0026quot;https://utteranc.es/client.js\u0026quot; repo=\u0026quot;{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}\u0026quot; issue-term=\u0026quot;{{ .Site.Params.utterances.issueTerm }}\u0026quot; label=\u0026quot;{{ .Site.Params.utterances.label }}\u0026quot; theme=\u0026quot;github-light\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026quot;https://github.com/utterance\u0026quot;\u0026gt;comments powered by utterances.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; {{- end }} {{- end }} 随后我们便可以在 config.toml 中对 utterances 按需进行配置：\n1 2 3 4 5 [params.utterances] # https://utteranc.es/ owner = \u0026quot;\u0026quot; # Your GitHub ID repo = \u0026quot;\u0026quot; # The repo to store comments issueTerm = \u0026quot;title\u0026quot; # 新增配置，可按需选择 issue 生成时的唯一标识方式 label = \u0026quot;utterances\u0026quot; # 新增配置，可按需指定 issue label 补齐底部社交图标 主题的社交图标使用的是托管于 iconfont 的私有实现所以直接拓展未支持的新图标较为困难。我在 记hexo-theme-even主题优化 ↗ 一文中提到了相同的问题，文中最终选择了使用 Font Awesome 来解决，对于 Hugo 的 even 主题我们也如法炮制进行处理。\n首先，在 Font Awesome ↗ 官网下载依赖并放置于 /static 目录下。例如我使用的是引入所有图标 JS 的方式，则最终路径为 /static/js/fontawesome.all.min.js 。然后在 config.toml 配置中引入该 JS 文件：\n1 2 [params] customJS = [\u0026quot;fontawesome.all.min.js\u0026quot;] 接着，我们在 /layouts/partials/ 目录下新建 footer.html 覆盖主题原实现并保留原实现的其他代码，只对 social-links 部分进行如下修改：\n| 1 2 3 4 5 6 7 8 9 10 11 12 | \u0026lt;div class=\u0026quot;social-links\u0026quot;\u0026gt; {{- range $name, $config := .Site.Params.social }} {{- if $config.path }} \u0026lt;a href=\u0026quot;{{ $config.path | safeURL }}\u0026quot; class=\u0026quot;iconfont\u0026quot; title=\u0026quot;{{ $name }}\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;{{ $config.icon }}\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; {{- end }} {{- end }} {{ if .Site.LanguagePrefix -}} \u0026lt;a href=\u0026quot;{{ .Site.LanguagePrefix | absURL }}/index.xml\u0026quot; type=\u0026quot;application/rss+xml\u0026quot; class=\u0026quot;iconfont\u0026quot; title=\u0026quot;rss\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fas fa-rss\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; {{- else -}} \u0026lt;a href=\u0026quot;{{ .Site.RSSLink }}\u0026quot; type=\u0026quot;application/rss+xml\u0026quot; class=\u0026quot;iconfont\u0026quot; title=\u0026quot;rss\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fas fa-rss\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/div\u0026gt; | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | | |\n最后在 config.toml 中添加需要的图标配置即可。icon 即图标的完整 class 属性，path 即需要跳转的链接地址。需要注意的是，主题的原逻辑为了实现多语言，将 RSS 图标的逻辑隔离在了通用逻辑之外。这里也保留了原实现，即 RSS 图标是默认出现且不可去除的。如果不需要 RSS 则可以对上面的代码再进行修改，以删除独立的 RSS 逻辑。\n1 2 3 4 5 6 7 [params.social] a-email = { title = \u0026quot;Email\u0026quot;, icon = \u0026quot;fas fa-envelope\u0026quot;, path = \u0026quot;\u0026quot; } b-twitter = { title = \u0026quot;Twitter\u0026quot;, icon = \u0026quot;fab fa-twitter\u0026quot;, path = \u0026quot;\u0026quot; } c-github = { title = \u0026quot;Github\u0026quot;, icon = \u0026quot;fab fa-github\u0026quot;, path = \u0026quot;\u0026quot; } d-weixinOfficialAccount = { title = \u0026quot;微信公众号\u0026quot;, icon = \u0026quot;fab fa-weixin\u0026quot;, path = \u0026quot;\u0026quot; } e-telegram = { title = \u0026quot;Telegram\u0026quot;, icon = \u0026quot;fab fa-telegram\u0026quot;, path = \u0026quot;\u0026quot; } f-search = { title = \u0026quot;Search\u0026quot;, icon = \u0026quot;fas fa-search\u0026quot;, path = \u0026quot;\u0026quot; } 除了 Font Awesome ，最近我还看到了 tabler ICONS ↗ 这个库，直接支持 SVG 同时还是 MIT 协议的开源项目，也值得一试。\n此外，由于我们已经覆盖了 footer 模板，那我们也可以对其他内容也进行自定义，比如将友情链接放置于 footer 等，下文的总字数统计也同样均基于自定义的 footer.html 进行处理。\n支持总字数统计 even 主题自带每篇文章的字数和预计阅读时间统计，但却没有之前我借助 hexo-wordcount ↗ 所实现的全站文章字数统计。检索网络后找到了这么一篇文章 Hugo 总文章数和总字数 ↗ ，照猫画虎在 footer.html 中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 {{ if .Site.Params.countAllWords.enabled }} {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026quot;Kind\u0026quot; \u0026quot;page\u0026quot; )}} {{$scratch.Add \u0026quot;total\u0026quot; .WordCount}} {{ end }} \u0026lt;span style=\u0026quot;display: block;\u0026quot;\u0026gt; {{ .Site.Params.countAllWords.prefix }} {{$scratch.Get \u0026quot;total\u0026quot; }} {{ .Site.Params.countAllWords.suffix }} \u0026lt;/span\u0026gt; {{ end }} 随后在 config.toml 中对相关参数进行配置即可：\n1 2 3 4 [params.countAllWords] enabled = true prefix = \u0026quot;共计\u0026quot; suffix = \u0026quot;字\u0026quot; 除了以上逻辑，还可以通过改变 range 的查询范围来按需限定需要进行总字数统计的页面集合。另外配置中的固定文案比较生硬，可以考虑加入 i18n 相关实现来满足多语言切换的需要。\n总结 天下武功，唯快不破，Hugo 的速度确实让我印象深刻。但对于从 Hexo 迁移而来，同时还对 Hexo 有很多自定义配置的用户来说，迁移过程中的兼容和适配的成本其实是不低的，实际上目前的迁移仍未实现「基于 LeanCloud 的阅读计数」和「推荐阅读」两项功能的兼容。此外，无论是 Hexo 还是 Hugo ，其主题的深度自定义修改都比较麻烦，以后还是要考虑自己实现一套主题（明年一定）。\n文章作者 Eason Yang\n上次更新 2022-08-10\n文章链接 https://easonyang.com/posts/hexo-to-hugo/ ↗ 许可协议 知识共享署名-非商业性使用 4.0 国际许可协议 ↗ 关注本站 Telegram Channel ↗ 获取最新文章推送\n扫码关注微信公众号**「举一得一」**获取最新文章推送\n赞赏支持\nhugo ↗ 把Notion变为个人网站 ↗ 旁路由的原理与配置一文通 ↗ 由 Hugo ↗ 强力驱动 | 主题 - Even ↗ 本站总访问量 72625 次 | 本站总访客数 46411 人\n共计 123042 字 站点地图 ↗ | 友情链接 ↗ © 2012 - 2024Eason Yang\n","date":"2024-12-22","tags":["hugo"],"title":"从 Hexo 迁移至 Hugo","url":"/post/2024/12/my-first-post/"},{"content":"我的博客之前是在云服务器上部署的java服务，现在把博客迁移到了github托管，使用 Hexo ↗ 以及主题 Theme NexT ↗ ， 在源码仓库通过hexo会生成静态html文件，通过github action部署到网站仓库。网站仓库自动部署到 vercel ↗ 作为一个把Hexo、NexT官网的文档看了一个遍的人，我想我可以写一篇文章总结一下。\n名词解释 名词 说明 网址 hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 https://hexo.io/zh-cn/docs/ ↗ Next NexT是Hexo的高品质优雅主题 https://theme-next.js.org/ ↗ vercel Vercel 是一个面向开发人员的平台，它提供了更快地构建和部署 Web 应用程序所需的工具、工作流和基础架构，而无需进行其他配置。Vercel 开箱即用地支持流行的前端框架，其可扩展的安全基础架构遍布全球，可从用户附近的数据中心提供内容，以实现最佳速度。 https://vercel.com/ ↗ github pages github官方的，直接用github仓库生成静态网站。但是速度比较慢，建议使用支持cdn的托管平台，例如vercel https://pages.github.com/ ↗ github actions 亦称为workflows。工作流是将运行一个或多个作业的可配置自动化过程。工作流由签入到存储库的 YAML 文件定义，并在存储库中的事件触发时运行，也可以手动触发或按定义的计划触发。工作流在存储库的 .github/workflows 目录中定义，一个存储库可以有多个工作流，每个工作流可以执行一组不同的任务。例如，您可以有一个工作流来构建和测试拉取请求，另一个工作流在每次创建发布时部署应用程序，还有另一个工作流在每次有人打开新问题时添加标签。 https://docs.github.com/en/actions/using-workflows/about-workflows ↗ 安装并使用hexo 首先安装 nodejs ↗ 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\nnpm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init \u0026lt;folder\u0026gt; cd \u0026lt;folder\u0026gt; npm install 新建完成后，指定文件夹的目录如下：.\n. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml 网站的 配置 ↗ 信息，您可以在此配置大部分的参数。\nsource 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\nthemes 主题 ↗ 文件夹。Hexo 会根据主题来生成静态页面。\n写文章 hexo new \u0026#34;My New Post\u0026#34; hexo new会在source/_posts文件夹中创建一个名为My-New-Post.md的新文件，—和—之间是meta元信息，有标题、创建时间、标签等。在其后使用markdown语法写文章。\n更多信息介绍: Writing ↗ 运行hexo hexo generate hexo server hexo generate会通过源码生成静态Html文件，hexo server会在本地开启服务器，默认url是http://localhost:4000/.\n也可以简写为：\nhexo g hexo s 安装NexT主题 打开终端，切换到 Hexo 站点根目录并安装 NexT 主题\ncd hexo-site npm install hexo-theme-next 启用NexT主题配置文件 NexT官方教程 ↗ 中给出的2个方式都不是太好，有缺陷。官方教程是修改themes/next/_config.yml或者node_modules/hexo-theme-next/_config.yml，这种方式不利于将来升级NexT，最新的最佳实践是创建_config.next.yml文件，和_config.yml同级。这一点可以查看[hexo的官方文档]( Configuration | Hexo ↗ ), 从Hexo 5.0.0版本开始支持。\n创建完_config.next.yml文件后，把_config.yml中theme值改为next即可启用\n# Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next Next主题重要配置 scheme 建议使用Gemini，NexT官方网站就是使用的Gemini\n#scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 开启搜索 安装[搜索插件]( GitHub - next-theme/hexo-generator-searchdb: 🔍 Seach data generator plugin for Hexo. ↗ )\nnpm install hexo-generator-searchdb Hexo config file _config.yml\nsearch: path: search.xml field: post content: true format: html NexT config file _config.next.yml\n# Local search # Dependencies: https://github.com/next-theme/hexo-generator-searchdb local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 开启评论 hexo支持很多评论系统，例如disqus、disqusjs、changyan、livere、gitalk、utterances、isso等，我基本上都测试了一遍。changyan是国产的，有一些特色功能，例如支持评论先审后发；gittalk、utterances等是基于github issues的；giscus是基于github discussions的，支持楼中楼。\n名称 说明 官网 评价 disqus Disqus 是一种美国博客评论托管服务，适用于使用网络平台的网站和在线社区。 https://disqus.com ↗ 官网不开代理打不开 disqusjs 基于Disqus，DisqusJS 提供一个纯前端的、不依赖后端服务器的 Disqus 评论基础模式。 https://disqusjs.skk.moe/ ↗ 同上，不能用 changyan 畅言云评，国内的 https://changyan.kuaizhan.com ↗ 可以用，支持先审后发。但是评论需要登录到畅言云评账号 gitalk 基于github issues https://gitalk.github.io/ ↗ 不推荐，需要的权限太高，配置也太复杂，我搞了一天也没有完全成功。作者也很久不维护了。评论时需要登录github utterances 基于github issues，gitalk的完全替代者。 https://utteranc.es/ ↗ 推荐，可以只给评论的存储仓库开权限，几分钟就成功了，配置简单。评论时需要登录github giscus 基于github discussions，本项目深受 utterances 的启发。 https://giscus.app/zh-CN ↗ 推荐，和utterances很像，没有授权问题，配置简单。基于discussions，支持楼中楼，评论时需要登录github。本博客使用的是giscus评论系统。 valine 基于LeanCloud https://valine.js.org/ ↗ 推荐，无需登录，支持匿名评论 如果要使用giscus，需要先在源代码项目安装[hexo giscus插件]( GitHub - next-theme/hexo-next-giscus: Giscus comment system for NexT ↗ ) :\nnpm install hexo-next-giscus 其次创建一个自己名下用来存储的公开仓库，然后打开 giscus ↗ 填写相关信息，即可自动生成giscus配置。\ngiscus: enable: true repo: #需要修改成自己的公开仓库 repo_id: 需要修改成自己的 category: General category_id: 需要修改成自己的 # Available values: pathname | url | title | og:title mapping: pathname # Available values: 0 | 1 reactions_enabled: 1 # Available values: 0 | 1 emit_metadata: 1 # Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme theme: preferred_color_scheme # Available values: en | zh-CN lang: en # Place the comment box above the comments input_position: top # Load the comments lazily loading: lazy 其他的设置都比较简单，可以自行参考 NexT官方文档 ↗ 。\n开启文章底部分享 _config.next.yml addtoany: enable: true buttons: - facebook - twitter - telegram - wechat - qzone - sina_weibo 开启文章字数计数 详见 hexo+word+counter ↗ 安装\nnpm install hexo-word-counter _config.next.yml配置\n# Post wordcount display settings # Dependencies: https://github.com/next-theme/hexo-word-counter symbols_count_time: separated_meta: true item_text_total: true 标签词云 标签词云的github地址为 hexo-tag-cloud ↗ 安装\nnpm install hexo-tag-cloud _config.next.yml配置\n# hexo-tag-cloud tag_cloud: textFont: Trebuchet MS, Helvetica textColor: \u0026#39;#333\u0026#39; textHeight: 25 outlineColor: \u0026#39;#E2E1D1\u0026#39; maxSpeed: 0.1 处理图片链接 在使用MarkText等软件编辑md文件上传图片时，生成的路径和hexo路径不匹配。可以使用hexo-image-link插件解决。参考： https://github.com/cocowool/hexo-image-link ↗ NexT其他插件 其他还有数学公式支持、基于LeanCloud的网站访客统计等功能，可参考官方教程\nhttps://theme-next.js.org/plugins ↗ https://theme-next.js.org/docs/third-party-services/ ↗ 部署流程 npm install -g hexo-cli 再hexo init之后，会生成一个nodejs项目，hexo new会在source 文件夹中生成新的markdown文件。这个项目有_config.yml、package.json、.gitignore等文件，可以把这个项目称之为“源代码”项目。源代码项目是私有的。\n然后生成的html静态网站，应该搞一个单独的html项目，例如项目名叫chunqiujinjing.github.io。\nhexo new 新文章编辑好之后，就可以把“源代码”项目commit+push到git上面了。最后运行一下hexo g + hexo d可以部署到html项目中。\n其实html项目也可以是私有的，只不过想使用github pages必须命名为chunqiujinjing.github.io并且公有才行。其实就算随便取名字，设置为私有，也可以自己部署到任意地方。\n如果想做到commit+push源代码之后自动部署html项目，可以使用github actions。\ngithub actions 在[hexo的github-pages文档]( GitHub Pages | Hexo ↗ ) 中有一个github actions的示例，但是其中配置的做法并不科学。它把源代码项目和html项目放到了一个仓库中，用不同的分支来区分，然后还部署到了github pages，github pages必须使用公开仓库。这就导致了网站的源代码和html代码都暴露了，你的所有配置将被一览无余：例如leancloud的appkey、giscus的id等等。\n最佳实践是源代码仓库设置为私有，通过hexo deploy（或者由github action自动化）部署到html仓库。html仓库如果使用github pages部署，必须设置为公开，但通过vercel或者其他托管网站部署则可以设置为私有。\n最佳实践 1 修改源代码仓库：\n_config.yml # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: git repo: git@github.com:你的用户名/你的html仓库 branch: main 2 添加github actions\n可以参考 hexo-action ↗ 来设置。\n2.1 设置 Deploy keys 和 Secrets\n2.1.1 运行ssh-keygen -t rsa -C \u0026quot;username@example.com\u0026quot; (替换为你的邮箱) ，会生成一个文件，里面有公钥和私钥。\n2.1.2 在 Github html存储库中：在 Settings \u0026gt; Deploy Keys 添加公钥。\n2.1.3 在 hexo 源代码存储库中：在 Settings \u0026gt; Secrets 菜单中添加私钥。\n2.2 创建github/workflows/deploy.yml 文件，\nname: Deploy on: [push] jobs: build: runs-on: ubuntu-latest name: A job to deploy blog. steps: - name: Checkout uses: actions/checkout@v1 with: submodules: true # Checkout private submodules(themes or something else). # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: ${{ runner.os }}-node-${{ hashFiles(\u0026#39;**/package-lock.json\u0026#39;) }} restore-keys: | ${{ runner.os }}-node- - name: Install Dependencies if: steps.cache.outputs.cache-hit != \u0026#39;true\u0026#39; run: npm ci # Deploy hexo blog website. - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} # user_name: your github username # (or delete this input setting to use bot account) # user_email: your github useremail # (or delete this input setting to use bot account) commit_msg: ${{ github.event.head_commit.message }} # (or delete this input setting to use hexo default settings) # Use the output from the `deploy` step(use for test action) - name: Get the output run: | echo \u0026#34;${{ steps.deploy.outputs.notify }}\u0026#34; 这样设置完之后，在hexo源代码仓库，创建或者修改完文章，只需要git commit、git push，就会自动触发github actions，完成部署代码到html仓库。\n当然也可以不设置github actions，就需要自己手动hexo generate hexo deploy了。\n部署到vercel 打开 vercel官网 ↗ ，注册并登录，关联github账号，新建项目，选择html项目（注意不是源码项目）即可一键部署到vercel。\n绑定域名 vercel分配的域名在大部分地区是被阻断的，可以绑定自己的域名。操作方法可以参考： GitHub - gaboolic/vercel-reverse-proxy ↗ ","date":"2024-12-22","tags":["hexo"],"title":"使用 Hexo+GitHub+Vercel 搭建个人免费博客的最佳实践","url":"/post/2024/12/hexo/"},{"content":" 原文 ↗ #!/bin/bash # 1. 自定义通知消息 # 传参 $1:消息描述 $2:通知标题 $3:通知副标题 function showNoteMessage(){ osascript -e \u0026#34;display notification \\\u0026#34;${1}\\\u0026#34; with title \\\u0026#34;${2}\\\u0026#34; subtitle \\\u0026#34;${3}\\\u0026#34; sound name \\\u0026#34;Funk\\\u0026#34;\u0026#34; } #test case: #showNoteMessage \u0026#34;消息内容\u0026#34; \u0026#34;通知\u0026#34; \u0026#34;通知副标题\u0026#34; # 2. 自定义弹窗(统一通用方法) # 传参$1 弹窗消息内容 # 传参$2 弹窗标题 # 传参$3 按钮标题,多个用英文逗号隔开 # 传参$4 默认选中的按钮标题或者按钮数字下标 # 传参$5 是否为输入框类型 传\u0026#34;0\u0026#34;或者\u0026#34;1\u0026#34; 默认\u0026#34;0\u0026#34; # 传参$6 输入框默认占位内容,传不传无所谓,默认为空字符串 \u0026#34;\u0026#34; # 传参$7 默认图标note/stop/caution 或者自定义文件路径(:格式路径可以通过choose file获取) # tips: 重要! 如果为输入框模式,那么输出结果就是{button returned:button,text returned:text} 否则只有按钮或者false function showCustomAlertMessage(){ if [[ -n \u0026#34;$4\u0026#34; ]]; then if [[ ${4} == *[!0-9]* ]]; then defaultButton=\u0026#34;default button \\\u0026#34;${4}\\\u0026#34;\u0026#34; else defaultButton=\u0026#34;default button ${4}\u0026#34; fi else defaultButton=\u0026#34;\u0026#34; fi #是否为输入框模式 if [[ \u0026#34;$5\u0026#34; = \u0026#34;1\u0026#34; ]]; then IS_InputMode=\u0026#34;default answer \\\u0026#34;${6}\\\u0026#34;\u0026#34; ReturnValue=\u0026#34;get result\u0026#34; else IS_InputMode=\u0026#34;\u0026#34; ReturnValue=\u0026#34;get the button returned of the result\u0026#34; fi if [[ -n \u0026#34;$7\u0026#34; ]]; then case ${7} in note) ICON=\u0026#34;with icon note\u0026#34; ;; stop) ICON=\u0026#34;with icon stop\u0026#34; ;; caution) ICON=\u0026#34;with icon caution\u0026#34; ;; *) ICON=\u0026#34;with icon file \\\u0026#34;${7}\\\u0026#34;\u0026#34; ;; esac else ICON=\u0026#34;with icon file \\\u0026#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\\\u0026#34;\u0026#34; fi osascript \u0026lt;\u0026lt;EOF set buttonStr to \u0026#34;${3}\u0026#34; set oldDelimiters to AppleScript\u0026#39;s text item delimiters set AppleScript\u0026#39;s text item delimiters to \u0026#34;,\u0026#34; set buttonList to every text item of buttonStr set AppleScript\u0026#39;s text item delimiters to oldDelimiters get buttonList set btns to buttonList display dialog \u0026#34;${1}\u0026#34; with title \u0026#34;${2}\u0026#34; buttons btns ${IS_InputMode} ${defaultButton} ${ICON} ${ReturnValue} EOF } # showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮2\u0026#34; \u0026#34;1\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;note\u0026#34; # showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; 2 \u0026#34;0\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;note\u0026#34; #showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮2\u0026#34; \u0026#34;0\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;stop\u0026#34; #showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮2\u0026#34; \u0026#34;0\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\u0026#34; # 普通弹窗 一个ok就够了 就是一个确认的那种 function onlyConfirmButton(){ showCustomAlertMessage \u0026#34;$1\u0026#34; \u0026#34;温馨提示\u0026#34; \u0026#34;好的\u0026#34; 1 } #onlyConfirmButton \u0026#34;登录成功!\\n弹窗成功!\u0026#34; # 多按钮弹窗 最多三个按钮 多了会报错 function mostButtons(){ showCustomAlertMessage \u0026#34;$1\u0026#34; \u0026#34;温馨提示\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮3\u0026#34; } #mostButtons \u0026#34;最多只能定义三个按钮哦\u0026#34; # 输入框弹窗 function showInputAlertMessage(){ showCustomAlertMessage \u0026#34;$1\u0026#34; \u0026#34;$2\u0026#34; \u0026#34;取消,确认\u0026#34; 2 \u0026#34;1\u0026#34; \u0026#34;\u0026#34; } showInputAlertMessage \u0026#34;请输入密码\u0026#34; \u0026#34;登录验证\u0026#34; ","date":"2024-11-09","tags":["编程","shell"],"title":"shell mac 教程","url":"/post/2024/11/shell_mac_pop/"},{"content":"参考：\n中州西鹿 ↗ 多图详细教你注册Google（Gmail）新账号，常见问题和注意事项 ↗ 此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法 ↗ 谷歌账号注册的问题 注册 通过google主页或直接访问 Gmail 主页，选择登录，在登录的时候选择“创建账号”，一般选个人用途就可以了。选好了以后点击下一步。耗时3秒\n如果你注册输入手机号提示“此电话号码无法用于进行验证”，那么有这样几种可能的原因：\n你用来访问的网络环境不是很稳定，Google认为有风险。 你用来访问的浏览器是新的，或者是手机浏览器，Google 认为有风险。 你输入的手机号已经被频繁验证 你的 IP 被注册了大量的 Google 账号 （可能）你的 Google 浏览器不是英文的 （可能）是个虚拟平台的号码 多个成功实践证明，只要是国内三大运营商正常使用的手机号，都是可以正常验证、接收验证码的，请不要怀疑这点。\n如果你已经注册成功了，但是要求你做验证，这时不需要使用的注册时使用的手机号，随便使用一个手机号就行，这个手机号最好是新的，并且你的魔法地址和手机号的归属地必须一样。\n[bsmessage type=\u0026ldquo;common\u0026rdquo; color=\u0026ldquo;red\u0026rdquo; title=\u0026ldquo;登录谷歌账号异常提示\u0026rdquo; icon=\u0026ldquo;exclamation\u0026rdquo;]此电话号码已用过太多次，此电话号码无法用于进行验证[/bsmessage]\n前置准备\n接收验证码的平台：https://sms-activate.io/cn/buy2\n“此电话号码已用过太多次” 与 “此电话号码无法用于进行验证” 是如何产生的？ 在注册谷歌时显示此电话号码已用过太多次，表示你之前使用此电话号码注册过谷歌账号。当你再次注册时候，谷歌会启动防止滥用的注册机制。当你更换其它号码后，如果是新的号码。会顺利的注册成功。\n如果依旧提示此电话号码已用过太多次的提示，只能继续尝试新的号码。\n尝试其它号码五次过后，最终会提示此电话号码无法用于进行验证。也就是说即便是真实有效而且没有注册过谷歌的电话号码，也会被提示无法注册，这个问题不出在电话号码上。\n这个时候你需要关闭页面，重新进行账号注册，然后到手机号码验证页面中继续验证。这一步需要注意的是，输入五次号码后，出现此电话号码无法用于进行验证时，再输入多少号码都是这个提示，即便是可以用于验证的号码，这时一定要关闭页面，重新进行注册填写。\n至于一个手机号可以绑定多少个谷歌账号，网上众说纷纭，有说可以绑定5个谷歌账号的，具体可以绑定多少个谷歌账号，自己可以实验一下，2-3个是没问题的。\n如何使用香港号码注册谷歌账号 目前可以使用香港号码进行谷歌账号注册，虽然说国内号码也可以注册谷歌账号，但是不建议使用国内电话号注册谷歌账号，有个人隐私泄露的风险。那么如何使用香港号码注册谷歌账号呢？\n使用 SMS-Activate 国外接码平台，这是一家俄罗斯的接码平台，里面各个国家的号码非常全面。\nSMS-Activate 提供世界上大多数国家的虚拟号码，以便您可以在线接收带有确认代码的短信。 在我们的服务中，还有虚拟号码的长期租赁，转发连接，电话验证等等。使用SMS-Activate的虚拟号码来在线接受短信。可以在 600个多服务注册的一次性号码。短信即刻送到给你\nSMS-Activate官网：https://sms-activate.org\n在SMS-Activate中充值也比较方便，支持比特币充值和国内支付宝充值等等。\n在 SMS-Activate 左侧的接码服务中点击 Google，YouTube，Gmail然后从中选择对应的国家，例如选择香港。\n使用香港号码注册 Google，只需 11.25 卢布。在注册时候，同时购买 5 个号码，接码不成功是可以取消的，号码多，注册成功的机率高一些。\n由于接码的号码每日数量有限，有很多的号码没有办法进行号码验证，在注册时候就会出现此电话号码已用过太多次\n遇到这样的情况，使用 5 个号码依次进行注册，如果无法注册需要先关闭Google账户注册页面，重新填写注册信息后，再更换号码进行验证。\n需要注意的一点，当你打开谷歌注册页面，填写完资料后，到电话验证的步骤，输入号码后，如果直接显示此电话号码无法用于进行验证\n这时候要关闭谷歌浏览器，打开浏览器的无痕模式！打开新的无痕式窗口，在Microsoft Edge浏览器中，无痕模式叫InPrivate 浏览！这个一定要注意。\n关于注册谷歌账号的几点总结 如果你不是大量注册谷歌账号的话，基本上不会触发谷歌账号滥用的限制，或者你之前注册过谷歌账号，但是长期不使用忘记了，你的电话号码已经进入谷歌的号码库，这时再次进行注册也会产生 此电话号码已用过太多次 的错误提示。\n如果在注册过程中，直接报 此电话号码无法用于进行验证 错误，可以关闭浏览器，使用浏览器的无痕模式再继续进行注册，只要报了 此电话号码无法用于进行验证 这个错误，接下来就必须关闭页面，这个错误无法进行下一步注册。\n关于IP地址和银行卡绑定的一点点经验，IP地址无需纷繁更换，同一个IP地址可以注册多个账号，这个不受影响，银行卡在注册谷歌云进行绑定的时候，有时候会造成谷歌云虽然注册成功，但是谷歌云默认关闭状态，不晓得触发了哪些机制，有时候在绑卡过程中还需要验证银行的短信。\n以上就是在注册谷歌账号时遇到问题的解决方法。\n我们检测到您在尝试访问的账号存在异常活动。如要继续，请按以下说明操作。\n请验证您的身份\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1当系统检测到账号异常，这时候也需要提供电话号码验证，同样可以使用接码平台的手机号码进行验证。\n注意：当你使用手机号码验证谷歌账号时，无需使用初始注册的电话号码，只要是可以接收的号码就可以用来验证。\nSMS-Activate官网：https://sms-activate.org\n在SMS-Activate中充值也比较方便，支持比特币充值和国内支付宝充值等等。\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1\n如果遇到 此电话号码已多次用于验证 的提示，重新更换其它号码，一直到可以接收验证码为止。\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1\n如果出现 此电话号码无法用于进行验证 。这种提示的话，需要关闭网页，等几个小时或者几天后，重新登陆进行验证，一般输入电话号码5-6次错误提示 此电话号码已多次用于验证 之后。会提示无法用于进行验证的错误提示。\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1\n验证码输入之后，验证通过！遇到类似的问题可以使用同样的方法解决。\n","date":"2024-07-17","tags":["运维","技能"],"title":"谷歌账号注册的问题","url":"/post/2024/07/google_account/"},{"content":" 3 * * * * * * * * 4 * * * * * * * * * * * * 非多组输入 #include \u0026lt;stdio.h\u0026gt; //行定位 int main() { int n = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; \u0026#43;\u0026#43;i) { if (i == 0 || i == n - 1) {//首尾行输出一行* for (int j = 0; j \u0026lt; n; \u0026#43;\u0026#43;j) { printf(\u0026#34;* \u0026#34;); } } else { for (int j = 0; j \u0026lt; n; \u0026#43;\u0026#43;j) {//其它行首尾输出* if(j==0 || j == n-1) printf(\u0026#34;* \u0026#34;); else printf(\u0026#34; \u0026#34;); } } printf(\u0026#34;\\n\u0026#34;);//换行 } return 0; } // 3 ---- n // * * * --- 1行每个位置都输出 一共n个 // * * --- 其它行1和n位置输出 一共2个 // * * * --- n行每个位置都输出 一共n个 // 思路： // 使用for 和 if // 判断是不吃首尾行 是则输出一行* 不是则输出首尾* 多组输入 #include \u0026lt;stdio.h\u0026gt; //行和列定位 int main() { int n = 0; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1){//输入的数量为1 for (int i = 0; i \u0026lt; n; \u0026#43;\u0026#43;i) {//控制行 for (int j = 0; j \u0026lt; n; \u0026#43;\u0026#43;j) {//控制列 if(i == 0 || i == n-1 || j == 0 || j == n-1)//第0行，第n-1行，第0列，第n-1列输出 *_,其它位置输出 __ printf(\u0026#34;* \u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } } return 0; } ","date":"2024-06-29","tags":["编程"],"title":"C 语言字符画","url":"/post/2024/06/c_shar/"},{"content":"如何生成 .dll文件 生成dll文件同时会生成lib文件\n在VS开始界面，搜索dll，创建dll动态链接库 创建一个类（右键创建类，会自动包含需要的文件） 以查询目录下的文件为例 创建的文件可以不用管 .cpp文件 输入自己的代码 #include \u0026#34;pch.h\u0026#34; #include \u0026#34;check_repository.h\u0026#34; namespace fs = std::filesystem; int Check::CheckRepository() { std::string folderName = \u0026#34;.Rysigy\u0026#34;; fs::path currentPath = fs::current_path(); fs::path folderPath = currentPath / folderName; if (fs::exists(folderPath) \u0026amp;\u0026amp; fs::is_directory(folderPath)) { std::cout \u0026lt;\u0026lt; \u0026#34;存储库 \u0026#39;.Rysigy\u0026#39; 文件夹存在\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[错误]\\t存储库 \u0026#39;.Rysigy\u0026#39; 文件夹不存在\\n请在右键菜单中点击 \u0026#39;创建存储库\u0026#39;\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;点击任意按键退出...\u0026#34; \u0026lt;\u0026lt; std::endl; _getch(); return 0; }; .h文件\n#pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; #include \u0026lt;conio.h\u0026gt; // 查询当前的目录下是否有.Rysigy class __declspec(dllexport) Check{ public: int CheckRepository();//检查是否有存储库 }; 为了让生成的文件尽量小，可以使用release模式，以及MT运行库MT生成\n","date":"2024-06-29","tags":["编程"],"title":"如何生成 dll 文件","url":"/post/2024/06/dl/"},{"content":"如果你需要删除错误提交到GitHub仓库中的文件，你可以通过以下步骤来创建一个新的提交来撤销之前的更改：\n在本地仓库中删除文件： 首先，在你的本地仓库中删除该文件：\ngit rm --cached \u0026lt;file\u0026gt; 这里 \u0026lt;file\u0026gt; 是你想要从仓库中删除的文件名。--cached 参数意味着仅从Git的跟踪中删除文件，而不删除工作目录中的文件。\n提交这个更改： 然后，提交这个更改到你的本地仓库：\ngit commit -m \u0026#34;Remove mistakenly added file\u0026#34; 推送到远程仓库： 最后，将这个更改推送到GitHub上的远程仓库：\ngit push origin \u0026lt;branch\u0026gt; 其中 \u0026lt;branch\u0026gt; 是你想要推送更改的分支名，比如 main 或 master。\n这样，你就创建了一个新的提交，它撤销了错误提交的文件。这个文件将从GitHub仓库中删除。\n如果你想要完全从仓库的提交历史中删除该文件（而不是仅仅创建一个新的提交来删除它），你可以使用 git filter-branch 或 BFG Repo-Cleaner 等工具来重写历史。但请注意，这些方法会改变仓库的历史，如果你已经推送了原始提交，这可能会给其他协作者带来问题。在这种情况下，最好的做法是联系仓库管理员来帮助解决。\n警告：使用 git filter-branch 或其他历史修改工具应该非常小心，因为它们可能会破坏公共仓库的历史，使得其他人难以与你的仓库同步。在尝试这些高级操作之前，请确保你完全理解它们的后果，并且已经备份了你的仓库。\n","date":"2024-06-19","tags":["编程","git"],"title":"删除错误提交到GitHub仓库中的文件","url":"/post/2024/06/git_delete_file/"},{"content":"软件 https://github.com/tangyoha/telegram_media_downloader/ ↗ 在 elease 里面下载可执行程序 Win https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.3/tdl-v2.2.3-win64.zip ↗ Linux （x86_64) https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-linux-amd64.zip ↗ mac 没有测试 https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-macos.zip ↗ 配置 所有配置都通过 config.yaml 文件传递​​给 Telegram Media Downloader。\n获取您的 API 密钥： 第一步需要您获得有效的 Telegram API 密钥（API id/hash pair）：\n访问 https://my.telegram.org/apps ↗ 并使用您的 Telegram 帐户登录。 填写表格以注册新的 Telegram 应用程序。 完成！ API 密钥由两部分组成：api_id 和api_hash。 获取聊天ID：\n如果你需要下载收藏夹的内容请填me\n1。使用网络电报：\n打开 https://web.telegram.org/?legacy=1#/im ↗ 现在转到聊天/频道，您将看到 URL 类似 https://web.telegram.org/?legacy=1#/im?p=u853521067_2449618633394 这里 853521067 是聊天 ID。 https://web.telegram.org/?legacy=1#/im?p=@somename 这里的 somename 是聊天 ID。 https://web.telegram.org/?legacy=1#/im?p=s1301254321_6925449697188775560 此处取 1301254321 并将 -100 添加到 id =\u0026gt; -1001301254321 的开头。 https://web.telegram.org/?legacy=1#/im?p=c1301254321_6925449697188775560 此处取 1301254321 并将 -100 添加到 id =\u0026gt; -1001301254321 的开头。 2。使用机器人： 1.使用 @username_to_id_bot ↗ 获取chat_id - 几乎所有电报用户：将用户名发送给机器人或将他们的消息转发给机器人 - 任何聊天：发送聊天用户名或复制并发送其加入聊天链接到机器人 - 公共或私人频道：与聊天相同，只需复制并发送给机器人 - 任何电报机器人的 ID\n配置文件 api_hash: your_api_hash api_id: your_api_id bot_token: your_bot_token chat: - chat_id: telegram_chat_id last_read_message_id: 0 download_filter: message_date \u0026gt;= 2022-12-01 00:00:00 and message_date \u0026lt;= 2023-01-17 00:00:00 - chat_id: telegram_chat_id_2 last_read_message_id: 0 # 我们将ids_to_retry移到data.yaml ids_to_retry: [] media_types: - audio - document - photo - video - voice file_formats: audio: - all document: - pdf - epub video: - mp4 save_path: D:\\telegram_media_downloader file_path_prefix: - chat_title - media_datetime disable_syslog: - INFO upload_drive: enable_upload_file: true remote_dir: drive:/telegram before_upload_file_zip: True after_upload_file_delete: True hide_file_name: true file_name_prefix: - message_id - file_name file_name_prefix_split: \u0026#39; - \u0026#39; max_download_task: 5 web_host: 127.0.0.1 web_port: 5000 web_login_secret: 123 api_hash - 你从电报应用程序获得的 api_hash api_id - 您从电报应用程序获得的 api_id bot_token - 你的机器人凭证 chat - 多频道 chat_id - 您要下载媒体的聊天/频道的 ID。你从上述步骤中得到的。 download_filter - 下载过滤器, 查阅 如何使用过滤器 ↗ last_read_message_id -如果这是您第一次阅读频道，请将其设置为“0”，或者如果您已经使用此脚本下载媒体，它将有一些数字，这些数字会在脚本成功执行后自动更新。不要改变它。 chat_id - 您要下载媒体的聊天/频道的 ID。你从上述步骤中得到的。 last_read_message_id - 如果这是您第一次阅读频道，请将其设置为“0”，或者如果您已经使用此脚本下载媒体，它将有一些数字，这些数字会在脚本成功执行后自动更新。不要改变它。 ids_to_retry - 保持原样。下载器脚本使用它来跟踪所有跳过的下载，以便在下次执行脚本时可以下载它。 media_types - 要下载的媒体类型，您可以更新要下载的媒体类型，它可以是一种或任何可用类型。 file_formats - 为支持的媒体类型（“音频”、“文档”和“视频”）下载的文件类型。默认格式为“all”，下载所有文件。 save_path - 你想存储下载文件的根目录 file_path_prefix - 存储文件子文件夹，列表的顺序不定，可以随机组合 chat_title - 聊天频道或者群组标题, 如果找不到标题则为配置文件中的chat_id media_datetime - 资源的发布时间 media_type - 资源类型，类型查阅 media_types disable_syslog - 您可以选择要禁用的日志类型，请参阅 logging._nameToLevel upload_drive - 您可以将文件上传到云盘 enable_upload_file - [必填]启用上传文件，默认为false remote_dir - [必填]你上传的地方 upload_adapter - [必填]上传文件适配器，可以为rclone,aligo。如果为rclone，则支持rclone所有支持上传的服务器，如果为aligo，则支持上传阿里云盘 rclone_path，如果配置upload_adapter为rclone则为必填，rclone的可执行目录，查阅 如何使用rclone ↗ before_upload_file_zip - 上传前压缩文件，默认为false after_upload_file_delete - 上传成功后删除文件，默认为false file_name_prefix - 自定义文件名称,使用和 file_path_prefix 一样 message_id - 消息id file_name - 文件名称（可能为空） caption - 消息的标题（可能为空） file_name_prefix_split - 自定义文件名称分割符号，默认为- max_download_task - 最大任务下载任务个数，默认为5个。 hide_file_name - 是否隐藏web界面文件名称，默认false web_host - web界面地址 web_port - web界面端口 language - 应用语言，默认为英文(EN),可选ZH（中文）,RU,UA web_login_secret - 网页登录密码，如果不配置则访问网页不需要登录 执行 python3 media_downloader.py 所有下载的媒体都将存储在save_path根目录下。 具体位置参考如下：\nfile_path_prefix: - chat_title - media_datetime - media_type 视频下载完整目录为：save_path/chat_title/media_datetime/media_type。 列表的顺序不定，可以随机组合。 如果配置为空，则所有文件保存在save_path下。\n代理 该项目目前支持 socks4、socks5、http 代理。要使用它，请将以下内容添加到config.yaml文件的底部\nproxy: scheme: socks5 hostname: 127.0.0.1 port: 1234 username: 你的用户名（无则删除该行） password: 你的密码（无则删除该行） 如果您的代理不需要授权，您可以省略用户名和密码。然后代理将自动启用。\n","date":"2024-05-29","tags":["运维"],"title":"TG 下载器","url":"/post/2024/05/download_telegram/"},{"content":"作者： 阮一峰 ↗ 日期： 2018年1月21日 ↗ 学习编程其实就是学高级语言，即那些为人类设计的计算机语言。\n但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。\n计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。\n汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。\n一、汇编语言是什么？ 我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。\n这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。 编译器 ↗ 的作用，就是将高级语言写好的程序，翻译成一条条操作码。\n对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。\n汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。\n二、来历 最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。\n为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。\n这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。\n每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。\n三、寄存器 学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。\n先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。\n但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。\n寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。\n四、寄存器的种类 早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。\nEAX EBX ECX EDX EDI ESI EBP ESP 上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。\n我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。\n五、内存模型：Heap 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。\n程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。\n程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。\n这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。\n六、内存模型：Stack 除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。\n请看下面的例子。\nint main() { int a = 2; int b = 3; } 上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。\n如果函数内部调用了其他函数，会发生什么情况？\nint main() { int a = 2; int b = 3; return add_a_and_b(a, b); } 上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。\n等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。\n所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做\u0026quot;入栈\u0026quot;，英文是 push；栈的回收叫做\u0026quot;出栈\u0026quot;，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做\u0026quot;后进先出\u0026quot;的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。\nStack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。\n七、CPU 指令 7.1 一个实例 了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。\nint add_a_and_b(int a, int b) { return a \u0026#43; b; } int main() { return add_a_and_b(2, 3); } gcc 将这个程序转成汇编语言。\n$ gcc -S example.c 上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。\nexample.s经过简化以后，大概是下面的样子。\n_add_a_and_b: push %ebx mov %eax, [%esp\u0026#43;8] mov %ebx, [%esp\u0026#43;12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。\n每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。\npush %ebx 这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。\n下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。\n7.2 push 指令 根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。\n然后，开始执行第一行代码。\npush 3 push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。\n虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。\npush 2 第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。\n7.3 call 指令 第三行的call指令用来调用函数。\ncall _add_a_and_b 上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。\n下面就开始执行_add_a_and_b的代码。\npush %ebx 这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。\n这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。\n7.4 mov 指令 mov指令用于将一个值写入某个寄存器。\nmov %eax, [%esp\u0026#43;8] 这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。\n下一行代码也是干同样的事情。\nmov %ebx, [%esp\u0026#43;12] 上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。\n7.5 add 指令 add指令用于将两个运算子相加，并将结果写入第一个运算子。\nadd %eax, %ebx 上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。\n7.6 pop 指令 pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。\npop %ebx 上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。\n注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。\n7.7 ret 指令 ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。\nret 可以看到，该指令没有运算子。\n随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。\nadd %esp, 8 上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。\nret 最后，main函数运行结束，ret指令退出程序执行。\n原文地址 ↗ ","date":"2024-05-02","tags":["编程","x86"],"title":"x86 教程","url":"/post/2024/05/x86/"},{"content":" 在idea中分号并不是必须加的, 在执行多条语句才必须加, 在控制台使用的时候必须加 数据库相关的操作 查询数据库\tSHOW DATABASES\n创建数据库 CREATE DATABASE 数据库名 CREATE DATABASE mydatabase\n查看数据库信息 SHOW CREATE DATABASE 数据库名 SHOW CREATE DATABASE database\n删除数据库 DROP DATABASE 数据库名 DROP DATABASE mydatabase\n使用数据库 USE 数据库名 USE mydatabase\nDDL语句\t数据定义语言 创建表\nCREATE TABLE 表名( 列名1 类型[长度] [DEFAULT 默认值] [约束条件] 列名2 类型 …… ); CREATE TABLE userinfo( id INT username VARCHAR(32) password VARCHAR(32) nickname VARCHAR(32) age INT(3) ); 查看当前数据库创建的所有表 SHOW TABLES;\n查看表的详细信息 SHOW CREATE TABLE 表名 SHOW CREATE TABLE table;\n查看表结构 DESC 表名 DESC table;\n删除表 DROP TABLE 表名 DROP TABLE table;\n修改表名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE old_table TO new_table;\n修改表结构 ALTER TABLE\n添加列 ALTER TABLE 表名 ADD 列名 类型[长度] ALTER TABLE hero ADD age INT(3)\n在表中插入一个字段 ALTER TABLE 表名 ADD 列名 类型[长度] AFTER 字段名 ALTER TABLE table ADD col VARCHAR(32) AFTER name\n删除表中现有的列 ALTER TABLE 表名 DROP 列名 ALTER TABLE table DROP col\n修改表中现有的列 ALTER TABLE 表名 CHANGE 原字段名 新字段名 新类型 ALTER TABLE table CHANGE old_name new_old VARCHAR(10)\nDML语句（数据操作语言，对表中数据进行操作的语言）（增、删、改操作） PreparedStatement\n插入数据 INSERT INTO 表名[(字段1,字段2...)] VALUES(字段1的值,字段2的值...) INSERT INTO person(name,age) VALUES('张三',22)\n查看表中的所有数据 SELECT * FROM 表名 SELECT * FROM person\n修改表数据 UPDATE 表名 SET 字段名1=心值1[字段2=新值2...][WHERE 过滤条件] UPDATE person SET age=23 WHERE name='李四'\n删除数据 DELETE FROM 表名[WHERE 过滤条件] DELETE FROM person WHERE name='李老四'\nDQL语句\t数据查询语句\tPreparedStatement 使用数据库 USE 数据库名 USE mydb\n查询数据库 SHOW DATABASE\n创建数据库 CREATE DATABASE 数据库名 SHOW DATABASE mydb\n查询表的部分所有字段 SELECT 字段名1[字段名2，字段名3，... 或 *] FROM 表名 SELECT * FROM user\n查看emp表的特定的字段 SELECT name,job FROM emp\nWHERE字句（添加过滤条件，查询满足条件的） SELECT name,job,sal FROM emp WHERE sal\u0026gt;1000; 连接多个条件 AND、OR 值在列表中 IN(列表)\tIN(emp) 区间 BETWWEEN 2000 AND 3000\t去重 SELECT DISTINCT SELECT DISTINCT job FROM emp\n多列去重 - 去除指定列中有重复的行 SELECT DISTINCT job,dept_id FROM emp\n模糊查询 - LIKE （两个通配符：_表示一个字符，和%表示任意个字符） WHERE name LIKE '%name%'\n总结:\n%X%:字符串中包含\u0026rsquo;X' %X:字符串以X结尾 X%:字符串以X开头 _X%:字符串第二个字符是X %X_:倒数第二个字符是X X%Y:字符串以X开头Y结尾 X_Y:字符串只有三个字，第一个是X，第三个是Y 根据指定的字段排序查询结果集 （该子句只能放在查询语句的最后一个子句上），默认升序，DESC降序 ORDER BY 字段\tORDER BY sal DESC\n多字段查询 ORDER BY 字段1,字段2,... ORDER BY sal,dept_id DESC\n分页查询 LIMIT 跳过的记录数（（页数-1）* 每页的记录数），，每页显示的记录数\t查询的字段可以使用表达式\tSELECT SELECT name,sal,sal*12 FROM emp; 查询时可使用函数的结果作为字段 SELECT CONCAT(name,'的职位是',job) FROM emp;\n数据库相关的操作 查询数据库： SHOW DATABASES;\n创建数据库： CREATE DATABASE 数据库名; CREATE DATABASE mydb;\n数据库创建时可以指定字符集： CREATE DATABASE 数据库名字 CHARSET=UTF8/GBK (字符集); CREATE DATABASE db1 CHARSET=UTF8;\n创建数据库db1(字符集用gbk) db2(字符集UTF8); CREATE DATABASE db1 CHARSET=UTF8; CREATE DATABASE db2 CHARSET=GBK;\n查看数据库信息 SHOW CREATE DATABASE 数据库名; SHOW CREATE DATABASE db1;\n删除数据库 DROP DATABASE 数据库名 DROP DATABASE db2;\n使用数据库 USE 数据库名字 USE mydb;\n表相关的操作 （列：字段，是一组数据中各属性信息） （行：记录，一条记录保存一组数据）\nDDL语句 （数据定义语言：用来操作数据库对象的）（数据库对象：表、视图、索引都属于数据库对象）\n创建表\nCREATE TABLE 表名( 列名1 类型[(长度)] [DEFAULT 默认值] [约束条件], 列名2 类型... )[CHARSET=UTF8/GBK] CREATE TABLE userinfo( id INT, username VARCHAR(32), password VARCHAR(32), nickname VARCHAR(32), age INT(3) ); 数字的长度表示位数，VACHAR的长度表示最多占用的字节数\n插入数据 INSERT INTO 表名[(字段1,字段2...)] VALUES (字段1的值,字段2的值...)\nINSERT INTO person(name,age) VALUES ('张三',22); INSERT INTO person(age,name) VALUES (27,'赵六'); # 对应即可\n未指定的列插入都是列的默认值，当创建表时没有为列声明特定的默认值时，列的默认值为null\nINSERT INTO person(name) VALUES ('李四');\n字段名可以忽略不写，此时为全列插入，即：VALUES需要指定每一列的值，且顺序、个数、类型必须与表相同\nINSERT INTO person VALUES ('王五',24);\n查看person表中的所有数据\nSELECT * FROM person;\n修改表数据操作: UPDATE语句\nUPDATE 表名 STE 字段名1=新值1[字段2=新值2...][WHERE 过滤条件]\nUPDATE person SET age=23 WHERE name='李四';\nWHERE 中常用的条件: =,\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;不等于（!= 不是所有数据库都支持）\nUPDATE person SET age=25 WHERE age\u0026gt;50;\nUPDATE person SET age=age+1 ;\nUPDATE person SET name='李老四',age=55 WHERE age=24;\n通常修改语句要添加WHERE子句，用于添加过滤条件来定位要修改的记录，不添加WHERE子句则是全表所有记录都修改\nUPDATE person SET age=55;\n删除数据 DELETE FROM 表名 [WHERE 过滤条件]\n注意！！！不添加WHERE条件则是全发表删除！！！\nDELETE FROM person WHERE name='李老四';\nUPDATE person SET age=20 WHERE name='张三'; DELETE FROM person WHERE age\u0026gt;25; #删除年龄大于25岁的人\nCREATE DATABASE day1db CHARSET=UTF8; USE day1db; CREATE TABLE t_hero( name VARCHAR(32) )CHARSET UTF8; RENAME TABLE t_hero TO hero; ALTER TABLE hero ADD money INT(10); ALTER TABLE hero ADD id INT FIRST; ALTER TABLE hero ADD age INT(3) AFTER name; INSERT INTO hero(name,age,money) VALUES (\u0026#39;李白\u0026#39;,22,6888); INSERT INTO hero(name,age,money) VALUES (\u0026#39;赵云\u0026#39;,30,13888); INSERT INTO hero(name,age,money) VALUES (\u0026#39;刘备\u0026#39;,25,6888); SELECT name FROM hero WHERE money=6888; SELECT * FROM hero; UPDATE hero SET age=52 WHERE name=\u0026#39;刘备\u0026#39;; UPDATE hero SET money=5000 WHERE age\u0026lt;50; DELETE FROM hero WHERE money=5000; DROP TABLE hero; DROP DATABASE day1db; USE empdb; SELECT * FROM emp; USE mydb; 数据类型 数字类型 整数: INT(m)和BIGINT(m) m表示的是长度 例如:m=5,存数字18,实际存储00018 浮点数:DOUBLE(m,n) m表示整体数字长度,n表示小数位 例如:DOUBLE(5,3) 99.999 （实际插入数据时，当精度超过可保存范围时，会四舍五入） 字符类型 CHAR(n):定长字符串，每条记录实际占用的字节空间是定长的，不足的部分补充空字符来满足长度要求 优点:查询速度快 缺点:浪费磁盘空间 VARCHAR(n):变长字符串，最多存n指定的字节数对应的字符，实际保存时，用多少占多少 （推荐） 优点:节省磁盘空间 缺点:查询速度慢 TEXT(n):可变长字符串，最大65535 日期时间类型\nDATE:保存年月日 TIME:保存十分秒 DATETIME:保存年月日时分秒 TIMESTAMP:时间戳，记录UTC时间，从1970-01-01 00:00:00到表示的时间之间经过的毫秒 DROP TABLE userinfo; CREATE TABLE userinfo( id INT, name VARCHAR(30), birth DATETIME, salary DOUBLE(7,2) )CHARSET UTF8; set names UTF8; INSERT INTO userinfo VALUES (1,\u0026#39;张三\u0026#39;,\u0026#39;1992-08-02 11:22:05\u0026#39;,5000.59); INSERT INTO userinfo VALUES (2,\u0026#39;李四\u0026#39;,\u0026#39;1999-05-16\u0026#39;,6500.23); INSERT INTO userinfo VALUES (3,\u0026#39;王五\u0026#39;,\u0026#39;06:12:45\u0026#39;,9700.342); DELETE FROM userinfo; SELECT * FROM userinfo; DELETE FROM userinfo WHERE name=\u0026#39;王五\u0026#39;; 约束:约束是为表中某个字段添加特定的限制条件，只有符合条件的记录才可以保存 主键约束:该字段非空且唯一，用该字段的值唯一表示一条记录 非空约束:该字段的值不允许为空 外键约束:实际开发中几乎不用\nCREATE TABLE student( id INT AUTO_INCREMENT PRIMARY KEY ,# AUTO_INCREMENT 自增 name VARCHAR(30) NOT NULL , age INT(3), gender CHAR(1) ); DESC student; SELECT * FROM student; INSERT INTO student VALUES (NULL,NULL,55,\u0026#39;m\u0026#39;); INSERT INTO student VALUES (NULL,\u0026#39;刘桑\u0026#39;,55,\u0026#39;m\u0026#39;); INSERT INTO student(name,age,gender) VALUES (\u0026#39;克晶\u0026#39;,18,\u0026#39;f\u0026#39;); 不允许\nINSERT INTO student(age,gender) VALUES (18,\u0026#39;f\u0026#39;); INSERT INTO student(name,age,gender) VALUES (\u0026#39;传奇\u0026#39;,22,NULL); INSERT INTO student(name,age) VALUES (\u0026#39;国斌\u0026#39;,33); DELETE FROM student WHERE id=3; CREATE TABLE teacher( id INT PRIMARY KEY , name VARCHAR(30) NOT NULL, age INT(3), gender CHAR(1) ); INSERT INTO teacher VALUES (1,\u0026#39;张三\u0026#39;,22,\u0026#39;F\u0026#39;); INSERT INTO teacher VALUES (1,\u0026#39;李四\u0026#39;,23,\u0026#39;M\u0026#39;);# 不可重复 INSERT INTO teacher VALUES (NULL,\u0026#39;李四\u0026#39;,23,\u0026#39;M\u0026#39;); SELECT * FROM teacher; NULL 要作为条件，要使用IS NULL 或 IS NOT NULL SELECT * FROM student WHERE gender IS NULL; SELECT * FROM student WHERE gender IS NOT NULL; DQL语句 数据查询语句 基本语法: SELECT 字段名1[字段名2，字段名2，...或 * ] FROM 表名\nUSE empdb;\n查看emp表的所有字段\nSELECT * FROM emp; 查看特定的字段 SELECT name,job,hiredate FROM emp;\nWHERE子句，用来添加过滤条件，此时可以仅将满足条件的记录查询出来 比较运算符:=,\u0026lt;,\u0026gt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;\n查看工资大于1000的员工的名字，职位，工资\nSELECT name,job,sal FROM emp WHERE sal\u0026gt;1000; SELECT name,job,sal FROM emp WHERE job\u0026lt;\u0026gt;\u0026#39;人事\u0026#39;; SELECT name,job,sal,dept_id FROM emp WHERE dept_id=2; 使用AND和OR来连接多个条件 SELECT name,sal,job,dept_id FROM emp WHERE dept_id=2 AND sal\u0026gt;1000; SELECT name,sal,job,dept_id FROM emp WHERE job=\u0026#39;人事\u0026#39; OR job=\u0026#39;销售\u0026#39;; SELECT name,sal,job FROM emp WHERE job=\u0026#39;人事\u0026#39; OR sal\u0026gt;1000 AND job=\u0026#39;销售\u0026#39;; SELECT name,sal,job FROM emp WHERE (job=\u0026#39;人事\u0026#39; OR job=\u0026#39;销售\u0026#39;) AND sal\u0026gt;1000; # and优先级大于or,可以通过（）提高优先级 IN(列表) 值在列表中（等于列表中的其中之一） SELECT name,sal,job,dept_id FROM emp WHERE job IN (\u0026#39;人事\u0026#39;,\u0026#39;销售\u0026#39;); SELECT name,sal,job,dept_id FROM emp WHERE job NOT IN (\u0026#39;人事\u0026#39;,\u0026#39;销售\u0026#39;); 区间 SELECT name,sal,job FROM emp WHERE sal BETWEEN 2000 AND 3000; 去重 SELECT DISTINCT job FROM emp; 多列去重时，就是去除指定这些列的值的组合有重复的行\nSELECT DISTINCT job,dept_id FROM emp; SELECT * FROM emp WHERE dept_id=2 AND sal\u0026gt;1000; SELECT name,job,sal,dept_id FROM emp WHERE dept_id=3 OR sal=5000; SELECT name,job,sal,dept_id FROM emp WHERE sal BETWEEN 1000 AND 2000; SELECT name,sal,job,dept_id FROM emp WHERE sal NOT IN (2000,5000); SELECT DISTINCT job FROM emp WHERE dept_id=1; 模糊查询: LIKE LIKE 中两个通配符:_和% %:表示任意的一个字符(0-多个) _:表示一个字符 SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;孙%\u0026#39;; SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;%悟%\u0026#39;; SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;__精\u0026#39;; SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;_骨%\u0026#39;; 总结:\n%X%:字符串中包含\u0026rsquo;X' %X:字符串以X结尾 X%:字符串以X开头 _X%:字符串第二个字符是X %X:倒数第二个字符是X X%Y:字符串以X开头Y结尾 X_Y:字符串只有三个字，第一个是X，第三个是Y SELECT name FROM emp WHERE name LIKE \u0026#39;猪%\u0026#39;; SELECT * FROM emp WHERE name LIKE \u0026#39;%僧%\u0026#39;; SELECT name FROM emp WHERE name LIKE \u0026#39;%精\u0026#39;; SELECT * FROM emp WHERE job LIKE \u0026#39;%销售%\u0026#39; AND sal\u0026gt;1500; SELECT name,job FROM emp WHERE job LIKE \u0026#39;_售%\u0026#39;; SELECT * FROM emp WHERE dept_id IN (1,2) AND job LIKE \u0026#39;市%\u0026#39;; ORDER BY 子句，根据指定的字段排序查询结果集，该子句只能放在查询语句的最后一个子句上 默认升序 DESC降序\nSELECT name,sal FROM emp ORDER BY sal; SELECT name,hiredate FROM emp ORDER BY hiredate; SELECT name,sal FROM emp ORDER BY sal DESC; 按照多字段排序，在前的优先，可以单独设置升序和降序\nSELECT name,dept_id,sal FROM emp ORDER BY dept_id,sal DESC; SELECT * FROM emp WHERE manager IS NOT NULL ORDER BY hiredate; SELECT * FROM emp WHERE dept_id=1 AND name LIKE \u0026#39;%八%\u0026#39;; SELECT * FROM emp WHERE dept_id IN (2,3) AND sal\u0026lt;5000; SELECT name,sal,job FROM emp WHERE job IN (\u0026#39;人事\u0026#39;,\u0026#39;程序员\u0026#39;) AND sal\u0026gt;2500; SELECT name,job,sal FROM emp WHERE job NOT IN (\u0026#39;CEO\u0026#39;) AND sal\u0026gt;2000 ORDER BY sal DESC ; 分页查询 将满足查询条件的数据分段分批查询出来。这可以减少不必要的系统开销。\nLIMITE 跳过的记录数，显示的记录数\nLIMITE (页数-1)*美页显示的记录数，每页显示的记录数\nSELECT name,sal FROM emp ORDER BY sal LIMIT 3,3; 查询的字段可以使用表达式 SELECT name,sal,sal*12 FROM emp;\n查询时也可以使用函数的结果作为字段 SELECT CONCAT(name,'的职位是',job) FROM emp;\nSELECT CONCAT(name,'的奖金是',comm) FROM emp;\n数字与NULL运算，结果就是NULL\nSELECT sal,comm,sal+comm FROM emp;\nNVL函数 用来替换NULL值\nNVL(arg1,arg2) 当arg1不为NULL时，则函数返回arg1的值，如果arg1为NULL在返回arg2的值\nSELECT name,sal,NVL(comm,0) FROM emp;\n别名（字段和表） 为字段定义别名:\n1.隐藏实际表字段名\n2.为计算表达式或函数的结果值作为字段时定义可读性更好的字段名\nSELECT name ename,sal salary FROM emp; SELECT name,sal*12 salary FROM emp;\n支持的语法 字段名 别名\nSELECT name,sal*12 salary FROM emp;\n字段名 as 别名 SELECT name,sal*12 as salary FROM emp;\n字段名 as \u0026lsquo;别名\u0026rsquo; SELECT name,sal*12 as 'salary' FROM emp;\n字段名 as \u0026ldquo;别名\u0026rdquo; SELECT name,sal*12 as \u0026quot;salary\u0026quot; FROM emp;\nSELECT * FROM emp WHERE dept_id=3 AND sal\u0026gt;1500; SELECT * FROM emp WHERE dept_id=2 OR manager IS NULL; SELECT name,sal FROM emp WHERE manager IS NOT NULL ORDER BY sal; SELECT name,hiredate FROM emp WHERE dept_id IN (2,3) ORDER BY hiredate DESC ; SELECT name FROM emp WHERE name LIKE \u0026#39;%僧%\u0026#39; OR name LIKE \u0026#39;%精%\u0026#39;; SELECT DISTINCT job FROM emp WHERE sal\u0026gt;2000; SELECT sal FROM emp ORDER BY sal LIMIT 6,2; 聚合函数（多行函数）: 用来将多条记录统计为一条记录 (忽略NULL值)\nMIN():求最小值\nMAX():求最大值\nCOUNT():统计记录数\nAVG():求平均值\nSUM():求和\nSELECT MIN(sal) 最低工资,MAX(sal) 最高工资,AVG(sal) 平均工资,SUM(sal) 工资总和 FROM emp; SELECT AVG(sal) FROM emp WHERE job=\u0026#39;销售\u0026#39;; SELECT MAX(sal) FROM emp WHERE job=\u0026#39;程序员\u0026#39;; SELECT COUNT(*) FROM emp WHERE name LIKE \u0026#39;%精%\u0026#39;; SELECT SUM(sal) FROM emp WHERE job LIKE \u0026#39;%销售%\u0026#39;; SELECT MAX(sal) 最高工资, MIN(sal) 最低工资 FROM emp WHERE dept_id=2; GROUP BY子句，分组 GROUP BY 也是为统计服务的，所以是搭配在聚合函数上使用的\nSELECT子句中不在聚合函数中的其他字段必须出现GROUP BY子句中\nSELECT AVG(sal),dept_id FROM emp GROUP BY dept_id; SELECT MAX(sal),job FROM emp GROUP BY job; SELECT MAX(sal),dept_id FROM emp GROUP BY dept_id; #查询最高工资 SELECT COUNT(*) FROM emp WHERE sal\u0026gt;2000 GROUP BY dept_id; SELECT MIN(sal),job FROM emp GROUP BY job; SELECT COUNT(*),dept_id FROM emp WHERE dept_id IN (1,2) GROUP BY dept_id; SELECT AVG(sal) avg,dept_id FROM emp GROUP BY dept_id ORDER BY avg DESC LIMIT 0,1; 聚合函数不能写在WHERE子句中\nSELECT AVG(sal) avg,dept_id FROM emp WHERE AVG(sal)\u0026gt;2000 ORDER BY dept_id; HAVING子句 HAVING子句是跟在GROUP BY子句之后，对分组统计出的结果再进行过滤的\nSELECT AVG(sal),dept_id FROM emp GROUP BY dept_id HAVING AVG(sal)\u0026gt;2000; SELECT AVG(sal),dept_id FROM emp GROUP BY dept_id HAVING MIN(sal)\u0026gt;1000; SELECT SUM(sal) sal,dept_id FROM emp WHERE manager IS NOT NULL GROUP BY dept_id HAVING SUM(sal)\u0026gt;5400; 嵌套在其他SQl语句中的查询语句被称作“子查询” SELECT name,sal FROM emp HAVING sal\u0026gt; (SELECT AVG(sal) FROM emp); SELECT * FROM emp HAVING sal\u0026gt; (SELECT AVG(sal) FROM emp WHERE dept_id=2); SELECT * FROM emp HAVING sal\u0026lt;(SELECT sal FROM emp WHERE name=\u0026#39;沙僧\u0026#39;); SELECT * FROM emp HAVING job=(SELECT job FROM emp WHERE name=\u0026#39;孙悟空\u0026#39;); SELECT * FROM emp HAVING dept_id=(SELECT dept_id FROM emp WHERE sal=(SELECT MIN(sal) FROM emp)); SELECT * FROM emp WHERE sal\u0026gt;ALL(SELECT sal FROM emp WHERE dept_id IN (2,3)); SELECT * FROM emp WHERE sal\u0026gt;ANY(SELECT sal FROM emp WHERE dept_id IN (2,3)); 子查询分类（按查询结果集分类）: 单行单列查询（结果集只有一个值） 多行单列子查询（结果集有多个值） 多行多列子查询（结果集是一个表）\n单行单列查询通常在过滤条件中使用 单行单列可以配合\u0026gt;,\u0026gt;=,=,\u0026lt;,\u0026lt;=使用 多行单列可以配合ANY,ALL,IN使用 例如:\nALL(子查询) \u0026lt;ALL(子查询) ANY(子查询) \u0026lt;ANY(子查询)： IN(子查询)：等于子查询结果集中的任意一个值\n多行多列子查询（结果通常是一个表），通常就当做一个表，可以跟在FROM子句中，或者跟在DDl语句中，可以基于一个查询结果集创建表。\nCREATE TABLE emp_dept1 AS SELECT * FROM emp WHERE dept_id=1; SELECT * FROM emp_dept1; 如果创建表基于的子查询某个字段是一个表达式或函数时，要给该字段取别名，那么创建出来的表该字段会以别名作为字段名 CREATE TABLE emp_dept_sal AS SELECT MAX(sal) max_sal,MIN(sal) min_sal,AVG(sal) avg_sal, SUM(sal) sum_sal,dept_id FROM emp GROUP BY dept_id; SELECT * FROM emp_dept_sal; DROP TABLE emp_annual_salary; CREATE TABLE emp_annual_salary AS SELECT name aneme,sal salary,sal\u0026#43;12 a_salary,dept_id FROM emp; SELECT * FROM emp_annual_salary; SELECT aneme,a_salary FROM emp_annual_salary WHERE aneme LIKE \u0026#39;%精%\u0026#39;; SELECT * FROM dept; 关联查询 查询结果集中的数据来自多张表，而表中的数据之间的对应关系就是关联关系\n两张表就可以产生关联关系了，关联关系分为三类: 1:一对一 A表中的1条记录只唯一对应B表中的1条记录 2:一对多 A表中的1条记录可以对应B表中的多条记录 3:多对多 A表与B表双向都是一对多时，就是多对多关系。\n关联查询就是基于多张表联合查询数据而形成一个结果集的过程，在关联查询中一个至关重要的点就是关联条件 原则:N张表关联查询至少要有N-1个连接条件。 缺失连接条件会产生笛卡尔积，该查询结果集的记录数是关联表中所有记录数乘积的结果，它通常是一个无意义的结果集，要 尽量避免产生\n关联查询语法:\nSELECT 字段\nFROM 表A，表B[，表C，表D\u0026hellip;]\nWHERE 过滤条件\nAND 连接条件\n注意:连接条件必须与过滤条件同时成立!!\nSELECT * FROM emp,dept; 当表中的字段名相同时，我们可以通过给表取别名用\u0026#34;别名.字段名\u0026#34; SELECT e.name,e.sal,e.dept_id,d.name,d.loc FROM emp e,dept d WHERE e.dept_id=d.id; SELECT e.name,e.sal,e.job,d.name,d.loc FROM emp e,dept d WHERE e.dept_id=d.id AND d.loc=\u0026#39;天庭\u0026#39;; SELECT e.name,d.loc FROM emp e,dept d WHERE e.dept_id=d.id AND e.name LIKE \u0026#39;%飞%\u0026#39;; SELECT e.name,MAX(e.sal) max_sal,d.loc FROM emp e ,dept d WHERE e.dept_id=d.id AND d.loc=\u0026#39;天庭\u0026#39; GROUP BY d.loc; SELECT AVG(e.sal),d.loc FROM emp e ,dept d WHERE e.dept_id=d.id GROUP BY d.loc; SELECT sal,name FROM emp WHERE sal\u0026gt;3000; 内连接JOIN子句\nSELECT 字段\nFROM A表 a\nJOIN B表\nON a.xx=b.xx(连接条件)\nJOIN C表 c\nON c.xxx=b.xxx或c.xxx=a.xxx;\nJOIN\u0026hellip;ON\u0026hellip;\nSELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e JOIN dept d on e.dept_id=d.id; 在内连接中，过滤条件还是写在WHERE子句中 SELECT e.*,d.loc FROM emp e JOIN dept d ON e.dept_id = d.id WHERE e.sal\u0026gt;1300; 在关联查询中不满足连接条件的记录会被排除在外 SELECT * FROM emp; INSERT INTO emp(name,dept_id) VALUES (\u0026#39;灭霸\u0026#39;,5); SELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e JOIN dept d ON e.dept_id = d.id 如果需要在结果集中列出不满足连接条件的记录时我们需要使用外连接 外连接: 左外连接: 以LEFT JOIN左侧表为主表，其中的记录都要展示，不满足连接条件时来自左侧记录的字段值全部为NULL 右外连接: 以RIGHT JOIN右侧表为主表，其中的记录都要展示，不满足连接条件时来自左侧记录的字段值全部为NULL\nSELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e LEFT JOIN dept d #此为主表，展示所有，不满足的为NULL ON e.dept_id = d.id; SELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM dept d RIGHT JOIN emp e ON d.id = e.dept_id 全连接效果，结果集包含满足连接条件的左连接和有连接的所有数据\nSELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e LEFT JOIN dept d #此为主表，展示所有，不满足的为NULL ON e.dept_id = d.id; UNION SELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e RIGHT JOIN dept d ON d.id = e.dept_id; SELECT e.*,d.* FROM emp e JOIN dept d on d.id = e.dept_id WHERE sal\u0026gt;(SELECT AVG(sal) FROM emp WHERE e.dept_id); 查看比本部门平均工资高的员工工资 1.查看每个部门的平均工资\navg_sal SELECT AVG(sal) avg_sal,dept_id FROM emp GROUP BY dept_id; 2.将子查询结果当做表进行关联\nSELECT e.name,e.sal,e.dept_id,a.avg_sal FROM emp e,(SELECT AVG(sal) avg_sal,dept_id FROM emp GROUP BY dept_id) a WHERE e.dept_id=a.dept_id AND e.sal\u0026gt;a.avg_sal; SELECT * FROM dept d,emp e WHERE d.id=e.dept_id; 1.查看每个地区的平均工资\nSELECT AVG(e.sal) avg_sal,d.loc FROM emp e JOIN dept d ON d.id = e.dept_id GROUP BY d.loc; SELECT e.name,e.sal,e.dept_id,a.avg_sal,d.loc,d.id FROM emp e, (SELECT AVG(e.sal) avg_sal,d.loc FROM emp e JOIN dept d ON d.id = e.dept_id GROUP BY d.loc) a,dept d WHERE a.loc=d.loc AND d.id=e.dept_id AND e.sal\u0026gt;a.avg_sal; 1.查看每个员工的工资及其所在的地区\nSELECT e.sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id; 2.每个地区平均工资（按照loc字段分组）\nSELECT AVG(e.sal) avg_sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id GROUP BY d.loc; 3.关联三张表查询:员工表-部门表-（第二步子查询的结果作为表）\nSELECT e.name,e.sal,a.avg_sal,d.loc FROM emp e,dept d,(SELECT AVG(e.sal) avg_sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id GROUP BY d.loc) a WHERE e.dept_id=d.id AND d.loc=a.loc AND e.sal\u0026gt;a.avg_sal; 内连接写法\nSELECT e.name,e.sal,a.avg_sal,d.loc FROM emp e JOIN dept d ON e.dept_id=d.id JOIN (SELECT AVG(e.sal) avg_sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id GROUP BY d.loc) a ON d.loc=a.loc WHERE e.sal\u0026gt;a.avg_sal; 查看每个地区的最高工资是谁\n查看最高工资\nSELECT MAX(sal) FROM emp SELECT MAX(sal),loc,e.name FROM emp e JOIN dept d ON e.dept_id = d.id # 将部门关联起来 GROUP BY loc; # 按地区分组 内连接 自连接的设计是为了保存同样的一组数字卡的数据，之间又存在上下级关系时（树状结构数据）\n查看每个员工和他的领导是谁\nSELECT e.name,m.name FROM emp e,emp m WHERE e.manager=m.id SELECT e.name,m.name FROM emp e JOIN emp m ON e.manager=m.id; 查看刘备的手下\nSELECT * FROM emp; SELECT e.name name,m.name manager FROM emp e JOIN emp m ON e.manager=m.id WHERE m.name=\u0026#39;刘备\u0026#39;; 查看孙悟空的领导\nSELECT e.name name,m.name manager,m.sal FROM emp e JOIN emp m ON e.manager=m.id WHERE e.name=\u0026#39;孙悟空\u0026#39;; SELECT name,sal FROM emp WHERE sal\u0026gt;(SELECT m.sal FROM emp e JOIN emp m ON e.manager=m.id WHERE e.name=\u0026#39;孙悟空\u0026#39;); CREATE TABLE userinfo( id INT primary key auto_increment, username VARCHAR(30) NOT NULL , password VARCHAR(30), age INT(3), salary DOUBLE(7,2) ); DROP TABLE userinfo; DESC userinfo; CREATE TABLE Student( id INT primary key auto_increment, name VARCHAR(32), age INT(3), class_id INT(3) ); CREATE TABLE Class( id INT primary key auto_increment, name VARCHAR(32) ); DESC Student; DESC class; DROP TABLE student; DROP TABLE class; SELECT * FROM class; 练习\n查询工资大于等于3000的员工姓名和工资 SELECT name,sal FROM emp WHERE sal\u0026gt;=3000;\n查询1号部门的员工姓名和工作 SELECT name,job FROM emp WHERE dept_id=1;\n查询不是程序员的员工姓名和工作(两种写法) SELECT name,job FROM emp WHERE NOT IN \u0026lsquo;程序员\u0026rsquo; ;\nSELECT name,job FROM emp WHERE job\u0026lt;\u0026gt;\u0026lsquo;程序员\u0026rsquo;\n查询奖金等于300的员工姓名,工资和工作 SELECT name,sal,job FROM emp WHERE comm=300;\n查询1号部门工资大于2000的员工信息 SELECT * FROM emp WHERE sal\u0026gt;2000 AND dept_id=1\n查询3号部门或工资等于5000的员工信息 SELECT * FROM emp WHERE dept_id=3 OR sal=5000\n查询出CEO和项目经理的名字 SELECT name FROM emp WHERE job=\u0026lsquo;CEO\u0026rsquo; OR job=\u0026lsquo;项目经理\u0026rsquo;\n查询工资为3000,1500和5000的员工信息 SELECT * FROM emp WHERE sal IN (3000,1500,5000)\n查询工资不等于3000,1500和5000的员工信息 SELECT * FROM emp WHERE sal NOT IN (3000,1500,5000)\n查询工资在1000到2000之间的员工信息 SELECT * FROM emp WHERE sal\u0026gt;1000 AND sal\u0026lt;2000\n查询工资在1000到2000以外的员工信息 SELECT * FROM emp WHERE sal\u0026lt;1000 OR sal\u0026gt;2000\n查询有领导的员工姓名和领导id SELECT name,manager FROM emp WHERE manager IS NOT NULL\n查询没有领导的员工姓名和领导id SELECT name ,manager FROM emp WHERE manager IS NULL\n查询员工表中出现了哪几种不同的工作 SELECT job FROM emp GROUP BY job\n查询员工表中出现了那几个部门的id SELECT dept_id FROM emp GROUP BY dept_id\n查询姓孙的员工姓名 SELECT name FROM emp WHERE name LIKE \u0026lsquo;孙%\u0026rsquo;\n查询名字最后一个字是精的员工信息 SELECT * FROM emp WHERE name LIKE \u0026lsquo;%精\u0026rsquo;\n查询工作中包含销售的员工信息 \bSELECT * FROM emp WHERE job LIKE \u0026lsquo;%销售%\u0026rsquo;\n查询工作中第二个字是售的员工信息 SELECT * FROM emp WHERE job LIKE \u0026lsquo;_售%\u0026rsquo;\n查询名字中包含僧的员工并且工资高于2000的员工信息 SELECT * FROM emp WHERE name LIKE \u0026lsquo;%僧%\u0026rsquo; AND sal\u0026gt;2000\n查询1号和2号部门中工作以市开头的员工信息 SELECT * FROM emp WHERE name LIKE \u0026lsquo;市%\u0026rsquo; AND dept_id IN (1,2)\n查询所有员工的姓名和工资 按照工资升序排序 SELECT name,sal FROM emp ORDER BY sal;\n查询所有员工的姓名和工资 按照工资降序排序 SELECT name,sal FROM emp ORDER BY sal DESC;\n查询所有员工姓名 工资和部门id 按照部门id降序排序,如果部门id一致则按照工资升序排序 SELECT name,sal,dept_id FROM emp ORDER BY dept_id DESC,sal;\n查询员工表中3号部门工资高于1500的员工信息 SELECT * FROM emp WHERE dept_id=3 AND sal\u0026gt;1500\n查询2号部门员工或者没有领导的员工信息 SELECt * FROM emp WHERE dept_id=2 OR manager IS NULL;\n查询有领导的员工姓名,工资按照工资降序排序 SELECT name,sal FROM emp WHERE manager IS NOT NULL ORDER BY sal DESC\n查询2号和3号部门的员工姓名和入职日期hiredate 按照入职日期降序排序 SELECT name,hiredate FROM emp WHERE dept_id IN (2,3) ORDER BY hiredate DESC\n查询名字中包含僧和包含精的员工姓名 SELECT name FROM emp WHERE name LIKE \u0026lsquo;%僧%\u0026lsquo;AND name LIKE\u0026rsquo;%精%\u0026rsquo;\n查询工资高于2000的工作有哪几种? SELECT job FROM emp WHERE sal\u0026gt;2000 GROUP BY job\n查询工资最高的前三个员工 SELECT *,MAX(sal) max_sal FROM emp ORDER BY sal LIMIT 0,3\n查询员工表按照id排序, 第2页的5条数据 SELECT * FROM emp ORDER BY id LIMIT 1,5\n查询员工表按照id排序, 第3页的4条数据 SELECt * FROM emp OEDER BY id LIMIT 2,4\n查询3号部门工资最低的员工姓名和工资 SELECT name,MIN(sal) FROM emp\n查询工作不是人事的员工中工资降序第二页的3条数据 SELECT * FROM emp WHERE job\u0026lt;\u0026gt;\u0026lsquo;人事\u0026rsquo; ORDER BY sal LIMIT 1,3\n查询没有领导的员工和3号部门的员工,工资降序取前三条 SELECT * FROM emp WHERE manager IS NULL AND dept_id=3 ORDER BY sal DESC LIMIT 0,3\n查询2号部门的最高工资 SELECT MAX(sla) FROM emp WHERE dept_id=2\n查询有领导的员工中工资在1000到2000之间的人数\n查询3号部门的工资总和\n查询程序员和销售的总人数\n查询1号部门有领导的员工的平均工资\n查询1号部门的最低工资和最高工资\n查询和销售相关的工作人数\n查询工资不是1500和3000的员工人数\n查询1号部门出现了哪几种工作\n查询名字包含精的员工数量\n查询和销售相关的工作一个月工资总和\n查询2号部门的最高工资和最低工资起别名\n查询每个部门的平均工资\n查询每种工作的平均工资\n查询每个部门的最高工资\n查询每种工作的最低工资\n查询每个部门工资高于2000的人数\n查询每个部门有领导的员工人数\n查询1号部门每种工作的最低工资\n查询平均工资最高的部门id和平均工资\n查询每个部门的平均工资,要求平均工资大于2000\n查询每种工作的人数,只查询人数大于1的\n查询每个部门的工资总和,只查询有领导的员工, 并且要求工资总和大于5400.\n查询每个部门的平均工资, 只查询工资在1000到3000之间的,并且过滤掉平均工资低于2000的\n/* SQLyog Ultimate v12.09 (64 bit) MySQL - 5.5.68-MariaDB : Database - newdb3\n*/\n/*!40101 SET NAMES utf8 */;\n/!40101 SET SQL_MODE=\u0026rsquo;\u0026rsquo;/;\n/!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 /; /!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 /; /!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=\u0026lsquo;NO_AUTO_VALUE_ON_ZERO\u0026rsquo; /; /!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 /; CREATE DATABASE /!32312 IF NOT EXISTS/empdb /*!40100 DEFAULT CHARACTER SET utf8 */;\nUSE empdb;\n/*Table structure for table dept */\nDROP TABLE IF EXISTS dept;\nCREATE TABLE dept ( id int(4) NOT NULL AUTO_INCREMENT, name varchar(14) NOT NULL, loc varchar(13) DEFAULT NULL, PRIMARY KEY (id), UNIQUE KEY DNAME (name) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n/*Data for the table dept */\ninsert into dept(id,name,loc) values (1,\u0026lsquo;神仙\u0026rsquo;,\u0026lsquo;天庭\u0026rsquo;),(2,\u0026lsquo;妖怪\u0026rsquo;,\u0026lsquo;盘丝洞\u0026rsquo;),(3,\u0026lsquo;普通人\u0026rsquo;,\u0026lsquo;北京\u0026rsquo;),(4,\u0026lsquo;赛亚人\u0026rsquo;,\u0026lsquo;外星球\u0026rsquo;);\n/*Table structure for table emp */\nDROP TABLE IF EXISTS emp;\nCREATE TABLE emp ( id int(4) NOT NULL AUTO_INCREMENT, name varchar(10) NOT NULL, job varchar(9) DEFAULT NULL, manager int(4) DEFAULT NULL, hiredate date DEFAULT NULL, sal double(7,2) DEFAULT NULL, comm double(7,2) DEFAULT NULL, dept_id int(4) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;\n/*Data for the table emp */\ninsert into emp(id,name,job,manager,hiredate,sal,comm,dept_id) values (1,\u0026lsquo;孙悟空\u0026rsquo;,\u0026lsquo;销售\u0026rsquo;,4,\u0026lsquo;1980-12-17\u0026rsquo;,800.00,NULL,1),(2,\u0026lsquo;猪八戒\u0026rsquo;,\u0026lsquo;销售\u0026rsquo;,4,\u0026lsquo;1981-02-20\u0026rsquo;,1600.00,300.00,1),(3,\u0026lsquo;沙僧\u0026rsquo;,\u0026lsquo;销售\u0026rsquo;,4,\u0026lsquo;1981-02-22\u0026rsquo;,1250.00,500.00,1),(4,\u0026lsquo;唐僧\u0026rsquo;,\u0026lsquo;销售经理\u0026rsquo;,8,\u0026lsquo;1981-04-02\u0026rsquo;,2975.00,NULL,1),(5,\u0026lsquo;刘备\u0026rsquo;,\u0026lsquo;项目经理\u0026rsquo;,NULL,\u0026lsquo;1981-09-28\u0026rsquo;,1250.00,1400.00,3),(6,\u0026lsquo;关羽\u0026rsquo;,\u0026lsquo;程序员\u0026rsquo;,5,\u0026lsquo;1981-05-01\u0026rsquo;,2850.00,NULL,3),(7,\u0026lsquo;张飞\u0026rsquo;,\u0026lsquo;程序员\u0026rsquo;,5,\u0026lsquo;1981-06-09\u0026rsquo;,2450.00,NULL,3),(8,\u0026lsquo;观音\u0026rsquo;,\u0026lsquo;CEO\u0026rsquo;,NULL,\u0026lsquo;1981-11-17\u0026rsquo;,5000.00,NULL,1),(9,\u0026lsquo;白骨精\u0026rsquo;,\u0026lsquo;人事\u0026rsquo;,8,\u0026lsquo;1981-09-08\u0026rsquo;,1500.00,0.00,2),(10,\u0026lsquo;蜘蛛精\u0026rsquo;,\u0026lsquo;人事\u0026rsquo;,8,\u0026lsquo;1981-12-03\u0026rsquo;,950.00,NULL,2),(11,\u0026lsquo;黑熊怪\u0026rsquo;,\u0026lsquo;市场\u0026rsquo;,8,\u0026lsquo;1981-12-03\u0026rsquo;,3000.00,NULL,2);\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE /; /!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS /; /!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS /; /!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; set names UTF8;\n","date":"2024-04-29","tags":["编程","sql"],"title":"SQL 教程","url":"/post/2024/04/sql/"},{"content":" 以下是我回忆的, 所以没有截图教程\n报税网址 四川省电子税务局 这个主要是企业报税用的\nhttps://etax.sichuan.chinatax.gov.cn/loginb/ ↗ 自然人电子税务局 这个主要是给法人报税用的\nhttps://etax.chinatax.gov.cn ↗ 关于注销 税务申报方面需要仔细一点, 然后就是一些文件里面的项, 我啥也不懂, 就没有改, 发现需要再缴 500, 不知道是什么, 就缴了,\n去注销企业的时候遇到的一些问题:\n我使用的是 \u0026ldquo;简易注销\u0026rdquo;, 这个比较方便, 是一站式的, 办理完后需要等待 20 天的公示期,公示期结束后继续办理注销流程\n登录 \u0026ldquo;四川省电子税务局\u0026rdquo; 在右上角的输入框中输入 \u0026ldquo;清税\u0026rdquo;, 选择 \u0026ldquo;清税申报\u0026rdquo;, 如果进不去提示等级低类似的字样,去窗口办理一下身份认证就行, 重新登录一下\n这时候系统会检查你是否符合条件, 不符合条件的项目会显示出来, 按照应有的内容提交上去就行,\n然后就是把文件打印出来, 到人工窗口办理注销就行, 这个流程还是比较简单的\n等注销的短信发到手机上之后就可以去注销社保和银行账户这些了\n","date":"2024-04-29","tags":["办公"],"title":"报税记账","url":"/post/2024/04/compent/"},{"content":" 我使用的是 Mac，所以以下都是 Mac 的说明\n一、前端（ts、react） 前端配置：TypeScript、React 依赖项：axios、codemirror、react-codemirror2\n1. 初始化模板 任意选一个就行\n1.1 交互式 npm init vite 可能需要先安装 npm install vite --save-dev\ncaoyang@cccy del % npm init vite # 使用 上下键 选择 ✔ Project name: … playground # playground 是项目名称，它会创建一个该名称的文件夹作为项目根目录 ✔ Select a framework: › React # 使用 React 库 ✔ Select a variant: › TypeScript # 使用 TS 语言开发 Scaffolding project in /Users/caoyang/Documents/Aptos/del/playground... Done. Now run: # 需要先运行以下代码 cd playground npm install npm run dev 1.2 一键创建 npm init vite playground -- --template react-ts 或者\nnpx create-vite playground --template react-ts 或者\nnpm init @vitejs/app playground -- --template react-ts {bs-accord style=line title=解析} npm init vite : 是一个 npm 初始化命令，它使用了 Vite 工具， my-react-ts-app : 是您希望创建的项目的名称。 -- : 是用来分隔 npm 命令行选项和参数的， --template react-ts : 是向 Vite 提供的选项，它告诉 Vite 使用 React TypeScript 模板来生成项目。 {/bs-accord}\n2. 安装并运行模板 # 需要先运行以下代码 cd playground npm install npm run dev caoyang@cccy playground % npm install added 218 packages, and audited 219 packages in 59s 41 packages are looking for funding run `npm fund` for details found 0 vulnerabilities 在 vscode 中打开，并编辑\n3. 删除不需要的文件 建议删除，否则可能出现非预期的情况\npublic / vite.svg src / App.css src / index.css 删除 App.tsx 和 main.tsx 中的导入 4. 创建 playground.tsx 组件 安装依赖项\nnpm install axios codemirror react-codemirror2 # 或者 npm install axios codemirror react-codemirror2 --legacy-peer-deps # 或者 npm install axios@1.6.8 codemirror@5.65.16 react@18.2.0 react-codemirror2@7.3.0 react-dom@18.2.0 import React, { useState } from \u0026#39;react\u0026#39;; import { Controlled as CodeMirror } from \u0026#39;react-codemirror2\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import \u0026#39;codemirror/lib/codemirror.css\u0026#39;; import \u0026#39;codemirror/theme/material.css\u0026#39;; import \u0026#39;./move.js\u0026#39;; // 导入 move.js 文件 const Playground: React.FC = () =\u0026gt; { const [code, setCode] = useState(\u0026#39;\u0026#39;); const [output, setOutput] = useState(\u0026#39;\u0026#39;); const handleCodeChange = (editor: any, data: any, value: string) =\u0026gt; { setCode(value); }; const executeCode = async () =\u0026gt; { try { // 发送 Move 代码到后端服务 const response = await axios.post(\u0026#39;http://127.0.0.1:8081/run_move\u0026#39;, code); setOutput(response.data); } catch (error) { console.error(\u0026#39;执行 Move 代码时出错:\u0026#39;, error); } }; return ( \u0026lt;div\u0026gt; \u0026lt;CodeMirror value={code} options={{ mode: \u0026#39;move\u0026#39;, // 使用 move 模式 theme: \u0026#39;material\u0026#39;, lineNumbers: true, }} onBeforeChange={(editor, data, value) =\u0026gt; { setCode(value); }} onChange={handleCodeChange} /\u0026gt; \u0026lt;button onClick={executeCode}\u0026gt;执行\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;执行结果:\u0026lt;/h3\u0026gt; \u0026lt;pre\u0026gt;{output}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Playground; 5. 修改main.tsx import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; import App from \u0026#39;./App.tsx\u0026#39; ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)!).render( // \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt;, ) 6. 修改App.tsx import { useState } from \u0026#39;react\u0026#39; import Playground from \u0026#39;./playground\u0026#39; function App() { const [count, setCount] = useState(0) return ( \u0026lt;\u0026gt; \u0026lt;Playground /\u0026gt; \u0026lt;/\u0026gt; ) } export default App 7. 创建语法高亮 move.js 这部分没有完全适配，只是一个 rust 模板。\nimport CodeMirror from \u0026#39;codemirror\u0026#39;; CodeMirror.defineMode(\u0026#34;move\u0026#34;, function (config, parserConfig) { var indentUnit = config.indentUnit, statementIndentUnit = parserConfig.statementIndentUnit || indentUnit, dontAlignCalls = parserConfig.dontAlignCalls, keywords = parserConfig.keywords || {}, builtin = parserConfig.builtin || {}, blockKeywords = parserConfig.blockKeywords || {}, atoms = parserConfig.atoms || {}, hooks = parserConfig.hooks || {}, multiLineStrings = parserConfig.multiLineStrings; var isOperatorChar = /[\u0026#43;\\-*\u0026amp;%=\u0026lt;\u0026gt;!?|\\/]/; var curPunc; function tokenBase(stream, state) { var ch = stream.next(); if (hooks[ch]) { var result = hooks[ch](stream, state); if (result !== false) return result; } if (ch == \u0026#39;\u0026#34;\u0026#39; || ch == \u0026#34;\u0026#39;\u0026#34;) { state.tokenize = tokenString(ch); return state.tokenize(stream, state); } if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) { curPunc = ch; return null; } if (/\\d/.test(ch)) { stream.eatWhile(/[\\w\\.]/); return \u0026#34;number\u0026#34;; } if (ch == \u0026#34;/\u0026#34;) { if (stream.eat(\u0026#34;*\u0026#34;)) { state.tokenize = tokenComment; return tokenComment(stream, state); } if (stream.eat(\u0026#34;/\u0026#34;)) { stream.skipToEnd(); return \u0026#34;comment\u0026#34;; } } if (isOperatorChar.test(ch)) { stream.eatWhile(isOperatorChar); return \u0026#34;operator\u0026#34;; } stream.eatWhile(/[\\w\\$_]/); var cur = stream.current(); if (keywords.propertyIsEnumerable(cur)) { if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \u0026#34;newstatement\u0026#34;; return \u0026#34;keyword\u0026#34;; } if (builtin.propertyIsEnumerable(cur)) { if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \u0026#34;newstatement\u0026#34;; return \u0026#34;builtin\u0026#34;; } if (atoms.propertyIsEnumerable(cur)) return \u0026#34;atom\u0026#34;; return \u0026#34;variable\u0026#34;; } function tokenString(quote) { return function (stream, state) { var escaped = false, next, end = false; while ((next = stream.next()) != null) { if (next == quote \u0026amp;\u0026amp; !escaped) { end = true; break; } escaped = !escaped \u0026amp;\u0026amp; next == \u0026#34;\\\\\u0026#34;; } if (end || !(escaped || multiLineStrings)) state.tokenize = null; return \u0026#34;string\u0026#34;; }; } function tokenComment(stream, state) { var maybeEnd = false, ch; while (ch = stream.next()) { if (ch == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; maybeEnd) { state.tokenize = null; break; } maybeEnd = (ch == \u0026#34;*\u0026#34;); } return \u0026#34;comment\u0026#34;; } function Context(indented, column, type, align, prev) { this.indented = indented; this.column = column; this.type = type; this.align = align; this.prev = prev; } function pushContext(state, col, type) { var indent = state.indented; if (state.context \u0026amp;\u0026amp; state.context.type == \u0026#34;statement\u0026#34;) indent = state.context.indented; return state.context = new Context(indent, col, type, null, state.context); } function popContext(state) { var t = state.context.type; if (t == \u0026#34;)\u0026#34; || t == \u0026#34;]\u0026#34; || t == \u0026#34;}\u0026#34;) state.indented = state.context.indented; return state.context = state.context.prev; } // Interface return { startState: function (basecolumn) { return { tokenize: null, context: new Context((basecolumn || 0) - indentUnit, 0, \u0026#34;top\u0026#34;, false), indented: 0, startOfLine: true }; }, token: function (stream, state) { var ctx = state.context; if (stream.sol()) { if (ctx.align == null) ctx.align = false; state.indented = stream.indentation(); state.startOfLine = true; } if (stream.eatSpace()) return null; curPunc = null; var style = (state.tokenize || tokenBase)(stream, state); if (style == \u0026#34;comment\u0026#34; || style == \u0026#34;meta\u0026#34;) return style; if (ctx.align == null) ctx.align = true; if ((curPunc == \u0026#34;;\u0026#34; || curPunc == \u0026#34;:\u0026#34; || curPunc == \u0026#34;,\u0026#34;) \u0026amp;\u0026amp; ctx.type == \u0026#34;statement\u0026#34;) popContext(state); else if (curPunc == \u0026#34;{\u0026#34;) pushContext(state, stream.column(), \u0026#34;}\u0026#34;); else if (curPunc == \u0026#34;[\u0026#34;) pushContext(state, stream.column(), \u0026#34;]\u0026#34;); else if (curPunc == \u0026#34;(\u0026#34;) pushContext(state, stream.column(), \u0026#34;)\u0026#34;); else if (curPunc == \u0026#34;}\u0026#34;) { while (ctx.type == \u0026#34;statement\u0026#34;) ctx = popContext(state); if (ctx.type == \u0026#34;}\u0026#34;) ctx = popContext(state); while (ctx.type == \u0026#34;statement\u0026#34;) ctx = popContext(state); } else if (curPunc == ctx.type) popContext(state); else if (((ctx.type == \u0026#34;}\u0026#34; || ctx.type == \u0026#34;top\u0026#34;) \u0026amp;\u0026amp; curPunc != \u0026#39;;\u0026#39;) || (ctx.type == \u0026#34;statement\u0026#34; \u0026amp;\u0026amp; curPunc == \u0026#34;newstatement\u0026#34;)) pushContext(state, stream.column(), \u0026#34;statement\u0026#34;); state.startOfLine = false; return style; }, indent: function (state, textAfter) { if (state.tokenize != tokenBase \u0026amp;\u0026amp; state.tokenize != null) return CodeMirror.Pass; var ctx = state.context, firstChar = textAfter \u0026amp;\u0026amp; textAfter.charAt(0); if (ctx.type == \u0026#34;statement\u0026#34; \u0026amp;\u0026amp; firstChar == \u0026#34;}\u0026#34;) ctx = ctx.prev; var closing = firstChar == ctx.type; if (ctx.type == \u0026#34;statement\u0026#34;) return ctx.indented \u0026#43; (firstChar == \u0026#34;{\u0026#34; ? 0 : statementIndentUnit); else if (ctx.align \u0026amp;\u0026amp; (!dontAlignCalls || ctx.type != \u0026#34;)\u0026#34;)) return ctx.column \u0026#43; (closing ? 0 : 1); else if (ctx.type == \u0026#34;)\u0026#34; \u0026amp;\u0026amp; !closing) return ctx.indented \u0026#43; statementIndentUnit; else return ctx.indented \u0026#43; (closing ? 0 : indentUnit); }, electricChars: \u0026#34;{}\u0026#34;, blockCommentStart: \u0026#34;/*\u0026#34;, blockCommentEnd: \u0026#34;*/\u0026#34;, lineComment: \u0026#34;//\u0026#34;, fold: \u0026#34;brace\u0026#34; }; }); (function () { function words(str) { var obj = {}, words = str.split(\u0026#34; \u0026#34;); for (var i = 0; i \u0026lt; words.length; \u0026#43;\u0026#43;i) obj[words[i]] = true; return obj; } var rustKeywords = \u0026#34;abstract async await become box break const continue crate do dyn else enum extern false fn for if impl in let loop macro match mod move mut pub ref return self Self static struct super trait true type union unsafe use where while yield\u0026#34;; function rustHook(stream, state) { if (!state.startOfLine) return false; for (; ;) { if (stream.skipTo(\u0026#34;\\\\\u0026#34;)) { stream.next(); if (stream.eol()) { state.tokenize = rustHook; break; } } else { stream.skipToEnd(); state.tokenize = null; break; } } return \u0026#34;meta\u0026#34;; } // Rust-style strings where \u0026#34;\u0026#34; escapes a quote. function tokenAtString(stream, state) { var next; while ((next = stream.next()) != null) { if (next == \u0026#39;\u0026#34;\u0026#39; \u0026amp;\u0026amp; !stream.eat(\u0026#39;\u0026#34;\u0026#39;)) { state.tokenize = null; break; } } return \u0026#34;string\u0026#34;; } function mimes(ms, mode) { for (var i = 0; i \u0026lt; ms.length; \u0026#43;\u0026#43;i) CodeMirror.defineMIME(ms[i], mode); } mimes([\u0026#34;text/x-rustsrc\u0026#34;, \u0026#34;text/x-rust\u0026#34;], { name: \u0026#34;rust\u0026#34;, keywords: words(rustKeywords), blockKeywords: words(\u0026#34;enum struct\u0026#34;), atoms: words(\u0026#34;true false None Some\u0026#34;), hooks: { \u0026#34;#\u0026#34;: rustHook } }); }()); 8. 测试运行 npm run dev 访问页面\nVITE v5.2.8 ready in 177 ms ➜ Local: http://localhost:5173/ # 访问这个地址可以打开 ➜ Network: use --host to expose ➜ press h \u0026#43; enter to show help 如果无法运行 报错：\n[vite] Internal server error: Missing \u0026#34;./lib/codemirror.css\u0026#34; specifier in \u0026#34;codemirror\u0026#34; package 检查 paclage.json 中的 \u0026quot;codemirror\u0026quot;: \u0026quot;^5.65.16\u0026quot; 版本是否正确\n这时候点击 执行 会出错，因为还没写服务端\n二、服务端（rust） 1. 安装 Rust（安装 Rust 时会默认安装 Cargo） curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 按照提示操作，选择默认选项安装即可。\n2. Rust 环境 安装完成后，根据终端中的提示，运行以下命令将 Rust 工具链添加到您的 shell 环境中：\nsource $HOME/.cargo/env 3. 验证安装 在终端中运行以下命令来验证 Rust 和 Cargo 是否成功安装：\nrustc --version # 或者 rustc -V cargo --version # 或者 cargo -V 查看帮助\nrustc --help cargo --help cargo run --help cargo build --help 4. 创建 Rust 项目 在您选择的目录中，打开终端。\n创建一个新的 Rust 项目\ncargo new rust_move_server # rust_move_server 是项目的名称，它会创建一个该名称的文件夹作为项目根目录 {bs-accord style=line title=文件解析} Cargo.toml 是 Rust 项目的配置文件，类似于其他语言中的 package.json 或者 requirements.txt。它用来指定项目的元数据、依赖项以及构建配置等信息。您可以在 Cargo.toml 中指定项目的名称、版本号、作者信息等，同时也可以列出项目的依赖项和构建脚本。\nsrc 目录是 Rust 项目的源代码目录，其中包含了您编写的 Rust 源代码文件。通常情况下，Rust 项目的主要源代码文件会放在 src 目录下。您可以在 src 目录中创建 Rust 源代码文件（通常以 .rs 扩展名结尾），并在这些文件中编写 Rust 代码来实现项目的功能。\n初始的 src 目录内包含一个 main.rs 文件\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } {/bs-accord}\n5. 进入项目目录 cd rust_move_server 进入您新创建的项目目录。\n6. 构建项目 您新创建的项目目录内\ncargo build Cargo 将会自动下载和构建项目的依赖项，并生成可执行文件。\n7. 运行项目 构建完成后，您可以在项目目录中找到生成的可执行文件。\n执行项目\n./target/debug/your_project_name {bs-accord style=line title=构建同时运行}\ncargo run 用于构建并运行 Rust 项目的可执行文件。它实际上是 cargo build 和执行生成的可执行文件的组合操作。\n具体来说，cargo run 命令会执行以下操作：\n构建项目：如果项目尚未构建，cargo run 会首先执行与 cargo build 相同的操作，即编译 Rust 项目的源代码并生成可执行文件。如果项目已经构建过，它会跳过这一步，除非代码或依赖项发生了变化。\n运行可执行文件：一旦项目构建完成，cargo run 会自动在项目的 target/debug 目录中查找生成的可执行文件，并将其运行起来。如果项目是库项目而不是可执行文件项目，则 cargo run 不会执行任何操作，因为库项目没有可执行文件。\n传递参数：cargo run 命令可以接受额外的参数，并将它们传递给生成的可执行文件。这些参数可以在执行可执行文件时使用，例如指定程序的运行配置或传递运行时参数。 {/bs-accord}\n8. 写入 Rust 服务端代码 8.1 配置依赖项 Cargo.toml [package] name = \u0026#34;test_server\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] actix-web = \u0026#34;4.0\u0026#34; actix-cors = { version = \u0026#34;0.6.0-beta.10\u0026#34; } 8.2 写入Rust 代码 use actix_web::{web, App, HttpResponse, HttpServer, Responder}; use std::process::{Command, Stdio}; use std::fs; use std::path::Path; use std::str; use actix_cors::Cors; async fn compile_and_run_move(move_code: web::Bytes) -\u0026gt; impl Responder { println!(\u0026#34;Received Move code: {:?}\u0026#34;, move_code); // 创建临时文件目录 let tmp_dir = \u0026#34;/tmp\u0026#34;; if !Path::new(tmp_dir).exists() { fs::create_dir(tmp_dir).expect(\u0026#34;Failed to create temporary directory\u0026#34;); } // 将接收到的 Move 代码写入临时文件 let tmp_file = \u0026#34;/Users/caoyang/Documents/Aptos/ts_playground/move_code/sources/test.move\u0026#34;; fs::write(tmp_file, move_code).expect(\u0026#34;写入文件：Failed to write Move code to file\u0026#34;); // 编译 Move 代码 let compile_output = Command::new(\u0026#34;aptos\u0026#34;) .arg(\u0026#34;move\u0026#34;) .arg(\u0026#34;test\u0026#34;) .arg(\u0026#34;--package-dir\u0026#34;) .arg(\u0026#34;/Users/caoyang/Documents/Aptos/ts_playground/move_code\u0026#34;) .output() .expect(\u0026#34;Failed to execute aptos move test command\u0026#34;); if !compile_output.status.success() { let stderr = str::from_utf8(\u0026amp;compile_output.stderr).unwrap_or(\u0026#34;Error reading stderr\u0026#34;); return HttpResponse::InternalServerError().body(format!(\u0026#34;Move compilation failed: {}\u0026#34;, stderr)); } // 将运行结果作为响应返回给客户端 HttpResponse::Ok().body(String::from_utf8_lossy(\u0026amp;compile_output.stdout).to_string()) } #[actix_web::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { // 启动服务器 HttpServer::new(|| { App::new() // 添加CORS中间件 .wrap( Cors::permissive() // \u0026lt;- 使用 Cors::permissive() 替换 Cors::new() .allowed_origin(\u0026#34;http://localhost:5173\u0026#34;) ) // 定义路由 .route(\u0026#34;/run_move\u0026#34;, web::post().to(compile_and_run_move)) }) .bind(\u0026#34;127.0.0.1:8081\u0026#34;)? .run() .await } 9. 发送 post 请求进行测试 curl -X POST -d \u0026#39;module 0x12::test{ use std::debug::print; use std::string::utf8; #[test] fun test_server(){ print(\u0026amp;utf8(b\u0026#34;server is running\u0026#34;)); } }\u0026#39; http://127.0.0.1:8081/run_move Rust 部分完成 三、move 临时代码 这个目录主要是用于存储前端的代码，然后执行这段代码，将结果返回给前端\n先创建目录 mkdir move_code_tmp cd move_code_tmp 1. 初始化 Move 项目 aptos move init --name move_code 这个命令会在当前目录下初始化一个 move 项目，不会新创建项目， 根据提示输入内容，或者直接回车 创建的 Move.toml 包含了程序的配置信息\n返回结果\ncaoyang@cccy move_code_tmp % aptos move init --name move_code { \u0026#34;Result\u0026#34;: \u0026#34;Success\u0026#34; } 2. 初始化 aptos 账户 aptos init --network testnet 这个命令会在 .aptos 目录下创建一个 config.yaml 文件，这个文件包含了账户的所有信息\n返回结果\ncaoyang@cccy move_code_tmp % aptos init --network testnet Configuring for profile default Configuring for network Testnet Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)] No key given, generating key... Account 0x3846fb4052a41807816c58611911e913526e2370cd97a160025cc7dc670efeff doesn\u0026#39;t exist, creating it and funding it with 100000000 Octas Account 0x3846fb4052a41807816c58611911e913526e2370cd97a160025cc7dc670efeff funded successfully --- Aptos CLI is now set up for account 0x3846fb4052a41807816c58611911e913526e2370cd97a160025cc7dc670efeff as profile default! Run `aptos --help` for more information about commands { \u0026#34;Result\u0026#34;: \u0026#34;Success\u0026#34; } 3. 创建临时 Move 代码文件 temp.move 用于临时存储前端发送的 Move 代码，并执行代码\n3.1 输入一段 Move 代码 module 0x42::test{ use std::debug::print; use std::string::utf8; #[test] fun test_my(){ print(\u0026amp;utf8(b\u0026#34;server is running\u0026#34;)); } } 3.2 测试运行 aptos move test 返回的结果\ncaoyang@cccy move_code_tmp % aptos move test INCLUDING DEPENDENCY AptosFramework INCLUDING DEPENDENCY AptosStdlib INCLUDING DEPENDENCY MoveStdlib BUILDING move_code warning: unused alias ┌─ /Users/caoyang/Documents/Aptos/del/move_code_tmp/sources/temp.move:2:21 │ 2 │ use std::debug::print; │ ^^^^^ Unused \u0026#39;use\u0026#39; of alias \u0026#39;print\u0026#39;. Consider removing it # 这是正常的，因为未使用 warning: unused alias ┌─ /Users/caoyang/Documents/Aptos/del/move_code_tmp/sources/temp.move:3:21 │ 3 │ use std::string::utf8; │ ^^^^ Unused \u0026#39;use\u0026#39; of alias \u0026#39;utf8\u0026#39;. Consider removing it # 这是正常的，因为未使用 Running Move unit tests [debug] \u0026#34;server is running\u0026#34; # 输出了源码中预期的结果 [ PASS ] 0x42::test::test_my Test result: OK. Total tests: 1; passed: 1; failed: 0 { \u0026#34;Result\u0026#34;: \u0026#34;Success\u0026#34; } Move 部分完成 四、测试 输入以下代码后，点击 执行，等待一段时间后，可以看到执行结果区域有输出\nmodule 0x12::test{ use std::debug::print; use std::string::utf8; #[test] fun test_server(){ print(\u0026amp;utf8(b\u0026#34;server is running\u0026#34;)); } } 五、目录结构 tree -I \u0026#39;node_modules|build|target\u0026#39; ./ caoyang@cccy ts_playground % tree -I \u0026#39;node_modules|build|target\u0026#39; ./ ./ ├── move_code # move 程序代码 │ ├── Move.toml # 可以更换为国内源 │ ├── scripts │ ├── sources │ │ └── temp.move # move 临时代码 │ └── tests ├── playground │ ├── README.md │ ├── codemirror.d.ts │ ├── index.html │ ├── package-lock.json │ ├── package.json │ ├── public │ │ └── vite.svg # 这个可以删掉 │ ├── src │ │ ├── App.tsx # 取消严格模式，防止渲染两个输入框 │ │ ├── assets │ │ │ └── react.svg # 这个可以删掉 │ │ ├── main.tsx │ │ ├── move.js # 高亮语法 │ │ ├── playground.tsx # 文本编辑器 │ │ └── vite-env.d.ts │ ├── tsconfig.json │ ├── tsconfig.node.json │ └── vite.config.ts └── rust_move_server # rust 服务端，用于接受 post 请求，并返回 move 的执行结果 └── test_server ├── Cargo.lock ├── Cargo.toml # 需要配置依赖项 └── src └── main.rs # 服务端代码 附录 playground package.json { \u0026#34;name\u0026#34;: \u0026#34;playground\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;tsc \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;axios\u0026#34;: \u0026#34;^1.6.8\u0026#34;, \u0026#34;codemirror\u0026#34;: \u0026#34;^5.65.16\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^18.2.0\u0026#34;, \u0026#34;react-codemirror2\u0026#34;: \u0026#34;^7.3.0\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^18.2.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/codemirror\u0026#34;: \u0026#34;^5.60.15\u0026#34;, \u0026#34;@types/react\u0026#34;: \u0026#34;^18.2.66\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^18.2.22\u0026#34;, \u0026#34;@typescript-eslint/eslint-plugin\u0026#34;: \u0026#34;^7.2.0\u0026#34;, \u0026#34;@typescript-eslint/parser\u0026#34;: \u0026#34;^7.2.0\u0026#34;, \u0026#34;@vitejs/plugin-react\u0026#34;: \u0026#34;^4.2.1\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^8.57.0\u0026#34;, \u0026#34;eslint-plugin-react-hooks\u0026#34;: \u0026#34;^4.6.0\u0026#34;, \u0026#34;eslint-plugin-react-refresh\u0026#34;: \u0026#34;^0.4.6\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.2.2\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^5.2.0\u0026#34; } } rust Cargo.toml [package] name = \u0026#34;rust_move_server\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] actix-web = \u0026#34;4.0\u0026#34; actix-cors = { version = \u0026#34;0.6.0-beta.10\u0026#34; } move Move.toml [package] name = \u0026#34;move_code\u0026#34; version = \u0026#34;1.0.0\u0026#34; authors = [] [addresses] [dev-addresses] [dependencies.AptosFramework] git = \u0026#34;https://github.com/aptos-labs/aptos-core.git\u0026#34; rev = \u0026#34;mainnet\u0026#34; subdir = \u0026#34;aptos-move/framework/aptos-framework\u0026#34; [dev-dependencies] ","date":"2024-04-29","tags":["move"],"title":"创建一个远程编译环境","url":"/post/2024/04/a_code_env/"},{"content":"\n样机 https://bannermockup.com/ ↗ https://mockupplanet.com/ ↗ https://www.anthonyboyd.graphics/ ↗ https://www.pixeden.com/ ↗ https://www.ls.graphics ↗ 条件 登录 grapicpear\n插画 https://dotown.maeda-design-room.net/ ↗ https://www.opendoodles.com ↗ 设计师必备 50 款免费可商用图库网站：照片、插画、纹理一网打尽\n免费素材图像素材工具推荐 Angel Wang・2022-10-13 大家好，本周我为大家准备了超全面的免费可商用高清图库，可能是全网最全的总结，推荐的图库类型有：照片图库、博物馆艺术品图库、图片生成器、纹理图库、插画图库、图标库，总有一种你用得到！\n注：由于免费商用图库网站经营不易，会遇到被收购转成收费素材等情况，所以为了更稳妥一些，在商用前，建议大家先到原网站仔细检查清楚版权限制，避免不必要的纷争哦！\n01 照片图库 1、unsplash\n网址：https://unsplash.com/ 非常经典的免费可商用图库，不仅量多，还支持中文搜索。\n且这个图库有很多宝藏用户，比如你搜索「museum」或者「library」，就能找到不少博物馆和图书馆上传的各种艺术作品。\n当然，你也可以用这种方法搜索看看有没有各领域垂直用户，就能把你需要的图片类型一网打尽！\n2、gratisography\n网址：https://gratisography.com/ 这个图库的图片风格相对比较轻松、搞怪，有故事感。\n3、magdeleine\n网址：https://magdeleine.co/license/cc0/ 此图库并非全部图片都可商用，首页右侧的 「LICENSE」下有专门的CC0分类，是无限制使用，另一个分类需要注明出处，网站还能在搜索结果中可通过颜色进行二次筛选。\n4、foodiesfeed\n网址：https://www.foodiesfeed.com/ 这是专属于食物的免费图库，共有 1700 多张食物图片，每一张都色彩鲜艳，让人食欲大增！\n5、designerspics\n网址：http://www.designerspics.com/ designerspics 是设计师 Jeshu 所拍摄的照片合集网站，供所有人免费商用，在搜索框的下拉菜单中，有不少可选分类。\n6、freejpg\n网址：https://en.freejpg.com.ar/ freejpg 的图片风格非常「北欧风」，可以使用关键词+色彩组合搜索图片。\n7、stocksnap\n网址：https://stocksnap.io/ 分类十分齐全的高清图库网站，是多为摄影师联合建立的。\n8、freephotos\n网址：https://freephotos.cc/zh 不仅是一个高清图库，还提供简单的线上编辑功能。\n首页每天都会有一张精选图片推荐\n9、天空图片素材汇总\n网址：https://www.priga.jp/ 日本的图库网站，顾名思义收录了各式天空图，是很好的合成素材！\n10、pixabay\n网址：https://pixabay.com/zh/ 图库内含图片/插画/矢量/视频/音乐素材，素材量大，支持中文搜索。\n搜索框可选择搜索类型\n11、streetwill\n网址：http://streetwill.co/ streetwill 是一个旅游图片收录图库，多为各地街头巷尾景色。\n12、pexels\n网址：https://www.pexels.com/zh-cn/ 依旧是支持中文搜索，分类十分全面的图库，网站会总结一段时间内的热门搜索词供用户参考，图片提供者是全世界各地的摄影师们。\n13、splitshire\n网址：https://www.splitshire.com/ 很有质感的图库，每张照片都有一种大片既视感。\n02 博物馆艺术品资源库 除了常规的图库外，很多人不知道的是，不少博物馆官方也会设立免费可商用图库，各类名画、艺术品高清大图都能在各大博物馆图库中找到。\n1、芝加哥艺术馆\n网址：https://www.artic.edu/collection 芝加哥艺术馆开放了五万多张高清原图作品，只要点击首页左边的筛选器，勾选Public domain，就可以筛选出可免费商用的艺术作品。\n有神奈川冲浪、巴黎街、莫奈的睡莲、梵高自画像等等等等我们很熟悉的作品，点开喜欢的作品，不仅有详细的介绍，在右下角点击下载键，就可以直接拥有它的高清无码大图。\n2、美国大都会博物馆\n网址：https://www.metmuseum.org/art/the-collection 大都会博物馆是美国最大的艺术博物馆，和中国北京的故宫、英国伦敦的大英博物馆、法国巴黎的卢浮宫、俄罗斯圣彼得堡的艾尔米塔什博物馆并称为世界五大博物馆，这就足以见得它的藏品有多么丰富了！\n打开大都会博物馆的网站首页，点击搜索框按回车，点选搜索框下方的 Open Access，即可跳转到免费可商用素材页面，还能通过材质类别、地理位置、年代等等进行检索，值得一提的是免费可商用的图超过 3 万 7 千副。\n点开喜欢的作品，就可以浏览到详细信息，左下角可以听到在线讲解，而在作品的右下角，点击下载键，就可以查看到高清大图，右键保存就好了。\n3、史密斯协会\n网址：https://www.si.edu/openaccess 史密斯学会网站里收藏了包括非洲艺术博物馆、美国历史博物馆等19个博物馆，一共有300万个数字藏品可以免费下载和商用。\n首页向下滑，就可以看到所有的数字藏品，点开一张作品，会有明确的CC0标识，左下角直接点击下载键就能够拥有作品。\n史密斯学会的数字藏品最特别的是，它还拥有3D模型，还能在线查看！\n4、台北故宫\n网址：https://theme.npm.edu.tw/opendata/ 它是中华文化史上三大博物馆之一，收藏和保存了很多国宝，包括著名的翠玉白菜和毛公鼎，打开官网，首页就很直接了当地说网站「文物图像下载」和「精选图像下载」区共超过7万张图像，都是可以免费商用的。\n点开「精选图像下载」，一万六千多件有名气的各类文物，随便点开一张，不仅能看到详细的文字说明，还可以一键下载72分辨率的图片。\n首页点击「文物查询下载」，然后可以进一步选择器物资料还是书画资料，就能更精细地检索朝代、类别等。\n另外值得一提的是，台北故宫博物馆与时俱进，还上线了动森专区，里面都是在游戏里画出来的知名文物，比如翠玉白菜、肉形石、百骏图、宋仁宗朝服、中式纹样等。\n5、巴黎博物馆\n网址：https://www.parismuseescollections.paris.fr/fr 之前，巴黎博物馆协会网站也宣布对外开放10万张的馆藏作品的可供免费下载商用，这些作品是来自协会管理的14间巴黎博物馆，比如巴尔扎克博物馆、维克多雨果故居等等。\n在首页向下滑，就会看到一个CC0区域，一共有 34 万多张，点击查看更多作品，就可以看到所有的CC0画作。\n点进去后可以直接搜索或者通过博物馆、作者、画面元素、作品时间、甚至是颜色来筛选寻找图片，不过页面是法语，善用浏览器翻译。\n6、荷兰国立博物馆\n网址：https://www.rijksmuseum.nl/nl/rijksstudio 它是荷兰规模最大的博物馆，藏有史前至近现代的各种展品，馆内最为知名的收藏就是十七世纪荷兰画家伦勃朗的作品。\n向下翻，除了官方分类，还有很多网友自己收集的灵感版，比如花卉合集、肖像画合集等等。\n7、沃尔特斯艺术博物馆\n网址：https://art.thewalters.org/browse/medium/ 美国的沃尔特斯艺术馆的三万六千多件藏品都开放了免费商用，除了可以看到不少非常经典的日本版画，还有木乃伊、彩绘玻璃、各式珠宝首饰等等藏品。\n点开作品后左下角就可以看到版权标识，右边就是下载键。\n8、纽约公共图书馆\n网址：https://digitalcollections.nypl.org/ 纽约公共图书馆一共收藏了超过90万件数字藏品，首页向下就可以看到专门的公共领域作品。\n一共有18万张多，包括了很多早年间的城市海报、专辑封面、百老汇资料等等，还有不少近代设计师的创意手稿。\n03 图片生成器、AI 工具 除了保存有限图片的图库外，不少 AI 工具或者各类图片生成器也能作为图库使用，而且内容可以说取之不尽用之不竭！\n但需要注意的是，由于 AI 工具是抓取网络数据生成图片，虽说不少工具声明遵守 CC0 协议，但直接使用还是有风险，毕竟风格抄袭难以定义，建议还是作为参考使用，作为新玩意儿，大家还是可以尝尝鲜。\n1、Midjourney\n网址：https://www.midjourney.com/home/ 这是一个输入关键词就能生成图片的网站，理论来说无版权限制，生成的图谁都能用，生成的图简直照片、建模级别的精细。\n官网有个案例库，是用户生成的各种图，总得来说有点像是一个所有用户共创的 AI 图库。\n生成速度也非常快，几分钟就能生成一组图片，操作起来也很简单。\n2、disco diffusion\n网址：https://colab.research.google.com/github/alembics/disco-diffusion/blob/main/DiscoDiffusion.ipynb 和 Midjourney 一样，是个输入关键词就能生成图片的网站，但生成图更多是原画场景。\n相比 Midjourney 操作起来比较繁琐，大家可参考 b 站视频一步步操作。\n3、Waifu Diffusion\n网址：https://colab.research.google.com/drive/1_8wPN7dJO746QXsFnB09Uq2VGgSRFuYE#scrollTo=1HaCauSq546O 可以说是二次元版的 disco diffusion ，你能用它生成你的二次元角色！生成效果堪比画师手绘！\n操作方法参考下方视频，快来试试生成你的二次元「老婆」！\n4、artbreeder\n网址：https://www.artbreeder.com/ 严格来说，这是一个「捏脸」的在线网站，你可以按自己的喜好捏人脸，然后生成人物肖像画。\n使用起来十分简单，打开网站注册账号后，在首页随便点选一个你喜欢的画风，就能直接开捏。\n除了人物肖像外，网站内还挺捏动物、捏场景等服务，但相对来说技术还没那么成熟。\n调整参数的页面也很好上手，就和游戏里捏脸是差不多的。\n5、fffuel\n网址：https://fffuel.co/ 超级实用的生成器素材大礼包，内含34款功能各异的生成器工具，emoji、像素图案、手绘涂鸦、流体渐变…通通都有，简直不能再全了！\n只要点击主页相应生成器即可跳转页面。\n6、coolbackgrounds\n网址：https://coolbackgrounds.io/ 网站可随机生成 5 种类别的背景，自定义程度极高，交互还非常丝滑，值得一试，适合作为网页背景！\n7、pppalette v2\n网址：https://fffuel.co/pppalette/ 非常全面的配色生成器，选择一个主色就能一键生成几十种不同配色，还能根据混合模式选择相应配色。\n8、meshgradient\n网址：https://meshgradient.in/ meshgradient 是一个一键生成网格渐变背景工具，还支持自定义输出尺寸，渐变样式还特别多，能为你介绍不少制作渐变背景的时间！\n04 纹理图库 无论是作为 PPT 背景，还是作为设计素材，纹理都是不可或缺的，下面这几款纹理图库，你肯定能在工作中用到。\n1、百桨素材网\n网址：https://www.hituyu.com/ 一个很实用的国产纹理图库，优点是本地化做得非常好，分类特别多。\n很多中式特色的纹理都收录在其中。\n2、everypixel\n网址：https://www.everypixel.com/patterns everypixel 包含了数千种纹理图案，有可爱的卡通插画，也有极具现代感的几何拼贴。\n选择一个图案后，图库内会再推荐几个相似的风格供你选择，还可以点击进入编辑页面，在线调整元素在画面中的大小和密度、配色，图库内还有预设的色卡可以选择。\n3、heropatterns\n网址：https://heropatterns.com/ 图库的UI很简洁，主页有两个拾色器，分别是调整纹理和背景的颜色，还有一个滑块是调整纹理的透明度，设置之后，图库中所有的纹理都会保持这种设置，方便统一视觉筛选素材。\n当我们单独选择纹理后 也能对它进行单独的配色调整。\n4、transparenttextures\n网址：https://www.transparenttextures.com/ 此图库的特点是可以下载透明的纹理，进入网站后，左侧可以选择预览颜色和饱和度，不过这个颜色只做预览。\n我们选择纹理下载后，还是会下到一个四方连续的透明纹理素材，下载的格式基本上是PNG，但每个素材都可以在网页左侧复制到CSS代码。\n5、visiwig\n网址：https://www.visiwig.com/patterns 此纹理图库的自定义程度极高，只需要点击一个喜爱的风格示例进去，我们就可以调整纹样的大小、密度、颜色等等诸多选项。\n05 插画图库 1、Pixeltrue\n网址：https://www.pixeltrue.com/free-illustrations 该图库有 400+ 免费插图，风格多样，可以打包下载，也能单独下载，最主要的是还有动画素材。\n2、getillustrations\n网址：https://www.getillustrations.com/illustration-packs 图库内有收费也有免费的素材包下载，虽然是免费的但质量一点也不差！\n3、weareskribbl\n网址：https://weareskribbl.com/ 图库内含多种黑白手绘风格插画，而且每周都会更新。\n4、Open Peeps\n网址：https://www.openpeeps.com/ 这个图库插图风格更偏日系手绘涂鸦风，网站预设了很多人物造型，可直接下载单个 png 或者 svg 格式图片使用。\n你还可以把这些素材都下载下来，然后自由组合搭配。\n5、Open Doodles\n网址：https://www.opendoodles.com/ 同样是手绘风插画图库，设计师的个人风格很强烈，画风很有特色。\n6、Fresh Folk\n网址：https://fresh-folk.com/ 图库内置多样人物素材，还附带各种场景，画风相对偏写实一些。\n和 open peeps 一样可下载下来随意组合。\n7、retro Vectors\n网址：https://retrovectors.com/category/free-vectors 图库内含多种美式复古风插画，就像是旧海报上的插图一样，很有年代感，非常独特。\n8、icon8插画库\n网址：https://icons8.com/illustrations 图库内插画素材风格多样，商务、童趣、休闲，统统都有，涵盖多种日常使用场景。\n甚至还有 3D 的插图。\n9、任天堂像素画库\n网址：https://dotown.maeda-design-room.net/ 这个插画图库是由任天堂的前设计师前田高志发布，内含700+任天堂元素的像素画，从人物到动植物、街景到建筑，统统都有！\n10、Openillux\n网址：https://openillux.com/ 如果上面的插画图库你还觉得不够，那么这个插画图库合集网站一定能满足你的需求，它相当于插画图库检索页，收集了市面上大部分的免费可商用插画网站。\n06 图标库 1、icooon\n网址：https://icooon-mono.com 图库内含 6000+ 免费图标，包括了生活中方方面面的主题，如医疗、动物、建筑物、音乐、文具等等，是个很「生活化」的图标库。\n2、iconduck\n网址：https://iconduck.com 图标库内有19组风格多样的 icon 素材，数量丰富，即下即用，可以说非常方便！\n3、日本旅游图标库\n网址：https://experience-japan.info/en/ 顾名思义，整个图库的图标是和日本文化相关的，有日式建筑、传统、自然景观、食物等相关的图标。\n每个图标点进去还有文化背景解释，特别有意思。\n4、healthcons\n网址：https://healthicons.org 医疗主题图标库，囊括了各类医疗用品图标，现如今可以说非常实用了。\n5、Fluent Emoji\n网址：https://github.com/microsoft/fluentui-emoji 来自微软的开源图标库，这套表情包数量多达1500+，每个 emoji 都包含2D、3D、单色等四个版本，轻拟物的风格看起来质感满满\n以上，就是今天超级丰富的干货分享，存了这么多图库网站，必须要有一个图片、文件管理软件来整理下载到电脑中的素材，Eagle 绝对是你的首选！\n利用它的网页插件，你能在浏览图片时直接拖拽快捷保存。\n快速批量存图也不在话下！\n网页有存图限制也能利用快捷键一键统统存下来！\n海量文件储存在电脑中，Eagle 能自动按照色彩、文件格式为你的素材分类，妥善帮你保管你的图库，让你的文件管理更加高效、透明！\n马上复制链接至官网即可下载试用哟！\n网址：https://cn.eagle.cool/\n如果上面的神器你还觉得不够，不妨收藏 Eagle 官方推出的资源社区，我们会定时跟进各类设计干货！\n网址：https://community-cn.eagle.cool/\n","date":"2024-04-29","tags":["设计"],"title":"设计资料：样机","url":"/post/2024/04/design/"},{"content":"一、什么是SimHash SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。\n对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。 比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。\n二、局部性敏感哈希 说到hash可能我们第一个想到的是md5这种信息摘要算法，可能两篇文本只有一个标点符号的差距，但是两篇文本A和B的md5值差异就非常大，感兴趣的可以试验一下看看。\n有时候我们希望的是原本相同的文章做了微小改动之后的哈希值也是相似的，这种哈希算法称为局部敏感哈希LSH(Locality Sensitive Hashing)，这样我们就能从哈希值来推断相似的文章。\n局部敏感哈希算法使得在原来空间相似的样本集合，进行相关运算映射到特定范围空间时仍然是相似的，这样还不够，还需要保证原来不相似的哈希之后仍然极大概率不相似，这种双向保证才让LSH的应用成为可能。\n三、simhash的基本过程 SimHash算法主要有五个过程：分词、Hash、加权、合并、降维。\n1.分词（可以用一些分词工具来实现） 使用分词手段将文本分割成关键词的特征向量，分词方法有很多，我用了jieba分词来实现，你可以先去除停用词，当然也可以不去除，根据自己的需求选择，假设分割后的特征实词如下：\n12306 服务器 故障 车次 加载失败 购买 候补订单 支付 官方 消费者 建议 卸载 重装 切换网络 耐心 等 目前的词只是进行了分割，但是词与词含有的信息量是不一样的，比如12306 服务器 故障 这三个词就比 支付 卸载 重装更能表达文本的主旨含义，这也就是所谓信息熵的概念。 为此我们还需要设定特征词的权重，方法有很多，简单一点的可以使用TF-IDF来实现。\n2.Hash 前面我们使用分词方法和权重分配将文本就分割成若干个带权重的实词，比如权重使用1-5的数字表示，1最低5最高，这样我们就把原文本处理成如下的样式：\n12306(5) 服务器(4) 故障(4) 车次(4) 加载失败(3) 购买(2) 候补订单(4) 支付(2) 官方(2) 消费者(3) 建议(1) 卸载(3) 重装(3) 切换网络(2) 耐心(1) 等待(1) 然后，通过hash函数对每一个词向量进行映射，产生一个n位二进制串，一般常用的位数为32、64、128。\n3.加权 前面的计算我们已经得到了每个词向量的Hash串和该词向量对应的权重，这一步我们计算权重向量W=hash*weight。 具体的计算过程如下：hash二进制串中为1的，w = 1 * weight，二进制串中为0的，w = weight * -1. 举个例子，12306的带权重哈希值为 [5 -5 -5 5 5 5 -5 -5]，服务器的带权重哈希值为 [-4 4 4 4 -4 4 -4 4]\n4.合并 对于一个文本，我们计算出了文本分词之后每一个特征词的权重向量，在合并这个阶段，我们把文本所有词向量的权重向量相累加，得到一个新的权重向量，假定最终结果为 [18 9 -6 -9 22 -35 12 -5]\n5.降维 对于前面合并后得到的文本的权重向量，大于0的位置1，小于等于0的位置0，就可以得到该文本的SimHash值，以上面提到的 [18 9 -6 -9 22 -35 12 -5] 为例，我们得到 [1 1 0 0 1 0 1 0] 这个bit串，也就是论文中提及的该文本的指纹。 到此为止，我们已经计算出了一个文本的SimHash值。那么，如何判断两个文本是否相似呢？我们要用到海明距离。\n四、相似度判断 对于两个文本的SimHash的相似度判断，我们使用海明距离来计算。 什么是海明距离呢？ 简单的说，海明距离可以理解为，两个二进制串之间相同位置不同的个数。\n举个例子，[1，1，1，0，0，0]和[1，1，1，1，1，1]的海明距离就是3。\n在处理大规模数据的时候，我们一般使用64位的SimHash，正好可以被一个long型存储。这种时候，海明距离在3以内就可以认为两个文本是相似的。 五、大规模数据下的海明距离计算 我们在存储时将64bit simhash值均分为4份每份16bit长，然后使用每一份作为key，value是每一份simhash值对应的二进制向量： 当新来一个文本生成哈希值S\u0026rsquo;之后，按照相同的规则生成abcd四部分，之后逐个进行哈希对比，这个时间复杂度是O(1)： 如果abcd四个作为key都不存在，那么可以认为S\u0026rsquo;没有相似的文本； 如果abcd四个key中有命中，那么就开始遍历对应key的value，查看是否满足\u0026lt;=3的海明距离确定相似性；（一般64位编码的simhash值对应的海明距离阈值设为3） 如果上一个命中的key未找到相似文本，则继续遍历剩下的key，重复相同的过程，直至所有的key全部遍历完或者命中相似文本，则结束。 六、参考文献： https://blog.csdn.net/Daverain/article/details/80919418 ↗ https://cloud.tencent.com/developer/article/1189493 ↗ 文章二 本文要解决的是这样一个问题：\n有一段文本线索：\n“延安西路921号，进门左边第三棵树，有一个一百三十年前的\u0026hellip;\u0026hellip;”\n我想从一个亿级数据库里，把包含这段线索的相似文本都捞出来，找到它背后更多的故事。 这是一个相似匹配的问题（文本相似匹配基础→ 词频与余弦相似度）。但是，亿级数据库，用传统的相似度计算方法太慢了，我们需要一个文本查询方法，可以快速的把一段文本的相似文本查出来。\n在实际的文本处理工作中，不解决海量查询这一基本问题，耗时等待是非常可怕的。比如我们时常要对海量相似文本进行去重、或者对海量相似文本的聚类等。\n具体场景为：在搜索引擎中查询一段文本，10分钟后才能返回？对微博上某种近一周的文本进行聚类，要等1个月？（说到聚类，效果好一点的聚类方法如DBSCAN，时间复杂度很高，耗时是非常让人绝望的，这个后续还会介绍）。\n你会发现，很多时候，如果不先解决掉大规模相似文本的问题，后面很多高大上的分析、模型都做不了，这也是为什么我文本分析这个系列中，我先介绍“大规模文本处理”，而没有先介绍word2vec、LSTM等方法的原因。\n在前面的文章里（→哈希函数），我们介绍过一种叫哈希函数的东西，他可以把文本转换成一段哈希指纹。从而对文本进行量化降维。但是，我们希望转换之后，相似的文本还能保持相似，比如 “最美数说君”，hash之后是 12345，“最帅数说君”，hash之后是12346，还能保持差不多的相似。这个是最难的，满足这种特性的hash函数，叫做局部敏感性哈希（LSH）。\n本文要介绍的SimHash，就是其中的一种，谷歌就是用它来对海量文本进行去重。\n一、SimHash原理\n1、Simhash的使用\nSimahash方法最早由Moses Charikar在《similarity estimation techniques from rounding algorithms》一文中提出。SimHash是将一段文本hash成一串二进制的指纹（如0010110），然后配用海明距离进行两两文本的比较。海明距离，说白了就是看两段二进制指纹有多少不一样，具体可以看这里→ 常用距离/相似度 一览。流程如下图所示：\n一般来说，如果海明距离小于3，则认为这两个文本是相似文本。那么SimHash是如何计算的呢？\n2、Simhash 的计算 我们以 “Python is sexy” 为例，展示以下 一段文本的SimHash过程：\n先给一个总的流程图：\n（1）分词、给定权重 首先是分词，且给定每一个词的权重。\n这里我们采用四字母为单位来切词（我们把大小写归一化、空格去掉），权重统一为1：\n[Pyth：1, ytho：1, thon：1, honi：1, onis：1, niss：1, isse：1, ssex：1, sexy：1] （2）传统hash 把每一个词用传统方法hash成数字（即 hashcode），这里位数根据存储成本和数据集大小来选取，一般多选64位：\nPyth： 0010001010010001101111101000111010100011110110111010100010110011 ytho： 0001110111100111000110010001111000001001001111000110110100011000 ...... （3）加权 每一个分词的 hashcode 中，对应位上如果为1，则该位加上权重w，这里权重为1，即+1,；对应位上如果不为1，则该位减去权重w，这里即-1。\nPyth： -1 -1 2 -1 -1 -1 2 -1 2 -1 -1 2 -1 -1 -1 2 2 -1 2 2 2 2 2 -1 2 -1 -1 -1 2 2 2 -1 2 -1 2 -1 -1 -1 2 2 2 2 -1 2 2 -1 2 2 2 -1 2 -1 2 -1 -1 -1 2 -1 2 2 -1 -1 2 2 ytho： -1 -1 -1 2 2 2 -1 2 2 2 2 -1 -1 2 2 2 -1 -1 -1 2 2 -1 -1 2 -1 -1 -1 2 2 2 2 -1 -1 -1 -1 -1 2 -1 -1 2 -1 -1 2 2 2 2 -1 -1 -1 2 2 -1 2 2 -1 2 -1 -1 -1 2 2 -1 -1 -1 ...... （4）合并 现在每个分词都有64位的二进制表示，我们将每一位进行纵向累加，也就是将每个分词的第1位累加，得到总的第1位，每个分词的第2位累加，得到总的第2位，同理第3位、第4位\u0026hellip;\u0026hellip;第64位。最终得到了一个总的64位的二进制表示：\nPython is sexy： -5, -5, -1, 1, 3, -3, -1, -3, -5, -1, -1, 3, 1, -3, 1, -1, 3, -1, -3, 1, 1, -3, 3, -3, -1, 5, -1, 1, -3, 1, -7, 3, 5, -1, 3, -1, 1, 1, -3, -3, 1, -1, -1, -1, -1, 1, -1, 7, 3, 3, -3, -1, 3, 5, 1, 5, -1, -1, 3, 1, 5, 3, 1, -3 （5）0/1处理 对于64位的每一位，如果大于0，则赋值为1，否则为0：\nPython is sexy 的最终 simhash 二进制指纹：\n0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0 以上，就是一段文本的Simhash过程。它的好处是相似的两段文本，Simhash 之后的值仍然能保持相似，而且经过了降维，储存空间也大大减少，计算效率会提高很多。一般来说，两端simhash的海明距离如果在3以内，就认为是相似文本。\n你可能会问，为什么？为什么这种 Hash 方法可以让相似的文本仍然相似？Simhash的发明人 Charikar 的论文中并没有给出具体的证明，但由于 Simhash 是由随机超平面hash算法演变而来的，有人根据这个给出了证明，大家可以搜搜看。\n二、加速查询：抽屉原理 虽然 Simhash 可以减少单次计算的耗时，海量文本来说，匹配的计算量还是很大的。如果数据库里有几百亿数据，那就意味着要匹配几百亿次。因此，我们需要一种方法来减少匹配。\n对于两段文本，我们分别映射成64位hash指纹之后，再每个文本分为四份，每个部分16位。对于这两段文本，如果海明距离在3以内，则它们对应的4个部分，至少有一个部分是一样的。\n因为，海明距离小于3，意味着，最多有3个位点有区别，而3个差异位点分布在四个部分，至少有一个部分是没有相同的。\n这就好比把3个球放到4个抽屉里面，一定有一个抽屉是空的，所以叫“抽屉原理”。\n基于此，可以把一段64位指纹分成 K-V格式（Key-Value），K就是其中四个部分中的一个部分，V就是剩下3个部分。我们在匹配的时候，只要精确匹配K，K相同了，再去匹配V，这样可以大大减少计算量。\n但问题是，我怎么知道差异位点分布在哪一部分？\n所以，一段文本的Simhash指纹，我们需要复制成四次存储，以text1为例，simhash 成64位之后，我们分成四个部分，A1-A2-A3-A4。我们把这段存储四份，以使得每一部分都做一次K，剩下其他三个为V：\n① K: A1, V: A2-A3-A4 ② K: A2, V: A1-A3-A4 ③ K: A3, V: A1-A2-A4 ④ K: A4, V: A1-A2-A3 这样就可以保证不会有遗漏。\n那么，用这一套方法，最终能减少多少查询呢？给大家算一笔账：\n假设数据库中有 2^30 条数据，也就是差不多10亿条数据：\n如果不用抽屉原理，那么就得与10亿条数据一一查询，即10亿次。 使用了抽屉原理，即与16位的K先查询。 想象一下由0/1组成的16位数字，可能有多少？最多2^16种K（每一位有0/1两种可能，一共有16位，排列组合一下）； 2^30数据，一共2^16种K，那么每个K-V返回的最大数量也就2^(30-16)=16384个候选结果，4个K的话，总的结果也就16384*4=65536，约66W。 这样一来，原来需要比较10亿次，现在只需要比较66万即可。\n项目：去Github搜一下就有，可以找来看看，还是比较容易懂的。\n","date":"2024-04-29","tags":["编程","算法"],"title":"什么是 SimHash","url":"/post/2024/04/simhash/"},{"content":"\n原文一 ↗ 原文二 ↗ 视频 ↗ 一、什么是 JWT JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n二、设计目标 不需要服务器端存储状态，安全地传递非敏感信息\n三、 JSON Web Token 的结构是什么样的 JSON Web Token由三部分组成，例如dafdsafdwfefeqwad.oijhdaffweqtgfdhfdws.dhshfsghhhhhwfsdke\n简化：xxxxx.yyyyy.zzzzz\n可以看到它们之间用圆点(.)连接。\n而这三部分分别是：\nHeader 头部 Payload 载荷 Signature 签名 1. Header 由两部分组成：\ntoken的类型（“JWT”） 签名算法名称（比如：HMAC SHA256或者RSA等等） 例如：\n{ \u0026#39;alg\u0026#39;: \u0026#34;HS256\u0026#34;, \u0026#39;typ\u0026#39;: \u0026#34;JWT\u0026#34; } 然后，用 Base64 对这个 JSON 编码就得到JWT的第一部分\n2. Payload 标准声明：就是该开放标准预先定义的一些字段\n公共声明：是自定义的声明，用于特定应用程序中共享信息\n私有声明：用于在同意双方之间共享信息，通常不会被 JWT 规范定义，而是由应用程序自行定义和使用\n它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。\nRegistered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。 Public claims : 可以随意定义。 Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子： { \u0026#34;sub\u0026#34;: \u0026#39;1234567890\u0026#39;, \u0026#34;name\u0026#34;: \u0026#39;john\u0026#39;, \u0026#34;admin\u0026#34;:true } 对payload进行Base64编码就得到JWT的第二部分\n注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。\n3. Signature 为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。\n例如：\nHMACSHA256(secret, base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload))\nsecret 保存在服务端，用来进行 JWT 的签发和验证，所以在任何时候都不应该泄漏\nJWT 的签发生成也在服务端\nHMACSHA256 是一种对称加密算法\n对称加密算法：用一个密钥加密解密的算法\n非对称加密算法：SSH key（用公钥加密的密文智能用私钥解密，用私钥签发的签名只能用公钥来验证）\n签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。\n看一张官网的图就明白了：\nJWT 是如何工作的 在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。\n无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema。\nheader应该看起来是这样的：\nAuthorization: Bearer\n服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。\n如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。\n三、场景 下列场景中使用JSON Web Token是很有用的：\nAuthorization (认证、授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。\nInformation Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。\n基于Token的身份认证\n基于服务器的身份认证\n1. 基于 Token 的身份认证 在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的：\nHTTP 协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证\n传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。\n这种基于服务器的身份认证方式存在一些问题：\nSessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。 Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。 CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。 CSRF : 用户很容易受到CSRF攻击。 5.2. JWT与Session的差异 相同点是，它们都是存储用户信息；然而，Session是在服务器端的，而JWT是在客户端的。\nSession方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。\n而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。\nSession的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。\n基于Token的身份认证是如何工作的 基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息。\n没有会话信息意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置。\n虽然这一实现可能会有所不同，但其主要流程如下：\n-用户携带用户名和密码请求访问 -服务器校验用户凭据 -应用提供一个token给客户端 -客户端存储token，并且在随后的每一次请求中都带着它 -服务器校验token并返回数据\n注意：\n-每一次请求都需要token -Token应该放在请求header中 -我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *\n5.4. 用Token的好处 - 无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。 - 安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!\n还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。\n5.5. JWT与OAuth的区别 -OAuth2是一种授权框架 ，JWT是一种认证协议 -无论使用哪种方式切记用HTTPS来保证数据的安全性 -OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。\n2. 基于服务器的身份认证 注意：\n服务器不能真正退出登录 用户信息修改后不能及时同步 Token 泄漏后没有有效的手段将 Token 置为无效 用户通过用户名和密码登录后，系统签发一个 JWT 给客户端，这个 Token 保存了一些用户的基本信息，以及权限相关的信息，后续用户请求的时候带上这个 Token ，服务器就知道当前访问的用户是谁、有哪些权限，而不用查询数据库去3获取用户的基本信息以及权限。\n3. 密码重置和电子邮件验证 服务器会生成包含用户信息的 JWT，并组成一个链接发到用户的邮箱，用户点击该链接后就可以重置密码或完成电子邮件验证（不是必须用 JWT）\n4. 单点登录 #\nJWS （Json Web Signature） 只对内容做签名，确保其不被篡改，但是其内容本身并没有被加密。（最常见的实现 JWT 实现方式）\n它的头部和载荷都是没有加密的，所以它的目的并不是想隐藏数据，而是防止数据被篡改，这点是通过第三方签名来实现的\nJWE（Json Web Encryption） 会对内容本身加密，相对更安全，但是成本也会更高。\n对比sesion 对比 Token jwt就是个生成token（用户令牌）的一个规范。session id 也是一种用户令牌。 就是这个令牌里面带的用户信息，表名是哪个用户的令牌。 jwt里存的用户id，也可以存redis里。也可以不存。传统的session id 是在服务器存储服务中。 过期时间可以各种设计，可以在服务端存储，也可以带到jwt里。如果是带到jwt传里的，那某个用户的jwt串只能同时有一个生效，还是只要在没过过期时间内的都有效，这个要怎么控制。 有各种设计，本质上jwt就是个把用户id安全的传给客户端，客户端安全的传给服务端。\n每个用户一个sha256哈希的密码，某个用户密码被破了，就改掉这个密码。 jwt和传统session(包括说的token)，唯一区别就是 服务端保存不保存这个token。然后是，jwt带的身份标识到了服务端后，需要获取权限。session的那个id 也可以存到redis里。redis key就是session的id，value就是鉴权信息。jwt的话，想要增加速度，鉴权信息得查出来后 也可以把鉴权的信息存储到redis里，那么问题来了，到底会不会节省服务器的内存？ 估计只会省掉存储身份id这个空间。 jwt还有个好处，就是服务器，redis炸了，session id的话就会丢失，jwt的话 还在。\n","date":"2024-04-12","tags":["编程"],"title":"JWT 解析","url":"/post/2024/04/jwt/"},{"content":" github ↗ 官方文档 ↗ 其实所有的配置都不推荐修改，但是如果改了一个配置一定要理解为什么改，以及会影响到什么，请务必打开服务器的端口（防火墙）。\n以下不一定能用，因为我搞了许久才发现是我没打开服务器防火墙，而导致无法访问。 简单说：服务器的配置建议改一下，主要是你服务器可能把8080端口占用了，其余的所有都可以不用改。又不是不能用。\n服务器 nps 需要公网服务器，我服务器的是腾讯云，用的 docker 管理\n1. 如果没下载 Docker 下载docker，使用包管理器下载，yum install -y docker\n2. 创建nps的配置文件夹， 可以自定义，我创建的命令是 mkdir /opt/nps/conf\n3. 拉取docker image docker pull ffdfgdfg/nps，可以使用docker images查看是否拉取成功\n4. 在nps的github下载配置文件 GitHub 下载地址 https://github.com/ehang-io/nps/blob/master/conf/nps.conf ↗ 也可以在 gitee 下载 https://gitee.com/mirrors/nps/tree/master/conf ↗ 把配置文件放在之前创建的 /opt/nps/conf\n5. 修改配置文件（也可以不改，见8） 具体文件内容在文末，修改nps.conf中的端口号，在nps.conf中将https_just_proxy设置为true，并且打开https_proxy_port端口，然后nps将直接转发https请求到内网服务器上，由内网服务器进行https处理\n6. 运行 docker run -d -p 20000-20010:20000-20010 -v /opt/nps/conf:/conf --name=nps ffdfgdfg/nps 解释：-d:后台运行容器，并返回容器ID；-p: 指定端口映射，格式为：主机(宿主)端口:容器端口; 20000-20010:20000-20010: 主机(宿主)端口:(docker)容器端口; -v:绑定一个卷; /opt/nps/conf:/conf: (宿主)目录: docker目录 -name=nps: 为容器指定一个名称； ffdfgdfg/nps:镜像，【应该是这个意思】\n如果报错，查看镜像是否存在 docker iamge; 查看运行状态 docker ps -a 删除容器 docker rm 容器名或id 停止运行docker stop 容器名或id\n使用默认配置 docker run --net=host --name nps_server -d ffdfgdfg/nps ，解释 --net=\u0026quot;bridge\u0026quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n通过公网ip访问：你的公网ip:你设置的端口 比如：8.8.8.8:20003, 默认端口20003\n后续发现停止运行了, 可以使用 docker start nps 启动 nps 服务\n面板上的客户端就是实体设备，客户端通过这里设置的秘钥访问nps 面板上的隧道就是设备上的端口，只要你客户端配置好了，隧道就自动在线了。隧道的就是客户端 id + 客户端端口 + 服务器映射端口（给公网访问）\n客户端 npc 1. 拉取docker image docker pull ffdfgdfg/npc\n2. 配置文件见文末 不推荐修改配置\n3. 未修改配置文件启动 在服务端打开面板 客户端 -\u0026gt; 新增（可以不用配置，改改备注就行）-\u0026gt; 新增； 点击新增条目左边的加号，获取客户端命令。类似于：./npc -server=8.8.8.8:20002 -vkey=fds4322we232w -type=tcp；./nps可以不用复制，命令其余部分复制下来，用于配置客户端docker 运行 docker run -d --name npc --net=host ffdfgdfg/npc -server=ip地址:20002 -vkey=z8uhasdfsfdshx -type=tcp 6. 配置文件启动 没用过，不瞎解释。\n主要是修改启动server_addr 改为你自己的地址 docker run -d -p 18080-18090:8080-8090 -v /root/npc/conf:/conf --name=npc ffdfgdfg/npc 配置文件 nps.conf appname = nps runmode = dev http_proxy_ip=0.0.0.0 http_proxy_port=20000 # http访问 https_proxy_port=20001 # https访问 https_just_proxy=true # 仅https代理 https_default_cert_file=conf/server.pem https_default_key_file=conf/server.key bridge_type=tcp bridge_port=20002 # bridge_ip=0.0.0.0 public_vkey=123 log_level=7 web_host=a.o.com web_username=admin #用户名 web_password=123 # 密码 web_port = 20003 # 记住这个端口，这是管理面板的端口 web_ip=0.0.0.0 web_base_url= web_open_ssl=false web_cert_file=conf/server.pem web_key_file=conf/server.key auth_crypt_key =1234567887654321 allow_user_login=false allow_user_register=false allow_user_change_username=false allow_flow_limit=false allow_rate_limit=false allow_tunnel_num_limit=false allow_local_proxy=false allow_connection_num_limit=false allow_multi_ip=false system_info_display=false http_cache=false http_cache_length=100 http_add_origin_header=false 配置文件（/etc/nps/conf/nps.conf）的含义：\n名称\t含义 web_port\tweb管理端口 web_password\tweb界面管理密码 web_username\tweb界面管理账号 web_base_url\tweb管理主路径,用于将web管理置于代理子路径后面 bridge_port\t服务端客户端通信端口 https_proxy_port\t域名代理https代理监听端口 http_proxy_port\t域名代理http代理监听端口 auth_key\tweb api密钥 bridge_type\t客户端与服务端连接方式kcp或tcp public_vkey\t客户端以配置文件模式启动时的密钥，设置为空表示关闭客户端配置文件连接模式 ip_limit\t是否限制ip访问，true或false或忽略 flow_store_interval\t服务端流量数据持久化间隔，单位分钟，忽略表示不持久化 log_level\t日志输出级别 auth_crypt_key\t获取服务端authKey时的aes加密密钥，16位 p2p_ip\t服务端Ip，使用p2p模式必填 p2p_port\tp2p模式开启的udp端口 pprof_ip\tdebug pprof 服务端ip pprof_port\tdebug pprof 端口 disconnect_timeout\t客户端连接超时，单位 5s，默认值 60，即 300s = 5mins 默认配置\nappname = nps #Boot mode(dev|pro) runmode = dev #HTTP(S) proxy port, no startup if empty http_proxy_ip=0.0.0.0 http_proxy_port=80 https_proxy_port=443 https_just_proxy=true #default https certificate setting https_default_cert_file=conf/server.pem https_default_key_file=conf/server.key ##bridge bridge_type=tcp bridge_port=8024 bridge_ip=0.0.0.0 # Public password, which clients can use to connect to the server # After the connection, the server will be able to open relevant ports and parse related domain names according to its own configuration file. public_vkey=123 #Traffic data persistence interval(minute) #Ignorance means no persistence #flow_store_interval=1 # log level LevelEmergency-\u0026gt;0 LevelAlert-\u0026gt;1 LevelCritical-\u0026gt;2 LevelError-\u0026gt;3 LevelWarning-\u0026gt;4 LevelNotice-\u0026gt;5 LevelInformational-\u0026gt;6 LevelDebug-\u0026gt;7 log_level=7 #log_path=nps.log #Whether to restrict IP access, true or false or ignore #ip_limit=true #p2p #p2p_ip=127.0.0.1 #p2p_port=6000 #web web_host=a.o.com web_username=admin web_password=123 web_port = 8080 web_ip=0.0.0.0 web_base_url= web_open_ssl=false web_cert_file=conf/server.pem web_key_file=conf/server.key # if web under proxy use sub path. like http://host/nps need this. #web_base_url=/nps #Web API unauthenticated IP address(the len of auth_crypt_key must be 16) #Remove comments if needed #auth_key=test auth_crypt_key =1234567812345678 #allow_ports=9001-9009,10001,11000-12000 #Web management multi-user login allow_user_login=false allow_user_register=false allow_user_change_username=false #extension allow_flow_limit=false allow_rate_limit=false allow_tunnel_num_limit=false allow_local_proxy=false allow_connection_num_limit=false allow_multi_ip=false system_info_display=false #cache http_cache=false http_cache_length=100 #get origin ip http_add_origin_header=false #pprof debug options #pprof_ip=0.0.0.0 #pprof_port=9999 #client disconnect timeout disconnect_timeout=60 npc.conf [common] server_addr=1.1.1.1:8024 conn_type=tcp vkey=123 username=111 password=222 compress=true crypt=true rate_limit=10000 flow_limit=100 remark=test max_conn=10 #pprof_addr=0.0.0.0:9999 项\t含义 server_addr\t服务端ip/域名:port conn_type\t与服务端通信模式(tcp或kcp) vkey\t服务端配置文件中的密钥(非web) username\tsocks5或http(s)密码保护用户名(可忽略) password\tsocks5或http(s)密码保护密码(可忽略) compress\t是否压缩传输(true或false或忽略) crypt\t是否加密传输(true或false或忽略) rate_limit\t速度限制，可忽略 flow_limit\t流量限制，可忽略 remark\t客户端备注，可忽略 max_conn\t最大连接数，可忽略 pprof_addr\tdebug pprof ip:port 通过域名访问\n[common] server_addr=域名:20002 conn_type=https vkey=123 auto_reconnection=true max_conn=1000 flow_limit=1000 rate_limit=1000 basic_username=11 basic_password=3 web_username=user web_password=1234 crypt=true compress=true #pprof_addr=0.0.0.0:9999 disconnect_timeout=60 [health_check_test1] health_check_timeout=1 health_check_max_failed=3 health_check_interval=1 health_http_url=/ health_check_type=http health_check_target=127.0.0.1:8083,127.0.0.1:8082 [health_check_test2] health_check_timeout=1 health_check_max_failed=3 health_check_interval=1 health_check_type=tcp health_check_target=127.0.0.1:8083,127.0.0.1:8082 [web] host=域名 target_addr=127.0.0.1:8080 说明\n[common] server_addr=1.1.1.1:8024 vkey=123 [web1] host=a.proxy.com target_addr=127.0.0.1:8080,127.0.0.1:8082 host_change=www.proxy.com header_set_proxy=nps ","date":"2024-03-29","tags":["运维"],"title":"搭建 NPS","url":"/post/2024/03/docker_pns/"},{"content":" 查看原文 ↗ 一、获取原厂固件的 ssh 登录权限 有些厂商的路由器会提供原厂固件的 ssh 登录权限，有些则需要通过原厂固件漏洞等方式来获取路由器后台登录权限，比如：小米路由器就需要先通过 OpenWRTInvasion 破解路由登录权限。\n小米路由器4A千兆版是利用 2.28.62 版本固件的一个 Shell 命令注入的漏洞，所以要想刷机成功就必须得降级到这个版本（2.28.62 之后的新版本应该是将这个漏洞修复了，我再次通过 OpenWRTInvasion 没获取到 ssh 登录权，所有刷的时候尽量在 2.28.62 这个固件版本下刷机）。\n克隆破解程序到电脑 并 执行破解 git clone https://github.com/acecilia/OpenWRTInvasion.git # 克隆 cd OpenWRTInvasion/ # 进入目录 pip install -r requirements.txt # 下载配置 python remote_command_execution_vulnerability.py # 执行脚本 二、在命令行登陆路由器后台 telnet 连接 （也可以使用 ssh ） 按 win + R 打开运行窗口。 输入 OptionalFeatures 打开 windows功能 窗口（也可以在设置里面搜索 windows功能 ） 下滑找到 Telnet Client 勾选后点击确定。 telnet 192.168.31.1 密码是 root 显示 \u0026ldquo;are u ok\u0026rdquo; 表示登陆成功\n使用 ssh 连接（也可以使用 telnet ） ssh root@192.168.31.1 密码是 root\n显示 \u0026ldquo;are u ok\u0026rdquo; 表示登陆成功\n刷入 Breed 对于路由器这类的嵌入式设备刷机有很大的可能会变砖。为了防止我们的路由器有变砖的风险，一般会在刷入第三方路由器固件之前先刷入 Breed。Breed 是国内个人 hackpascal 开发的闭源 Bootloader，也被称为“不死鸟”。 因为有些官方升级固件自带 bootloader，如果从官方固件升级，会导致现有 bootloader 被覆盖。而当 Breed 更新固件时，它会自动删除固件附带的引导加载程序，因此可以防止 Breed 被覆盖。 Breed 拥有以下特性： 实时刷机进度，进度条能准确反映刷机进度 Web 页面快速响应 最大固件备份速度，依 Flash 而定，一般能达到 1MB/s 免按复位键进入 Web 刷机模式 Telnet 功能，免 TTL 进入 Breed 命令控制台 复位键定义测试功能 固件启动失败自动进入 Web 刷机模式 可自定义位置和大小的环境变量块 由于是闭源，无法进行二次开发，所有支持的设备均由 hackpascal 一人完成。在 2020-10-09 后已经停止版本更新，但官网目前 然开放所有的 Breed 下载。 一句话概括就是：Breed 是操作系统，第三方路由器固件是应用软件，软件频繁更换和安装不会影响操作系统。\n备份分区数据 cat /proc/mtd dd if=/dev/mtd0 of=/tmp/all.bin dd if=/dev/mtd1 of=/tmp/Bootloader.bin dd if=/dev/mtd3 of=/tmp/eeprom.bin 下载 Breed： Breed 下载地址：https://breed.hackpascal.net/ 在 文件资源管理器 中输入 ftp://192.168.31.1 打开路由器的文件系统\n刷入 Breed：\ncd /tmp mtd -r write breed-mt7621-pbr-m1.bin Bootloader 刷入第三方路由器固件 OpenWRT下载地址：https://downloads.openwrt.org/releases/21.02.3/targets/ramips/mt7621/\n找到对应型号：openwrt-21.02.3-ramips-mt7621-xiaomi_mi-router-4a-gigabit-squashfs-sysupgrade.bin。\ncd /tmp mtd -e OS1 -r write openwrt-21.02.3-ramips-mt7621-xiaomi_mi-router-4a-gigabit-squashfs-sysupgrade.bin OS1 通过 Breed Web 恢复控制台刷入第三方路由器固件 当我们刷入 Breed 后就相当于是给路由器装了个操作系统，可以在上面随意刷入第三方路由器固件，一般情况下不会出现变砖的风险。\nOpenWrt 一般情况都安装 OpenWRT 或者是魔改后的 OpenWRT，小米路由器本身也是魔改的 OpenWRT。 OpenWRT官网下载地址：https://downloads.openwrt.org/releases/21.02.3/targets/ramips/mt7621/ 默认账户：root OpenWRT魔改下载地址：https://download.csdn.net/download/yilovexing/87600550 默认账户：root 默认密码：coolxiaomi\nPadavan 据说小米路由器使用老毛子固件更稳定，我也没有具体去考证，也不知道是不是真的。反正我是比较喜欢用 Padavan，无论是界面还是稳定性都不错（还有个使用老毛子的原因是 2022-07-24 Breed 进行了重大更新，OpenWrt 不再支持直接用底包刷固件了。）！\nPadavan官网源码：https://bitbucket.org/padavan/rt-n56u/src/master/ Padavan下载地址：https://opt.cn2qq.com/padavan/ 默认账户：admin 默认密码：admin\n","date":"2024-03-24","tags":["硬件"],"title":"小米 4a 路由器刷机","url":"/post/2024/03/xiaomi_4a/"},{"content":" 原文 ↗ 介绍一下配置：\nwifi 全程不用连网 win系统电脑刷机，需要下载一个刷机包 windows 有 python 程序，查看方法：在命令提示符窗口输入 python --version，会输出版本号 Breed也被称为“不死鸟”，顾名思义刷入Breed后即使后续为路由器刷固件失败，也不至于让路由器变砖，并且对于以后更换固件非常友好，强烈建议刷Breed。\n首先下载刷机所需要用到的工具 链接：https://pan.baidu.com/s/1kGnIe2T8Ul1XvWobdyxDbQ 提取码：iaxp\n提示：小米路由器后管理地址，一般为192.168.31.1\n打开小米路由器的 Telnet 和 FTP 打开下载工具包中的 R3GV2 patches 文件夹 运行文件夹中的 0.start_main.bat 批处理文件，此文件实际上是运行了一个 python 脚本，向路由器上传了一个开启 Telnet 和 FTP 的文件。 用 MobaXterm 连接小米路由器 （也可以在终端连接，我在小米4a路由器的刷机过程中就是用的终端）\n打开下载的工具包中的 MobaXterm_Personal_21.1.exe 程序， 依次点击 Sessions -\u0026gt; New session -\u0026gt; Telnet ， 在 Remote host 中输入192.168.31.1 Username 中输入 root 最后点击 OK，回到主界面后会发现生成了一个新的session 双击运行新的 session（这一步可能会提示无法连接，从头开始按照以上步骤多试几次就行了），如果需要输入密码，尝试输入 root 或者 password 或者你的 wifi 密码。 界面显示 “are u ok”，表示连接成功。\n备份文件 在 MobaXterm 命令行中分别输入以下命令 dd if=/dev/mtd0 of=/tmp/all.bin 将整个磁盘分区命名为all.bin备份到tmp路径\ndd if=/dev/mtd1 of=/tmp/bootloader.bin 将Bootloader分区命名为bootloader.bin备份到tmp路径\ndd if=/dev/mtd2 of=/tmp/eeprom.bin 将Eeprom分区命名为eeprom.bin备份到tmp路径\n备份完成后打开 文件资源管理器，在地址栏输入 ftp://192.168.31.1，打开 tmp 文件夹，并将刚刚备份的 3个bin文件 复制到 自己的电脑 中(注意：务必检查eeprom.bin文文件大小，通常为64kb，若文件只有几百字节则须重新备份) 刷入Breed 打开工具包中的 Breed 文件夹复制 breed.bin 文件，然后上传到 tmp 目录内\n回到 MobaXterm 中输入 mtd write /tmp/breed.bin Bootloader 刷入Breed。\n刷入完成后将小米路由器4C断电，按住复位键的同时通电，可以看到电源灯与网络灯闪烁几下后即可松开复位键，此时就进入了Breed模式。\n在浏览器输入 192.168.1.1 进入 Breed 页面。\n刷入OpenWrt {bs-font color=\u0026quot;#080000\u0026quot;}注意：一定要先刷入eeprom.bin再刷入OpenWrt固件{/bs-font}\n在 Breed Web 恢复控制台中依次刷入备份好的 eeprom.bin 与 OpenWrt固件 即可 OpenWrt固件在工具包文件夹OpenWrt固件中\n其他 刷好OpenWrt后输入 192.168.5.1 进入路由器管理界面，默认密码为 password\n","date":"2024-03-23","tags":["硬件"],"title":"小米 4c 路由器刷机","url":"/post/2024/03/xiaomi_4c_router/"},{"content":"{bs-font color=\u0026quot;#FF0000\u0026quot;}刷机有风险，如果能用，请不要为了不一样而刷机，又不是不能用！{/bs-font}\n现在你的路由器和小米已经没有任何关系了，恭喜你上了贼船！\n基本介绍： OpenWrt 是一个开源的路由系统，开放、自由的特性让这个路由系统深受欢迎！ 几乎所有的商业路由器品牌都是封闭的，可以操作的空间非常小，往往需要为一些小的功能，而增加几十几百甚至上千的费用。 OpenWrt很好地解决了这个问题。\n我该怎么选择？ 商业品牌的路由器：稳定 OpenWrt路由系统：软件丰富\n一、登陆管理后台 用网线连接电脑的网口和 Wi-Fi 的 LAN口打开浏览器地址烂 （一般是在窗口顶部） 输入：192.168.5.1 打不开地址：确定网口没有连错，比如拔掉 WAN口 的网线 （有的品牌叫 Internet 或者 宽带 ），确保 LAN 口是连接的电脑 在上面一栏的 用户名 或者叫 username 输入 root 在下面一栏的 密码 或者叫 password 输入 password 按 回车键 或者点击 登陆 按钮 二、配置宽带 登陆 路由器后台管理 页面 把路由器的 WAN 口连接到宿舍的网口 打开路由器后台的 网络 -\u0026gt; 接口， 找到 WAN 选择 修改 -\u0026gt; 基本设置 协议选择 PPPoE 用户名：输入你自己的用户名，注意检查空格 密码：输入你自己的密码，注意检查空格 如果登陆成功会出现 pppoe-wan的字样显示 IPv4:xxx.xxx.xxx.xxx 登陆失败？ 第一步：检查账户名或者密码是否正确 ，此时可以登陆，那么无需进行第二步。 第二步：禁用 IPv6：在 WAN -\u0026gt; 修改 -\u0026gt; 高级设置 -\u0026gt; 获取IPv6地址（或者是英文的，总之就是第一个下拉菜单选项），选择 禁用（或者英文的禁用） 11.连接成功\n三、设置无线密码 在 网络 -\u0026gt; 无线：有的有两个有的有一个，这取决于你的 wifi 硬件。 点击 修改 在新页面的下方 接口配置 部分，选择 基本设置 -\u0026gt; ESSID：修改为你想要的网络名称（其余的建议不要动，除非你懂） 在选择 接口配置 -\u0026gt; 无线安全 加密：加密方式，一般是 WPA3 或者 WPA2 算法：选择 自动 就行。 密码：设置你的 wifi 密码。 SSID：是你的无线网络名称，在修改页面对应的是 ESSID。 加密：是你的无线网络加密方式，如果有加密方式就必须要设置密码\nSSID = Service Set IDentifier BSSID = Basic Service Set IDentifier ESSID = Extended Service Set IDentifier\n其他功能说明（不重要） {bs-font color=\u0026quot;#000000\u0026quot;}如果看不懂就不用看，只改自己看得懂的，否则可能出问题！{/bs-font} 以下内容有一些可能没有，这是开发者为了路由器性能做的权衡，没有那些功能会更流畅稳定。\n概览：路由器的基本信息。 路由表：连接路由器的所有设备。 系统日志：日志，对用户来说不重要。 内核日志：日志，对用户来说不重要。 系统进程：请勿更改，可能导致系统不稳定。 实时信息：路由器的状态，可以检查到路由器是不是性能差、网络差等问题 实时监控：实时信息的升级版。 负载均衡：没用过，不知道。 Web管理：设置如何访问到后台管理页面。【不要轻易改】 系统：系统的基本设置，可以改主题和语言。 管理权：设置后台管理页的登陆密码 TTYD终端：访问路由器的Linux系统 软件包：安装和卸载软件。 启动项：脚本，可以实现一些自动化的操作 计划任务：简单版的启动项 挂载点：不要轻易改动，除非你理解Linux 备份/升级：路由器的备份和升级 重启：重启路由器 ShadowSocksR：师夷长技以制夷。 DDNS.to内网穿透：让你的设备可以在外面被访问。 动态DNS：域名解析，可以把一个域名指向 IP地址 KMS服务器：激活 Windows 系统和 office 系统的。 UPnP：端口转发 UU游戏加速器：游戏加速器，我不玩游戏，不了解。 网络唤醒：没用过 目前就这些吧，其他的我几乎没有用，我认为也不是一个普通用户会接触的，就不介绍了。\n","date":"2024-03-22","tags":["硬件"],"title":"小米路由器","url":"/post/2024/03/xiaomi_router/"},{"content":" 原作者 ↗ 个人配置 ↗ 下载 git clone https://github.com/caoyang2002/quartz-obsidian-webside.git cd quartz-obsidian-webside npm i npx quartz build --serve 配置 布局 某些 emitters 可能还会输出HTML文件。为了方便定制，这些 emitters 允许您完全重新排列页面的布局。 默认页面布局可以在 quartz.layout.ts 中找到。\n每个页面由多个不同的部分组成，这些部分包含 QuartzComponents。以下代码片段列出了您可以向其中添加组件的所有有效部分：\nquartz/cfg.ts\nexport interface FullPageLayout { head: QuartzComponent // 单个组件 header: QuartzComponent[] // 水平布局 beforeBody: QuartzComponent[] // 垂直布局 pageBody: QuartzComponent // 单个组件 left: QuartzComponent[] // 桌面上垂直布局，在移动设备上水平布局 right: QuartzComponent[] // 桌面上垂直布局，在移动设备上水平布局 footer: QuartzComponent // 单个组件 } 这些对应于页面的以下部分：\n注意 还有两个未在上图中显示的附加布局字段。\nhead 是一个单独的组件，用于在HTML中呈现\u0026lt;head\u0026gt;标签。这在页面上不会可见，只负责文档的元数据，如标签标题、脚本和样式。 header 是一组以水平方式布局的组件，出现在beforeBody部分之前。这使您可以复制旧的Quartz 3标题栏，其中包含标题、搜索栏和暗模式切换。默认情况下，Quartz 4不在标题中放置任何组件。\nQuartz 组件，就像插件一样，可以接受额外的属性作为配置选项。如果您熟悉React术语，可以将它们视为Higher-order Components。\n查看所有可用组件以及其配置选项的列表。如果您有兴趣进一步定制Quartz的行为，请查看创建组件的指南。\n样式 大多数有意义的样式更改，如颜色方案和字体，都可以通过常规配置选项简单完成。但是，如果您想进行更复杂的样式更改，可以通过编写自己的样式来实现。与Quartz 3一样，Quartz 4也使用Sass进行样式设计。\n您可以在 quartz/styles/base.scss 中查看基本样式表，并在 quartz/styles/custom.scss 中编写自己的样式。\n注意 某些组件可能还提供自己的样式！例如，quartz/components/Darkmode.tsx从quartz/components/styles/darkmode.scss 导入样式。如果您想为特定组件定制样式，请仔细检查组件定义，以查看其样式是如何定义的。\n创建自己的Quartz组件 原文 ↗ 警告 本指南假设您具有编写JavaScript的经验并熟悉TypeScript。\n通常在网络上，我们使用HTML编写布局代码，看起来像下面这样：\n\u0026lt;article\u0026gt; \u0026lt;h1\u0026gt;文章标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;一些内容\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; 这段HTML表示一篇文章，具有领先的标题“文章标题”和一个包含文本“一些内容”的段落。这与CSS结合在一起来为页面添加样式，使用JavaScript添加交互。\n但是，HTML不允许您创建可重用的模板。如果您想创建一个新页面，您需要复制并粘贴上述代码片段，并自行编辑标题和内容。如果我们的网站上有很多内容共享相似的布局，那么这并不理想。创建React的聪明人也有类似的抱怨，并发明了组件的概念——返回JSX的JavaScript函数——来解决代码重复的问题。\n实际上，组件允许您编写一个JavaScript函数，该函数接受一些数据并生成HTML作为输出。虽然Quartz不使用React，但它使用相同的组件概念，以便您可以轻松地在Quartz网站中表达布局模板。\n示例组件 构造函数 组件文件是以 .tsx 文件编写的，位于 quartz/components 文件夹中。这些文件被重新导出到 quartz/components/index.ts 中，以便您可以更轻松地在布局和其他组件中使用它们。\n每个组件文件应该有一个默认导出，满足 QuartzComponentConstructor 函数签名。它是一个接受一个可选参数 opts 并返回一个 Quartz 组件的函数。参数 opts 的类型由您作为组件创建者决定的 Options 接口定义。\n在您的组件中，您可以使用配置选项中的值来更改组件内的渲染行为。例如，下面代码片段中的组件如果 favouriteNumber 选项小于 0，则不会呈现。\ninterface Options { favouriteNumber: number } const defaultOptions: Options = { favouriteNumber: 42, } export default ((userOpts?: Options) =\u0026gt; { const opts = { ...userOpts, ...defaultOpts } function YourComponent(props: QuartzComponentProps) { if (opts.favouriteNumber \u0026lt; 0) { return null } return \u0026lt;p\u0026gt;我的最喜欢的数字是 {opts.favouriteNumber}\u0026lt;/p\u0026gt; } return YourComponent }) 满足 QuartzComponentConstructor 属性 Quartz 组件本身（上面高亮的第 11-17 行）看起来像一个React组件。它接受属性（有时称为 props）并返回JSX。\n所有Quartz组件接受相同的一组属性：\n// 简化以便演示 export type QuartzComponentProps = { fileData: QuartzPluginData cfg: GlobalConfiguration tree: Node\u0026lt;QuartzPluginData\u0026gt; allFiles: QuartzPluginData[] displayClass?: \u0026#34;mobile-only\u0026#34; | \u0026#34;desktop-only\u0026#34; } fileData : 可能已添加到当前页面的任何元数据插件。 fileData.slug : 当前页面的 slug。 fileData.frontmatter : 解析的任何 frontmatter。 cfg : quartz.config.ts 中的配置字段。 tree : 处理和转换文件后的结果HTML AST。如果您想使用 hast-util-to-jsx-runtime 渲染内容，这将非常有用（您可以在 quartz/components/pages/Content.tsx 中找到此示例）。 allFiles : 已解析的所有文件的元数据。用于执行页面列表或确定整体站点结构非常有用。 displayClass : 指示用户如何在移动设备或桌面环境中渲染它的首选项的实用类。如果要在移动设备或桌面环境中有条件地隐藏组件，则很有帮助。 样式 Quartz 组件还可以在实际函数组件上定义 .css 属性，Quartz 将对其进行捕获。这预期是一个 CSS 字符串，可以是内联的也可以是从 .scss 文件导入的。\n请注意，内联样式必须是纯粹的普通 CSS：\nexport default (() =\u0026gt; { function YourComponent() { return \u0026lt;p class=\u0026#34;red-text\u0026#34;\u0026gt;示例组件\u0026lt;/p\u0026gt; } YourComponent.css = ` p.red-text { color: red; } ` return YourComponent }) 满足 QuartzComponentConstructor 但是，导入的样式可以来自 SCSS 文件：\n// 假设您的样式表位于 quartz/components/styles/YourComponent.scss import styles from \u0026#34;./styles /YourComponent.scss\u0026#34; export default (() =\u0026gt; { function YourComponent() { return \u0026lt;p\u0026gt;示例组件\u0026lt;/p\u0026gt; } YourComponent.css = styles return YourComponent }) 满足 QuartzComponentConstructor 警告 Quartz 不使用 CSS 模块，因此在此处声明的任何样式都是全局的。如果您只希望它应用于您的组件，请确保使用特定的类名和选择器。\n脚本和交互性\n那么交互性呢？假设您想添加一个点击处理程序，例如。与组件上的 .css 属性一样，您还可以声明 .beforeDOMLoaded 和 .afterDOMLoaded 属性，这些属性是包含脚本的字符串。\nexport default (() =\u0026gt; { function YourComponent() { return \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击我\u0026lt;/button\u0026gt; } YourComponent.beforeDOM = ` console.log(\u0026#34;hello from before the page loads!\u0026#34;) ` YourComponent.afterDOM = ` document.getElementById(\u0026#39;btn\u0026#39;).onclick = () =\u0026gt; { alert(\u0026#39;button clicked!\u0026#39;) } ` return YourComponent }) 满足 QuartzComponentConstructor 提示 对于那些来自React的人来说，Quartz 组件与React组件不同，因为它只使用JSX进行模板化和布局。像 useEffect、useState 等钩子不会被渲染，其他接受函数的属性如 onClick 处理程序也不起作用。相反，使用一个普通的 JS 脚本，直接修改 DOM 元素。\n正如名称所暗示的那样，.beforeDOMLoaded 脚本在页面加载完成之前执行，因此它不能访问页面上的任何元素。这主要用于预取任何关键数据。\n.afterDOMLoaded 脚本在页面完全加载后执行。这是设置任何在站点访问期间应该持续存在的东西的好地方（例如，从本地存储中获取的内容）。\n如果需要创建一个依赖于页面特定元素的 afterDOMLoaded 脚本，在导航到新页面时可能会更改，您可以监听 “nav” 事件。每当页面加载时都会触发该事件（如果启用了 SPA 路由，则可能会在导航时发生）。\ndocument.addEventListener(\u0026#34;nav\u0026#34;, () =\u0026gt; { // 在这里执行页面特定的逻辑 // 例如，附加事件监听器 const toggleSwitch = document.querySelector(\u0026#34;#switch\u0026#34;) as HTMLInputElement toggleSwitch.addEventListener(\u0026#34;change\u0026#34;, switchTheme) window.addCleanup(() =\u0026gt; toggleSwitch.removeEventListener(\u0026#34;change\u0026#34;, switchTheme)) }) 最佳实践是通过 window.addCleanup 跟踪任何事件处理程序，以防止内存泄漏。这将在页面导航时调用。\n导入代码 当然，将代码作为字符串文字写入组件通常既不实际（也不受欢迎！）。\nQuartz 支持通过 .inline.ts 文件导入组件代码。\n// @ts-ignore: typescript doesn\u0026#39;t know about our inline bundling system // 所以我们需要消除错误 import script from \u0026#34;./scripts/graph.inline\u0026#34; export default (() =\u0026gt; { function YourComponent() { return \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击我\u0026lt;/button\u0026gt; } YourComponent.afterDOM = script return YourComponent }) 满足 QuartzComponentConstructor // 在这里导入的任何内容都将被浏览器捆绑 import * as d3 from \u0026#34;d3\u0026#34; document.getElementById(\u0026#34;btn\u0026#34;).onclick = () =\u0026gt; { alert(\u0026#34;按钮被点击了！\u0026#34;) } 此外，就像上面示例中所显示的一样，您可以在 .inline.ts 文件中导入包。这将由 Quartz 捆绑并包含在实际脚本中。\n使用组件\n创建自定义组件后，重新导出它在 quartz/components/index.ts ：\nimport ArticleTitle from \u0026#34;./ArticleTitle\u0026#34; import Content from \u0026#34;./pages/Content\u0026#34; import Darkmode from \u0026#34;./Darkmode\u0026#34; import YourComponent from \u0026#34;./YourComponent\u0026#34; export { ArticleTitle, Content, Darkmode, YourComponent } 然后，您可以像在 quartz.layout.ts 中使用任何其他组件一样使用它。有关详细信息，请参见布局部分。\n由于Quartz组件只是返回 React 组件的函数，因此您可以在其他 Quartz 组件中进行组合使用。\nimport YourComponent from \u0026#34;./YourComponent\u0026#34; export default (() =\u0026gt; { function AnotherComponent(props: QuartzComponentProps) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;它是嵌套的！\u0026lt;/p\u0026gt; \u0026lt;YourComponent {...props} /\u0026gt; \u0026lt;/div\u0026gt; ) } return AnotherComponent }) 满足 QuartzComponentConstructor 提示 在 quartz/components 中查找更多Quartz组件示例，作为您自己组件的参考！\n制作自己的插件 原文 ↗ 警告 本文档的这一部分将假定您具有 TypeScript 的工作知识，并包含描述 Quartz 插件应该具有的接口的代码片段。\nQuartz 的插件是一系列针对内容的转换。下面是处理流水线的图示：\n所有插件都被定义为一个函数，该函数接受一个参数用于选项类型 OptionType = object | undefined，并返回一个与其所属类型相对应的对象。\ntype OptionType = object | undefined type QuartzPlugin\u0026lt;Options extends OptionType = undefined\u0026gt; = (opts?: Options) =\u0026gt; QuartzPluginInstance type QuartzPluginInstance = | QuartzTransformerPluginInstance | QuartzFilterPluginInstance | QuartzEmitterPluginInstance 接下来的几节将详细介绍每种插件类型可以实现的方法。在我们进行之前，让我们澄清一些更模糊的类型：\nBuildCtx 在 quartz/ctx.ts 中定义。它由以下组成：\nargv : 传递给 Quartz 构建命令的命令行参数 cfg : 完整的 Quartz 配置 allSlugs : 所有有效内容 slug 的列表（有关 ServerSlug 的更多信息，请参阅路径部分） StaticResources 在 quartz/resources.tsx 中定义。它由以下组成：\ncss: 应加载的样式表的 URL 列表 js: 应加载的脚本列表。脚本用 JSResource 类型描述，该类型也在 quartz/resources.tsx 中定义。它允许您定义加载时间（在 DOM 加载前或后），是否应为模块以及脚本的源 URL 或内联内容。\n转换器 转换器对内容进行映射，接受一个 Markdown 文件，并输出修改后的内容或向文件本身添加元数据。\nexport type QuartzTransformerPluginInstance = { name: string textTransform?: (ctx: BuildCtx, src: string | Buffer) =\u0026gt; string | Buffer markdownPlugins?: (ctx: BuildCtx) =\u0026gt; PluggableList htmlPlugins?: (ctx: BuildCtx) =\u0026gt; PluggableList externalResources?: (ctx: BuildCtx) =\u0026gt; Partial\u0026lt;StaticResources\u0026gt; } 所有转换器插件必须至少定义一个 name 字段以注册插件，并且一些可选函数，使您能够连接到转换单个 Markdown 文件的各个部分。\ntextTransform 在将文件解析为 Markdown AST 之前执行文本到文本的转换。 markdownPlugins 定义一个 remark 插件列表。remark 是一个工具，以结构化方式将 Markdown 转换为 Markdown的工具。 htmlPlugins 定义一个 rehype 插件列表。与 remark 类似，rehype 是一个工具，以结构化方式将 HTML 转换为 HTML。 externalResources 定义插件可能需要在客户端加载的任何外部资源。 通常对于 remark 和 rehype，您可以找到现有的插件可供使用。如果您想创建自己的 remark 或 rehype 插件，请查看使用 unified（底层 AST 解析器和转换器库）的插件的指南。\n从 remark 和 rehype 生态系统借鉴的转换器插件的一个很好的例子是 Latex 插件：\nquartz/plugins/transformers/latex.ts import remarkMath from \u0026#34;remark-math\u0026#34; import rehypeKatex from \u0026#34;rehype-katex\u0026#34; import rehypeMathjax from \u0026#34;rehype-mathjax/svg\u0026#34; import { QuartzTransformerPlugin } from \u0026#34;../types\u0026#34; interface Options { renderEngine: \u0026#34;katex\u0026#34; | \u0026#34;mathjax\u0026#34; } export const Latex: QuartzTransformerPlugin\u0026lt;Options\u0026gt; = (opts?: Options) =\u0026gt; { const engine = opts?.renderEngine ?? \u0026#34;katex\u0026#34; return { name: \u0026#34;Latex\u0026#34;, markdownPlugins() { return [remarkMath] }, htmlPlugins() { if (engine === \u0026#34;katex\u0026#34;) { // 如果您需要将选项传递给插件，您可以使用 [插件，选项] 的元组 return [[rehypeKatex, { output: \u0026#34;html\u0026#34; }]] } else { return [rehypeMathjax] } }, externalResources() { if (engine === \u0026#34;katex\u0026#34;) { return { css: [ // 基础 CSS \u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css\u0026#34;, ], js: [ { // 修复复制行为：https://github.com/KaTeX/KaTeX/blob/main/contrib/copy-tex/README.md src: \u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js\u0026#34;, loadTime: \u0026#34;afterDOMReady\u0026#34;, contentType: \u0026#34;external\u0026#34;, }, ], } } else { return {} } }, } } 转换器 插件还经常做的一件事是解析文件并为该文件添加额外数据：\nexport const AddWordCount: QuartzTransformerPlugin = () =\u0026gt; { return { name: \u0026#34;AddWordCount\u0026#34;, markdownPlugins() { return [ () =\u0026gt; { return (tree, file) =\u0026gt; { // tree 是一个 `mdast` 根元素 // file 是一个 `vfile` const text = file.value const words = text.split(\u0026#34; \u0026#34;).length file.data.wordcount = words } }, ] }, } } // 告诉 TypeScript 关于我们正在添加的自定义数据字段 // 其他插件也将意识到这个数据字段 declare module \u0026#34;vfile\u0026#34; { interface DataMap { wordcount: number } } 最后，您还可以使用 unist-util-visit 包中的 visit 函数或 mdast-util-find-and-replace 包中的 findAndReplace 函数对 Markdown 或 HTML AST 进行转换。\nexport const TextTransforms: QuartzTransformerPlugin = () =\u0026gt; { return { name: \u0026#34;TextTransforms\u0026#34;, markdownPlugins() { return [() =\u0026gt; { return (tree, file) =\u0026gt; { // 使用斜体版本替换 _text_ findAndReplace(tree, /_(.\u0026#43;)_/, (_value: string, ...capture: string[]) =\u0026gt; { // inner 是正则表达式括号内的文本 const [inner] = capture // 返回一个 mdast 节点 // https://github.com/syntax-tree/mdast return { type: \u0026#34;emphasis\u0026#34;, children: [{ type: \u0026#39;text\u0026#39;, value: inner }] } }) // 删除所有链接（替换为仅链接内容） // 通过 mdast 节点上的 \u0026#39;type\u0026#39; 字段进行匹配 // 例如在这个例子中的 https://github.com/syntax-tree/mdast#link visit(tree, \u0026#34;link\u0026#34;, (link: Link) =\u0026gt; { return { type: \u0026#34;paragraph\u0026#34; children: [{ type: \u0026#39;text\u0026#39;, value: link.title }] } }) } }] } } } 所有转换器插件都可以在 quartz/plugins/transformers 下找到。如果您决定编写自己的转换器插件，请不要忘记在 quartz/plugins/transformers/index.ts 下重新导出它。\n最后一句话：转换器插件相当复杂，所以如果您一开始不理解也不必担心。查看内置的转换器，了解它们如何在内容上操作，以更好地了解如何实现您想要做的事情。\n过滤器 过滤器用于过滤内容，接受所有转换器处理的输出，并确定实际要保留的文件以及要丢弃的文件。\nexport type QuartzFilterPlugin\u0026lt;Options extends OptionType = undefined\u0026gt; = ( opts?: Options, ) =\u0026gt; QuartzFilterPluginInstance export type QuartzFilterPluginInstance = { name: string shouldPublish(ctx: BuildCtx, content: ProcessedContent): boolean } 过滤器插件必须定义一个 name 字段和一个 shouldPublish 函数，该函数接受所有转换器处理的内容，并根据是否应将其传递给发射器插件返回 true 或 false。\n例如，这是用于移除草稿的内置插件：\nquartz/plugins/filters/draft.ts import { QuartzFilterPlugin } from \u0026#34;../types\u0026#34; export const RemoveDrafts: QuartzFilterPlugin\u0026lt;{}\u0026gt; = () =\u0026gt; ({ name: \u0026#34;RemoveDrafts\u0026#34;, shouldPublish(_ctx, [_tree, vfile]) { // 使用从转换器解析的 frontmatter const draftFlag: boolean = vfile.data?.frontmatter?.draft ?? false return !draftFlag }, }) 发射器 发射器用于在内容的所有转换和过滤输出上进行缩减，并创建输出文件。\nexport type QuartzEmitterPlugin\u0026lt;Options extends OptionType = undefined\u0026gt; = ( opts?: Options, ) =\u0026gt; QuartzEmitterPluginInstance export type QuartzEmitterPluginInstance = { name: string emit(ctx: BuildCtx, content: ProcessedContent[], resources: StaticResources): Promise\u0026lt;FilePath[]\u0026gt; getQuartzComponents(ctx: BuildCtx): QuartzComponent[] } 发射器插件必须定义一个 name 字段、一个 emit 函数和一个 getQuartzComponents 函数。emit 负责查看所有解析和过滤的内容，然后适当创建文件并返回插件创建的文件路径列表。\n创建新文件可以通过常规的 Node fs 模块（例如 fs.cp 或 fs.writeFile）或者通过 quartz/plugins/emitters/helpers.ts 中的 write 函数进行，如果您正在创建包含文本的文件。write 具有以下签名：\nexport type WriteOptions = (data: { // 构建上下文 ctx: BuildCtx // 要发出的文件的名称（不包括文件扩展名） slug: ServerSlug // 文件扩展名 ext: `.${string}` | \u0026#34;\u0026#34; // 要添加的文件内容 content: string }) =\u0026gt; Promise\u0026lt;FilePath\u0026gt; 这是对向适当的输出文件夹写入并确保中间目录存在的简单包装。如果选择使用本机 Node fs API，请确保发出到 argv.output 文件夹。\n如果您正在创建需要渲染组件的发射器插件，还有三件事需要注意：\n您的组件应该使用 getQuartzComponents 声明一个 QuartzComponents 列表，用于构造页面。有关更多信息，请参阅创建组件页面。 您可以使用 quartz/components/renderPage.tsx 中定义的 renderPage 函数将 Quartz 组件呈现为 HTML。 如果需要将 HTML AST 渲染为 JSX，可以使用 quartz/util/jsx.ts 中的 htmlToJsx 函数。您可以在 quartz/components/pages/Content.tsx 中找到一个示例。\n例如，以下是一个简化版本的内容页面插件，它呈现每个页面：\nquartz/plugins/emitters/contentPage.tsx export const ContentPage: QuartzEmitterPlugin = () =\u0026gt; { // 构造布局 const layout: FullPageLayout = { ...sharedPageComponents, ...defaultContentPageLayout, pageBody: Content(), } const { head, header, beforeBody, pageBody, left, right, footer } = layout return { name: \u0026#34;ContentPage\u0026#34;, getQuartzComponents() { return [head, ...header, ...beforeBody, pageBody, ...left, ...right, footer] }, async emit(ctx, content, resources, emit): Promise\u0026lt;FilePath[]\u0026gt; { const cfg = ctx.cfg.configuration const fps: FilePath[] = [] const allFiles = content.map((c) =\u0026gt; c[1].data) for (const [tree, file] of content) { const slug = canonicalizeServer(file.data.slug!) const externalResources = pageResources(slug, resources) const componentData: QuartzComponentProps = { fileData: file.data, externalResources, cfg, children: [], tree, allFiles, } const content = renderPage(cfg, slug, componentData, opts, externalResources) const fp = await emit({ content, slug: file.data.slug!, ext: \u0026#34;.html\u0026#34;, }) fps.push(fp) } return fps }, } } 请注意，它以 FullPageLayout 作为选项。它由共享布局和页面布局组合而成，这两个布局都是通过 quartz.layout.ts 文件提供的。\n提示 在 Quartz 中查看 quartz/plugins 下更多插件的示例，作为您自己插件的参考！\n国际化 原文 ↗ 国际化允许用户将Quartz界面中的文本翻译成各种支持的语言，而无需进行大量的代码更改。这可以通过 quartz.config.ts 中的 locale 配置字段进行更改。\nlocale 字段通常遵循一定的格式：{language}-{REGION}\n{language} 通常是一个由两个小写字母组成的语言代码。 {REGION} 通常是一个由两个大写字母组成的地区代码。 有兴趣贡献吗？ 我们欢迎翻译的 Pull Request！要贡献翻译，请执行以下操作：\n在 quartz/i18n/locales 文件夹中，复制 en-US.ts 文件。 将其重命名为 {language}-{REGION}.ts，使其与上述格式的语言环境匹配。 填写翻译！ 在 quartz/i18n/index.ts 中的 TRANSLATIONS 下添加条目。\n设置你的 GitHub 仓库 原文 ↗ 首先，确保你已经在本地克隆并设置了 Quartz。\n然后，在 GitHub.com 上创建一个新的仓库。不要初始化新仓库，也不要添加 README、许可证或 gitignore 文件。\n在 GitHub.com 仓库的“快速设置”页面顶部，单击剪贴板图标以复制远程仓库的 URL。\n在你选择的终端中，导航到你的 Quartz 文件夹的根目录。然后，运行以下命令，将 REMOTE-URL 替换为你刚刚从上一步复制的 URL。\n列出所有被跟踪的仓库\ngit remote -v 如果 origin 不匹配你自己的仓库，将你的仓库设置为 origin\ngit remote set-url origin REMOTE-URL 如果你没有将上游设置为远程仓库，添加它以便更新工作\ngit remote add upstream https://github.com/jackyzha0/quartz.git 然后，你可以同步内容以将其上传到你的仓库。这是一个辅助命令，将会将你的内容初始推送到你的仓库。\nnpx quartz sync --no-pull 致命错误：--[no-]autostash 选项只能在 --rebase 时有效。\n你可能使用的是过时版本的 git。更新 git 应该会解决这个问题。\n在以后的更新中，每当你想要 将更新推送到你的仓库 时，你只需要运行 npx quartz sync。\n标志和选项 要获取完整的帮助选项，你可以运行 npx quartz sync --help。\n大多数情况下，它们都有合理的默认值，但如果你有自定义设置，你可以覆盖它们：\n-d 或 --directory ：内容文件夹。通常只是 content。 -v 或 --verbose ：打印额外的日志信息 --commit 或 --no-commit ：是否为你的更改进行 git 提交 --push 或 --no-push：是否将更新推送到你的 Quartz GitHub fork --pull 或 --no-pull ：是否在推送之前尝试拉取来自你的 GitHub fork 的任何更新（即来自其他设备的更新）\n编写内容 原文 ↗ 你的 Quartz 中的所有内容都应该放在 /content 文件夹中。Quartz 的主页内容位于 content/index.md。如果你已经设置了 Quartz，那么这个文件夹应该已经被初始化了。这个文件夹中的任何 Markdown 文件都将由 Quartz 处理。\n推荐你使用 Obsidian 来编辑和维护你的 Quartz。它带有一个漂亮的编辑器和图形界面，可以预览、编辑和链接你的本地文件和附件。\n一切都设置好了吗？让我们本地构建和预览你的 Quartz！\n语法 由于 Quartz 使用 Markdown 文件作为编写内容的主要方式，因此它完全支持 Markdown 语法。默认情况下，Quartz 还附带了一些语法扩展，如 Github Flavored Markdown（脚注、删除线、表格、任务列表）和 Obsidian Flavored Markdown（标注、Wiki 链接）。\n以下是 GitHub Flavored Markdown 的全部功能和语法：\n任务列表（Task Lists）：使用 - [ ] 和 - [x] 语法创建待办事项列表，可以勾选或取消勾选每个项目。\n表格（Tables）：使用管道符 | 和连字符 - 创建简单的表格，包括行和列。\n删除线（Strikethrough）：使用双波浪线 ~~ 表示删除的文本。\n自动链接（Autolinks）：GitHub Flavored Markdown 会自动将 URL 和电子邮件地址转换为链接。\n标记语法（Disallowed Raw HTML）：GitHub Flavored Markdown 不允许使用原始 HTML 标记，以确保安全性。\n脚注（Footnotes）：使用 [^] 语法创建文本注释，通常在页面底部显示。\nObsidian Flavored Markdown（OFM）提供了以下功能和语法：\n呼唤（Callouts）：允许在文本中添加特殊样式的注释，以突出显示关键信息或提醒。\n内部链接（Wikilinks）：可以使用双括号 [[ 和 ]] 来创建内部链接，链接到其他笔记或文件。\n时间戳链接（Timestamp Links）：可以使用 [[YYYY-MM-DD]] 的格式创建时间戳链接，链接到特定日期的笔记。\n标签链接（Tag Links）：可以使用 #[tag] 的格式创建标签链接，链接到具有相同标签的笔记。\n这些特性使得 Obsidian 用户可以更方便地创建交互式笔记，并在笔记之间建立丰富的关联。\n此外，Quartz 还允许你在笔记中指定额外的元数据，称为 frontmatter。\ncontent/note.md\n--- title: 示例标题 draft: false tags: - 示例标签 --- 你的其余内容在这里。你可以在这里使用 Markdown :) 一些常见的 frontmatter 字段，Quartz 本身支持：\ntitle: 页面标题。如果没有提供，Quartz 将使用文件名作为标题。 description: 页面描述，用于链接预览。 aliases: 此笔记的其他名称。这是一个字符串列表。 tags: 此笔记的标签。 draft: 是否发布页面。这是在 Quartz 中创建私密页面的一种方式。 date: 表示笔记发布日期的字符串。通常使用 YYYY-MM-DD 格式。 同步你的内容\n当你对 Quartz 满意时，你可以将更改保存到 GitHub。首先确保你已经设置了 GitHub 仓库，然后运行 npx quartz sync。\n自定义\n标题、标签、别名和 cssclasses 的 frontmatter 解析是 Frontmatter 插件的功能，日期由 CreatedModifiedDate 插件处理，描述由 Description 插件处理。查看插件页面以获取自定义选项。\n配置 原文 ↗ Quartz旨在非常可配置，即使您不懂编程也可以进行大多数配置。您应该需要的大多数配置只需编辑quartz.config.ts或更改quartz.layout.ts即可。\n提示 如果您使用像VSCode这样具有TypeScript语言支持的文本编辑器来编辑Quartz配置，当您在配置中出现错误时，它会提醒您，帮助您避免配置错误！\nQuartz的配置可以分为两个主要部分：\nquartz.config.ts\nconst config: QuartzConfig = { configuration: { ... }, plugins: { ... }, } 通用配置 这部分配置涉及可能影响整个站点的任何内容。以下是您可以配置的所有内容的列表：\npageTitle：站点标题。这也用于生成站点的RSS Feed时。 enableSPA：是否在站点上启用SPA路由。 enablePopovers：是否在站点上启用浮窗预览。 analytics：站点分析使用什么。值可以是 null：不使用分析； { provider: 'google', tagId: '\u0026lt;your-google-tag\u0026gt;' } ：使用Google Analytics； { provider: 'plausible' }（托管）或{ provider: 'plausible', host: '\u0026lt;your-plausible-host\u0026gt;' }（自托管）：使用Plausible； { provider: 'umami', host: '\u0026lt;your-umami-host\u0026gt;', websiteId: '\u0026lt;your-umami-website-id\u0026gt;' } ：使用Umami； { provider: 'goatcounter', websiteId: 'my-goatcounter-id' }（托管）或{ provider: 'goatcounter', websiteId: 'my-goatcounter-id', host: 'my-goatcounter-domain.com', scriptSrc: 'https://my-url.to/counter.js' }（自托管）：使用GoatCounter。 locale ：用于国际化和日期格式化。 baseUrl ：这用于需要绝对URL的站点地图和 RSS feeds，以了解站点的规范‘home’位于何处。这通常是站点的部署URL（例如，对于此站点，quartz.jzhao.xyz）。不包括协议（即https://）或任何前导或尾随斜杠。 如果您在 GitHub 页面上没有自定义域名的情况下托管，则此还应包括子路径。例如，如果我的存储库是 jackyzha0/quartz，则GitHub页面将部署到 https://jackyzha0.github.io/quartz，并且 baseUrl 将是 jackyzha0.github.io/quartz。 请注意，Quartz 4将尽可能避免使用此功能，并且在任何情况下都可以使用相对URL以确保您的站点正常工作。 ignorePatterns ：Quartz应忽略并在查找内容文件夹中查找文件时不应搜索的一组glob模式。有关更多详细信息，请参见私有页面。 defaultDateType ：默认要在页面和页面列表上显示的日期是使用created、modified 还是 published。 theme ：配置站点外观。 cdnCaching ：如果为true（默认值），则使用Google CDN缓存字体。这通常会更快。如果要使Quartz下载字体以便自包含，请禁用（false）它。 typography ：要使用的字体。Google字体中的任何字体都可以在这里使用。 header ：标题使用的字体 code ：内联和块引用的字体。 body ：所有内容的字体 colors ：控制站点的主题。 light ：页面背景 lightgray ：边框 gray ：图链接，更重的边框 darkgray ：正文文本 dark ：标题文本和图标 secondary ：链接颜色，当前图节点 tertiary ：悬停状态和已访问的图节点 highlight ：内部链接背景，突出显示的文本，代码行 插件\n您可以将Quartz插件视为内容上的一系列转换。\nquartz.config.ts\nplugins: { transformers: [...], filters: [...], emitters: [...], } 变换器（transformers）对内容进行映射（例如，解析frontmatter、生成描述） 过滤器（filters）过滤内容（例如，过滤掉草稿） 发射器（emitters）在内容上减少（例如，创建RSS Feed或列出所有具有特定标签的文件的页面） 您可以通过在transformers、filters和emitters字段中添加、删除和重新排序插件来自定义Quartz的行为。\n注意 每个节点都按顺序由每个变换器修改。某些转换器是位置敏感的，因此您可能需要特别注意它们是在哪些其他插件之前还是之后。\n您应该小心将插件添加到与其插件类型相对应的正确条目中。例如，要添加ExplicitPublish插件（一个过滤器），您将添加以下行：\nquartz.config.ts\nfilters: [ ... Plugin.ExplicitPublish(), ... ], 要删除插件，应从 quartz.config.ts 中删除它的所有出现。\n要进一步自定义插件，一些插件还可能具有自己的配置设置，您可以传递给它们。如果您没有传递配置，则插件将使用其默认设置。\n例如，Latex 插件允许您传递一个字段，指定 renderEngine 以在 Katex 和 MathJax 之间进行选择。\nquartz.config.ts\ntransformers: [ Plugin.FrontMatter(), // 使用默认选项 Plugin.Latex({ renderEngine: \u0026#34;katex\u0026#34; }), // 设置一些自定义选项 ] 某些插件默认包含在 quartz.config.ts 中，但还有更多可用。\n您可以在此处查看所有插件及其配置选项的列表。\n如果您想制作自己的插件，请参阅制作自定义插件指南。\n语法高亮 原文 ↗ 插件/变换器 此插件用于在Quartz中的代码块中添加语法高亮。有关更多信息，请参见语法高亮。\n注意 有关如何添加、删除或配置插件的信息，请参阅配置页面。\n此插件接受以下配置选项：\ntheme：Shikiji 捆绑的主题之一的单独 ID。一个用于浅色模式，一个用于深色模式。默认为 theme: { light: \u0026quot;github-light\u0026quot;, dark: \u0026quot;github-dark\u0026quot; }。 keepBackground：如果设置为 true，则将使用 Shikiji 主题的背景。如果为 false（默认值），则将改用 Quartz 主题颜色作为背景。 此外，您还可以在 quartz/styles/syntax.scss 文件中进一步覆盖颜色。\nAPI\n类别：变换器 函数名称：Plugin.SyntaxHighlighting()。 来源：quartz/plugins/transformers/syntax.ts\nSPA 路由 原文 ↗ 单页面应用程序风格的渲染。这可以防止出现未经样式化的内容闪烁，并提高了 Quartz 的流畅度。\n在底层，这是通过劫持页面导航来完成的，而不是直接通过 GET 请求获取 HTML ，然后使用 micromorph 进行差异化和选择性地替换页面的部分。这使我们能够在不完全刷新页面的情况下更改页面的内容，减少浏览器需要加载的内容量。\n配置 禁用SPA路由：将 quartz.config.ts 中配置的 enableSPA 字段设置为 false。\n","date":"2024-02-29","tags":["编程","quartz"],"title":"Quartz 教程","url":"/post/2024/02/quartz/"},{"content":"C语言系列 《C漏洞与缺陷》 《C语言深度解剖》 《C和指针》 《明解C语言》 C++系列 《高质量的C/C++编程》 《程序员的自我修养》 java系列 《java编程思想》 计算机系列 深入理解计算机系统 数据结构 《大话数据结构》 内存 《地址的故事》 编程 《程序员编程故事》 算法 《剑指offer》 ","date":"2023-11-29","tags":["书"],"title":"C 语言推荐书籍","url":"/post/2023/11/c_book/"},{"content":"技术领导力 《C语言程序设计（第二版）》 《深入理解计算机系统》 《UNIX环境高级编程》 《UNIX网络编程》 《Windows核心编程》 《TCP/IP详解》 每个程序员都应该要读的书 《Code Complete (2nd edition) 》《代码大全》 《The Pragmatic Programmer》 《程序员修炼之道》 《Structure and interpretation of Computer Programs》 《The C Programming Language》 《Introduction to Algorithms 》 《Design Patterns》 《Refactoring: Improving the Design of Exsting Code》 《The Mythical Man Month》 《The Art of Computer Programming》 《Compilers: Principles, Techniques and Tool》 \u0026hellip;\u0026hellip; 推荐 《代码大全》 《程序员修炼之道》 《计算机的构造和解释》 《算法导论》 《设计模式》 《重构》 《人月神话》 《代码整洁之道》 《Effective C++》/《More Effective C++》 《Unix编程艺术》《Unix高级环境编程》 经典文章 《What every computer science major should know》 《LinkedIn\u0026rsquo;s Tips for Highly Effective Code Review》 《A Large-Scale Study of Programming Language and Code Quality in Github》 《Optimizing Software in C++ - Agner Fog》 ","date":"2023-11-29","tags":["经验"],"title":"左耳朵耗子：技术领导力","url":"/post/2023/11/houle/"},{"content":" OpenWRT下载地址 ↗ 下载 制作启动盘 将PE系统写入到U盘，window：rufus，macOS：balenaEtcher 将OpenWRT镜像、rufus（在PE系统上写盘会需要）拷贝到写完的U盘里（也可以用另一个U盘）\n进入BIOS 将U盘插入至路由器，根据硬件选择启动顺序为U盘，笔者的路由器是F12\n删除设备的磁盘分区 进入PE系统之后，打开rufus（按Ctrl-Alt-F开启内部磁盘的识别），选择OpenWRT镜像并将其写入到内置的磁盘\n写入镜像 (IMG写盘工具) 打开IMG写盘工具, 选择设备的物理盘, 选择OpenWrt镜像\n重启 写入完成之后，就可以拔掉U盘，重启后进入OpenWRT了\n其他信息 ip: 一般是: 192.168.5.1, 可以自己改 账号密码: 账号是 root, 密码不填, 直接登录即可\n","date":"2023-10-29","tags":["运维","openwrt"],"title":"OpenWRT 教程","url":"/post/2023/10/openwrt/"},{"content":"25~35岁是每个人最宝贵的时间，应该用在刀刃上\n本质上来说，程序员就是个手艺人，有手艺的人就能做出别人做不出来的东西，而付费就是一件很自然的事了。\n提升方法 要去经历大多数人经历不到的， 要把时间花在那些比较难的地方。 要写文章就写没有人写过的，或者是别人写过，但是自己能写得更好的。 更重要的是， 技术和知识是完全可以变现的。 如何变现 一、积累 千里之行，积于跬步。任何一件事都是通过小成功达到的，所以你得确保自己有一个一个的小成功，具体来说，你得让你身边的人 有求于你，或是向别人推荐你，这就需要你能够掌握大多数人不能掌握的技术，需要你更多地去学习，并要更多的别人没有的经验和经历。\n二、关注有价值的东西 不仅要看到市场，还要看到技术的趋势，能够分辨什么是主流的技术，什么是过渡的技术。以具备先发优势。\n关注市场：看清市场，看到各个公司都在做什么，他们的难题是什么，中国不缺人，缺的是能够解决技术难题的人。 关注技术：看清技术趋势，你需要将一些老技术吃透，并推测出他未来的走向。 所以在学习技术的过程中一定要多问自己两个问题：\n这个技术解决了什么问题？为什么别的同类技术做不到？ 为什么是这样解决的？有没有更好的方式？ 另外还有一种简单的判断方法：\n如果一个新的技术顺应技术发展趋势，那么这个新的技术出现时，后面一定会有大学的商业公司支持，这类公司支持越多，就说明你越需要关注\n三、找到能体现价值的地方 在一家高速发展的公司中，技术人员的价值可以达到最大，这并不是之大型的成熟公司或许新兴的创业公司，前者是因为稳定性大于创新性，而后者是因为业务还没有跑顺，不需要高精尖的技术。\n四、动手能力很重要 在解决任何一个具体问题的时候，有没有动手能力就成为了关键。只有实践了解细节，你才能提出更好或是更靠谱、可以落地的解决方案，二不是一下笼统和模糊的东西。\n五、关注技术付费点 一是能帮别人挣钱，二是能帮别人“省钱”。也就是说，能够帮别人更流畅地挣钱，或是帮别人提供效率，能够节省更多的成本。而且这个技术或是解决方案最好还是别人做不到的。\n六、提升自己的能力和经历 付费的前提是信任只有提升自己的能力和经历后，别人才会对你有一定的信任，才会觉得你靠谱，才会给你机会。\n七、找到有价值的信息源 在信息社会，如果你比别人有更好的信息源，就意味着你可以比别人成长得更快。对于技术人员来说，几乎所有的技术都来自西方时世界，所以你应该走到信息的源头去。 如果你的信息来自朋友圈、微博、知乎、百度、或是今日头条，那么我觉得你完蛋了。因为这些渠道有就价值的信息不多，有营养的可能只有1%，而为了这1%，你需要读完99%的信息，太不划算了。\n那么如何用好信息源呢？用好Google就是一个关键，比如你在Google搜索引擎里输XXX best practice或是Best programming resource你就会找到很多。而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。\n八、输出观点和价值观 只有输出先进的价值观，才会获得真正的影响力，但是你要能输出观点和价值观并不是一件容易的事，这需要你长期的经历和积累，这本质上一个厚积薄发的过程。\n九、朋友圈很重要 你在什么样的朋友圈，就会有什么样的朋友。优质的朋友圈基本都有这样的特性：\n这些人都比较有想法，有观点，经验也比较丰富 这些人涉猎的面都比较广 这些人都有或多或少的成功 这些人都是喜欢折腾喜欢搞事情的人 这些人都对现状有些不满，并想做一些改变 这些人都有一定的影响力 最后有一个冠关键问题：物以类聚，人以群分，你如何才能进入这样的朋友圈呢？ 会挣钱的人一定是会投资的人，我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱宝贵，因为钱不用它还在那里，但是时间你不用你就浪费掉了。 你把时间投资在什么地方，就意味着你未来会走什么样的路。\n所以利用好你的时间，投到一些有意义的地方吧！\n","date":"2023-09-29","tags":["经验"],"title":"左耳朵耗子：程序员","url":"/post/2023/09/coder/"},{"content":" 原文链接 ↗ 查看 CPU 架构 uname -m：该命令会输出当前系统的CPU架构，如x86_64、i386、armv7l等。 arch：该命令可以查看Linux系统的CPU架构。 cat /proc/version：该命令可以查看系统内核的版本信息。 cat /proc/cpuinfo：该命令可以查看CPU信息，如每个物理CPU中core的个数、逻辑CPU的个数、CPU型号等。 脚本目录 ↗ X86_64 架构安装 切换到root账号 sudo -i 下载脚本 wget http://ipkg.nslu2-linux.org/optware-ng/bootstrap/buildroot-x86_64-bootstrap.sh 添加可执行权限 chmod \u0026#43;x buildroot-x86_64-bootstrap.sh 执行脚本 ./buildroot-x86_64-bootstrap.sh 升级ipkg /opt/bin/ipkg update 安装gcc /opt/bin/ipkg install gcc ARM 架构安装 切换到root账号 sudo -i 安装脚本 切换到临时目录，下载一个脚本 buildroot-armeabihf-bootstrap.sh，并添加可执行权限\ncd /volume1/@tmp wget http://ipkg.nslu2-linux.org/optware-ng/bootstrap/buildroot-armeabihf-bootstrap.sh . chmod \u0026#43;x buildroot-armeabihf-bootstrap.sh 执行脚本 ./buildroot-armeabihf-bootstrap.sh 升级ipkg /opt/bin/ipkg update 安装gcc /opt/bin/ipkg install gcc 可选 设置别名\nalias ipkg=/opt/bin/ipkg ","date":"2023-08-29","tags":["编程","群晖"],"title":"群晖开发","url":"/post/2023/08/synology/"},{"content":"浮点数的存储 IEEE745 国际标准：\n任意一个二进制的浮点数可以表示为下面的形式：\nV = (-1)^s^ * M * 2^E^ (-1)^s^表示符号位，当S=0的时候V为正数，当S=1的时候V为负数 M表示有效数字，大于等于1，小于2; 1\u0026lt;= M \u0026lt;2 2^E^：E表示指数位 科学计数法：123.45 = 1.2345 * 10^2^\n举例：\nV = 5.0 f\n二进制：101.0\n科学计数法：1.01 * 2^2^\niEEE：(-1)^0^ * 1.01 * 2^2^\nS = 0; M = 1.01; E = 2\nV = 9.5f\n二进制：1001.1 小数点后面的权重从左往右为2^-1^ ，2^-2^ ， 2^-3^ \u0026hellip;\u0026hellip;表示1/2^1^， 1/2^-2^，1/2^-3^ \u0026hellip;\u0026hellip;即为0.5，0.25， 0.125\u0026hellip;\u0026hellip; 科学计数法：1.0011 * 2^3^ IEEE：(-1)^0^ * 1.0011*2^3^ S = 0; M = 1.0011; E = 3 精度丢失：\nV = 9.6f 二进制：1001.100\u0026hellip;\u0026hellip;(难以精确) float - 4byte - 32bit double - 8byte - 64bit 浮点数在内存中无法精确保存 对与浮点数，最高位的1位是符号位S，接着8位是指数E，剩下23位位有效数字M M：可以写成1.xxxxxx，在计算机内部保存时，默认M的第一位总是1，因此可以被舍去，只保留后面的xxxxx 部分，比如保存1.01时，舍去前面的1，保留后面的01，等到读取的时候再把第一位加上去，这样做的目的是节省一位有效数字，以单精点浮点数为例原本23位有效数字，在舍去一位后可以保存24位 E：为一个无符号整数，如果E为8位，它的取值范围是0-255；如果是11位，它的取值范围是0-2047。但是科学计数法是可以出现负数的（0.5 = 0.1 * 2^-1^ ），因此规定，存入时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E这个中间数是1023，存储值 = E(真实值) + 127(float) / 1023(double) (中间值) 比如：2^10^ 的E时10，所以保存成32位浮点数时，必须保存位10+127=137，即10001001 #include\u0026lt;stdio.h\u0026gt; int main(){ float f = 5.5; //5.5 //101.1 //1.011 * 2^2 ----科学计数法 //S=0; M=1.011; E=2 //0 ----符号位 //2 \u0026#43; 127 = 129 ----有效数字 //129 = 1000 0001 ----二进制 //011 ----指数 //指数位为23位，不够补零 //011 0000000000 0000000000 //内存存储：0 10000001 01100000000000000000000 ---二进制 //内存存储：0100 0000 1011 0000 0000 0000 0000 0000 = 0x40 b0 00 00 ---十六进制 return 0; } //输出 40 b0 00 00 取出：\nE的三种情况\nE不全为0或不全为1时，既有0又有1\n指数的E减去127（或1023），得到真实值，再将有效数字M得前面加上第一位的1\n比如0.5(1/2)的二进制形式为0.1，由于规定正数必须为1，即将小数右移一位，则为1.0 * 2^-1^ 其阶码为 -1+127 = 126表示为01111110，而尾数1.0去掉整数部分为0，补齐到23位00000000000000000000000，则二进制表示为:\n0 011111110 00000000000000000000000 E全为0\n浮点数的指数E等于1-127（或1-1023）即为真实值 有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数，这样做是为了表示+-0，以及接近0的很小的数字 E全为1\n这是，如果有效数字M全为1，表示+-无穷大，正负值取决上符号位的S #include\u0026lt;stdio.h\u0026gt; int main(){ int n = 9; // 00000000 00000000 00000000 00001001---整数的原码，反码，补码相同 // float* pFloat = (float*)\u0026amp;n; printf(\u0026#34;n为：%d\\n\u0026#34;,n);//9 printf(\u0026#34;n为：%f\\n\u0026#34;,*pFloat);// 0.000000无限接近于0的数 // 0 0000000 00000000 00000000 00001001--- // E= -126 \\ // M = 0.000000000000000000000000001001 // \u0026#43;0.000000000000000000000000001001 * 2^-126 // *pFloat = 9.0; //1001.0 // 1.001 * 2^3 // S = 0; E = 3; M = 1.001 //0 10000010 00000000000000000000000 --- 内存存储 printf(\u0026#34;num为：%d\u0026#34;, n); //1091567616 // \u0026#43;1091567616 （正数原码补码相同） //01000001000000000000000000000000 printf(\u0026#34;*pFloat为：\u0026#34;,*pFloat);//9.0 } ","date":"2023-07-29","tags":["编程"],"title":"浮点数的存储","url":"/post/2023/07/float_at_mem/"},{"content":"C/C++\n函数栈帧的创建和销毁\n在学习最基础的C语言程序的语法与使用时，但你是否有疑问？\n比如：\n函数的作用域是怎么形成的呢？\n局部变量是如何创建的？\n为什么未初始化的局部变量的值是随机值或是乱码呢？\n函数是如何传参的？\n传参的顺序又是怎么样的呢？\n形参和实参的关系是什么？\n函数的调用是怎么实现的呢？\n函数调用结束后是怎么返回的呢？\n为什么会存在函数递归的最大深度呢？\n到达最大深度所提出的堆栈溢出错误是什么意思呢？\n当你了解了函数的栈帧创建与销毁的时候，这些疑惑将会一一解开！带着这些问题，我们来进入函数栈帧！\n由于篇幅较长，本系列文章共分为上、下两篇。本篇为上篇，将主要介绍：\n有疑问欢迎在公众号后台回复。\n什么是寄存器？ 什么是栈？ 函数栈帧的形成过程 函数变量的形成过程 了解函数栈帧需要涉及到反汇编操作，笔者会根据相关的汇编指令来介绍。\n圆规正转，进入正题！\n什么是寄存器？ 首先需要了解的：什么是寄存器？\n计算机硬件中，具有存储功能的硬件有什么？\n它们分别是 硬盘 \u0026ndash;\u0026gt; 内存 \u0026ndash;\u0026gt; 高速缓存(cache) \u0026ndash;\u0026gt; 寄存器，它们4个中访问速度和存储速度由上至下不断递增；\n同时，它们的大小是从下至上依次递减的。\n到最顶上的寄存器，它的存储空间可能只有4byte位的存储单元大小，但它的访问速度是最快的，因为寄存器一般是集成在CPU上，与内存是不同的独立的存储空间。\n常言道，网速飞快是坐在服务器上打游戏，而读取速度越快就是坐在CPU上读取，寄存器读取快就是这个道理。\n寄存器分类 计算机的寄存器还分多种，在程序中我们常用到：\n一般寄存器:EAX、EBX、ECX、EDX\nax:累积暂存器，bx:基底暂存器，cx:计数暂存器，ed:资料暂存器\n索引暂存器:ESI、EDI\nsi:来源索引暂存器，di:目的索引暂存器\n堆叠、基底暂存器:ESP、EBP\nsp:堆叠指标暂存器，bp:基底指标暂存器；\n这两个寄存器，也是函数栈帧中最重要的两个寄存器\n其中：\nEAX、ECX、EDX、EBX：\n为ax,bx,cx,dx的延伸，各为32位\nESI、EDI、ESP、EBP：\n为si,di,sp,bp的延伸，各32位\nEAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。\n寄存器用途 那么，它们在程序中的用途是怎么样的呢？\n这些32位的寄存器但每一个都有“专长”，有各自的特别之处。\nEAX 是\u0026quot;累加器\u0026quot;(accumulator), 它是很多加法乘法指令的缺省寄存器。\nEBX 是\u0026quot;基地址\u0026quot;(base)寄存器, 在内存寻址时存放基地址。\nECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。\nEDX 则总是被用来放整数除法产生的余数。\nESI/EDI分别叫做\u0026quot;源/目标索引寄存器，因为在很多字符串操作指令中，其中DS:ESI指向源串，而ES:EDI指向的是目标串。\nEBP是\u0026quot;基址指针\u0026quot;， 它最经常被用作高级语言函数调用的\u0026quot;框架指针\u0026quot;。\n在破解软件时,经常可以看见一个标准的函数起始汇编代码:\npush ebp ;保存当前ebpmov ebp,esp ;EBP设为当前堆栈指针sub esp, xxx ;预留xxx字节给函数临时变量\u0026hellip;.这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp/pop ebp/ret 即可.\nESP 专门用作堆栈指针，被形象地称为栈顶指针。\n堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。\n在32位操作平台上，ESP每次会减少4个字节。\n关于寄存器的概念就说到这。实际运用起来是将内容存到寄存器内而使用其地址。真正与形成函数栈帧有密切关系的是：EBP和ESP这两个寄存器地址。\n什么是\u0026quot;栈\u0026quot;？ 在开始讲解前，需要再注意一个关键词：什么是“栈”？\n栈是一类数据存储结构，本篇不会对其实现方法做太多解释，只需要了解它的一个特性：数据依次放入栈内后，取出元素时顺序是最先进入的元素最后出；\n例如在一个木桶内放入一堆书籍，在你需要取出底部的书时，你需要先把上部分内容取出才能取出最底部的内容。而本篇说的栈区，与我们常说的数据结构是两个概念，函数的栈区是在操作系统级别上的，管理内存区，是主要运行在系统内存之上的。\n函数栈帧的概念 在寄存器内，EBP、ESP这2个寄存器中存放的是地址，这两个寄存器的指针是用来维护函数栈帧的。而这两个指针维护的内存空间就是一个函数的栈帧。\n每一次函数调用时，都需要在栈区内创建一个空间，而创建的过程就是由这两个指针去实现的；调用了哪个函数，EBP、ESP两个指针地址就会去维护这个函数的内存空间，这就是函数的栈帧；例如main函数在运行过程的当中，esp和ebp两个指针地址会位于函数的它的栈顶和栈底。\n这么说，你可能会不理解。那就画图吧！\n可以看到的是，esp和ebp两个指针地址会位于函数的它的栈顶和栈底，维护属于main函数的内存空间，而esp和ebp形成的这一块空间就是函数的栈帧。\n那么，再回到前面的话题，变量、作用域、函数调用和返回等操作又是如何实现的呢？我们需要来进一步了解函数压栈的过程、\n函数压栈的过程 本篇将以本段代码进行举例，以此来介绍函数的栈帧、局部变量和函数调用的生成与销毁的过程。\n在开始讲解前，我们需要了解的一点是，因为不同的编译器对于程序汇编封装的方法可能是不同的，而更高阶的编译器对于程序的封装会更加细致，不利于观察，所以本处我会使用VS2013版本演示函数压栈的过程，并且会带着你一块一步步的读程序运行中的汇编指令并讲解每一个步骤会做出什么样的操作，最后会对整个指令进行一个总结。\n本篇中，我将结合C语言X86(32位)代码生成细节的汇编指令文档来讲解本篇的汇编指令，以下是将会常用到的汇编语句。\n同时，因为汇编指令的地址会随着每次程序编译而变化（因为内容都是随机分配的），如果你在本地也在进行调试时，请保持在同一个编译情景下以免出现前后差异。但原理上都是相通的。\n（观察方式：运行程序-\u0026gt;调试-\u0026gt;反汇编，观察变化需要开启内存空间监视器。）\n需要说明的是，C语言标准中不允许main函数被调用，但是在VS2013之前的版本中，运行程序调试时查看调用堆栈时会发现main函数也是被其他函数调用的。\n分别是__tmainCRTStartup和mainCRTStartup函数，其中，mainCRTStartup压在最底部。\n调用逻辑是mainCRTStartup \u0026ndash; \u0026gt; __tmainCRTStartup \u0026ndash;\u0026gt; main 函数\n当我们开始运行程序时，main函数被调用，栈帧区的建立过程应该是这样的。\n栈帧区的建立过程 mainCRTStartup函数运行__tmainCRTStartup函数\n__tmainCRTStartup函数调用main函数\n根据我们刚刚说的，先运行的会被先压入函数栈的最底部，以此摞下去\n由此，我们可以理解此时的内存栈表示为\n我们刚刚说的，当函数在运行过程当中，会用esp栈顶指针和ebp栈底指针形成一块内存空间而形成函数的栈帧。那么，程序具体是怎么做的呢？\n下面，我们通过查看程序的反汇编的指令来研究它的压栈过程。以下是主函数的部分反汇编代码，现在我们来看看它的具体原理是如何走的。\n主函数汇编指令 (部分)\n我们刚刚提到主函数也是被其他函数调用的，当程序进入主函数时，那这个调用主函数的函数是不是已经创建起它的函数栈帧了呢？答案是肯定的。此时原函数__tmainCRTStartup 是被esp和ebp两个栈顶/底指针维护的。\n最初开始时的栈区应该如图所示\n一、构建函数栈帧准备 (一) 接下来我们来看main函数进来的第一句汇编指令\n进来的第一句话就是push ebp，汇编指令中，它的意思是把ebp的值放到栈顶\n那么我们可不可以假设：因为esp维护的是程序的栈顶，此时的esp已经跑到了栈的最顶部，esp的地址会指向ebp的值？如图所示\n该如何论证这个假设呢？\n当你去开启监视器去监控esp就可以发现它的值会变动。\n当前是esp栈顶指针的初始值\npush ebp完成后，esp地址是不是由高到低，所以地址应该是减小吧？\n监视器进入逐过程时就可以证明这个道理：a8 到 a4 减少了4个字节\n那么esp的值会不会是ebp的值呢？打开内存块，搜索新的esp的地址会是ebp的值，答案一目了然！~\n刚刚ebp的值时多少？008ffbf4, 现在搜索esp的地址的值就是008ffbf4，假设成立。\nesp维护的是程序的栈顶，此时的esp已经跑到了栈的最顶部，新的esp的地址会指向ebp的值\n而压入的这个ebp是调用函数的ebp，它的作用是什么？我们到下一章会进行讲解。\n二、构建函数栈帧准备 (二) 现在我们再来看第二句汇编指令：mov 把esp的值给到ebp。\n事实果真如此吗？我们运行调试下一步，监控器反馈如下\n此时它的栈区示意图应该是\n三、构建函数栈帧的范围 再来看第三句会汇编指令：sub esp的地址，减去0E4h。（sub是英文中减少的意思，add同理为加上）\n通常来说，ebp减去的值都是0E4h，而这里的0E4h实际上是一个八进制的数字。当你想查看0E4h是一个什么数字时，你可以将它放入监控区后可以显示其十六进制的值，再查看十进制数字\n走到这里，不就是相当于esp减去了0E4h的值吧？那此时的esp会不会已经发生变化了呢？监视器逐过程查看结果\n此时的esp的值已经变成了0x008ffac0，相当于esp的地址值变小上移不再指向原来的地方，而是指向原地址上方某一块区域内。\n这个时候你有没有发现，新的esp栈顶和ebp栈顶指针在进入main函数后已经形成的一块新的维度空间，并且esp和ebp不再是维护原来的函数空间了呢？没错，这一块新的区域就是为main函数预开辟的函数栈帧区。而sub就是提出为main函数开辟的多少字节空间。\n栈区示意图可以理解成下面这张图\n四、放入三个非易失寄存器\n这里的ebx、esi、edi是我们前面所说的寄存器中基底、来源索引、目标索引暂存器，它们三个在这里统称为非易失寄存器。这是一个C语言中的调用约定，这里将三个寄存器压栈的原因就是实现跨平台使用。在X86平台下的调用约定下这3个寄存器用途在于，调用函数时要求压入这3个寄存器以此用来保存调用前的数据，应在调用期间长期存储。\n它们此处是在入栈操作，别忘了入栈的同时，esp栈顶指针也在不断的变化。\n入栈的过程详情可以如下：\n观察监视器内esp和ebx的值\nebx开始压入栈时，esp会如何变化呢？答案是肯定的，esp的值会递减向上挪动\n打开内存器时，会发现对应esp的地址是ebx的值0x007e5000\n同理继续往里压入esi时，esp的变化如下\n压入edi时，esp的变化如下\n综上，原来的esp栈顶指针的值已经由最初的008ffac0变成现在的008ffab4，地址在不断的减小，栈顶在不断的上移。\n现在的栈区的示意图可以理解为 五、加载栈帧有效空间 到了这里为了方便直观感受与理解，我们会显示汇编符号名。 到了第七句这里的lea语句，它的全名应该是load effective address(**加载有效地址**)；顾名思义，从此处开始，程序会正式加载当前函数的有效栈帧区域。我们来看看它该如何走吧。 lea edi, [ebp-0E4h]，这里的0E4h是不是很眼熟？没错，就是刚刚在预申请main函数的函数栈帧中所预申请的大小。 在这里的意思就是将ebp - 0E4h大小的空间存到edi当中去，而ebp-0E4h这块空间就是刚刚esp做减法转移动作使的空间位置，同时这个edi不就是栈顶指针指的寄存器吗？ 由栈区图，我们可以观察到如下情景。 如何论证呢？翻到刚刚前面的三个非易失寄存器未压入栈时esp的地址 现在，我们打开监视器查看ebp-0E4h和edi的地址，答案显而易见！~ebp-0E4h的地址就是当前esp所指的第3个栈——edi的位置，也是三个非易失寄存器未压入栈时esp的地址。 再接着，mov ecx,39h和mov eax,0CCCCCCCCh意思分别是，把39h次和0CCCCCCCCh分别放在ecx, eax寄存器内。 **这里可能会有点绕，但真正起作用的应该是下一句！** 下一句：rep stos dword ptr es:[edi] ，这里就非常有意思，此处会最终形成函数的栈帧有效空间。来看看指令语句的表述：\n从**edi**内所标记的ebp-0E4h处(**低地址**)开始向高地址重复**拷贝ecx次eax的内容**，直到**栈底指针ebp处**(高地址)。需要注意的是，**dword表达的是double word双字节的意思**，假设一个word是2个字节，**double word就是双字节等同于4字节**。 它们的具体流程是什么样的呢？**从edi所标记的ebp-0E4h处开始，向高地址的部分进行字节拷贝，每一次拷贝4个字节。拷贝的内容就是eax的内容（0CCCCCCCCh），拷贝次数为39h次，到栈底指针ebp处停止**。 根据上面的描述，程序会从ebp-0E4h（内存地址：008ffac0）处开始往高地址进行字节拷贝 直到ebp栈底指针处；当你打开内存图查看此时的内存情况时，就可以论证这一个观点~ 从008ffac0出开始向高地址拷贝\n到008ffba4栈底指针处结束 可能你会有疑问，这个cccccccc是什么意思呢？它们在各个编译器可能都有些许不同，而当我们平时在编写程序时，**变量未定义初始值时，打印输出来的是“烫烫烫”乱码字符，实际上这就是内存中放的0CCCCCCCCh字符**。 综上，栈区的示意图可以如下\n程序运行到这里，程序历经五步，为main函数开辟的函数栈帧正式完成，这一块由esp和ebp共同维护形成的区域就是一个函数的栈帧，形成完成后会往一块空间内填入39h次的0CCCCCCCCh字符，而这里面的内容能做什么？函数如何调用和返回，会在下一章进行讲解 生成函数的局部变量\n由上面的诸多操作下来，一个函数的有效栈帧区已经形成，此时程序才会真正执行它的有效代码。根据之前写的代码要求，程序一进来会创建局部变量，在栈帧区内，局部变量又是如何被创建的呢？\n首先我们来看汇编指令：这个语法是不是很熟悉呢？语句的的意思是：依次的将0Ah、14h、0放入到\nebp - 8、ebp - 14h、ebp - 20h 位置处。\nebp - 8、ebp - 14h、ebp - 20h是以栈底指针为基准向低地址减小的一串地址，在这里就是开辟一块空间分配给0Ah、14h、0 ，而这个0Ah、14h、0 就是计算机的十六进制的10、20、0的表达形式。所\n现在我们来论证刚刚所说的。首先来继续观察ebp栈底指针的值，看它是不是往低地址存放变量；\n逐过程进入语句，答案很明显，从栈底指针008ffba4处往低地址 - 8处，存放的值就是0ah。此时局部变量a = 10已创建\n我们继续看下一步，创建局部变量 b = 20，后面的c同理。\n根据观察在栈帧中局部变量的创建过程，我们可以发现局部变量是在形成一片有效的栈帧空间后，由高地址向低地址存放。如果变量未设置初始值时，程序会划定好一块区域规定为该变量的地址。\n此时的栈区示意图可以如下\n本节小节 本篇我们基于main主函数简单介绍了一个函数的栈帧建立的基本过程；我们了解到，一个函数的栈帧实际上是由esp和ebp两个栈顶和栈底指针共同维护的一片内存空间；当一个函数在开始生成栈帧以后，会首先压入上一个函数的栈底指针ebp地址。在生成栈帧过程中，不断扩大的栈帧、压入新的内容或寄存器都会使得esp栈顶指针向上偏移；在进行确定方位相关操作时，都是以栈底指针ebp的位置作为偏移量向低地址开始偏移的。在压入3个非易失寄存器后，程序会基于ebp栈顶指针向低地址的填充一块区域，而这块区域就是一个函数的作用域。在这块作用域中，程序会根据ebp指针向上（低地址）作为方位，生成对应的变量。 下一篇，我们将会介绍函数的调用与返回过程，以及对我们开篇提出的问题做出一个总结。\nC/C++：函数栈帧的创建与销毁(下) 上一篇中，我们介绍了什么是寄存器、已经一个函数栈帧创建的基本过程和函数变量和作用域是如何生成的。那么本篇我们将继续上一篇内容，继续介绍函数的调用过程以及函数返回值，以及函数栈帧销毁的过程。最后，我们会对整个过程以及相关知识点进行一个总结。\n生成函数的局部变量 由上面的诸多操作下来，一个函数的有效栈帧区已经形成，此时程序才会真正执行它的有效代码。根据之前写的代码要求，程序一进来会创建局部变量，在栈帧区内，局部变量又是如何被创建的呢？\n首先我们来看汇编指令：这个语法是不是很熟悉呢？语句的的意思是：依次的将0Ah、14h、0放入到\nebp - 8、ebp - 14h、ebp - 20h 位置处。\nebp - 8、ebp - 14h、ebp - 20h是以栈底指针为基准向低地址减小的一串地址，在这里就是开辟一块空间分配给0Ah、14h、0 ，而这个0Ah、14h、0 就是计算机的十六进制的10、20、0的表达形式。所\n现在我们来论证刚刚所说的。首先来继续观察ebp栈底指针的值，看它是不是往低地址存放变量；\n逐过程进入语句，答案很明显，从栈底指针008ffba4处往低地址 - 8处，存放的值就是0ah。此时局部变量a = 10已创建\n我们继续看下一步，创建局部变量 b = 20，后面的c同理。\n根据观察在栈帧中局部变量的创建过程，我们可以发现局部变量是在形成一片有效的栈帧空间后，由高地址向低地址存放。如果变量未设置初始值时，程序会划定好一块区域规定为该变量的地址。\n此时的栈区示意图可以如下\n函数调用与传参过程 上面已经完成了局部变量的创建，那程序的调用函数操作时如何进行的呢？接下来我们来看一看！废话不多说，先看汇编指令：\n前面讲解了这么多汇编指令，到这里看到的指令是不是开始按捺不住跳动的DNA了呢（bu）？能不能直接说出它们都做了什么呢？ 第一、第三句的mov，含义是将ebp-14h和ebp-8分别放到eax和ecx当中去，我们翻到上一步，看看 ebp-14h和ebp-8是什么呢？根据栈底指针向低地址偏移观察可以看到，没错，就是我们a和b的值。这里是将a和b分别放入寄存器eax和ecx中去。 第二、第四局中的push，是压入栈的指令。分别将eax和ecx压入栈(别忘了每一次压入栈时，程序的栈顶指针也在变化哦)，而eax和ecx现在里面是什么呢？不就是a和b的值吗？ 此时顶部栈区的示意图应该如下\n通过示例函数中我们可以看到。这4个动作是不是很像在进行传参前的准备呢？答案是确定的。那这样的放入和压入操作真的可以把参数传入函数嘛？调用函数又是如何使用我们的参数的呢？让我们继续往下看！\n第五句，call实际上是一个转移指令，转移到另外一个区域内，同时为了执行转移后完成原区域的下一条指令，call指令会总是会将下一条指令压入栈区中，以此实现转移区内指令完成后返回至原地（简单来 说，原地插个眼后传送去支援，最后还能传送回到线上。做到有去有回）。到这里，我们知道call指令会将原区域内的下一个指令的地址压入栈，所以栈顶应该就是下一条指令（00C21450） 的地址，打开内存和监视器确认果真如此 继续看，call指令的右边的一串标识，实际是call的“传送”位置，这个时候我们按下调试的F11进入到声明处，会看到声明处的指令。这里的jmp，就是跳入add函数当中去（本处只需了解jmp也是个转移操作，会在后续深挖细节） 接下来，我们继续往下走，欢迎来到Add函数的内部！！\n到这里函数的调用和传参操作已经完成了，我们可以总结出来的是： 传参时：程序在传参前会把要传入的参数先放入到寄存器当中，并将寄存器地址压入栈中。再观察他们的顺序 a-\u0026gt;b，是由左往右依次压入栈的（示意图显示b在上，根据栈的先进后出原则证明b是后进的），同时栈顶指针在时刻变化。 调用函数时：在调用函数时，程序会使用call指令进入函数，call指令首先会将调用函数完成后的下一步指令压入栈区中，以此实现调用后返回至原函数继续执行内容的操作，接着就会根据标识进行转移，最后进入到新的函数中。 此时栈区顶部示意图应该如下：\n新函数的栈帧的生成 进入到Add函数内，观察到参数z形成前的所有代码，是不是有一种恍然之间中遇见梦中的那个TA的一般的感觉呢？ 没错，这里是在将Add函数基础元素压入栈区并形成其作用域，最后生成这个函数内的局部变量； 这里唯一需要提醒的一点是，我们前面所提到的esp和ebp是用来维护当前运行函数的指针，而push ebp处，实际上是压入main函数的ebp栈底指针地址，以此实现ebp的转移以及函数运行完成后ebp返回原处。\n下面一部分就是形成有效的Add函数栈帧区了，由此可以得到栈顶区域的示意图（画完才发现有点粉\u0026hellip;\u0026hellip;\n粉色即正义！）\n接下来，我们来观察新函数内是如何使用传入进来的参数的。\n函数形参的使用 在开始学习C语言程序时，我们之前一直知道一个函数传参的理论：形参是实参的一份临时拷贝。现在我们来看看它是怎么执行的！ 话不多说，上汇编指令！\n观察这段汇编指令，ebp+8, ebp+0Ch，顺应十六进制转化就是ebp+8和ebp+12，结合当前ebp所指向的位置翻看栈帧区，这两个位置指向的是哪里呢？\n没错，就是进入函数前就已经早早压入栈的函数形参。形参和实参在栈上是两个独立的个体存在，形参的改变不会影响到原来实参的改变，所以有形参是实参的一份临时拷贝。\n汇编指令处，mov 会把ebp+8(a)的值放入寄存器eax中，add会把ebp+12(b)的值加进寄存器eax当中去，这也是程序实现加法的原理。\n再看下一条，mov 将寄存器eax内的值放入到ebp-8的位置，ebp-8是什么？ebp-8就是z的值！此时它已经从0变成了30。\n到这里我们可以看到，在一个函数内，形参是实参的一份临时拷贝，因为程序是不会主动创建的形参 的，在我们调用这个函数之前程序就已经早早把将会用到的形参压入到栈上的，程序只要往前面去拿就可以拿到想要的形参值。这就是函数的形参使用原理。\n函数返回值与函数返回的实现 栈帧销毁的过程） 我们前面看到，程序会把a+b的值结果赋值给z，再将z返回。按照我们之前所学的，程序会在出作用域内会将局部变量销毁，而z又是在新函数内临时生成的局部变量，那程序又是如何拿到z的返回值的呢？而程序在运行结束后，又是怎么将esp和ebp两个栈顶和栈顶指针回到原位，程序又是如何回到原函数内的下一条指令的呢？\n接下来，我们继续通过汇编指令回答这一个问题。\n前面带着你看了那么多汇编指令，现在5秒钟时间可以回到我第一句汇编指令是什么意思吗？5...4...3...2...1，答案没错，就是把ebp-8的值放入到eax当中去。而ebp-8的值就是刚刚z的位置，那么我们可以得到，函数的返回值，通常会放入到临时存放到寄存器eax当中去（为什么叫通常，因为超出寄存器大小时会借用其他的寄存器，比如esi） 再继续往下看，pop指令是什么意思呢（英文含义是什么）？pop指令出栈的意思，将元素弹出栈区以此释放掉。这里连续的3个pop，想想这是啥？是一个函数顶上的3个非易失寄存器。当函数要返回结束时，这3个寄存器会被弹出去。需要注意一点，弹出栈时esp的位置也在调整（向高地址挪动相加） 弹出栈前esp和ebp的值\n弹出3个寄存器地址完成后。\n程序要结束弹出栈区了，那我的esp和ebp指针是不是也要回到原地了呢？来下一句的mov esp,ebp，就是在调整esp和ebp的位置，将ebp的值给到esp。\n此时，程序pop掉add函数内的ebp，这里的ebp是在进入Add函数时压入的栈的main函数ebp，那它是如何返回的呢？这需要提到pop指令的一个用法，pop指令可以实现用一个寄存器接收出栈的数据，此处的pop实际上就是将Add函数的ebp弹出后，又获取到原来压到栈上的main函数的ebp，做到ebp的跳转，这就是此处的pop ebp的作用。 到下面的ret，就比较有意思了。ret是什么意思呢？ret是将栈顶字单元出栈，其值赋给IP寄存器，实现了一个程序的转移。在汇编语言中，IP寄存器是表示即将执行的下一条指令的段内偏移地址。那现在栈顶元素是什么呢？\n还记得现在栈顶的这个（00C21450）元素是什么嘛？如果不太了解，答案在这！这是在调用函数前，程序预留的call指令的下一条指令的地址。通过ret指令，程序已经回到main函数内部了。 到此，程序栈区示意图可以如下图\n综上所述我们可以了解到：\n函数返回值的操作是，会暂时将返回值放入到寄存器eax当中去；\n当函数运行即将返回时，程序首先会销毁当前函数的局部变量，随后悔将放置在函数栈帧上的3个非易失寄存器以此由上至下弹出栈区；\n紧接着程序会把当前栈底指针的ebp的值，赋值给栈顶指针esp，栈帧区的收缩调整，以此实现销毁一个函数的栈帧；与此同时，程序会读取曾经存储在栈区上原函数的ebp的地址（当前位于栈顶），并将ebp转移至之前记录的地址上，之后再弹出压在栈上原函数ebp的地址元素，实现ebp返回至原函数内。\n最后，程序会进行ret 操作，目的是读取调用函数前压在栈上的下一条指令的地址，以此实现调用函数后返回至原函数还能继续执行指令的操作。\n根据以上步骤，可得当前栈区示意图\n返回后形参的销毁与原函数获取返回值 前面我们提到，形参并非是在新函数栈帧区内创建的，而是临时拷贝一份实参后压在栈上的元素。当函数运行完成后，它的形参又该如何销毁的呢？通过前面的许多步骤和观察上方的函数当前栈帧示意图，现在开动你聪明的大脑思考形参会如何处理时一定会有所思路吧！或许你的思路和答案完全一致，就是弹出栈区。 本处只会讲到两句指令。话不多说，上才（hui）艺（bian）！ 现在大声告诉我！add esp,8是什么意思？ 答案就是，esp向高地址出挪上8个字节，而我们前面说一个32位机器上一个栈帧元素是4个字节，那现在向高地址挪动8个字节，不就是把原来存放在栈帧上的2个形参的空间给销毁了么？一个函数的形参销毁的答案就是如此，不接受任何反驳QWQ！~\n到现在，我们程序也返回了，形参也销毁了，返回值说：“我呢？我呢？”别急，再看下一句，说说看这句话是什么意思呢？ 答案：把eax里面的值放到ebp-20h处。\n而eax刚刚不就是放的是Add函数的返回值么？到ebp-20h处，我们刚刚提到，ebp已经返回到原函数了，而ebp-20h所指向的区域就是我们之前所声明的变量c的内存空间。这样，一个函数的返回值从返回处获取到原函数的方式就是先把返回值放到eax寄存器内，返回至原函数后再从eax里拿到这个返回值。\n根据示例代码剩余的内容无非剩下主函数退出和printf输出。不再做过多赘述。\n函数栈帧创建与销毁过程总结 到这里，一个程序的函数栈帧的形成和销毁的全过程就讲解结束啦~你可能会感觉到云里雾里和蒙圈。那现在来带你一点点的回顾整个过程并做出相应的总结吧。 函数栈帧可以追溯到最顶层的三个非易失寄存器顶上，也可以**将edi所标记的ebp-0E4h处开始向高地址填充内容的区域叫做函数栈帧的有效区域**。当真正有效意义上的栈帧应该是除去三个非易失寄存器的。 函数栈帧创建可以分为3步： 第一步：一个函数在准备调用前会做的第一件事是什么呢？先插眼！程序会首先把当前运行的函数的ebp地址压到内存栈上，以此实现函数运行完成后ebp能返回到调用前的ebp原处。如果是调用普通函数（非main函数），还会压入下一条指令的地址做到调用完后继续执行。同时，因为压入了新的数据，所以esp栈顶指针也会随之上浮挪动，随后ebp栈底指针也会移动到esp栈顶指针处，此时esp和ebp两个指针同处在栈顶区域。\n第二步：程序会发出sub 地址减法指令，指示esp向低地址偏移一片区域。esp偏移到新的区域后与当前ebp栈顶指针形成的一片新的内存空间就是这个函数的栈帧区，这也是函数的作用域。随后程序会压入3个非易失寄存器eax,esi,edi，这3个寄存器是一个调用约定（为了能够在不同平台运行）。\n第三步：程序由ebp栈底指针位置为基准发出lea指令，目的是加载一个函数栈帧的有效空间，通常会向低地址偏移0E4H个空间单位直至前面压入的ebx寄存器之下，并在这个空间内填满字符 0CCCCCCCCh，最终这个加载出来的有效空间就是一个函数真正意义上的栈帧有效空间，而这一片由0CCCCCCCCh字符填满的空间就是这个函数的作用域。现在，一个函数的栈帧才真正意义上是完整的。而这时候程序才开始执行它的有效代码。\n函数栈帧的销毁和返回同样可以分为3步： 第一步：程序会首先会将函数内的局部变量给弹出栈，如果程序有返回值，会把返回值暂时放入寄存器eax当中。随后会将栈顶上的非易失寄存器ebx、esi、edi弹出。\n第二步：程序将当前栈底指针的ebp的值，赋值给栈顶指针esp，将esp下移后的释放的那一片空间就是函数的栈帧区。\n第三步：如果还有下一条指令，程序会读取曾经存储在栈区上原函数的ebp的地址，并将ebp转移至之前记录的地址上，实现ebp返回至原函数内，之后再弹出压在栈上原函数ebp的地址元素。最后，程序读取压在栈上的下一条指令的地址，读取完成后弹出栈区，执行下一条指令。\n无论程序做出什么指令，最需要记住的原则就是：无论取多少偏移量，都是以栈底的ebp指针位置为基准；无论压入什么内容，栈顶的esp指针都要跟着向上偏移。\n我们回到前篇我们提出的几个问题，学习完函数栈帧就已经把这些问题都能一一回答了吧！现在来大声告诉我答案吧！！\n问: 函数的作用域是怎么形成的呢？\n答: 一个函数的栈帧就是一个函数的作用域。\n问: 局部变量是如何创建的？\n答: 程序在发出lea（load effective address)指令后开始绘制这个函数的定义域后，开始以底部的 ebp栈底指针为标准不断向低地址划定区域，并将这块区域赋予十六进制的值，这个过程就是局部变量创建的过程。\n问: 为什么未初始化的局部变量的值是随机值或是乱码呢？\n答: 程序在发出lea（load effective address)指令后开始绘制这个函数的定义域并分配好局部变量，因为该区域的初始字符均为0CCCCCCCCh，所以此时打印出来的值多数情况下都是 0CCCCCCCCh的表达形式。\n问: 函数是如何传参的？传参的顺序又是怎么样的呢？\n答: 程序在传参前会把要传入的参数先放入到寄存器当中，并将寄存器地址压入栈中。再观察他们的顺序 a-\u0026gt;b，所以有函数传参是由左往右依次压入栈的（示意图显示b在上，根据栈的先进后出原则证明b是后进的）.\n问: 形参和实参的关系是什么？\n答: 在调用函数内，任何新产生的局部变量会在调用函数的栈帧区内创建，而使用形参的方法实际上是回到当前函数栈帧创建前压入栈上的形参数据。正因为形参和实参在栈上是两个独立个体的存在，形参的改变不会影响到原来实参，所以才有形参是实参的一份临时拷贝。\n问: 函数的调用是怎么实现的呢？\n答: 在开始调用函数前，程序会把需要用到的函数形参提前压到栈。在调用一个函数时，程序会首先压入下一条指令和当前函数的ebp的地址进入栈区内，以此实现调用完成后程序继续执行与ebp返回原处。随后就开始以栈顶位置为起始并同时压入3个非易失寄存器形成一个完整的函数栈帧区。一个函数调用过程正是如此。\n问: 函数调用结束后是怎么返回的呢？\n答: 当被调用函数的栈帧被销毁后，程序会读取曾经存储在栈区上原函数的ebp的地址，并将ebp转移至之前记录的地址上，实现ebp返回至原函数内，之后再弹出压在栈上原函数ebp的地址元 素。最后，程序读取压在栈上的下一条指令的地址，读取完成后弹出栈区，执行下一条指令。\n问: 为什么会存在函数递归的最大深度呢？到达最大深度所提出的堆栈溢出错误是什么意思呢？\n答: 函数的递归之所以有最大深度，是因为每个函数都存在函数栈帧，在每次调用时都会生成对应的栈空间，并有esp与ebp两个栈顶和栈底指针维护。受到了栈空间的限制，如果递归深度超出栈所能承受的空间，此时就会出现最大深度的堆栈溢出的警告。而不同的函数深度可能会有所不同，毕竟每个函数所需要的栈空间是不一样的。\n函数栈帧的创建与销毁（深入了解c的汇编代码） 基础知识介绍 从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。首先应该明白， 栈是从高地址向低地址延伸 的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址)。 从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。首先应该明白，栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址)。\n1.寄存器的种类与功能 寄存器名称 功能 eax 累加寄存器，相对于其他寄存器，在运算方面比较常用。 ebx 基地址寄存器，在内存寻址时存放基地址。 ecx 计数寄存器，用于循环操作，比如重复的字符存储操作，或者数字统计。 edx 作为EAX的溢出寄存器，总是被用来放整数除法产生的余数。 esp 栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，esp也就越来越小。在32位平台上，esp每次减少4字节。栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。是CPU机制决定的，push、pop指令会自动调整esp的值。 ebp 指栈的栈底指针。基址指针寄存器(extended base pointer)，一般与esp配合使用，可以存取某时刻的esp，这个时刻就是进入一个函数内后，CPU会将esp的值赋给ebp，此时就可以通过ebp对栈进行操作，比如获取函数参数，局部变量等。其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。 2. 常用汇编指令 push指令：他首先减少esp的值，再将源操作数复制到栈地址，在位平台上，esp每次减少4个字节\n\u0026nbsp;\n解释：首先esp的值减少4个字节，再将ebp的值压入栈中；\npop指令：它首先把 esp 指向的栈元素内容复制到一个操作数中，再增加 esp 的值。在32位平台上， esp 每次增加4字节。 解释：首先将 esp 所指地址处的值赋给 edi ，再将 esp 的值减少4字节。 mov指令：用于将一个数据从源地址传送到目标地址，源操作地址的内容不变。 解释：将esp 值赋给ebp，这里并不是将esp所指向的内存空间的值赋给 ebp\nsub指令：减操作指令，从寄存器中减去\u0026lt;shifter_operand\u0026gt;表示的数值，并将结果保存到目标寄存器中。\n解释：esp-0E4h字节的结果保存在esp中。\n下面这张图片的指令一般是一起集中出现，所以我集中解释一下：\n解释：rep指令：重复其上面的指令，ecx的值是重复的次数，每执行一次，ecx 减 1，直到 ecx 减至0。stos指令：将 eax中的值拷贝到es:[edi]指向的地址。dword：双字 就是四个字节。ptr：pointer缩写 即指针[ ]里的数据是一个地址值，这个地址指向一个双字型数据一次拷贝双字（4个字节)的数据到目的地址。es:[edi]：指向目的串解释：合起来的意思就是，将栈上从 ebp-0E4h开始的位置，向高地址方向的内存赋值 0CCCCCCCCh，重复 39h 次，每次赋值双字（四字节的空间）。\ncall指令 ：将程序下一条指令的位置的IP压入堆栈中，并转移到调用的子程序。 解释：将下一条指令的IP（00BF1A30)压入栈中，并移动到调用的子程序。\nadd指令 ：用于将两个运算子相加，并将结果写入第一个运算子。 解释：给 esp 加8，也就是 esp 向高地址方向移动 8字节 ，相当于 pop 操作后的指针变化。 ret指令 ：用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。 解释：执行这条命令之后，就自动返回刚才call指令的下一行。 3. 内存模型 图片来源：CNDN作来源csdn：三•九《函数栈帧的创建和销毁（图解)》 对于初学者，只需要简单理解为：\n演示函数栈帧的创建销毁过程 首先来看下这次演示使用的代码：\n\u0026nbsp;\n#include \u0026lt;stdio.h\u0026gt; int Add(int x, int y) { int z = 0; z = x + y; return z; } int main() { int a = 10; int b = 20; int c = 0;\nc = Add(a, b);\nprintf(\u0026quot;%d\\n\u0026quot;, c); return 0; } 按下F10，在视图中打开调用堆栈窗口，我们发现 main() 函数被调用了。 但是 main() 函数被谁调用了呢？ 当我们接着调试到 return 0; 之后，再按F10，我们发现程序跳转到了调用 main() 函数的函数内 原来 main() 函数是被 __tmainCRTStartup 函数调用的，而 __tmainCRTStartup 又是被 mainCRTStartup 调用的。 分步骤演示函数栈帧的创建和销毁的过程。 为main()函数开辟栈帧 \u0026nbsp;\n在main()函数中创建变量 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解）》\n调用Add()函数前的准备 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解）》\n\u0026nbsp;\n为Add()函数开辟栈帧 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解)》 \u0026nbsp;\n在Add()函数中创建变量并运算 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解)》 6.Add()栈帧的销毁\n图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解)》 返回main()函数栈帧 可以看到这里返回到了第3步(3. 调用Add()函数前的准备)，最后指令 call 的下一条指令。 接下来的一系列mian函数的销毁与ADD函数销毁相似，不做过多赘述。\n\u0026nbsp;\n\u0026nbsp;\n思考问题： 局部变量是怎么创建的？ 为什么局部变量的值是随机值？ 函数是怎么传参的？传参的顺序是怎样的？ 形参和实参是什么关系？ 函数调用是怎么做的？ 函数调用是结束后怎么返回的？ ","date":"2023-07-15","tags":["编程","c","cpp"],"title":"函数栈帧的创建和销毁","url":"/post/2023/07/function_stack/"},{"content":"结构体内存对齐 #include \u0026lt;stdio.h\u0026gt; struct S1{ char c1;//1 int i;//4 char c2;//1 }; struct S2{ char c1;//1 char c2;//1 int i;//4 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S1));//12 printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S2));//8 return 0; } 对齐规则：\n第一个成员在与结构体变量偏移量为0的地址处\n其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处 对齐数 = 编译默认的一个对齐数与该成员大小的较小值。 vs中默认是8\n(即：第二个成员和编译器的默认对齐数比较大小,第三个成员和编译器的默认对齐数比较大小,第四个成员和编译器的默认对齐数比较大小\u0026hellip;..)\n结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍\n如果嵌套了结构体的情况，嵌套结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体对齐数）的整数倍。\n如果编译器没有默认对齐数，那么大小就是成员的自身大小\nS1\nstruct S1{ char c1;//1 int i;//4 char c2;//1 }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 结构体成员 c1 \\ \\ \\ i i i i c2 \\ \\ \\ c1 为char类型，占用1个字节；\ni 为int类型，占用4个字节；\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S1{ char c1;//1 int i;//4 char c2;//1 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S1));//12 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S1,c1));//0 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S1,i));//4 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S1,c2));//8 返回结构体成员在这个类型中的偏移量 return 0; } S2\nstruct S2{ char c1;//1 char c2;//1 int i;//4 }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 结构体成员 c1 c2 \\ \\ i i i i 结构体总大小为最大对齐数（每个成员变量都一个对齐数）的整数倍：最后的i放入后已经是整数倍了，不用偏移\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S2{ char c1;//1 char c2;//1 int i;//4 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S2));//8 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S2,c1));//0 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S2,c2));//1 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S2,i));//4 返回结构体成员在这个类型中的偏移量 return 0; } 嵌套\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S3{ double d;//8 char c;//1 int i;//4 }; struct S4{ char c1;//1 struct S3 s3; double d; }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S3)); printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S4)); return 0; } S3\nstruct S3{ double d;//8 char c;//1 int i;//4 }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结构体成员 d d d d d d d d c \\ \\ \\ i i i i 结构体总大小为最大对齐数（每个成员变量都一个对齐数）的整数倍，当前是16，为最大8的整数倍。\n#include \u0026lt;stdio.h\u0026gt; struct S3{ double d;//8 char c;//1 int i;//4 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S3));//16 return 0; } ​\nS4\nstruct S4{ char c1;//1 struct S3 s3; double d; }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 结构体成员 c1 \\ \\ \\ \\ \\ \\ \\ \\ s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 d d d d d d d d 第一个成员：从0开始，占用1个字节\n第二个成员：嵌套结构体对齐到自己的最大对齐数的整数倍处，此处S3的最大对齐数是8，所以从8为位置处开始\n第三个成员：自己需要占用8个自己，如果当前在所占字节的整数倍处，则从当前开始，如果没有，则跳到整数倍位置处再开始\n结束位置是所有成员最大对齐数的整数倍，这里最大是8，32是8的整数倍，所以是32\n#include \u0026lt;stdio.h\u0026gt; struct S4{ char c1;//1 struct S3 s3; double d; }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S4));//32 return 0; } 为什有内存对齐：\n平台原因：不是所有的硬件平台都能访问任意地址上的任意数据；某些硬件平台只能在某些地址处取得特定类型的数据，否则会抛出硬件异常。 性能原因：数据结构，尤其是栈，应尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要一次访问。 结构体的内存对齐是拿空间换时间的做法\n结构体在设计的时候，要尽量满足对齐：\n让占用空间小的成员集中在一起\n默认对齐数 在vs上默认对齐数是8\n#include \u0026lt;stdio.h\u0026gt; #pragma pack(8)//设置默认对齐数为8，一般是2的n次方（0，1，2，3，4......） #pragma pack()//取消设置的默认对齐数，还原为默认 #pragma pack(1)//还原默认对齐数为1 struct S{ int i;//4个字节 double d;//8个字节 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S)); return 0; } 设置默认对齐数为8 \u0026mdash;\u0026gt; 结构体占用16个字节\n内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结构体成员 i i i i \\ \\ \\ \\ d d d d d d d d 设置默认对齐数为1 \u0026mdash;\u0026gt; 结构体占用12个字节\n内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结构体成员 i i i i d d d d d d d d 第一个成员：从0开始，占用4个字节，默认对齐数为4，对齐数：4；占用0-3， 第二个成员：从4开始，占用字节数为8，默认对齐数是4，取较小的对齐数：4；占用4-11 总大小是最大对齐数 ：4，12是4的整数倍，所以是12 ","date":"2023-06-29","tags":["编程"],"title":"C 语言结构体","url":"/post/2023/06/c_struct/"},{"content":" 暴力算法 时间复杂度过大\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc/_malloc.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; // 最大公约数 // 最小公倍数 //计算最小公倍数和最大公约数的和 int main(){ int n = 0; int m = 0; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m) == 2){//读取两个数 int min = n \u0026lt; m ? n : m; int max = n \u0026gt; m ? n : m; int i = min;//最大公约数 int j = max;//最小公倍数 while(1){ if(n%i == 0 \u0026amp;\u0026amp; m%i == 0){ break; } i--; } // i就是最大公约数 while(1){ if(j%n == 0 \u0026amp;\u0026amp; j%m == 0){ break; } j\u0026#43;\u0026#43;; } // j就是最大公倍数 printf(\u0026#34;最大公倍数 %d \u0026#43; 最小公约数 %d = %d\\n\u0026#34;,j,i,j\u0026#43;i); } return 0; } 辗转相除法 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数\n``c 24 18 \u0026mdash;- 计算最大公约数 24%18 = 6 \u0026mdash;- 获取余数 18%6 = 0 \u0026mdash;- 较小数字于余数的模为0，这个余数就是最大公约数\n\u0026gt; 最大公倍数就是两个数字的积除以最大公约数 ```c 24 * 18 / 6 最终：\n#include \u0026lt;stdio.h\u0026gt; // 最大公约数 // 最小公倍数 //计算最小公倍数和最大公约数的和 int main(){ long n = 0; long m = 0; while(scanf(\u0026#34;%ld %ld\u0026#34;,\u0026amp;n,\u0026amp;m) == 2){//读取两个数 long i = n; long j = m; long r = 0; while(r=i%j){ i = j; j = r; } //j就是最大公约数 //m * n / j //最小公倍数 printf(\u0026#34;%ld\\n\u0026#34;,m*n/j\u0026#43;j); } return 0; } ","date":"2023-06-29","tags":["编程"],"title":"C 语言数学","url":"/post/2023/06/c_number/"},{"content":" codeif ↗ 文件命名 所有文件\n头文件和原文件成对出现\n全部小写, 可是使用下划线\u0026quot;_\u0026quot;(默认)或连字符\u0026quot;-\u0026quot;, 称完整, 不要有歧义\nsystem_file.c \u0026amp; system_file.h item_name.c item-name.c 类型命名 类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数\n每个单词首字母大写, 不使用下划线\nNumber Timer File Name 变量命名 变量, 函数参数, 数据成员名\n全部小写, 使用下划线连接\u0026quot;_\u0026quot;\n类的成员变量以下划线结尾\nvar\nitme_var\nstruct\nitme_struct\ncalss_\nitme_class_\n普通变量命名: string name; string other_name; int a; int a_other; char b; 类数据成员: class PeopleInfo{ public: string name; string other_name int age; int itme_num; static Pool\u0026lt;Psople\u0026gt;* pool_; } 结构体变量: struct person{ string name; int num_age; static Pool\u0026lt;person\u0026gt;* pool_; } 常量 声明为constexpr 或 const的变量,或在程序运行期间其值始终不变的\n静态变量, 全局变量,\n以\u0026quot;k\u0026quot;开头, 所有首字母大小, 大驼峰命名\n函数命名 函数名\n首字母大写(大驼峰命名), 或使用下划线\nmy_parent() MyParent() 枚举命名 枚举和宏或常量一样\n首字母大写, 大驼峰命名\nName\nOtherName\nenum Name{ lisa, tom = 1, } 宏命名 不建议使用宏\n单词全部大小,使用下划线连接\nNAME_ONE\nMY_NAME\n#define MY_NAME #define ORUND(x)... #define PI_NUMBER 3.14 ","date":"2023-05-29","tags":["编程"],"title":"C++ 命名规范","url":"/post/2023/05/cpp_named/"},{"content":"mermaid可以在主流的markdown工具中使用 下面是几个常用的图示类型\n1.思维导图 空格敏感 mindmap root((思维导图)) 节点一 记录1.1 ::icon(fa fa-book) 节点1.1 记录1.1.1 节点二 记录2.1 记录2.2 节点2.1 记录2.1.1 记录2.1.2 记录2.1.3 节点三 记录3.1 记录3.2 基础\n语法\n形状\n默认\nmindmap I am the default shape []矩形\nmindmap id[I am a square] 圆角矩形\nmindmap id(I am a rounded square) 圆形\nmindmap id((I am a circle)) 爆炸形\nmindmap id))I am a bang(( 云朵形\nmindmap id)I am a cloud( 六边形\nmindmap id{{I am a hexagon}} ::icon()图标\nmindmap Root A ::icon(fa fa-book) B(B) ::icon(fa fa-car) 级别\nmindmap Root A[A] :::urgent large B(B) C markdown字符串\nmindmap id1[\"**Root** with a second line Unicode works too: 🤓\"] id2[\"`The dog in **the** hog... a *very long text* that wraps to a new line`\"] id3[Regular labels still works] 翻动\n翻动\n语法\n语法\n2. 顺序图 sequenceDiagram 张三-\u003e\u003e李四: 我是张三！ 李四--\u003e\u003e张三: 我是李四! 张三-)李四: 好的! 基础\n语法\nactor 名称象形图形 sequenceDiagram actor 张三 actor 李四 张三-\u003e\u003e李四: 你好，李四，我是张三！ 李四-\u003e\u003e张三: 你好，张三！ participant A as A的别名 使用别名\nsequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL: 你好，李四！ L-\u003e\u003eZ: 你好! 使用盒子分组\nbox 组名 box 颜色 组名 participant 马克 participant B as 杰森 可以使用as取别名 end box Group without description ... actors ... end box 指定颜色 box rgb(33,66,99) ... actors ... end box 指定透明 box transparent Aqua ... actors ... end 盒子（分组）\nsequenceDiagram box rgb(255,34,67) 场景组 participant A as 马克 participant B as 杰森 end box orange 后期组 participant C as 泰克 end box white 道具组 participant D as 斯坦 end box lightblue演员组 participant 瓦特 participant E as 托尼 end box transparent 导演组 participant F as 塔克 end A-\u003e\u003eB: 不错 B-\u003e\u003eE: 演员呢 A-\u003e\u003eD: 换道具了 B-\u003e\u003eC: 后期组在吗? A-\u003e\u003eF: 我是马克 F-\u003e\u003eD: 我是塔克 E-\u003e\u003eF: 我是托尼 瓦特-\u003e\u003eF: 这里是演员组 可以使用的箭头\n类型 描述 -\u0026gt; 没有箭头的实线 --\u0026gt; 没有箭头的虚线 -\u0026gt;\u0026gt; 带箭头的实线 --\u0026gt;\u0026gt; 带箭头的虚线 -x 末尾有十字的实线 --x 末端有十字的虚线。 -) 尾端有开箭头的实线（异步） --) 末端有开放箭头的虚线（异步） deactivate保持对象（activate激活对象）\n通常用于表示一个完整的内容，避免分割造成的歧义 sequenceDiagram 张三-\u003e\u003e李四: 我是可以使用的对象 activate 李四 李四--\u003e\u003e张三: Great! deactivate 李四 张三-\u003e\u003e李四: 刚才被停用了 李四--\u003e\u003e张三: Great! activate 李四 李四--\u003e\u003e张三: Great! 快捷方式：在消息箭头上附加+/-后缀 -\u0026gt;\u0026gt;+ --\u0026gt;\u0026gt;- sequenceDiagram 张三-\u003e\u003e+李四: Hello John, how are you? 李四--\u003e\u003e-张三: Great! 堆叠\nsequenceDiagram 张三-\u003e\u003e+李四: Hello John, how are you? 张三-\u003e\u003e+李四: John, can you hear me? 李四--\u003e\u003e-张三: Hi Alice, I can hear you! 李四--\u003e\u003e-张三: I feel great! 注释\nsequenceDiagram participant 李四 Note right of 李四: 这是注释 跨对象注释\nsequenceDiagram 张三-\u003e\u003e李四: 你好，李四 Note over 张三,李四: 这是注释 注释使用换行符\nsequenceDiagram 张三-\u003e\u003e李四: 你好 Note over 张三,李四: 尖括号内使用br斜杠换行 循环\nloop 循环说明 循环内容 end\n```mermaid sequenceDiagram 张三-\u0026gt;李四: 接下来是一个循环 loop 循环的说明 李四--\u0026gt;张三: 循环的内容 end 替换和选择\n可以在序列图中表达替代路径。\nalt 描述信息 \u0026hellip; statements \u0026hellip; else \u0026hellip; statements \u0026hellip; end\n或者\n如果有可选的序列（如果没有其他）\nopt 描述信息 \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram 张三-\u0026gt;\u0026gt;李四: 怎么样 alt 生病了 李四-\u0026gt;\u0026gt;张三: 不太好:( else 健康 李四-\u0026gt;\u0026gt;张三: 很好 end opt 额外的 李四-\u0026gt;\u0026gt;张三: 谢谢关心 end 并行发生\n可以显示并行发生的行为。\npar [Action 1] \u0026hellip; statements \u0026hellip; and [Action 2] \u0026hellip; statements \u0026hellip; and [Action N] \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram par 张三 to 李四 张三-\u0026gt;\u0026gt;李四: 你好 and 张三 to 王五 张三-\u0026gt;\u0026gt;王五: 你好 end 李四--\u0026gt;\u0026gt;张三: 你好，张三 王五--\u0026gt;\u0026gt;张三: 你好，张三 嵌套平行块\nsequenceDiagram par 张三 to 李四 张三-\u003e\u003e李四: Go help John and 张三 to 王五 张三-\u003e\u003e王五: I want this done today par 王五 to 赵六 王五-\u003e\u003e赵六: Can we do this today? and 王五 to 小明 王五-\u003e\u003e小明: Can you help us today? end end 条件触发\n可以显示必须通过有条件处理情况自动发生的操作。 critical [Action that must be performed] \u0026hellip; statements \u0026hellip; option [Circumstance A] \u0026hellip; statements \u0026hellip; option [Circumstance B] \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram critical 拨打电话给李四 张三--\u0026gt;李四: 打电话 option 话费不足 张三--\u0026gt;张三: 通话失败 option 被拒绝 张三--\u0026gt;张三: 再次通话失败 end sequenceDiagram critical 张三打电话给李四 张三--\u003e李四: 成功 end 中断\n可以指示流中序列的停止（通常用于模拟异常）。\nbreak [something happened] \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram 消费者--\u0026gt;商家: 买一个笔记本 商家--\u0026gt;仓库: 查仓库的库存 break 无库存 商家--\u0026gt;消费者: 提示无库存 end 商家--\u0026gt;财务系统: 财务登记 背景高亮显示\n可以通过提供彩色背景来突出显示流。 颜色是使用rgb和rgba语法定义的。\nrect rgb(0, 255, 0) \u0026hellip; content \u0026hellip; end rect rgba(0, 0, 255, .1) \u0026hellip; content \u0026hellip; end\n```mermaid sequenceDiagram participant Alice as 张三 participant John as 李四 rect rgb(191, 223, 255) note right of Alice: 张三给李四打电话 Alice-\u0026gt;\u0026gt;\u0026#43;John: 你好，李四！ rect rgb(200, 150, 255) Alice-\u0026gt;\u0026gt;\u0026#43;John: 李四，你能听到我说话吗？ John--\u0026gt;\u0026gt;-Alice: 我可以听到 end John--\u0026gt;\u0026gt;-Alice: 很清晰 end Alice -\u0026gt;\u0026gt;\u0026#43; John: 今晚有空看比赛吗？ John --\u0026gt;\u0026gt;- Alice: 可以的！ %%注释内容，换行结束注释\nsequenceDiagram A-\u0026raquo;J: Hello J, how are you? %% this is a comment J\u0026ndash;\u0026raquo;A: Great!\n- 转义字符 ```mermaid sequenceDiagram A-\u0026gt;\u0026gt;B: I #9829; you! B-\u0026gt;\u0026gt;A: I #9829; you #infin; times more! 翻动分\n赛\n翻动\n语法\n扽色\n冬粉\n使用end时，建议用[] 或 {} 或 ()括起来 3. 流程图flowchart 使用graph也可以\n基础：\n节点：箭头（连接线）指向的图形 内容：节点上的文字 对空格不敏感 ---三个减号表示线，最后一个减号改为\u0026gt;可带箭头，增加-可增加长度 ```mermaid graph LR 思维导图--\u0026gt; 第一部分 第一部分--\u0026gt;1.1小节 第一部分--\u0026gt;1.2小节 思维导图--\u0026gt; 第二部分 第二部分--\u0026gt;2.2小节 思维导图--\u0026gt; 第三部分 第三部分--\u0026gt; 3.1小节 思维导图--\u0026gt; 若干 ``` graph LR 思维导图--\u003e 第一部分 第一部分--\u003e1.1小节 第一部分--\u003e1.2小节 思维导图--\u003e 第二部分 第二部分--\u003e2.2小节 思维导图--\u003e 第三部分 第三部分--\u003e 3.1小节 思维导图--\u003e 若干 A[Content A]--\u003eB[Content B] B--\u003eC[Content C] B--\u003eD[Content D] 语法：\n排列方式\ngraph LR 从左到右排列，RL相反 graph BT 从上到下排列，TB相反 连接方式\n--\u0026gt; 箭头连接\ngraph LR A --\u003e B --- 无箭头连接\ngraph LR A---B --连接线上带文字--- 或 C---|连接线上带文字|D连接线上带文字\ngraph LR A-- 连接上的文字 ---B C---|连接线上带文字|D --\u0026gt;箭头连接线上带文字--- 或 C---\u0026gt;|箭头连接线上带文字|D箭头连接线上带文字\ngraph LR A--\u003e 连接上的文字 --\u003eB C---\u003e|连接线上带文字|D A-.-\u0026gt;B虚线连接\ngraph LR A-.-\u003eB A-.带文字的虚线连接.-\u0026gt;B带文字的虚线连接\ngraph LR A-.带文字的虚线连接.-\u003eB A==\u0026gt;B粗连接\ngraph LR A==\u003eB A == 带文本的粗连接 ==\u0026gt; B 带文本的粗连接\ngraph LR A == 带文本的粗连接 ==\u003e B - 特殊字符的显示 ```mermaid graph LR A[\u0026quot;这里有个引号#quot;\u0026quot;] --\u0026gt;B[\u0026quot;特殊字符:#9829;\u0026quot;] ``` - 破坏语法的字符`!` ```mermaid graph LR A[\u0026quot;破坏语法的特殊字符 ! \u0026quot;] ``` 节点形状\nA(圆角矩形) “A”和“圆角矩形”可以是任意字符\ngraph RL A(圆角矩形) A[矩形]\ngraph RL A[矩形] A((圆形))\ngraph RL A((圆形)) A\u0026gt;非对称形状]\ngraph RL A\u003e非对称形状] A{菱形}\ngraph RL A{菱形} 文字（别名）\nstart[开始]start将作为节点，显示的字符为开始 子图\nsubgraph 图像块标题1 图像快中的连接 subgraph 图像块标题2 图像快中的连接 ...... end graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end 带样式的连接\n参数 fill：内部填充色 stroke：描边颜色 stroke-width：描边宽度 stroke-dasharray: 虚线描边（虚线块的宽度 虚线空格的宽度） graph LR A(Start)--\u003eB(Stop) style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 style C fill:#f9f,stroke:#993,stroke-width:4px style D fill:#ccf,stroke:#f6f6,stroke-width:6px,stroke-dasharray: 4 2 对 fontawesome ↗ 的基本支持\n图标通过语法\u0026quot;fa:图标名称\u0026quot;来获取\ngraph TD B[\"fa:fa-twitter 和平\"] B--\u003eC[fa:fa-ban 禁止] B--\u003eD(fa:fa-spinner); B--\u003eE(fa:fa-camera-retro 也许?); E--\u003eF(fa:fa-car 汽车) B--\u003eG(fa:fa-file 文件) fds\nfdsfsd\n4. 甘特图 gantt title 一个案例 dateFormat YYYY-MM-DD section 分区 任务一 :a1, 2023-01-01, 30d 其它任务 :after a1, 20d section 其它 任务一中的次要任务 :2023-01-12, 12d 次要任务 :24d 甘特图将把每个计划的任务记录为一个从左向右延伸的连续条。x轴表示时间，y记录不同的任务和完成它们的顺序。\n重要的是要记住，当特定于任务的日期、日期或日期集合被“排除”时，甘特图将通过向右延长相等的天数来适应这些变化，而不是在任务内部创建空隙。但是，如果排除的日期在设置为连续开始的两个任务之间，则排除的日期将以图形方式跳过并留空，以下任务将在排除日期结束后开始。\n甘特图可用于跟踪项目完成所需的时间，但它也可以用于以图形方式表示“非工作日”，只需进行一些调整。\n语法\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section A section Completed task :done, des1, 2023-01-06,2023-01-08 Active task :active, des2, 2023-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2023-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d Functionality added :milestone, 2023-01-25, 0d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 由多个空间分割的依赖项\ngantt apple :a, 2023-07-20, 1w banana :crit, b, 2023-07-23, 1d cherry :active, c, after b a, 1d title标题\ntitle是一个可选字符串，显示在甘特图表的顶部，以描述整个图表。 section章节声明\n将图标分为多个部分 milestone重要事件\n代表时间上的单个瞬间\n里程碑的确切位置由里程碑的初始日期和任务的“持续时间”决定：初始日期+持续时间/2。\ngantt dateFormat HH:mm axisFormat %H:%M Initial milestone : milestone, m1, 17:49, 2m Task A : 10m Task B : 5m Final milestone : milestone, m2, 18:08, 4m 日期\ndateFormat定义甘特元素的日期输入格式。这些日期如何在渲染的图表输出中表示，由axisFormat定义。\n日期格式dateFormat YYYY-MM-DD\n输入的信息 示例： 描述 YYYY 2014 年 4位数年 YY 14 2位数年 Q 1..4 一年的四分之一。将月份设置为季度的第一个月。 M MM 1..12 月号 MMM MMMM 一月..十二月 区域设置中的月份名称由dayjs.locale() D DD 1..31 月日 Do 第1..31 带有序数的月日 DDD DDDD 1..365 一年中的一天 X 1410715640.579 Unix时间戳 x 1410715640579 Unix ms时间戳 H HH 0..23 24小时时间 h hh 1..12 12 hour time used with a A. a A 下午上午 帖子或ante meridiem m mm 0..59 备忘录 s ss 0..59 秒 S 0..9 十分之一秒 SS 0..99 数百秒 SSS 0..999 千分之一秒 Z ZZ +12:00 从UTC偏移为+-HH:mm、+-HHmm或Z 轴上的日期格式\n默认输出日期格式是YYYY-MM-DD。您可以定义自定义axisFormat，例如2020年第一季度的2020-Q1。\naxisFormat %Y-%m-%d\n格式 定义 %a 缩写的工作日名称 %A 完整的工作日名称 %b 缩写的月名 %B 完整月份名称 %c 日期和时间，如“%a %b %e %H:%M:%S %Y” %d 每月零填充日作为十进制数[01,31] %e 每月用空格填充的十进制数[1,31]；相当于%_d %H 小时（24小时时钟）作为十进制数[00,23] %I 小时（12小时时钟）作为小数[01,12] %j 一年中的一天作为十进制数[001,366] %m 月份作为十进制数[01,12] %M 分钟作为十进制数[00,59] %升 毫秒作为十进制数[000,999] %p 上午或下午 %S 第二个十进制数[00,61] %U 一年中的周数（周日作为一周的第一天）作为十进制数[00,53] %w 工作日作为十进制数[0（周日），6] %W 一年中的周数（周一作为一周的第一天）作为十进制数[00,53] %x 日期，如“%m/%d/%Y” %X 时间，如“%H:%M:%S” %y 没有世纪的年份作为十进制数[00,99] %Y 以世纪为十进制数的年份 %Z 时区偏移，例如“-0700” %% 字面上的“%”字符 轴刻度\n默认输出刻度是自动的。您可以自定义您的tickInterval，如1day或1week tickInterval 1day 模式：/^([1-9][0-9]*)(minute|hour|day|week|month)$/; 紧凑模式输出\n--- displayMode: compact --- gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2023-01-01, 30d Another task :a2, 2023-01-20, 25d Another one :a3, 2023-02-10, 20d ·%%注释\nfds\nfds\n5. 饼图 pie title 字符统计 \"中文\" : 386 \"英文\" : 85 \"标点符号\" : 15 饼图（或圆图）是一种圆形统计图形，分为切片以说明数字比例。在饼图中，每个切片的弧长（以及其中心角度和面积）与它所代表的数量成正比。\n语法\npie关键字\nshowData在图例文本之后呈现实际数据值。这是可选的\n后面跟着title关键字及其在字符串中的值，以给饼图一个标题。这是可选的\n其次是数据集。饼图将按照与标签相同的顺序顺时针排序。\nlabel在\u0026quot; \u0026quot;引号中的饼图中的一部分。\n其次是:冒号作为分隔符\n后跟positive numeric value（最多支持小数点后两位）\n%%{init: {\"pie\": {\"textPosition\": 0.5}, \"themeVariables\": {\"pieOuterStrokeWidth\": \"5px\"}} }%% pie showData title 软件技能 \"PS\" : 42.96 \"Word\" : 50.05 \"Exl\" : 10.01 \"Ppt\" : 5 参数 描述 默认值 textPosition 馅饼片标签的轴向位置，从中心0.0到圆圈外缘的1.0。 0.75 ","date":"2023-03-19","tags":["编程"],"title":"mermaid 教程","url":"/post/2023/03/marmaid/"},{"content":" http://patorjk.com/software/taag ↗ http://www.network-science.de/ascii/ ↗ http://www.degraeve.com/img2txt.php ↗ http://life.chacuo.net/convertfont2char ↗ ","date":"2022-07-29","tags":["编程"],"title":"字符图片","url":"/post/2022/07/chart_image/"}]