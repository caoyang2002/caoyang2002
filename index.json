[{"content":" 这是一个注意事项 解密 已加密，请输入密码 访问 ","date":"2024-03-21","tags":["公告"],"title":"公告","url":"/post/2024/03/notice/"},{"content":"\n1/53\n2/53\n3/53\n4/53\n5/53\n6/53\n7/53\n8/53\n9/53\n10/53\n11/53\n12/53\n13/53\n14/53\n15/53\n16/53\n17/53\n18/53\n19/53\n20/53\n21/53\n22/53\n23/53\n24/53\n25/53\n26/53\n27/53\n28/53\n29/53\n30/53\n31/53\n32/53\n33/53\n34/53\n35/53\n36/53\n37/53\n38/53\n39/53\n40/53\n41/53\n42/53\n43/53\n44/53\n45/53\n46/53\n47/53\n48/53\n49/53\n50/53\n51/53\n冯卫东：品牌起名这件小事，攸关生死【笔记】 12月24日，天图资本CEO冯卫东来到混沌研习社，用多年投资消费品品牌的经验和我们分享了他对于品牌定位理论的思考。冯卫东说，一个新的品类相当于一块空白的殖民地，找到它并抢先进入，是打造新品牌的最好机会。但新品类的命名往往攸关生死。\n演讲者｜冯卫东（天图资本CEO）\n可口可乐总裁罗伯特有这么一句话：即使可口可乐在全世界的工厂被一把大火烧掉，我们也能一夜间起死回生。什么意思呢？\n假设某天可口可乐全世界的工厂如果被大火烧掉了，第二天各大报纸的头版头条，一定是各大银行排队给可口可乐贷款。\n如果银行愿意给可口可乐贷款，那么供应商也会来找它，并且给它放很长的账期。经销商肯定也会排队把货款交过来。消费者呢，也是翘首以盼，可口可乐什么时候重新上架。\n这是可口可乐所处的状况。因为顾客到了小卖部前，闭着眼睛说，拿一罐可口可乐。如果店员拿出一罐别的东西，顾客会问，怎么不是可口可乐？\n可口可乐的优势还在，成果还在。只要这个成果在，其他东西都是成本，只要你花钱就可以重建。\n这也印证了德鲁克曾经说过的一句话：企业的经营成果在企业的外部，企业内部只有成本。\n企业的经营成果到底在企业外部的什么地方，以什么形式存在？如何来回答这个问题？\n其实就是我们今天要说的品牌定位理论：企业的经营成果在企业的外部，在顾客的心智，这个成果其实就是品牌。 可口可乐这个可以一夜之间起死回生的神话，揭示出品牌才是企业经营的核心成果。\n11月24日，天图资本CEO冯卫东登上研习社讲台，与我们分享了品牌的定位理论。\n定位理论的三大贡献自1972年，里斯和特劳特创立了定位理论以来，定位理论得到了很多解读和翻新。\n今天我们再来看定位理论对于品牌营销的贡献，其实可以归纳为以下三点：1竞争的终极战场是顾客的心智。如果我们看不到真正关键竞争存在于顾客的心智，那么我们所做的一切事情都是在内部，都停留在成本。\n2竞争的基本单位是品牌。顾客是购买品牌，不是企业。品牌是我们真正创造成果的地方。\n3品牌是品类或者特性的代表。产品本身是不会进入消费者心智的，进入心智的一定是概念，首先是品类，其次的特性。eg，矿泉水就是农夫山泉或者怡宝，或者安全就是沃尔沃、飘柔就是柔顺。竞争的基本单位是品牌，所以其实企业战略等于品牌战略之和。因为混淆企业战略和品牌战略，我们很多企业都在犯错误。\n茅台企业要实现增长应该怎么做？一开始茅台采取了降价的策略。\n降价严重伤害茅台这个品牌，一降价就是在贬值。\n同时茅台还做了什么错误的动作？生产茅台红酒，甚至茅台啤酒。\n我有一次看到茅台啤酒的广告：“茅台啤酒，啤酒中的茅台。”这些错误的动作，都让茅台这个品牌的价值受到巨大的损伤。 正确的策略应该怎么做？茅台占据的是奢侈品定位，所以你不能追求销量的增长。\n真正做奢侈品的人都知道，寻求增长是不能降价的，每过一段时间还要小幅度的涨价，才能够维持这个奢侈品的品牌定位。\n那企业的增长应该怎么办？收购其他品牌。比如说它收购习酒，就非常正确。并且收购以后不能把茅台这两个字打在习酒上面，尽可能保证习酒可以成长为独立的强大品牌。\n我们看到中国也有多品牌战略高手，比如马云。\n阿里集团是多品牌战略的成功典范，淘宝、天猫、支付宝、余额宝、高德地图、UC浏览器、芝麻信用、阿里云、聚划算，当然还有一些大家不注意的旺旺、花呗、闲鱼\u0026hellip;\u0026hellip;每个品牌占据一个强大的定位。并且他早期用了品牌延伸战略做为试探，一旦做大了就改名，比如天猫最开始叫淘宝商城，做大了以后改名天猫。\n当然腾讯也是多品牌策略，有QQ也有微信，做的很好。\n这方面百度就略逊一筹，百度搜索、百度地图、百度外卖、百度百家、百度同学、百度医生，都叫百度，这个就是不会使用多品牌策略。\n一个新的品类相当于一块空白的殖民地，找到它并抢先进入，是打造品牌的最好机会。品牌三问：你是什么？有何不同？何以见得？\n消费者面对一个陌生的品牌，他会思考什么问题？\n1你是干什么的？\n2和其他品牌相比，你“有何不同”：能给我带来什么价值\n3“何以见得”你的价值真的存在？\n所以做好一个品牌，就是面对消费者，回答好这三个问题。\n第一问：你是干什么的？\n新品类命名八字诀\n向消费者提供核心简单的信息\u0026ndash;“品类”。什么叫品类？就是顾客做出购买决策前的最后一级分类。鞋子是不是品类？鞋子叫做抽象品类，真正的品类应该是运动鞋。1、一定要明确自身品牌所代表的品类，才能有效对接顾客的需求。\n无印良品是什么？不知道。优衣库呢，卖衣服的。相对于无印良品来说，优衣库在顾客心智中的定位更清晰。虽然无印良品售卖的商品类目比优衣库多得多，但是谁的销售额更大呢？\n优衣库，大多少倍？六倍。所以柳井正成为了日本首富，而无印良品被沃尔玛收购了。 不明确自己的品类，顾客很难在产生品类需求的时候想到它，只有逛街的时候，随机地进去看看，这两者带来的转化率是有巨大差别的。 2、新品类是新品牌的主要来源。\n品类最重要的一个特点就是，持续分化，不断产生新的品类。一个新的品类相当于一块空白的殖民地，找到它并抢先进入，是打造品牌的最好机会。 随着品类的成长壮大，它的顾客会越来愈多，顾客一多，必然会带来一些不能被有效满足的用户需求，当这些少数派越来越多，达到一定临界规模的时候，就会催生出一个新的细分品类，去满足这些新产生的需求。 3、当一个新品类产生的时候，它一定会获得一个名字。这个名字基本上攸关这个品类的生死。\n比如有这么一个品类，有人叫PDA，有人叫掌上电脑，有人叫智能手机。\n当初苹果推出了这个能够手写、上网、打电话的东西的时候，把它叫做PDA，轰轰烈烈地推广，最后轰轰烈烈地失败。这个名字叫错了，说PDA，个人数字助理，没有人听得懂，不知道从哪里来的。\n但是苹果做PDA的过程中形成了技术，没有浪费，最后做出了iPhone，非常成功。 品牌延伸的跷跷板效应：同一个品牌，强化它的一个认知，必然会弱化它的另一个认知。如何为新品类命名？我们有个原则叫八字诀。\n1、有根。遵循品类分化的原则，把老品类需求和顾客挖过来。 比如酸奶和豆奶，借助牛奶这个品类的联想，分化用户对牛奶的需求。\n2、好感。更有价值的表达角度。 同样是从植物中提取的黄油，你叫人造黄油，大家肯定没兴趣吃了，你说叫植物黄油，素食者可能会更偏爱。而且你还可以重新定义，植物黄油不含胆固醇，富含异黄酮等等，更好地表达这样的品类。 3、直白。直指品牌的特性，或者形象化。 平衡车最早叫什么？叫体感车，身体感应控制的车。大部分人以为跟拉杆箱的“体感”一样。我们觉得最好的翻译应该叫立行车，最形象直白。\n4、简短。便于记忆和传播。因为顾客能说两个字，绝对不说三个字的。比如电脑和计算机一字之差，但是现在电脑的使用频率明显超过计算机。因为电脑这个品类太强大了，以它为词根还要延伸其他众多的品类，比如电脑包、电脑桌。计算机包和计算机桌这种表达就让人觉得很累。 好的定位就是，让顾客不再追问“那又如何”？第二问：有何不同？9种品牌差异化的办法 第二个问题回答就是有何不同，明确你的定位。你的品牌一定是和竞争对手不同，并且存在着对顾客有意义的差异。 一个重要的标准就是顾客听到你的广告之后，不再追问“那又如何？”比如恒大冰泉的广告，“一处水源供全球”。我们忍不住会想，那又怎样？一处水源供全球，对我来说，有什么意义呢？有一本书叫做《与众不同》，里面讲了9种品牌差异化的办法，可以帮助我们更好地展示自己的品牌特性。比如它将产品分为两种特性，一种叫物理特性，一种叫市场特性。\n1、物理特性指产品的内在利益。这里再细分，第一种叫做直接特性，比如好吃、美白、保湿。第二种叫做间接特性，比如说制造方法，纯手工，或者经过72道工序，强调这个天然或复杂的制造过程，对消费者特殊的价值。再比如，新一代，比如iPhone1到iPhone7，让人感到技术迭代和进步的价值。这些都能够间接暗示，你的产品比竞争对手更好。\n2、市场特性指能够影响顾客选择的市场表现。这里可以分为很多种。 比如说开创者。开创者就意味着原创，别人都是山寨，因为你是原创，所以很大程度上，你拥有更多的专业知识。 领导者。我就是市场上卖的最好的，最受消费者认可的，这点对于顾客来说，很有说服力。 经典。我这个品牌存在了300年，经过了历史的验证，顾客也会觉得很有价值。 热销。卖断货了，这个信息往往会让消费者觉得印象很深刻。 最受青睐。是某个特定人群最喜欢的品牌，比如耐克，是专业运动员最青睐的品牌，对于消费者来说也马上不一样了。 专家。专注细分领域，你在这个领域拥有更多的知识。其实市场千变万化，品牌差异化的办法肯定不只9种，还有很多大家可以自己探索总结的办法。 多种方法并用，尽可能打造一个立体的信任状。第三问：何以见得？向顾客提供三种信任状 第三位叫做何以见得，要向顾客提供信任状。信任状分为三种类型。 1、权威第三方证明：德州扒鸡（中华老字号）、八马铁观音（国家级非物质文化遗产）。2、顾客自行验证：眼见为实的信息。比如我们看到一家餐馆门前排队，我们潜意识就判断这家餐馆一定很好吃。3、品牌有效承诺：免费试吃、无效退款，这些都是品牌的承诺。其实取得顾客信任的方法是非常多的，我们在向顾客提供信任状的时候，一定要多种方法并用，尽可能打造一个立体的信任状。比如“百果园”，其实是向顾客提供了三种信任状：权威第三方证明：亚洲2015年度果蔬零售商大奖，中国连锁百强里面唯一的水果企业。 顾客自行验证：非常多的门店，如果你说你是全国最大的水果连锁店，如果看不到你的门店，顾客肯定不会相信。品牌的有效承诺：不好吃三无（无理由、无小票、无食物）退款。不好吃直接退款给你，这样的承诺让顾客买起来很放心，百果园每年为此退款几千万，但是相对于几十亿的销售来说的话，这个是非常值得的。 “我知道一半广告费被浪费了，却不知道是哪一半。\n”——约翰•沃纳梅克怎么才能写出有效的广告？“二语三性”法则 最后一个广告。怎么才能够写出有效的广告？其实我把它总结成“二语三性”的法则。“二语”指的是销售用语和顾客用语。 什么是销售用语？是否包含了有效卖点？我们判断的标准就是，一线销售人员是否会使用它，向顾客解释我们的产品，比如“怕上火喝王老吉”，“经常用脑喝六个核桃”，销售人员一定会说，这个是预防上火的，补脑的，等等。顾客用语。顾客是否会用这个广告用语向朋友介绍这款产品？说人话、简单、弱化广告腔。三性，指可信性，竞争性和传染性。可信性：顾客是否相信。这里面就涉及到你是否向客户提供了有效的信任状。“劲霸男装专注夹克29年”。非常具体，比专注夹克20多年要好，变得更可信。 “云南白药创可贴，有药好的更快些”。反衬出没有药的邦迪，可能就是挡灰而已，我这个有药的完全不一样。竞争性：是否能够有效转化竞争对手的顾客。 “高档装修不用大理石，就用简一大理石瓷砖。”这句广告语直接转化了原先那些购买大理石做为装修材料的顾客，到简一这里来。传染性：让你的广告语能够劈开客户的大脑，产生二次传播。\n怎么样才能具有传染性呢？首先要有冲突，有新意，再加一点简单的依据，才能进入顾客的大脑。\n第二，具有高频属性或诱因。\n让顾客常常能想起你的广告。第三，必须包含社交货币。这个其实传染性最核心的东西，就是传播你的广告，能够提升传播者的社交地位，彰显传播者的品味、财富、学识、关心等等。\n*本文根据冯卫东在混沌研习社的课程内容整理而成，有删节，欢迎转发朋友圈。转载请注明来源。\n","date":"2025-02-24","tags":["暂无"],"title":"冯卫东：定位理论的贡献","url":"/post/2025/02/00daf5af/"},{"content":"领导者战略 市场领导者：占有最大市场份额，在价格变化、新产品开发、分销渠道，以及促销战略上对本行业其他公司起到领导作用的公司。例如苹果、谷歌这样的公司。\n如何才能成为领导者呢？第一种方式是把蛋糕做大，第二种方式是吧蛋糕做厚\n市场总量 Q = aq\nQ：总量\na：使用频率\nq：使用改产品的人数\n提升市场总量的两种方式：\n提升消费者使用频率 提升使用该产品的人数 对于提升消费者使用频率方面，有个口香糖品牌叫益达，口香糖这个品类很难想到它的使用场景是什么，所以销量一致不好，而后做了一系列广告，比较知名的广告语是 “吃完喝完嚼益达” 和 “吃完来两粒”。通过这些广告，益达成功地将自己与餐后清洁口腔的场景绑定在一起，培养了用户在进食后嚼口香糖的习惯，从而提升了使用频率。\n对于提升使用该产品的人数方面，可口可乐是一个经典案例，它通过一系列广告宣传和品牌推广活动，成功地将自己定位为一种快乐、分享和时尚的饮品。其广告语如 “开放幸福” 和 “分享一瓶可乐” 等，不仅传递了品牌的核心价值观，还通过情感共鸣吸引了更多消费者。此外，可口可乐还通过与电影、音乐节等跨界合作，以及推出个性化产品如印有人名的可乐瓶，进一步扩大了消费群体。这些策略使得可口可乐在全球范围内吸引了大量新用户，提升了品牌的知名度和影响力。\n类似的案例屡见不鲜。在大众服饰开始饱和的时候，一些品牌开始定位户外休闲或者极限运动，同样是提升使用人数的策略，而作为王老吉，则通过 “怕上火喝王老吉” 的广告语培养用户的消费场景意识，不再是 “口渴” 的场景，而是火锅川菜这样的场景，提升了消费频率。\n提升消费者人数，并非只能面向潜在顾客，例如香水，它一开始的定位是女性、婴儿洗发水的用户是婴儿，但是我们也能发现为爱运动的男性打造的运动香水、把婴儿洗发水卖给过敏性皮肤的成年人。\n市场竞争往往不进则退。当挑战者越来越多，市场领导者需要考虑扩大整体市场规模，所以出现了 “竞合” 的概念。一个健康的市场一定不是互相拆台，而是互相扶持的\n追随者战略 大企业看不上的机会可能是小企业竞争的关键，比如大淘宝京东将目光瞄准消费能力强悍的一二线城市的时候，拼多多瞄准消费能力不高的下沉市场，市值直逼甚至超过淘宝京东。中国市场并不缺乏这样的案例。\n“1999 元” 出现在小米手机发布会上的时候，现场一片沸腾，销量迅速突破百万台，成为当时市场上的一匹黑马。初出牛犊的小米肯定不是市场的领导者，哪怕是在中国市场，还有华为这样的公司。但是这一价格策略不仅让小米在竞争激烈的智能手机市场中脱颖而出，还成功吸引了大量年轻消费者和价格敏感型用户。\n像这样的竞争者，我们把它叫做 “市场补缺者” 或者是 “市场追随者”\n市场追随者：收到自身资源限制，只能为规模较小，或大公司不感兴趣的细分市场提供产品或服务的公司。\n那么这样的公司如何在市场中获得竞争优势呢？\n用户专业化：企业专门服务一个特定类别的用户\n顾客规模专业化：挑选一种规模进行投放\n服务专业化：集中资源塑造一种业务\n销售渠道专业化：挑选一种渠道进行销售\n当资源有限的时候，小企业只要做到一点的突破，也足以在市场中存活下来。\n中国的英语教育市场牢牢被新东方占据，早期的新东方是大班课，而一家只做一对一的在线英语教育平台 VIPKID，成功在市场中占据了一席之地。这是典型的 “顾客规模专业化” 的策略，满足了用户对高效、互动性强的英语学习需求，从而在竞争激烈的英语教育市场中脱颖而出。\n如今的摩托罗拉早已风光不再，但是他们推出的 X40 因其具备强大的性能和耐用性，特别适合户外使用，被称为“手机中的SUV”，受到了市场的认可，这是一种用户专业化的思维。\n服务专业化方面，美国的 Wingz 是一家主要提供接送机服务的网约车公司，其服务覆盖多个机场。他们重新设计出租车的空间，使其具有较大的行李存放空间，能够轻松容纳多个大型行李箱，以满足旅客携带大量行李的需求。\n我们想到西装，往往会想到高大上的店面和精美的剪裁包装，但是有一家公司另辟蹊径，这家公司是衣邦人，自2014年成立以来，一直采用 “互联网 + 上门量体 + 工业 4.0” 的 C2M 创新模式，这种模式的成功，就是渠道专业化的结果。\n有时候，竞争不一定发生在食物链的顶端，老虎嘴边的残羹剩饭，对蚂蚁而言仍算是饕餮盛宴。对于小企业来说，完成从追随者到挑战者的转型是生存的关键。\n","date":"2025-02-24","tags":["暂无"],"title":"营销基础：市场领导者与市场追随者","url":"/post/2025/02/strategy_and_marketing_management/"},{"content":" 热榜网 ↗ ","date":"2025-02-24","tags":["暂无"],"title":"热榜查询","url":"/post/2025/02/hotsort/"},{"content":"\n在移动互联网时代到来之后，关于咨询公司和广告公司之间的边界就开始模糊。随着市场环境的变化和行业竞争的加剧，广告公司和咨询公司之间的界限确实变得越来越模糊。广告公司开始涉足咨询领域，而咨询公司也在不断拓展其服务范围，这种现象在近年来尤为明显。\n一方面，广告公司为了提升自身的竞争力和盈利能力，开始向咨询领域拓展。例如，奥美等 4A 公司纷纷设立了咨询部门，提供包括战略规划、品牌咨询等在内的服务。这种转型不仅帮助广告公司提升了在客户心目中的地位，还使其能够提供更全面的服务，满足客户多样化的需求。\n另一方面，咨询公司也开始涉足广告和营销领域。例如，埃森哲互动、德勤数字等咨询公司通过收购广告公司和创意机构，拓展了其在广告和营销领域的业务。这些咨询公司利用自身的数据分析和战略规划优势，为客户提供从战略到执行的一站式服务。\n在移动互联网的浪潮下，广告公司传统的业务模式受到冲击，而咨询公司则需要不断创新以满足客户多样化的需求。这种背景下，广告公司咨询化的趋势逐渐显现。广告公司通过转型咨询，不仅可以拓展业务范围，还能提升自身的专业能力和市场竞争力。\n广告行业更是流行起了 “广告公司咨询化” 这个概念。很多人说，这是因为行业紧缩，广告公司挣不到钱，只能向上游摸索新业务；也有人说，相比 20 万的策略费，200 万的战略咨询更有盼头。这种转型不仅是市场环境变化的结果，也是广告公司自身发展的需要。\n于是，4A 公司率先在 2017 年开启了并购之旅，切入咨询行业。这一举动标志着广告公司正式进入咨询领域，开始与传统咨询公司展开竞争。4A 公司的这一战略转型，不仅为其带来了新的业务增长点，也为整个广告行业树立了新的标杆。\n借着移动互联网和 4A 公司转型的东风，大量的热店开始在广告行业迎来自己的高光时刻。这些热店凭借创新的业务模式和灵活的市场策略，迅速崛起，成为广告行业的新宠。它们不仅在创意和执行上表现出色，还在咨询领域展现出了强大的竞争力。\n一、转型案例 在当今竞争激烈的市场环境中，广告公司纷纷寻求转型升级，通过拓展咨询业务来提升自身的竞争力。这一趋势在全球范围内愈发明显，许多国际广告巨头通过并购、合作等方式，积极布局咨询领域，以期在新的市场格局中占据一席之地。\n2020 年 7 月， WPP 集团 ↗ 宣布将旗下三家代理商合并，成立新的全球性战略传播和公共事务咨询公司 Finsbury Glover Hering，并于2021年10月， Finsbury Glover Hering和 Sard Verbinnen \u0026amp; Company宣布了合并的意图，成立了 富捷思国际 ↗ ，从而综合了战略传播所有方面的咨询能力，包括董事会层级咨询、政府事务、公司声誉、危机管理和转型变革等等。这一举措旨在整合资源，提供更全面的战略传播和公共事务咨询服务。\n2022 年 6 月， 阳狮集团 ↗ 宣布收购数字化产品咨询和技术公司 Wiredcraft（琢品网络） ↗ ，进一步强化其在数字转型和咨询业务方面的能力。通过此次收购，阳狮集团能够更好地为客户提供数字化解决方案和咨询服务。这一战略举措不仅提升了阳狮集团的技术实力，还为其在数字化转型领域的发展注入了新的活力。\n在国内市场，广告公司转型咨询化的趋势同样显著。2021年5月20日， Okk.创意咨询 ↗ 宣布诞生，主创团队来自国内TOP创意热店（前有门创始人王小塞）、国际一线4A以及大型综合媒介代理公司。Okk.创意咨询致力于为客户提供创意设计、传播规划等传统服务，同时在战略、市场、品牌、营销等层面提供咨询服务。这一转型不仅丰富了Okk.的业务范围，还提升了其在市场中的竞争力。\n2021年8月，国际创意热店FF（FRED\u0026amp;FARID）宣布启动策略咨询机构 FLAWED否哲 ↗ ，开始咨询化尝试。FLAWED否哲旨在为客户提供品牌策略、市场分析等咨询服务，帮助客户更好地制定品牌战略。这一举措标志着FF在业务拓展上的新尝试，也为其在咨询领域的发展奠定了基础。\n2022年3月3日，人均从业经历20年+的广告人马晓波、姚俊、孙涛、周骏联合成立了全新的品牌营销咨询公司—— 群玉山 ↗ 。群玉山凭借团队丰富的行业经验，为客户提供品牌定位、营销策略等咨询服务。这一新成立的公司，不仅汇聚了行业内的顶尖人才，还为市场带来了新的活力。\n2023年2月14日，前小马宋高级咨询师苏佬师创立了 苏佬师品牌营销咨询 ↗ ，团队成员来自奥美、华与华、小马宋等知名公司。苏佬师品牌营销咨询专注于品牌战略、营销策划等咨询服务，帮助客户提升品牌价值。这一转型不仅为苏佬师带来了新的发展机遇，还为客户提供了一流的专业服务。\n2023年3月13日，因赛集团控股子公司天与空和找马品牌管理联合注资成立 上海找马天与空品牌营销咨询有限公司 ↗ ，简称找马天与空。找马天与空致力于为客户提供品牌营销咨询、创意策划等服务，助力客户实现品牌增长。这一新成立的公司，不仅整合了双方的资源，还为市场带来了新的服务模式。\n二、行业入侵 在2016年以前，广告公司和咨询公司还是一对亲密的合作伙伴，各自在自己的领域里发光发热，分工明确：广告公司负责创意，把甲方想要传递的价值传递给消费者；咨询公司则负责顶层建设，为甲方解决公司的战略方向。然而，从2016年开始，这份默契逐渐被打破，咨询公司开始涉足广告业务，一场没有硝烟的战争悄然拉开帷幕。\n咨询公司凭借其在战略规划和数据分析方面的优势，开始向广告业务渗透。2017年，埃森哲互动拿下玛莎拉蒂的全球品牌体验营销代理业务，这标志着咨询业巨头旗下的广告公司首次“抢到”一家品牌的主要广告代理业务。同年，AdAge发布的全球十大数字营销集团榜单中，埃森哲互动（Accenture Interactive）、IBM互动体验部（IBM iX）、德勤数字（Deloitte Digital）赫然在列。这一系列事件，仿佛是咨询公司向广告行业投下的重磅炸弹，引发了行业的广泛关注和讨论。\n面对咨询公司的入侵，广告公司自然不会坐以待毙。4A公司开始怒怼咨询公司，双方的口水仗愈演愈烈。一时间，媒体上甚至出现了“埃森哲收购 WPP，真的不是天方夜谭” 这样的标题。这不仅反映了广告公司对咨询公司入侵的不满，也揭示了广告行业面临的巨大压力。\n咨询公司和广告公司的思维模式迥异，咨询公司更注重战略，而广告公司则更看重创意。咨询公司认为，产品的力量才是企业成功的关键，而广告公司的创意只是锦上添花。这种差异，就像英文单词“Strategy”在中文语境下被分成了“策略”和“战略”两个词，策略成了广告的一部分，而战略则成了咨询公司最重要的武器。\n然而，随着互联网的发展，品牌和效果的数据逐渐被打通，咨询公司需要直接参与到战略的执行层面，收购广告公司就自然而然了。这使得咨询公司和广告公司的界限越来越模糊，双方的相互渗透已经成为一种趋势。广告公司凭借其在执行层面的丰富经验，也在不断提升自己的竞争力，以应对咨询公司的挑战。\n在这场咨询公司与广告公司的较量中，双方各有优势，但也都面临着前所未有的挑战。广告公司需要不断提升自己的战略规划能力，而咨询公司则需要加强在创意和执行层面的实力。只有这样，才能在这场激烈的竞争中立于不败之地。\n1. 广告创意 在广告行业，创意一直是广告公司的核心竞争力。从奥美、WPP、阳狮、宏盟等国际4A公司，到本土成长起来的广告代理公司，创意都是他们最为看重的核心。那些让人称道的广告人，往往凭借一个个创意，让产品从无人问津到迅速打开市场，成为热销产品。\n4A公司们也希望通过整合策略和媒介部门的实力，提升自家业务的门槛，最终向客户证明：他们输出的是一个值得高溢价的创意。为了实现这一目标，各大4A集团不断并购新的公司，为调查、策略、媒介部门招兵买马，将广告公司变成一个个庞然大物。然而，创意依旧是广告公司的立身之本，就像广告界最重要的盛会——戛纳国际创意节，从名字就能看出创意对于广告人的重要性。\n那些被广为传唱的广告传奇故事，也进一步凸显了创意在广告圈的重要地位。例如，宝洁能够在早期脱颖而出，很大程度上是因为它是最早在肥皂上打上LOGO的品牌。\n然而，随着数字媒体的崛起，媒体渠道变得越来越分散，数据成为了深水区。各家有各家的围墙花园，每家有每家的投放逻辑。这种媒体环境的改变，使得消费者的圈层化越来越明显，信息茧房、圈层壁垒在很大程度上区隔了消费者。这就意味着，过去那种依靠一个“Big idea”让一个地区的消费者对品牌有一致认知的做法，已经变得不太现实。\n如果完全寄希望于精准投放，也不是什么好主意。当年阿迪达斯就是这么干的，最终的结果却是：“在两年后，发现全面效果广告，忽视长期品牌”的负面案例。这表明，广告公司需要在创意和精准投放之间找到平衡，才能在数字媒体时代取得成功。\n2. 咨询战略 在广告人眼中，创意是无可替代的核心，那些传奇般的营销成果，往往被视作创意力量的集中展现。从广告人的视角出发，创意就如同魔法一般，能够赋予产品独特的魅力，使其在市场中脱颖而出。然而，当我们将目光从广告领域转向咨询公司，会发现一个截然不同的世界。\n咨询公司，这个以战略为武器的商业智囊团，他们的DNA中刻写着“战略”二字。在他们看来，宝洁之所以能够风靡全美，绝非仅仅依赖于在肥皂上印上logo的创意，而是其过硬的产品质量。那块印有logo的肥皂，不过是让消费者在琳琅满目的货架上能够迅速识别出宝洁产品的标识，归根结底，是产品的力量铸就了宝洁的辉煌。\n大众甲壳虫汽车在美国的成功，也不仅仅是那句经典的广告语“Think Small”的功劳。20世纪60年代的美国，正经历着通货膨胀的冲击，经济形势的不稳定让美国消费者更加倾向于选择经济实惠、耗油量小的汽车。大众甲壳虫以其小巧的车身和出色的燃油经济性，恰好契合了当时美国消费者的需求，从而赢得了市场的青睐。\n苹果公司的崛起，同样不是单纯依靠“Think different”这一广告口号。苹果的iOS系统以其“傻瓜式”的封闭性设计，提供了极高的易用性，再加上苹果在产品层面持续不断的创新，才引发了一个时代的变革。可以说，是苹果的创新精神和革命性的产品，赋予了“Think different”这一口号真正的力量。\n广告公司与咨询公司，这两种截然不同的思维模式，如同两条并行不悖的河流，各自流淌在商业世界的版图上。在中文语境下，英文单词“Strategy”被拆分成了“策略”与“战略”两个词。策略，成为了广告公司手中的利刃，用于在市场中披荆斩棘；而战略，则是咨询公司最重要的武器，用于为企业规划长远的发展蓝图。\n资深战略咨询顾问、原贝恩咨询总监Michael Farmer曾言，咨询从业者会全身心投入，帮助客户厘清如何重振品牌增长、如何实现品牌盈利。这背后，是大量的数据分析、战略计划的制定，以及对收购代理公司的具体执行营销传播落地的把控。\n在行业发展的黄金时期，咨询公司与广告公司各司其职，相安无事。咨询公司专注于企业的战略规划，为企业指引方向；广告公司则负责将这些战略转化为具体的营销传播行动。麦迪逊大道上的4A公司，作为广告行业的翘楚，牢牢把控着几乎全部的流量资源。在那个稳定的市场环境中，咨询公司与广告公司各自安守本分，按照既定的分工模式，平稳地运行着。如果世界永远保持这种高速发展的态势，或许双方将继续在各自的领域中稳步前行，下一个40年，也将如往昔一般，按照既定的轨迹延续下去。\n3. 市场变革 当时间的指针拨向 2017 年，一场悄无声息却影响深远的变革已在市场这片广袤的土壤中悄然萌芽。回溯至 2014 年，移动数字广告宛如一颗初升的朝阳，带着蓬勃的朝气踏入了人们的视野，经过三年的砥砺前行，它逐渐走向成熟，为市场格局带来了全新的变数。\n曾经，4A 公司在广告领域手握重权，媒体资源几乎被他们牢牢掌控。那些巨型代理公司，凭借着对媒体资源的垄断，再搭配上创意的火花，构建起了一条看似坚不可摧的护城河，将竞争对手拒之千里。然而，移动互联网媒体的极端分散化，却如同一把利刃，无情地斩向了这层护城河，使其出现了裂痕。\n数字媒体的特性，让创意的作用在一定程度上被削弱，与此同时，移动互联网却展现出了强大的数据收集能力，能够全方位、多角度地捕捉用户的偏好和使用习惯。这使得企业恍然大悟，沉淀、解读和运用数据的能力，已然成为了决定企业竞争力的关键因素。于是，数据报告成为了人们热议的焦点，大家依据这些报告洞察消费者的需求，进而制定精准的营销策略，确定执行营销项目的供应商，合理分配投放预算和渠道，只为确保能够达到客户预期的营销效果。\n咨询公司敏锐地察觉到了这一变化，他们发现，数据运用能力正是自己的拿手好戏。回首过往，咨询公司凭借专业的研究，为客户出具市场报告和洞察，如今，进一步涉足营销报告领域，似乎也并非难事。既然如此，为什么不干脆把品牌策略、媒介分配这些任务也一并交给咨询公司来完成呢？\n在过去，这样的想法或许还面临着诸多阻碍。以策略为主的 Warc 奖项中，那些荣获全场大奖的案例，其背后的品牌几乎都与代理机构合作了五年之久。某日化快消品牌的前高管曾向 Morketing 表示，长时间的合作让代理机构能够深入了解品牌主的诉求，精准把握品牌想要传递的价值，以及深刻洞悉品牌目标人群的喜好。然而，如今有了海量的数据，这个漫长的过程便可以被大幅缩短，无需再依靠各种创意去试探品牌目标人群的喜好，而是可以通过人群的属性，来定制和规划创意。\n埃森哲互动等公司的出现，便是这一变革的有力见证。他们不再像传统广告公司那样，挥舞着基于Brief、通过头脑风暴做出的企划书，而是转而运用关于市场和消费者的调查和数据，来打动广告主，让其心甘情愿地买单。自 2016 年埃森哲互动拿下第一次比稿的胜利之后，仿佛一场狂风骤起，吹得整个营销传播赛道风云变幻。埃森哲、德勤这样的咨询公司，Snapchat、Google 手握算法的互联网公司，Salesforce 和 IBM 这样的 IT 技术公司，乃至像纽约时报、Vice 一直专注于内容制作的媒体公司，都纷纷在这条赛道上疯狂并购，试图在这场变革中分得一杯羹。\n在这场变革的浪潮中，甲方也在悄然改变。互联网技术革命为广告主带来了直接、免费接触和沟通消费者的手段与可能。大量免费内容平台、流量入口、网络大号如雨后春笋般涌现，让广告主拥有了绕开传统机构化媒体，直接传播品牌的机会。传统的 “IN House” 内部广告部门，也开始大刀阔斧地向 “自营内容” 进化。过去，服务商最大的护城河是创意，那些能够制作出优秀创意的人才被视为无价之宝。但在今天，除了人这一永远重要的资产之外，服务商更加需要补足的是在数据和技术方面的硬资产。\n这一点，在数字广告营销服务商身上体现得淋漓尽致。那些伴随着互联网时代崛起的数字广告服务商，几乎没有一个在强调创意，反而将这个充满浪漫主义色彩的词，冷漠地称呼为 “投放素材”。而他们的宣传重点，几乎都集中在两件事上：一是第三方数据提供广告主所没有的多维数据洞察；二是强有力的模型能力，完成高效且精准的广告投放。\n于是，在那个因数字广告平台到来而动荡不安的广告新纪元，数字广告服务商如雨后春笋般涌现，成为了广告行业重要的新生力量。\n三、为什么要咨询化 在当今竞争激烈的商业环境中，广告公司纷纷寻求转型升级，而咨询化成为了一条重要的发展路径。咨询化不仅能够提升广告公司的专业形象，还能增强其在市场中的话语权和议价权。以下是咨询化的重要性和优势：\n1. 话语权与议价权 不同于传统广告公司主要处理单次营销活动的传播策略、创意输出或媒介采买，咨询公司能够提供包括市场调研、数据分析、战略规划、营销策略、创意内容等高阶化系统服务。咨询公司以调研分析师、咨询顾问，甚至是教练导师、创业伙伴的身份，直接与企业创始人或CEO等高层对话。这种直接对话的方式使得咨询公司在合作中拥有更高的话语权。\n现在的广告公司往往需要疯狂内卷去参加比稿，而强势的咨询公司则拥有选择邀约哪些广告公司来比稿的权利。因此，有志向的广告公司一定会力争产业链上游，往营销行业的金字塔顶端迈进。咨询公司通过提供更专业的能力和更权威的资源，能够更深入地为客户解决更大的问题，对企业经营层面的影响更深更广，从而具有更大的价值和议价空间。\n群玉山在服务客户期间，不仅提供品牌定位、营销策略等咨询服务，还发现了某些团队的不专业性，一度协助品牌优化调整市场团队。这种深度参与客户内部管理的方式，进一步提升了其在客户心中的地位和话语权。群玉山的收费情况未公开，但其服务的高质量和专业性得到了客户的广泛认可。作为老牌营销类咨询公司，特劳特的收费高达2000万一年。其通过独特的定位理论和丰富的行业经验，为客户提供战略规划和品牌定位等高阶服务。麦肯锡的价格也是 2000万，君智咨询的收费同样是一年2000万，其专注于为客户提供战略咨询和营销策划，帮助企业在竞争激烈的市场中脱颖而出。\n叶茂中的收费为一年1500万，其以创意策划和营销策略见长，为众多知名品牌提供了专业的咨询服务。东极定位的报价为1200万一年。其通过深入的市场调研和数据分析，为客户提供精准的品牌定位和战略规划。华与华的收费为一年580万起，一般会签3年，其提供品牌策划、创意设计、营销推广等全方位服务，华杉直言，他们完全可以把价格定到2000万，但那样客户会从60个锐减到6个，更糟的是，高价可能会导致核心成员另起炉灶。\n小马宋品牌咨询的收费为160万起，其以品牌战略和营销策划为核心，为客户提供专业的咨询服务，小马宋自己也坦言，这样的定价不仅能锻炼团队，还能迅速扩大市场影响力。低价成为他们进入市场的杀手锏。。刚成立三个月的苏佬师咨询收费为20万起，其团队成员来自奥美、华与华、小马宋等知名公司，具备丰富的行业经验。\n具体收费还得看项目的复杂程度和时间长度，但不难看出，咨询业务的议价权更高。这种高议价权不仅体现了咨询业务的专业性和权威性，也为咨询公司带来了更高的利润空间。\n2. 竞争 根据前瞻产业研究院的数据，截止到2022年10月，我国广告行业相关企业超过73万家，且自2018年起，每年新成立的数量以数万计。广告公司野蛮生长，数字化、自媒体时代、网红经济的背景下，广告行业也多了更多外来竞争者。在创意内容层面，个体KOL、KOC爆发式增长，他们基于对自己粉丝群体内容偏好、行为习惯的了解，常常能产出更具传播效果的广告创意。在媒介投放层面，互联网平台作为媒体本身，掌握核心推荐算法和运营数据，MCN机构运营了大量的网红达人，越来越多的广告主跳过广告公司直接找他们打包做投放。像无忧传媒这种MCN巨头直接成立媒介投放部门，抢占广告业务。在总体业务层面，一些品牌主也有“去乙方化”的倾向，他们成立内部创意部门，自行组建业务团队，自己运营官方自媒体矩阵，自己做创意和传播，in-house正在成为一种风气。随着GPT这样的内容生成式技术的不断发展，可预见的是，一般性的内容制作业务将会更少。广告公司不再特别，业务不断被蚕食，只能不断内卷。经常能看到这类吐槽/自嘲：比稿不再需要支付比稿费；只有极少公司才敢收创意费；以前比稿只需要做好一个idea，现在都默契地准备N+1个方案，为了拿下一个客户，需要耗费更多的人力和时间资源；有些广告公司为了接活，不惜干起赔本买卖，低价竞标，甚至在后续的服务中为了做出案例，而选择倒贴。不难看出，广告行业内卷的原因是竞争大，而竞争大的核心原因是广告业务门槛低，似乎人人都能分一杯羹，于是入场竞争的越来越多。\n相对来说，咨询公司的门槛更高。系统化的咨询工作，要求团队的能力更综合，大部分广告公司，需要通过收购、合伙、再招聘等形式，去重组团队配置，才能达到基本门槛。在此之前，他们还需要积累经典案例，在业内形成口碑和权威，同时需要积累大量客户资源，才能保证能接到活儿，且要保证这些活的量要能够支撑新团队健康运转下去。这对能力、资金、资源的要求更高，所以不是所有的广告人或广告公司，都能、都敢转型。也因此，咨询行业竞争更小。\n3. 适配性 广告公司向咨询领域转型展现出较强的适配性，这主要得益于业务相关性强、人员配置重叠以及客户资源重合等多重优势。市场营销咨询公司除了提供战略、市场、品牌和营销等咨询服务外，还需要创意、内容和传播等传统广告服务来确保方案的落地执行。而全案广告公司通常已经具备策略、创意策划、文案、美术、媒介以及摄影摄像、后期等岗位，覆盖了咨询、创意、内容、传播四个业务板块中的三个，可以说是半个行家，能够保障创意、内容、传播的有效执行。理论上，他们只需补充咨询板块业务，增加调研分析、战略规划师等岗位，就能进一步完善业务布局。\n广告公司在长期服务客户的过程中，积累了丰富的客户资源和深厚的客户关系。广告人，尤其是核心创意人和客户经理，需要反复与客户沟通交流，因此对客户的业务状况、市场定位、品牌理念等有着深入的了解。同时，为了挖掘更多的业务需求，他们也会主动思考和探索客户面临的问题，从而能够先一步发现和接触到客户的咨询需求。随着双方合作的不断深入，爆款案例的不断涌现，甲乙双方的合作愈发默契，客户也会逐渐给予广告公司更大的权限，遇到问题时会以商量甚至是请教的态度与广告人交流。例如，马晓波在胜加为银联打造《大唐漠北的最后一次转账》时，已经能够与银联的董事长和核心副总裁直接对谈；为知乎制作《有问题就会有答案》时，对接的是知乎的创始人周源及其核心高管层。这些积累的客户资源，不仅为广告公司咨询化转型提供了第一批客源，也为其顺利转型提供了有力保障。\n四、现状和趋势 1. 数字化 广告公司向咨询领域的转型并非近年的新趋势，其雏形可追溯至十几年前，这与 “咨询公司广告化” 现象密切相关。曾经有这样一个调侃：全世界的咨询公司，一半在忙着和4A抢生意，另一半忙着收购4A公司。这一现象揭示了咨询公司与广告公司之间日益模糊的边界。\n早在2009年，咨询巨头 埃森哲（Accenture） ↗ 便成立了埃森哲互动（Accenture Interactive），将全球范围内的数十家广告代理机构纳入旗下，标志着其正式进军广告营销领域。2012年前， 普华永道 ↗ 设立了PwC数字（PwC Digital），提供数字咨询服务，并紧接着收购了多家亚洲和欧洲的数字创意公司，以提供数字营销代理服务。同年， 德勤咨询 ↗ 成立了德勤数字（Deloitte Digital），最初通过传统咨询和IT项目交付切入数字营销领域，随后通过一系列收购，逐渐发展成为一个涵盖咨询、技术、渠道执行的“全服务”机构。2013年，IBM也成立了IBM iX，开始提供营销咨询服务。\n随着埃森哲、普华永道、德勤等知名国际咨询巨头通过大规模收购广告营销公司来争夺市场，国内外的广告公司也开始了积极的反击。他们通过内部增设咨询业务部门或成立专门的咨询公司来应对这一挑战。\n据不完全统计，2012年，IPG集团旗下的创新设计和传播公司R/GA宣布新增咨询业务。2014年11月，阳狮集团以37亿美元收购了美国专精于数字广告的咨询和技术服务公司Sapient，并成立了璞砺营销咨询（Publicis Sapient）。2016年9月，WPP集团旗下的伟门（Wunderman）将首屈一指的营销技术咨询公司Acceleration纳入旗下网络，旨在提升其数据和技术咨询服务的能力。2018年1月，WPP集团旗下的凯度集团宣布成立凯度咨询公司（Kantar Consulting）。同年6月，WPP集团旗下的奥美宣布将其OgilvyRED战略部门重新命名为奥美咨询公司（Ogilvy Consulting）。此外，WPP旗下的AKQA、VML和Mirum等公司也设立了咨询业务部门，向客户提供“数字化转型及成长”与“业务设计及创新”的咨询服务。2021年8月，阳狮集团宣布推出阳狮营销咨询业务板块，业务范围包括但不限于商业目标制定、业务模式梳理、产品线规划、产品服务创新、数据策略、数字化转型、体系化故事、视觉包装、传播落地等一站式解决方案。\n面对大牌咨询公司对广告业的挑战，国际4A公司率先转型，积极布局咨询业务，推动数字化进程，带领传统广告业对抗介入营销传播行业的大牌国际咨询公司，展现出你来我往、兵戎相见的竞争态势。\n2. 理论 长期以来，以英美为首的西方营销理论，深刻影响了中国广告营销领域的认知与方法论。许多国外营销理论专家在研究出一套理论后，便会成立自己的咨询公司，例如定位理论创始人之一的特劳特创办的 Trout \u0026amp; Partners ↗ （特劳特伙伴）公司。特劳特伙伴公司有许多经典案例，如香飘飘奶茶 “一年卖出7亿多杯，杯子连起来可绕地球两圈”，瓜子二手车 “没有中间商赚差价”，东阿阿胶 “滋补国宝”，猿辅导在线教育 “全国累计用户突破4亿” 等。\n另一位定位之父艾·里斯先生创办了 里斯品类创新战略咨询公司 ↗ 。虽然师出同门，但与特劳特强调广告传播不同，里斯对定位理论做出了全新发展，更加强调品类聚焦与公关传播。例如，帮助老板电器通过聚焦大吸力油烟机，推动长城聚焦经济型SUV哈弗、女性电动车领导品牌欧拉和潮玩越野SUV坦克等。\n随着中国市场的发展和本土广告人的努力，众多本土广告公司在被西方营销理论影响、教育的基础上，在咨询化的道路中回过头来，结合中国古老的智慧，打造属于自己的营销理论。例如， 君智战略咨询 ↗ 创始人谢伟山、徐廉政均出自特劳特中国公司，与特劳特不同的是，君智不仅重视定位理论，更结合《孙子兵法》和《道德经》的思想，用东方智慧融合西方商业理论，独创出属于自己的战略系统，案例成果也很经典。如服务 7 年，助力飞鹤化解国产信任危机，打破洋品牌垄断，成为中国婴配粉市场领导者；服务5年，协助波司登化解竞争困局，传统老牌重获主流青睐；服务7年，帮助雅迪突围价格战，借助高端成为行业第一等。\n同样出身特劳特和君智的 东极定位咨询 ↗ 创始人王博，在定位理论中引入毛泽东思想，强调一定要高度重视中国市场的特殊性，推动特劳特定位理论的本土化创新与升级，曾做出如 “飞鹤奶粉，更适合中国宝宝体质” 和 “唯品会，一家专门做特卖的网站” 等经典战略定位案例。\n本土战略营销品牌咨询公司 华与华 ↗ 创立了超级符号理论，其创始人华杉还喜欢研究儒家思想和孙子兵法，用其中的思想来指导公司管理、日常工作。公司拥有“牙齿好，喊田七！”“蓝瓶时代，选三精！”“你爱我，我爱你，蜜雪冰城甜蜜蜜”“晒足180天，厨邦酱油美味鲜！”等经典案例。根据广告狂人的文章描述，华与华前合伙人陈伟恩于 2021 年成功创立 纬恩品牌咨询公司 ↗ 。\n叶茂中冲突营销 ↗ 的创始人叶茂中，通过多年的营销策划经验，总结出了一套完整的冲突营销理论体系。他认为，发现冲突就是发现需求，制造冲突就是创造需求。这一理论在营销界产生了深远的影响，并被许多广告人和营销人视为重要的方法论。他的著作《冲突》详细阐述了这一理论，成为广告营销行业的经典书籍之一。此外，叶茂中还提出了营销的16个关键词，进一步解析了营销的各个方面。叶茂中对国画艺术也有深厚的兴趣和研究。他曾在病中举办“叶茂中画展”，由龙美术馆创办人刘益谦担任策展人。他对绘画的热爱和造诣体现了他在艺术领域的另一面。他曾在文章《感恩有画》中表达对绘画的感恩之情，认为绘画为他保留了一个开阔的心灵空间。\n叶茂中做出过 “恒源祥，羊羊羊” “赶集网，啥都有” “爱华仕，装得下，世界就是你的” “有问题，上知乎” “一年逛两次海澜之家” 等经典案例。但是在广告狂人的文章中提到 “叶茂中有 35 名徒弟成功离职创业，并且咨询费均在 300 万左右。” 截止发文，四二角并未找到可信来源。\n百思特管理咨询集团 ↗ 提出了“一体化解决方案式管理咨询”模式，其创始人张正华专注于企业战略、组织变革和管理提升等领域，将实战经验与理论相结合，为企业提供切实可行的解决方案。公司拥有 “一品红药业”“翰宇药业”“德力西集团”“欣龙控股”“劲拓股份” 等经典案例。根据百思特官网的描述，百思特咨询已帮助包括 500 多家上市公司在内的 5000 多家企业全面提升企业核心竞争力和行业地位，并帮助近百家客户成为中国乃至世界的标杆和隐形冠军。\n其他还有由邵军创立的 智旗咨询 ↗ ，成功打造了小罐茶、花西子等经典案例，由徐丽创建的 焦点咨询 ↗ 拥有“江中健胃消食片” “猴菇米稀” “慢严舒柠” 等爆款案例，由徐超创立的 火橙咨询 ↗ 拥有 “立马大动力电动车” “圣农鸡肉” “天喔蜂蜜柚子茶” 等案例，以及由储门创立的 雷艺后道广告 ↗ 秉承“一切为了销售，否则就不是做营销”的 等等。\n除了以上在公司名字里有“咨询”二字的营销公司，越来越多本土广告公司也开始有意识地提高自己的策略水平，在输出创意的同时，为品牌方提供一点策略参考。\n3. 参与经营 在咨询化转型的过程中，一些公司进一步探索商业模式，开始通过合伙人甚至创业者的身份，更多地参与具体的经营活动。例如，特劳特在服务过程中入股了明月镜片、瓜子二手车等企业，打造了战略合伙人长期护航模式，逐步转型为企业的“创业伙伴”和“外部合伙人”。这种模式使他们能够更加深入地参与企业的经营决策，确保咨询工作的时效和实效，对企业的结果、生意和效果负责。\n国内的整合营销咨询集团 十相 ↗ 也是一个典型例子。创始人张帆出身广告行业，集团业务除了营销咨询和落地执行外，还涉足自主品牌孵化业务。他们在餐饮连锁、时尚生活和宠物服务三大板块投资孵化了8个新消费品牌，包括满吉拉面、FMACM、宠物公民（Petizen）等多个知名品牌。通过从0到1自行孵化品牌，十相全方位地运用公司的智力和资源，为自己的理论和能力提供强有力的背书，同时在实践中不断提高公司的服务水平和优化方法论。\n4. 方法论 在咨询行业，沉淀下来的方法论不仅是提升公司品牌专业度和辨识度的重要工具，还能增强公司在行业内的知名度和影响力。这些方法论不仅可以用来培养和训练员工，还能作为产品或服务销售出去，为公司带来额外的收入来源。\n华与华在营销知识商业化方面有着成熟的思考和布局。他们出版了多本工具书，如《超级符号原理》和《设计的目的》，这些书籍不仅传播了其独特的营销理念，还为公司带来了额外的收入来源。此外，华与华还开发了多个营销课程和培训项目，形成了以线下培训、文库出版、学术研究、线上课程为主的四大板块业务。\n昆仑战略定位培训 ↗ 是 成美战略定位公司 ↗ 旗下专注战略定位实战培训的机构，由向光宁和梁山共同创建，成美战略定位董事长耿一诚担任总顾问，专注于为中国企业提供战略定位课程和咨询项目，如《战略定位班》和《战略定位方案班》等培训咨询服务。这些课程和项目已经累计培训学员过万人，为企业提供了专业的战略定位指导。\n叶茂中咨询机构的创始人叶茂中，其确立江湖地位的两本书《广告人手记》和《冲突》也是方法论产品化的典型例子。这些书籍不仅传播了其独特的营销理念，还为公司带来了额外的收入来源。叶茂中通过这两本书，将复杂的营销理论转化为通俗易懂的语言，使更多的广告从业者和企业能够理解和应用。这种做法不仅提升了叶茂中个人的知名度，也增强了其咨询机构的市场竞争力。\n撬动战略的“定位方程”通过AI技术分析消费者心智数据，构建“战略-战役-战术”协同模型，帮助企业实现全球化布局。例如，霸王茶姬凭借“现代东方茶”定位成为国际茶饮代表品牌。这一战略工具利用先进的AI技术，深入分析消费者的心理和行为数据，从而为企业提供精准的市场定位。同时，撬动战略还推出了AI驱动的战略诊断工具和《定位方程》理论课程，并通过案例库（如舒福德智能床、奔图打印机）吸引企业购买咨询服务。这些工具和课程不仅帮助企业更好地理解市场，还提供了实用的操作指南，使企业能够在全球市场中占据一席之地。\n里斯的“品类创新”方法论强调通过创造新品类或重塑消费者认知来实现增长。例如，长城汽车旗下的坦克品牌通过聚焦越野车市场，开创了“潮玩越野”新品类，占据了中国越野车市场50%的份额。这一方法论的核心在于通过市场调研和消费者洞察，发现新的市场机会，从而推出具有创新性的产品或服务。里斯中国不仅出版了《品类战略》等书籍，还推出了“品类创新工作坊”，帮助企业从市场调研到品类定义的全流程落地。这些实践不仅为企业提供了清晰的战略方向，还通过实际操作帮助企业实现增长。\n黑格咨询的“品牌竞争战略”通过创建竞争公式、品类公式、产品公式等六大模块重构品牌竞争格局。例如，汾杏酒通过“杏花村第二瓶美酒”的定位迅速崛起。这一战略的核心在于通过系统化的分析和规划，帮助企业找到独特的市场定位，从而在竞争中脱颖而出。黑格咨询不仅推出了《品牌竞争战略原理》书籍及配套工具（如《运营罗盘》《营销日历》），还通过线下培训（如“酒类专用工具箱”）实现方法论商业化。这些工具和培训不仅提供了理论指导，还通过实际案例帮助企业更好地理解和应用这些战略。\n观速的“零到一战略”聚焦品牌从零到一的战略创新，强调赛道选择和传播成本降低。例如，“头等大事，冬雷脑科”等案例通过符号化语言快速占领用户心智。这一战略的核心在于通过精准的市场定位和高效的传播策略，帮助初创品牌迅速建立市场地位。观速不仅通过案例集《战略新赛道》展示了其成功案例，还通过定制化咨询服务（如品牌定位+视觉设计一体化方案）吸引初创企业客户。这些服务不仅帮助企业明确了品牌定位，还通过视觉设计等手段提升了品牌的市场影响力。\n五、转型关键 广告公司要成功转型咨询并提升咨询水平，关键在于以下两点：\n1. 人才培养 广告公司若想在咨询领域站稳脚跟，人才培养与引进是其转型路上的基石。广告公司需广纳贤才，通过收购、合并、招聘、合伙及内部培养等多种方式，配备各类专业人才，如调研分析师、策略规划师等，以弥补传统广告公司在咨询岗位上的不足。同时，整合外部资源，包括市场调研、数据分析、营销技术、咨询培训等方面的资源，为公司提供额外支持，为品牌方提供更全面、深入的咨询服务。\n2. 系统思维 广告公司应正视方法论的重要性，有意识地将直觉和经验沉淀为体系化的方法论，将工作流程、评定标准、营销方法规范化。通过基于可重复使用的方法论开展日常工作，能够迅速了解新行业和新品牌，为客户找准问题并提供解决方案，帮助客户内化咨询成果，而非依赖特定的经验和灵光一现。\n广告公司在转型咨询的过程中，需要承担相应的风险，发挥自身的优势，做自己最擅长的事情。只有这样，才能在市场竞争中立于不败之地，实现可持续发展。在这个过程中，广告公司要深刻理解“被需要，即是正义”的内涵，以客户需求为导向，不断提升自身的专业能力和服务水平。\n六、参考 广告公司咨询化，是个伪命题 ↗ 广告杂谈丨广告公司可以转咨询公司？ ↗ 宏盟又收购了一家咨询公司 广告与咨询之间的界限愈发模糊 ↗ 叶茂中走了，留下16个营销关键词和无数经典 ↗ 为什么很多咨询公司都有自己的方法论 ↗ 行至9年，黑格给出了怎样的“升级方法论”？ ↗ 逝者 | 走进“广告狂人”叶茂中的艺术人生 ↗ 百思特（百思特管理咨询有限公司） ↗ 广告公司咨询化 ↗ 广告公司为什么都想做咨询？（上） ↗ 广告公司为什么都想做咨询？（下） ↗ 咨询公司入侵广告业？蓝色光标想用数据破解困局 | 营销观察 ↗ 2024-2030年中国广告行业转型升级市场深度调研与发展趋势预测报告 ↗ 找马天与空：品牌强国，从战略创意开始 ↗ WPP将两家公关公司合并，又一个行业巨无霸诞生 ↗ “入侵”广告业，咨询公司会给未来营销界带来什么？ ↗ ","date":"2025-02-23","tags":["转型"],"title":"咨询广告：为何广告公司纷纷转型咨询公司？","url":"/post/2025/02/a/"},{"content":"美可特品牌设计成立于1988年，最初以广告公司的形式运作。然而，由于公司位于台中，相较于广告资源丰富的台北，美可特在媒体资源获取上存在天然劣势。当时的市场环境对仅有广告创意的公司极为不利，尤其是当客户越来越倾向于整合营销的模式时，这种单一的广告业务模式严重限制了美可特的早期发展。\n在美可特成立后的早期阶段，中南部的业主往往较为强势，认为自己作为出资方，理应拥有项目百分之百的主导权。这使得设计师在合作过程中话语权较弱，创意和想法难以充分施展，公司发展受到抑制。直到美可特成立10年后，1999年台湾发生了921大地震。这场灾难促使人们深刻反思商业模式的可行性和有效性。与此同时，美可特的执行总监王盈发观察到设计生态的变化，业主开始放松对合作主导权的把控，逐渐意识到从设计出发也能实现理想的市场效果。\n转型：您的设计伙伴 面对市场和业主观念的转变，王盈发果断化被动为主动，向客户提出了“您的设计伙伴”（Your Design Partners）的概念。这一概念的核心是将原本处于营销旅程末端的产品设计角色向前推进，以“伙伴”的身份融入到业主的决策环节中。美可特不再仅仅是执行设计任务的供应商，而是与客户并肩作战，共同探讨客户未来的发展方向。这一转型举措为美可特后续20年的发展奠定了坚实基础，使其在市场竞争中脱颖而出，与客户建立了更为紧密和深入的合作关系。\n在转型过程中，美可特深知理念和认知的一致性是成功合作的关键。因此，公司执行总监王盈发非常谨慎地对待潜在客户的合作探询。他不仅要求客户认同公司的收费标准，更重要的是希望客户能够亲自到位于台中的办公室进行深入交流。通过花费几个小时的时间，双方共同探讨多个议题，来判断彼此是否投缘、是否有共鸣。这种前期的深入沟通有助于客户更全面地了解美可特的设计理念和工作方式，从而增强客户对合作的信心。\n美可特将投资时间进行“认知整合”视为进入设计阶段前最为重要的工作，这也是公司赢得客户信赖的重要原因之一。在正式开展设计工作之前，公司会花费大量时间去评估双方的认知是否一致，确保大家朝着相同的目标前进。他们会深入研究产品在市场的反应，分析消费市场的特点和趋势，甚至还会观察客户内部的组织决策环境，层层解构营销面向，再重新整合合作结构。只有在双方都处于非常笃定的状态下，才会正式进入设计阶段。\n美可特将营销包装视为一种“品牌工程”，并将其划分为三个阶段：前端的“认知整合”、中间的“形象整合”以及后续的“功能整合”。为了更好地推进这一品牌工程，王盈发提出了“美可特创意跳板”（Creative Spring Board，简称CSB）系统。该系统能够将营销目标、竞争对手、目标对象、市场策略等关键要素，转化为对视觉设计与沟通传达具有具体影响的项目。通过这一系统，项目企划人员与客户在合作过程中能够有章可循，遵循既定的原则循序渐进地推进项目，从而确保品牌建设工程的结构稳固且强健。\n在创意行业深耕超过30年的王盈发，对市场的变化有着敏锐的洞察力。他深知市场的“变”与“不变”，并能够根据市场动态灵活调整公司的策略。以致力于发展台湾苦茶油文化的“茶籽堂”为例，王盈发在品牌前期阶段摒弃了传统的市场调研方式，转而建议客户直接与台北各大文创场域建立联系，提供茶籽堂的产品，取代公共厕所中缺乏温度且充满化学原料的洗手乳，甚至在厕所里悬挂茶籽堂包装上的版画，使整个空间氛围保持一致。通过这种方式，让消费者自然而然地与品牌产生接触，再辅以情境思考，创造出视觉、触觉与嗅觉的共感，形成了一种有别于传统模式的创新营销方法。\n尽管市场环境不断变化，但人类对“美”的追求却是恒久不变的，而且标准也在不断提高。面对市场日益严苛的期望，王盈发忌惮急躁，反而坚持与客户共同拉长合作的战线，一同布局未来的发展。与其他品牌设计公司相比，美可特的每一步都走得相对缓慢，但却异常坚定。王盈发认为，那些期望在3个月内就看到成效的案子，都属于急案。而美可特与客户共同思考的是更长远的市场布局，例如2021年中秋节的市场布局等。\n台湾品牌发展三阶段 美可特通过出版《担露》、《担露1.5》与《担露2018》三本作品集，从伴手礼品牌设计的角度梳理了各阶段的作品，总结归纳了自身的创作意识与市场关联，见证了台湾品牌发展的三个阶段。\n第一阶段的代表品牌是发迹自台中大甲的“小林煎饼”与嘉义的“老杨方块酥”。这些传统饮食品牌虽然做工实在，但缺乏让人印象深刻的记忆点。美可特从感性角度出发，在舌尖美味中寻找故事论述，用人文情怀调和传统美味，同时改造品牌包装等视觉形象。经过脉络化设计后，这些地方特色美食被装在精心设计的纸盒包装中，不仅提升了产品的档次，更使其成为地方伴手礼的代表，品牌再造在这一过程中发挥了重要作用。\n最近十几年来，随着新世代接手家族品牌，第二代接班人的营销逻辑与美感观点与上一代有所不同，从而推动品牌发展进入第二阶段：注重社会企业责任，在追求商业利益的同时，兼顾环境永续和社会回馈等议题。以茶籽堂为例，创办人赵文豪在接手父亲的事业后，坚持推广苦茶油文化，近年来与农民合作，还在宜兰南澳朝阳社区推行复兴计划，鼓励当地年轻人回流耕耘。\n近年来，许多有理念的企业接班人开始挑战传统思维，以友善环境为信仰，采用颠覆性的做法，推动品牌发展进入第三阶段：从产地到餐桌，坚信从产品源头进行改变的力量。例如，“trreeo树重奏”的主理人在自己的农场里奉行酵道自然农法，根据不同季节的作物特点，发展出独特的产品；南投的鸡只养殖品牌“十八养场”让鸡食用拌有台茶十八号红茶的草本饲料，使得红玉鸡的活动力增强，肉质中的氨基酸含量提升，口感更加鲜嫩美味。\n细节成就品牌价值 在当今市场环境下，好的产品内容和悠扬的信念固然重要，但需要通过优秀的包装设计传递给消费者。王盈发认为，包装是立体化的平面传达，打开包装的过程可以视为一种仪式。设计师精心安排各种开箱环节，让消费者在一步步开启礼物的过程中产生仪式感，并在这一过程中巧妙地嵌入各种细节，与品牌精神相互呼应，从而成就品牌价值。包装就像是将理性的情感转化为理性过程的载体。\n在包装设计中，挑选字体是至关重要的细节。王盈发将挑选字体比喻为给一件衣服挑选扣子和缝制车线，这些细节虽然看似微小，但却主导着最终的视觉效果。选择合适的字体能够让整体作品更加精致。除了商标和说明文字外，包装上的营养成分和成分说明等信息也至关重要。很多人在设计包装时，常常会忽略这些看似微不足道的细节。早期，字体的排版和印刷从铅字活印到照相排版，都依赖于打字行或排版公司，字体的选择有限，只能满足“看得清楚”的基本要求。但现在，随着字体厂商的不断涌现，字体选择变得丰富多样，对设计师的细节执行完成度也提出了更高的要求。\n尤其是像成分表、业务标、注意事项这类排版，字体大小有明确的规范，不能过小，但又要兼顾可读性和用户体验。在没有“微字体”的时代，这依赖于设计师的手动微调和高超的印刷技巧。例如，最近为保养品牌“CLAUD可洛迪”进行品牌包装设计时，王盈发使用了文鼎晶熙黑微字体，使得5pt到8pt的微型文字能够清晰地呈现，尤其是在文鼎对小字体的浓淡度进行了调整后，包装实际印刷出来的小字体不会模糊在一起，印刷效果良好，消费者阅读起来更加舒适，也更愿意阅读。\n","date":"2025-02-23","tags":["设计转型"],"title":"王盈发与美可特：从广告公司到品牌设计伙伴的营销转型之路","url":"/post/2025/02/marketing_transformation_from_advertising_agency_to_brand_design_partner/"},{"content":"顾客让渡价值 顾客让渡价值 = 顾客价值 - 顾客成本\n顾客价值：顾客从某个产品或服务获得的利益综合（功能、符号、利益等），比如一款手机，其具备高清拍照、快速运行软件、大容量存储等功能，这些功能满足了顾客在通讯、娱乐、工作等方面的需求。其次是符号价值，像一些奢侈品品牌，消费者购买它们不仅仅是为了产品的实际使用功能，更是因为品牌所代表的社会地位、身份象征等符号意义。还有服务价值，例如在购买汽车时，4S 店提供的免费保养、道路救援等售后服务，也构成了顾客价值的一部分，让顾客在使用产品的过程中享受到更全面的保障和便利。 顾客成本：顾客购买产品或服务所付出的成本或费用（货币、时间、精力等），比如购买一台笔记本电脑花费了 5000 元。时间成本也不容忽视，例如顾客为了购买一款热门的限量版球鞋，可能需要提前几天排队等候，这段时间就是顾客付出的时间成本。精力成本同样重要，像消费者在购买复杂的金融产品时，需要花费大量精力去了解产品的风险、收益、条款等内容，这个过程所耗费的精力就是精力成本。 如何提升顾客让渡价值？ 提升顾客价值：为顾客提供的不是物理形态的产品，而是效用（产品、商品、解决方案、价值）。 比如增加产品的功能，例如一个耳机不仅可以听音乐，还有防水功能，并且提供三年质保，或者采用更优质的材料制作耳机，让音质更清晰、佩戴更舒适；或者优化产品的外观设计，使其更符合当下流行的审美，更具时尚感和吸引力，这些都是通过物理形态上提升顾客价值的方式。 如何从效用层面提升顾客价值呢？同样是一个耳机，企业生产出耳机是一个产品；这个产品放在经销商的仓库里，这是商品；这个商品被顾客购买后，于顾客而言是一个解决方案；这个耳机在顾客游泳的时候可以听，给顾客带来了更好的游泳体验，这是价值。 提高顾客让渡价值，通过增加服务、降低价格、增加满意度，比如京东的商品保价服务，或者与顾客建立良好的沟通，及时了解顾客的需求和反馈，做出相应的调整和改进。 降低顾客成本，比如通过重组供应链，让耳机的生产变的高效，从而降低成本，或者优化物流配送服务，缩短配送时间，使顾客能更快地收到产品。此外，还可以降低顾客的精力成本，例如提供简单易懂的产品使用说明和操作指南，让顾客无需花费过多精力就能轻松上手使用耳机。 ","date":"2025-02-22","tags":["营销基础"],"title":"营销基础：营销的核心价值","url":"/post/2025/02/the_core_values_of_marketing/"},{"content":"需要、欲望和需求的区别？ 需要（needs）：抽象理解是人类最基本的要求，比如一套服装、一份食物、一个住处，马斯洛需求层次原理中的表述。\n欲望（wants）：具体化的需要，比如一件衬衫、一份牛排、一所大学、一个节目等。\n需求（demands）：具有支付能力的欲望，一件 100 元的衬衫、一份 50 元的牛排、一所学费 6000 元的大学。\n对于企业来说，需要了解顾客的需要，激发顾客的欲望，满足顾客的需求。\n例如外卖平台，顾客的需要是解决饥饿问题，欲望是吃到美味的食物，需求是能够支付得起的外卖餐品。企业通过提供多样化的餐饮选择、优惠活动和便捷的配送服务，激发顾客的欲望，并满足他们的需求。\n在营销中我们经常误用这些词，有时候让我们本应顺利的营销活动变的曲折， 下边是解释：\n把梳子卖给和尚的营销人员是好的营销人员吗？ 、 首先假设第一种场景，所谓的营销人员是把梳子卖给和尚自己梳头发。\n从推销的角度来说，这个产品成功地被卖掉了，为企业带来了利润当然是好的。但是，从营销的角度来说，“把梳子卖给和尚” 的潜台词是 “企业可以创造需要”，让和尚需要梳子。如果四营销学的狭义定义来说，顾客的需要是最基本的一种要求。如果梳子不是和尚最基本的要求，那么营销人员是不能创造需要的。也就是：“需要” 是不能被营销人员创造的。营销人员能创造的是营销的机会。\n如果和尚不需要，那就是强买强卖。\n公司激发了更多的顾客需求？ 企业能激发顾客需求吗？实际上是不能的，企业只能激发顾客的欲望。比如顾客买不起的情况下，这种需求是激发不出来的。\n公司创造了大量的顾客需求？ 这句后本意应该是：我们创造性地满足客顾客的需求。\n顾客会有哪些需要？ 在外卖点奶茶这个场景来说。\n1. 明确表述的需要 顾客明确知道自己想要什么，并能够清晰地表达出来。 例如：“我想点一杯珍珠奶茶，少糖，去冰。” 这是最表层的需求，顾客已经明确了自己的选择，商家只需准确执行即可。\n2. 内心的需要 顾客希望通过消费满足某种心理或情感需求。 例如：“我想喝奶茶解馋，缓解一下工作压力。” 这是一种符号化的需要，奶茶不仅仅是一种饮品，更成为了一种情绪调节的工具，代表着放松、愉悦或奖励。\n3. 未明确表述的需要 顾客没有直接说出来，但内心期待的服务或体验。 例如：“我希望奶茶能快速送到，不用等太久。” 这种需求通常与效率、便利性相关，顾客希望商家能够提供快速、准时的配送服务，而无需自己主动提出。\n4. 令人愉悦的需要 顾客希望获得超出预期的惊喜或额外价值。 例如：“如果有优惠券或赠品，我会觉得更划算、更开心。” 这种需求体现了顾客对附加价值的期待，优惠券、赠品或个性化服务都能让顾客感到被重视，从而提升满意度。\n5. 秘密的需要 顾客潜意识中的需求，可能与身份认同、社会归属感相关。 例如：“大家都在喝奶茶，我也想喝，这样感觉自己没有落伍。” 这是一种象征性的需求，奶茶成为了一种社交符号，代表着潮流、群体认同感或归属感。顾客希望通过消费融入某种社会群体，或表达自己的生活方式。\n需求 1. 负需求 我们对某个产品感到厌烦，甚至想花钱回避它，比如噪音、广告等。像一些过度推送的手机广告软件，用户不仅不想要看到，还愿意付费去开通无广告版本来避开这些广告；还有工厂周边的噪音污染，附近居民可能会考虑安装隔音设备，花费金钱来减少噪音对自己的干扰。\n2. 没有需求 对某个产品有欲望但是不了解、不感兴趣或者没有支付能力。比如一些高端的进口红酒，许多消费者可能听说过它的名气，内心也有一丝尝试的欲望，但由于对其复杂的品鉴方式不了解，或者本身对酒类不感兴趣，又或者价格过高超出自己的支付能力，所以就处于没有需求的状态。\n3. 潜在需求 消费者对某个产品有需求，但是市场上没有这个产品，消费者在等待的需求。例如，随着环保意识的增强，消费者对于环保型、可降解的便捷餐具需求日益增长，然而市场上这类产品在早期供应不足，消费者只能等待更多企业推出相关产品来满足他们的需求。\n4. 下降的需求 逐渐减少，停止，甚至不愿意购买某种产品。以传统胶卷相机为例，随着数码相机和智能手机拍照功能的兴起，胶卷相机的需求不断下降，消费者越来越不愿意购买胶卷相机，甚至将其闲置。\n5. 不规则的需求 不均匀，随着一些外部条件改变的需求，比如电影，消费者会随着热点变化，不断改变想看的电影。像一部电影在获得某知名电影节大奖后，会吸引大量原本没打算观看的消费者走进影院；或者某个明星陷入负面新闻，其主演的电影需求就会骤降。\n6. 充分的需求 消费者有欲望并且有支付能力。比如云南的褚橙，这样的产品由于品质好，消费者往往抢购一空。还有苹果手机每年推出新款时，尽管价格不菲，但很多消费者因其品牌影响力、性能提升等因素，既有购买欲望又有支付能力，导致产品一经发布就销量火爆。\n7. 过度的需求 消费者的需求大于市场的供应，比如双十一在家里囤货。在一些特殊促销活动期间，像双十一、双十二，消费者会大量囤积日用品、食品等，导致短时间内市场需求远超平时的供应量，商家常常出现断货情况。\n8. 不健康的需求 产品可能吸引消费者，但是会对社会产生不良的影响。比如早期低劣环境下制作的辣条，以及吃野生动物。还有一些含有大量添加剂、高糖高脂的垃圾食品，虽然口味可能吸引消费者，尤其是青少年，但长期食用会对身体健康造成损害，引发肥胖、糖尿病等疾病，对社会的健康环境产生不良影响。\n","date":"2025-02-22","tags":["基础"],"title":"营销基础：如何理解需求？","url":"/post/2025/02/how_to_understand_needs/"},{"content":"产品导向 以产定销，这是一个企业本位的营销思想，企业生产多少就销售多少。有三个观念：\n生产观念： 产品观念 推销观念 生产观念 规模化、大批量、单一品种 关心产品的有无，而非数量 供不应求、垄断 福特通过标准化技术，实现规模化生产，在 1908 年福特成为美国乃至世界的汽车大王。\n那时候无论是平民百姓还是达官贵人，都开的是黑色的 T 型车，顾客这时候的需求是换一个颜色，但是福特义正严辞的说：“任何顾客都可以选择任何他所中意的汽车颜色，只要它是黑色的。” 这体现了福特生产本位的思想 —— 从生产出发，考虑标准化生产，降低生产成本，而不是从市场需求出发。\n福特的竞争对手通用敏锐地捕捉到了这一点，开始设置不同的品牌，对应不同的阶层和价格，很快超越福特，成为美国第一大汽车生产商。\n产品观念 重视产品质量，丰富产品功能 排斥销售手段销售产品 1998 年的摩托罗拉如日中天，这时候突发奇想 “让任何人，在任何时间任何地方，联系到任何人” 但是这个项目需要投资 34 亿美金，通过计算，达到盈亏平衡，需要 50 万消费者，更重要的是这个产品非常贵，当时一部手机需要 8000 美金，通话费用也是非常高。而当时的竞争者，价格比他便宜的多。\n产品营销的条件：\n我原因 我能够 摩托罗拉片面强调产品本身的特征，而忽略了消费者的真实需求，也就是购买能力。这个计划破灭，而后被诺基亚替代。\n围绕着这个产品观念，哈佛大学莱维特教授提出 “营销近视症” —— 美国的很多企业，把大量的资源和精力集中在技术研发，就还有生产和制造上面，这些东西是同质化的，总有一天是会被超越的，而真正的差异化的东西是藏在消费者内心的需求。\n推销观念 市场的供需关系发生变化，厂商隐隐约约感到一些销售的压力，这时候他们会采用一些销售的方式把产品卖出去，最知名的例子是 “把梳子卖给和尚” 和 “把冰卖给爱斯基摩人”。\n顾客导向 二十世纪五六十年代，在美国发生了一场消费者民主主权主权运动，消费者的要求就是 “消费者也要参与”，这时候企业的经营哲学开发发生变化，开始从 “产品导向” 转到 “顾客导向”，即：以销定产。表现上就是企业实现市场需求，满足顾客饿需要，实现双赢。这个阶段产生了三个观念：\n满足需求：单纯的市场营销观，即市场有什么需求，就满足什么需求，是一种被动的满足。 创导需求：有些需求隐藏在消费者的内心深处，需要企业根消费者进行互动、沟通、洞察，把这种潜在的需求变现。 顾客满意：注重顾客价值的提升，实现顾客满意。 满足需求 注重前期的市场调研 注重营销工具的整合使用，即 4P 的 综合使用 注重消费者的反馈 但是存在的问题是 “需求从何而来？” 于是总结出潜在需求的四种表现：\n开发不及时：消费者有这个需求，但是市场上没有这个商品。 宣传不力：市场上有这个商品，消费者也有这个需求，但是消费者不知道市场上有。 渠道不畅：消费者有这个需求，市场上也有这个商品，并且消费者知道这个商品，但是消费者买不到。 需求待开发：市场上有这个商品，但是消费者没有这个需求，这时候就需要厂商进行消费者教育。 海尔的洗衣机在云贵地区可以洗地瓜，在合肥洗龙虾，在西藏可以打酥油，这些东西都是根据市场需求反馈进行改进的，所以成为单纯的市场营销观 —— 被动满足市场现存的需求。\n创导需求 即 “大的市场营销观”，在二十世纪六十到八十年代的时候，美国企业大量进行国际化，菲利普·科特勒在原来的 4P 理论基础上，提出另外的 2P：公共关系和政治权利。\n也就是，当一个企业拓展市场的时候，首先要和政府和媒体建立良好的关系，然后才能在市场中经营和发展。\n宝洁在八十年代初的时候进入中国大陆，当时中国有 8 亿人，宝洁认为他们的产品在中国会畅销，但是市场调研后发现，那时候的中国人不爱干净。以洗头频率来说，香港一周 4 次，日本一周 5 次，西欧国家一周 6.5 次，而中国一周 1 次。这就是消费者还没有梳理消费意识的情况，这时候要进行的就是消费者教育。\n宝洁拍了一支广告：两个人在公交车相遇，第一句话是 ”今天你洗头没“。传达的信息就是洗头不仅有利于健康，还有利于社会公众形象。经过消费者教育，现在的数据表明，中国消费者一周洗头 2 次。对于快销品，要么提升使用频率，要么提高使用量。对于宝洁来说，一次的提升也是巨大的进步。\n顾客满意 二十世纪八十年的，由美国的教授弗莱尔提出，他构建了 “美国顾客满意度指数模型（ASCI）”。消费者对一个服务或产品的感知和真实的体验之间会存在一个差额，这个差额就是顾客满意。\n在这个模型中，一方面要提升产品和服务本身的质量，另一方面要提升顾客的期望，同时也要提升顾客的感知价值。\n后来发展出了 “欧洲顾客满意度指数模型（ESCI）”，中国在他们的基础上提出了 “中国顾客满意度指数模型（CCSI）”。\n理论上说，顾客越满意，就会导致顾客的忠诚，但是在实践中并不是这样，厂商发现，那些越满意的顾客，逃离速度其实是最快的。后来学者通过理论分析，把顾客的忠诚分为三类：\n态度忠诚 信任 价格容忍 口碑 推荐 行为忠诚 在购买 抱怨 转换 复合忠诚 复合忠诚 所以，后来认为，顾客表现出来的忠诚更多是态度忠诚，而不是行为忠诚。后来还发现，不同的消费者具有的价值是不同的 —— “顾客终身价值”。顾客忠诚金字塔：\n对企业忠诚不二 做好某一企业 对企业满意或习惯 没有顾客忠诚，对顾客漠不关心 并且不同行业之间，顾客的满意关系是不一样的。有时候顾客满意和顾客忠诚是线性的，而有时候是非线性的，比如边际递增或者边际递减。\n顾客满意源于顾客的感知价值，那么什么是顾客感知价值呢？\n顾客让渡价值：顾客总利益 - 顾客总成本 顾客总利益：产品价值、服务价值、人员价值、形象价值 顾客总成本：货币成本、时间成本、精神成本、体力成本 顾客感知价值：一种主观感受，难以测量 价值导向 在二十一世纪初，学者提出一个新的框架：3Vs 理论。\n重要顾客：你的目标顾客是谁？ 价值主张：提供什么价值，解决什么问题？ 价值网：如何将价值诉求有效地传递给你的目标顾客？ 在英国有一个航空公司 EasyJet，中文名叫易捷。于 1995 年在英国成立，因其价格低廉，广受欢迎。他们只飞行单航线 —— 从伦敦到苏格兰，距离大概 1000 公里；其次，他们价格便宜一趟航班大概 29 英镑，约合 400 人民币。他们和核心价值是 “一条牛仔裤的价格将你送到苏格兰”。自从诞生以来，他们始终盈利，他们是如何做到的呢？\n他们对航空旅客进行分析发现，一类是公费人员，他们在意的是体验，座位要靠窗、餐食美味以及服务优良；另一类是自费的旅客，他们在意的是准点、便宜以及安全。易捷把后者作为自己的目标群体，这个群体虽然价格敏感，但是基数庞大。他们的价值主张从何而来呢？\n易捷通过对行业内，可能对盈利有影响的属性罗列出来，然后根据自己服务的群体进行重新定位，从而找到自己的优势。最后是价值网，他们通过和竞争者比较，评价出是优势还是劣势，然后对不必要的劣势删除，对必要的劣势项降低质量，对优势进行增强，对行业内没有的属性进行创新。比如不提供餐食、不排座位号、使用同种规格的飞机、限重、付费卫生间、动态定价。\n参考 《蓝海战略》\n《营销思辨》\n","date":"2025-02-22","tags":["营销基础"],"title":"营销基础：营销导向","url":"/post/2025/02/marketing_orientation/"},{"content":"\n丹·艾瑞里（英语：Dan Ariely，1968年4月29日至今）是一位拥有犹太人血统的美国心理学及行为经济学教授。[1] 他任教于杜克大学进阶后知之明中心（Center for Advanced Hindsight）。\n—— 维基百科\n在大学的时候，如果你是男生，你可能会有这样的经历：\n你有个好兄弟非常喜欢一个女生，然后有一天，他实在按捺不住心中的激动，于是把女生约了出来吃饭，想创造一点机会。\n这时候你兄弟会对你说什么？\n“你也去，帮我\u0026hellip;\u0026hellip;” 这时候，你以为“真实好兄弟，这么私密的事情还带我” 那就错了，其实帮他做什么都是幌子，你去才是目的。\n在他们还没有见面的时候，你兄弟会对你说什么？“看着情况办事，聪明点”，言外之意是什么呀？“不要让我难堪，我要给她留下一个好印象” 什么叫好印象啊？\n好坏都是对比出来的。比如带你去，意思就是你可能在外貌方面，相较于你兄弟来说有一些劣势，你在他们见面之后的表现也要足够差，至少要凸显出你兄弟的深情和聪慧。\n所以，你在他们吃饭的时候像个笨蛋，十足的多余。如果你胆敢妙语连珠，恐怕你兄弟会把你先支开。\n你在这个过程里就扮演了一个 “诱饵”。\n诱饵效应是艾瑞里教授在书中所用的名称，在不同的地方，它也被称作 “对比效应”，换个说法，就是我们平时说的 “拉个垫背的”。在商业中对比效应是如何被应用的呢？\n我们先从行为经济学家丹·艾瑞里的一次偶然发现说起。\n一、经济学人杂志的定价策略 杜克大学的艾瑞里教授在网上冲浪时，无意间发现了《经济学人》杂志的以下广告：\n单订电子版：59 美元 单订印刷版：125 美元 合订印刷加电子版套餐：125 美元 艾瑞里教授在麻省理工学院的斯隆商学院，让100个学生做选择，结果是：\n单订电子版 59美元：16人 单订印刷版 125美元：0人 合订印刷加电子版套餐 125美元：84人 随后，艾瑞里教授进行了一个有趣的实验：他去掉了“单订印刷版”这一选项，再次让学生们选择。结果是：\n单订电子版 59美元：68人 合订印刷加电子版套餐 125美元：32人 传统经济学假设消费者是理性的，会根据价格和价值做出最优选择。在这种假设下，消费者会选择性价比最高的选项。在这个案例中，单订电子版和合订印刷加电子版套餐的价格分别是 59 美元和 125 美元。从理性经济人的角度来看，单订电子版显然更划算，因为价格更低且提供了电子版的内容。然而，实验结果显示，当 “单订印刷版” 这一选项存在时，大多数学生选择了合订印刷加电子版套餐，这与传统经济学的预测存在偏差。\n而行为经济学强调人类行为的非理性特征，认为人们在决策时会受到各种心理因素的影响。在这个案例中，“单订印刷版” 作为一个诱饵选项，影响了学生们的决策。具体来说，当 “单订印刷版” 存在时，它与合订印刷加电子版套餐形成了对比，使后者显得更具吸引力。这种现象艾瑞里教授称之为 “诱饵效应”。\n不难理解，当 “单订印刷版” 存在时，它作为一个诱饵选项，使合订印刷加电子版套餐显得更具吸引力。学生们在选择时，会不自觉地将“单订印刷版”与合订印刷加电子版套餐进行比较，从而倾向于选择后者。而没有诱饵的时候，即：“单订印刷版”被去掉后，学生们的选择发生了显著变化。选择单订电子版的人数从 16 人增加到 68 人，而选择合订印刷加电子版套餐的人数从 84 人下降到 32 人。这表明，诱饵选项的存在对决策产生了重要影响。\n这一发现对市场营销和定价策略具有重要意义，商家可以通过设置诱饵选项来引导消费者做出特定的选择。\n“诱饵效应” 和 “对比效应” 是两个结果相似的研究。简单来说，这两个效应都说明了，有时候通过引入一个不太好的选项，反而能让原来的某个选项显得更好，影响人们的选择。以下分别解释：\n1. 诱饵效应（decoy effect） 想象一下，你在餐厅看菜单，犹豫是点一份牛排还是意面。牛排贵一点但更美味，意面便宜但也不错。这时，服务员给你推荐了一道价格更高、分量更大但看起来不太吸引人的海鲜拼盘。你可能会觉得牛排更划算，于是选择了牛排。这就是诱饵效应。诱饵效应就是当我们在两个差不多的选项之间犹豫时，加入一个新选项（诱饵），这个诱饵可能本身并不吸引人，但它会让其中一个旧选项显得更有吸引力。\n2. 对比效应（Contrast Effect） 假设市场上有华为和小米的两款手机，华为的一款手机功能强大但价格较高，小米的一款手机功能一般但价格便宜。根据传统经济学原理，华为手机会吸引那些更看重功能的人，而小米手机会吸引那些更看重价格的人。这时，如果加入一款菠萝手机，功能比小米手机还差，价格却和小米手机一样，甚至更高。按理说，小米手机的市场份额应该下降，因为多了一个竞争对手。但实际上，小米手机的市场份额反而上升了。这就是对比效应。\n在封闭的市场里，A 产品和 B 产品正在激烈竞争。A 产品质量更优，但价格相对较高；B 产品价格更实惠，但质量稍逊一筹。\n根据传统经济学原理，A 产品会吸引那些更注重质量、愿意支付更高价格的消费者，而 B 产品则会吸引那些更看重价格、对质量要求相对较低的消费者。因此，A 产品和 B 产品各自占据一定的市场份额。\n然而，当一个新的 C 产品进入市场时，情况会发生变化。传统经济学原理认为，C 产品的加入会使市场竞争更加激烈，从而导致 A 产品和 B 产品的市场份额都下降。\n但对比效应却揭示了另一种可能性：如果 C 产品在各方面都不如 B 产品，那么 B 产品的市场份额不仅不会下降，反而会因为与 C 产品的对比而显得更具优势，进而吸引更多消费者选择 B 产品，导致其市场份额上升。\n那么这个有趣的现象是谁发现的呢？\n二、起源 在1982年，杜克大学的营销学者乔尔·休伯教授与他的同事约翰·佩恩教授以及克里斯托弗·普托博士共同在美国《消费者研究学报》发表了一篇具有里程碑意义的论文。通过一项创新的啤酒实验，他们首次揭示了“对比效应”的存在，为理解消费者决策提供了新的视角。\n实验设计巧妙，将参与者随机分为两组，以观察不同选择情境下的决策变化。\n1. 第一组实验 参与者在两种啤酒中做出选择：\n啤酒A：价格为2.6美元，质量评分为70分 啤酒B：价格为1.8美元，质量评分为50分 结果显示，57%的参与者选择了质量更优但价格稍高的啤酒A，而43%的参与者选择了价格更实惠但质量较低的啤酒B。这一结果符合预期，表明消费者在质量和价格之间进行了权衡。\n2. 第二组实验 在这一组中，参与者在三种啤酒中做出选择，其中啤酒A和啤酒B与第一组相同，新增了啤酒C：\n啤酒A：价格为2.6美元，质量评分为70分 啤酒B：价格为1.8美元，质量评分为50分 啤酒C：价格为1.8美元，质量评分为40分 根据传统经济学原理，啤酒 A 和啤酒 B 的市场份额应因啤酒 C 的加入而下降。然而，实验结果出人意料：63% 的参与者选择了啤酒 B，其市场份额从第一组的 43% 显著增加到 63%。\n这一现象可以用 “对比效应” 来解释。在第一组中，啤酒 A 和啤酒 B 各具优势，消费者难以抉择。然而，在第二组中，啤酒 C 的加入改变了这一局面。啤酒 C 在价格上与啤酒 B 相同，但质量更低，成为啤酒 B 的“托”。这种对比使啤酒 B 显得更具吸引力，消费者更倾向于选择它。\n这一实验表明，消费者的决策并非完全基于产品的客观属性，而是受到决策情境的显著影响。传统经济学假设消费者会独立评估每个选项，但行为经济学揭示了消费者在实际决策中会受到 “对比效应” 等心理因素的影响。这一发现对市场营销和产品定位具有重要的启示意义。\n三、索诺玛的面包机 许多年前，威廉姆斯－索诺玛公司推出了一款售价279美元的家用面包机，但销量不佳。毕竟，对于习惯在面包店购买新鲜面包的美国人来说，花 279 美元买一台不常用的面包机显得不太划算。按照常理，公司应该停止生产这款面包机。然而，威廉姆斯－索诺玛公司采取了一个意想不到的策略：他们不仅没有下架这款滞销的产品，反而推出了一款新的面包机，容量更大，价格高达 429 美元。结果，原先滞销的 279 美元面包机的销量在短时间内翻了一倍。\n为什么原本滞销的面包机会突然变得受欢迎呢？这背后的原因是 “对比效应”。当消费者在面对多个选择时，往往会通过比较来做出决策。在新推出的 429 美元面包机的对比下，279 美元的面包机显得更加经济实惠，成为了一个更具吸引力的选择。\n这个案例生动地展示了对比效应在市场营销中的应用：通过引入一个更贵的产品，公司成功地改变了消费者对原有产品的感知，使其显得更具性价比，从而显著提升了销量。\n四、参考 《怪诞行为学：可预测的非理性》 《理性与非理性：行为学》\n","date":"2025-02-22","tags":["对比效应","诱饵效应"],"title":"诱饵效应：如何让无人问津的产品销量翻倍？","url":"/post/2025/02/bait_effect_how_to_double_sales_of_products_that_no_one_cares_about/"},{"content":"\n一、行业定义 1. 专家解释 现代营销学之父菲利普·科特勒在不同的场景下分别解释了 “营销” 和与之相关的词。\n企业的营销能力是企业盈利的根本保证。 市场营销就是辨别并满足人类和社会的需要。对市场营销最简洁的定义，就是 “满足别人并获得利润”。 我们可以把营销管理看成艺术和科学的组合 —— 选择目标市场，并通过创造、交付和传播优质的顾客价值来获得顾客、挽留顾客的科学与艺术。 所谓市场营销，就是个人和集体通过创造、提供、出售、同别人自由交换产品和服务的方式，以获得自己所需产品或服务的社会过程。 营销人员主要经营以下十大类产品：有形的商品、服务、节事、体验、人物、场所、产权、组织、信息和创意。 科特勒将营销分为 4 个阶段：\n著名管理学家德鲁克先生曾经指出：\n“可以这样说，推销往往是需要的。然而，市场营销的目的却是使推销成为多余。市场营销的目的就在于深刻地认识和了解顾客，从而使产品和服务完全适合特定顾客的需要，从而实现产品的自我销售。因此，理想的市场营销应该可以自动生成想要购买特定产品或服务的顾客，而剩下的工作就是如何使顾客可以购买到这些产品。”\n知名营销战略专家小马宋说：“营销是企业经营活动中的一部分，它创造价值、传播价值、传递价值。”\n不难理解，小马宋老师认为，营销首先是企业为这个社会解决了一个具体的问题，这是创造价值，需要的是创新能力；传播价值，传播的是知名度，这需要的是影响力；传递价值是从品牌到生产再通过渠道流通到消费者的整个过程，这需要的是组织能力。\n那么行业内的专家如此定义，那么作为行业的权威组织是如何定义的呢？\n2. AMA 对营销的四次定义 AMA：美国市场营销协会\n销售过程（1960）：市场营销是将货物和劳动，从生产者流转到消费者过程中的一切活动。它实际上以一个所有权转移的过程。 营销管理（1985）：通过对货物、劳务和计谋的构想、定价、分销、促销等方面的计划和实施，以实现个人和组织的预期目标的交换过程。这个阶段的本质是交易，或者交换。 价值营销 + 关系管理（2004）：市场营销即是一种组织职能，也是为了组织自身和利益相关者的利益而创造、传播、传递客户价值，管理客户关系的一系列过程。这个阶段认为营销的本质是价值和关系。 宏观营销 + 微观营销（2007）：市场营销是一种全组织范围内的活动，一组制度的集合，同时也是为了顾客、客户、合作伙伴以及社会的整体利益而创造、传播、传递、交换价值的一系列过程。这个定义没有得到广泛的认可，因为它和经济学的定义在一定范围内有重合。 目前而言，提起营销时，更多的是认同：营销 = 价值 + 关系\n从定义变化的过程，可以看到一些改变：\n营销主体的变化，从 企业 转移到了 一切面向市场的个人和组织。 营销客体的变化，从 产品、货物 到 计谋、创意、故事 再到 价值、关系。 营销对象的变化，从 顾客 到 利益相关群体，即商业生态 营销内容的变化，从 销售 到 构思、定价、分销、促销 再到 建立、维持、巩固关系 营销目标的变化，从 提高销量（主体利益） 到 满足需求（客体利益） 再到 价值及关系（实现多赢） 营销工具的变化，从 4P 理论（产品导向） 到 4C 理论（顾客导向：20 世纪 50 年代后） 再到 4R 理论（关系导向：20 世纪 90 年代） 最后是 3VS 理论（价值导向：21 世纪） 我们对营销应该是分层次的：\n营销思想：趋势洞察。\n社会认同 思想和格局 营销战略：做正确的事，提高营销决策效率。\n定向：未来战略发展的方向\n定芯：寻找核心能力\n定位：在生态为里面，价值、产品和客户的定位是什么\n营销策略：具体的执行层，通常称为销售，提高营销效益。 正确地进行营销 二、营销的历史演变 1. 大生产的年代 1908年9月27日，福特T型车正式问世，这款汽车在1927年停产前累计生产了1500万辆，创造了当时汽车行业的生产纪录。\n1915年，第1000万辆T型车下线，当时全球90%的汽车均为福特生产。T型车的成功不仅体现在销量上，更在于其创新的生产方式。它是世界上首款大量使用通用零部件并进行大规模流水线装配的汽车。\n这种流水线装配的灵感来源于威廉·C·克莱恩对芝加哥一家屠宰厂的观察。他发现屠宰场通过将流程分解成一系列专门步骤，使用传送带运输，极大地提高了效率。将这一理念引入福特工厂后，T型车的生产效率显著提升，生产成本大幅降低。\n与此同时，弗雷德里克·泰勒在1911年出版了《科学管理》一书，提出了标准化、专业分工、精细化管理等理念。这些理念与福特的流水线生产方式高度契合，进一步推动了生产效率的提升。泰勒的科学管理理论对后世企业管理产生了深远影响，成为现代企业管理的重要基石。\n在20世纪初，企业最关注的问题是如何提高生产效率、降低生产成本，这也是当时企业面临的第一个营销问题，即如何提高流通效率。\n2. 产品为王的年代 20 世纪 50-60 年代，美国经济在经历了经济危机后迎来了黄金时代，这一时期营销领域也进入了百家争鸣的阶段。\n20 世纪 50 年代是市场营销从生产观念向产品观念转变的关键十年。1950 年，尼尔·鲍顿首次提出了市场营销组合的概念，试图明确营销的各个组成要素。到1960年，杰罗姆·麦卡锡进一步明晰了这一概念，提出了著名的 4P 理论，即产品（Product）、价格（Price）、渠道（Place）和推广（Promotion）。\n同样在 1950 年，乔尔·迪安引入了产品生命周期的概念，这一概念随后得到了西奥多·莱维特的高度认同，他在其著名论文《利用产品生命周期》中对这一理论进行了详细阐述。从那时起，产品成为了营销界一个基础且富有争议的话题。\n在广告界，50 年代初，达彼思广告公司的董事长罗瑟·瑞夫斯提出了著名的 USP 理论（Unique Selling Proposition），即独特的销售主张。这一理论强调，每一则广告必须向消费者提供一个明确的主张，让消费者清楚购买广告中的产品可以获得的具体功效和利益。例如，1954年，瑞夫斯为 M\u0026amp;M 巧克力豆创造了经典的广告语 “只溶在口，不溶在手”，成功地突出了产品不黏手的特点，使其成为家喻户晓的品牌。\n整个50年代，营销界始终高举着产品观念的大旗，强调产品本身的质量和特点，以及如何通过营销策略更好地展示这些特点。\n3. 顾客至上的年代 20 世纪 60 年代，美国经济持续繁荣，技术进步和竞争加剧促使产品同质化现象愈发明显，同时产品的更新换代速度也在加快。在这一背景下，企业面临的主要问题转向了顾客问题。\n20 世纪 60 年代是市场营销从产品观念向顾客观念转变的关键十年。1960 年，哈佛商学院教授西奥多·莱维特在《哈佛商业评论》上发表了著名论文《营销短视症》，奠定了他在营销史上的重要地位。莱维特在文中指出，企业衰退的原因在于过分关注 “产品” 而非 “顾客”。他强调，如果企业不关注顾客需求，而只是专注于产品本身，即使现有产品再成功，也难以避免被淘汰的命运。\n莱维特的这一观点催生了 “现代营销学之父” 菲利普·科特勒在 1967 年出版的《营销管理》一书。科特勒提出，营销的核心是管理消费者的需求。他的策略体系可以用一个公式来表示，即 STP + 4P。其中，STP 代表战略层面的市场细分（Segmentation）、目标人群（Target）和产品定位（Positioning），而 4P 则是战术层面的产品（Product）、价格（Price）、渠道（Place）和推广（Promotion）。\n科特勒的《营销管理》被誉为营销学的 “圣经”，自 1967 年首次出版以来，已经更新至第 16 版，培养了全球数千万企业家和高层管理人员。时至今日，营销公司和广告公司在制定方案时，仍然遵循科特勒的逻辑框架，从市场分析入手，确定细分市场和产品定位后，再设计相应的营销战术组合。\n这一时期，营销界对顾客观念的深化体现在对市场需求的高度重视，企业开始以销定产，将市场作为生产的起点。这种以顾客为中心的营销理念，不仅推动了企业的发展，也为现代营销理论奠定了坚实的基础。\n4. 竞争与定位的年代 20 世纪 70 年代，美国经济在经历了 50、60 年代的黄金时期后，突然急转直下。1969 年，美国再次爆发经济危机，这场危机不仅冲击了美国，还波及了整个西方世界。70 年代，西方国家普遍陷入了滞胀的困境，高失业率、高通胀率以及企业破产倒闭成为常态，这让习惯了黄金时代的美国人感到震惊。在这样的背景下，企业面临的主要问题不再是产品和用户需求，而是如何在激烈的竞争中生存下来。\n20 世纪 70 年代是市场营销从顾客观念向竞争观念转变的二十年。在这个时期，企业之间的竞争愈发激烈，市场上的产品种类繁多，同质化现象严重，品类分化问题也日益突出。由于产品过多，消费者很难记住所有品牌，而消费者的心智又极其简单，害怕麻烦，一个大品类下最多只能记住少数个品牌。因此，企业必须成为某个品类的代表，才能在消费者心智中占据一席之地。谁在消费者心智中的位置越靠前，市场份额就会越大。\n杰克·特劳特和艾·里斯在 1968 年提出了 “定位” 理论，并在 1981 年出版了《定位》一书。他们将商业比作一场战争 —— 商战，而市场营销的战场则在消费者心智之中。企业必须在消费者心目中占据一个位置，才能在这场战争中取得胜利。根据企业在用户心智中的位置，企业可以确定战略性质：防御战、进攻战、侧翼战、游击战。这就是特劳特和里斯的营销战理论。\n沿着竞争这一路线，1980 年，迈克尔·波特出版了《竞争战略》，随后又出版了《竞争优势》（1985）和《国家竞争优势》（1990）。波特因此成为全球第一战略权威，被誉为 “竞争战略之父”。他提出了三种基本的竞争战略：总成本领先、差异化和聚焦。\n总成本领先战略是指企业通过降低成本，即使产品与竞争对手相同，也能以更低的价格赢得市场。差异化战略则是通过提供个性化价值或增值型服务，创造与竞争对手的差异，实现盈利。聚焦战略是在某个细分市场实现总成本领先或差异化。这就是竞争战略，也是激烈的20世纪 70、80 年代的写照。\n5. 开放与回归的年代 20 世纪 80 年代以后，市场营销进入了一个开放与回归的时代。一方面，美国以外的经济体如日本、欧洲和中国相继崛起，经济全球化成为世界经济发展的重要特征和趋势。特别是苏联解体和冷战结束后，经济发展成为全球主题，世界被更紧密地联系在一起，地球村的概念逐渐形成。\n1986 年，菲利普·科特勒提出了“大市场营销”概念。他在原有的 4P 组合（产品、价格、渠道、促销）基础上，增加了两个 P：政治力量（Political Power）和公共关系（Public Relations）。\n21 世纪的公司必须掌握两种新的技能：一是如何与国家打交道，了解一个国家的政治状况和政治壁垒，以便更好地向这个国家推销产品；二是如何在公众中树立良好的企业形象，承担社会责任，从而赢得公众舆论，这样才能在全球市场上有效地开展营销工作。\n科特勒认为，塑造现代营销的三股重要力量是科技、全球化与企业社会责任。营销越来越走向开放，走向社会，走向公众，走向全球。在增加了这 2P 后，科特勒又将 STP（市场细分、目标人群、产品定位）演绎成另外 4P：探查（Probing）、分割（Partitioning）、优先（Prioritizing）、定位（Positioning），这是战略层面的 4P；后 4P 则是产品、价格、渠道、促销，属于战术层面。最后 2P 是公共关系（Public Relations）和政治权力（Political Power），代表新的营销技巧和力量。\n有人将这 10P 视为市场营销学的第二次革命。而在这 10P 之外，科特勒又重申了另一个 “P” 的重要性，那就是人（People），这是所有 “P” 中最基本和最重要的一个。营销，必须回归到人。\n自从 1912 年，哈佛大学学者 J·E·哈格蒂出版第一本《市场营销学》以来，营销已经走过了一百多年的历史。在这一百年的历史中，不同时期诞生了观念各异的众多营销理论。但我们不要忘记，不同理论诞生的社会背景与商业环境不同，在不同时期下，企业面临的问题不同，因此诞生了不同的营销理论去解答、解决企业面临的经营问题。营销的根本，是要帮助企业解决问题，即从产品、用户、竞争上解决问题。\n一家企业在创立成长过程中，会遇到很多问题。不同的企业，面临的问题也不同。企业面临的要么是产品问题，要么是竞争问题，要么是用户问题。但归根结底，企业面临的都是营销问题！产品、用户、竞争这便是营销不变的铁三角，这便是百年营销史上不断的观念循环。\n6. 数字共创的全球化年代 如今，我们正处于一个数字化和全球化的时代，营销领域也在不断演变。根据美国营销协会（AMA）的2025年营销技能报告，未来的营销人员需要掌握一系列新的技能，以应对不断变化的市场环境。报告基于对1200多名营销人员的调查、450多个职位发布和行业专家的访谈，指出了人工智能转型、消费者期望的变化和营销漏斗的优化等新现实正在塑造营销领域。\n菲利普·科特勒在谈到数字化时代的营销时，提出了“邻近性”（proximity）的概念，即消费者在想要某物的那一刻就能得到它。他认为，在数字化时代，企业可以收集大量关于个人行为的数据，从而实现 “完美营销” —— 在正确的时间、以正确的形式和价格向需要的人提供产品。这种营销方式不仅提高了消费者满意度，还减少了库存，实现了按需生产。\n21世纪以来，市场营销进入了营销 4.0 时代，这一时代的核心特征是数字化与共创营销。随着移动互联网、物联网和大数据技术的飞速发展，消费者的行为和需求发生了巨大变化，企业需要重新审视和调整营销策略，以适应新的市场环境。\n在营销 4.0 时代，数字化转型成为企业营销的核心战略之一。根据美国营销协会（AMA）的报告，数字化营销不仅改变了消费者获取信息和购买产品的方式，也为企业提供了更精准、更高效的营销手段。企业通过收集和分析消费者数据，可以实现精准营销，满足消费者的即时需求。例如，中国快时尚品牌 SHEIN 通过数字化供应链和营销策略，实现了从设计到生产再到交付的高效流程，成为全球访问量最大的服装与时尚品牌之一。\n菲利普·科特勒在 2022 年提出了“共创营销”（Co-creation Marketing）的概念，认为这是营销的第五个阶段。共创营销的核心是让消费者参与到产品的设计、生产和营销过程中，形成企业与消费者之间的互动和合作。例如，星巴克通过“星巴克伙伴计划”让消费者参与到产品创新和品牌建设中，增强了消费者的忠诚度和品牌认同感。\n在营销 4.0 时代，品牌建设的要求也发生了变化。科特勒提出了“BRAND”模型，强调品牌需要具备以下五个特征：\nB（Believable）：品牌必须是可信的，消费者对品牌的评价应该是正面的。 R（Relevant）：品牌必须与消费者的需求和价值观相关联。 A（Adaptable）：品牌必须能够适应时代的变化，保持灵活性和创新性。 N（Narrative）：品牌必须有故事，能够通过叙事驱动消费者的情感共鸣。 D（Differentiated）：品牌必须与其他品牌区分开来，具有独特的价值主张。 除了数字化转型和共创营销，企业还需要关注社会责任和可持续发展。根据 AMA 的报告，消费者越来越关注企业的社会责任和环保行为。企业需要通过承担社会责任，树立良好的企业形象，赢得消费者的信任和支持。例如，巴塔哥尼亚（Patagonia）通过“1% 地球税”计划，将部分利润用于环保项目，赢得了消费者的广泛赞誉。\n尽管营销的手段和形式发生了巨大变化，但营销的本质仍然没有改变。营销的核心仍然是满足消费者需求，帮助企业解决问题。正如菲利普·科特勒所言，营销的本质是“创造和管理价值”。企业需要通过创造、交流和传递价值，帮助目标市场获取利润。\n三、营销工具箱 4P理论 4P理论是20世纪60年代在美国冒出来的。这4P分别是产品（Product）、价格（Price）、地点（Place）和促销（Promotion）。\n产品：就是企业要琢磨产品的功能，得有独特的卖点，把产品的功能放在首位。比如说，你卖手机，那就要突出你手机拍照清楚、运行速度快这些特点。 价格：根据不同的市场定位来定不同的价格。定价得考虑企业的品牌战略，注重品牌的含金量。比如，苹果手机价格高，但因为品牌响，还是有人愿意买。 地点：企业不直接面对消费者，要靠经销商和销售网络。企业跟消费者的联系是通过分销商来实现的。就像你去超市买东西，超市就是企业的分销商。 促销：企业通过一些短期的行为来刺激消费者，比如让利、买一送一、搞活动现场气氛等，目的是促进消费增长，吸引其他品牌的消费者，或者让消费者提前购买。 4P理论的特点是可控性强，企业可以根据市场情况调整产品、价格、地点和促销方式；动态性强，要根据内外部环境变化做出反应；整体性强，各种手段要配合起来，形成统一的营销战略。\n4C理论 4C理论是以消费者为中心的，4C分别是消费者（Consumer）、成本（Cost）、便利（Convenience）和沟通（Communication）。\n消费者：企业要把满足消费者的需求和欲望放在第一位，不能只卖自己想卖的产品，要卖消费者想买的产品。比如，现在消费者对健康食品需求大，企业就可以多开发这类产品。 成本：不仅包括企业的生产成本，还包括消费者购物的成本，比如时间、精力、风险等。企业要在消费者能接受的价格范围内，降低成本，提高利润。 便利：要让消费者购买方便，企业提供售前、售中、售后服务，让消费者既买到商品，也享受到便利。比如，电商企业提供送货上门服务，让消费者不用出门就能买东西。 沟通：企业要和消费者进行双向沟通，了解他们的需求和反馈，这样才能提供适销对路的产品，培养忠诚的顾客。 4S理论 4S理论强调从消费者需求出发，建立“消费者占有”的营销导向。4S分别是满意（Satisfaction）、服务（SERVICE）、速度（Speed）和诚意（Sincerity）。\n满意：企业要以顾客满意为中心，站在顾客立场考虑问题，用真情服务感化顾客。比如，海底捞以优质的服务让顾客满意，从而赢得市场。 服务：包括微笑服务、精通业务、态度亲切、把顾客当上帝等。比如，酒店服务员微笑迎接客人，让客人感受到温暖。 速度：不让顾客久等，能迅速接待和办理。比如，快餐店快速出餐，满足顾客的需求。 诚意：用具体的行动来服务客人，比如提供贴心的服务，让顾客感受到企业的诚意。 4R理论 4R理论是在4C理论基础上提出的，4R分别是关联（Relevance）、反应（Reaction）、关系（Relationship）和回报（Reward）。\n关联：企业要通过有效的方式与顾客建立关联，形成互助、互求、互需的关系，减少顾客流失，提高忠诚度。比如，会员制度可以让顾客和企业建立更紧密的联系。 反应：企业要及时倾听顾客的需求，并做出反应，满足他们的希望和渴望。比如，企业通过社交媒体及时回复顾客的留言和投诉。 关系：企业要与顾客建立长期而稳固的关系，把交易变成一种责任。比如，企业定期回访顾客，了解他们的使用体验。 回报：企业要注重营销活动的产出，满足客户需求，为客户提供价值。比如，企业通过提供优质的产品和服务，获得顾客的长期支持和利润回报。 4V理论 4V理论是在高科技产业迅速崛起的背景下产生的，4V分别是差异化（Variation）、功能化（Versatility）、附加价值（Value）和共鸣（Vibration）。\n差异化：企业要实施差异化营销，使自己与竞争对手区别开来，树立独特形象，同时满足消费者个性化的需求。比如，苹果手机以其独特的设计和用户体验，与其他手机品牌区分开来。 功能化：产品或服务要有更大的柔性，能针对消费者具体需求进行组合。比如，模块化家具可以根据消费者的需求自由组合。 附加价值：重视产品或服务中的无形要素，通过品牌、文化等满足消费者的情感需求。比如，星巴克不仅卖咖啡，还卖一种“第三空间”的体验。 4I 理论 4I理论是网络时代的营销法则，4I分别是趣味（Interesting）、利益（Interests）、互动（Interaction）和个性（Individuality）。\n趣味：营销活动要有趣味性，吸引消费者的注意力。比如，杜蕾斯的广告常常以幽默有趣的方式呈现，让消费者乐于接受。 利益：营销活动要为消费者提供利益，包括信息、功能、服务、心理满足等。比如，电商网站提供优惠券、赠品等，让消费者感到实惠。 互动：企业要与消费者进行互动，让消费者参与到营销活动中来。比如，品牌在社交媒体上举办互动活动，让消费者参与投票、评论等。 个性：营销活动要体现个性化，满足消费者的个性化需求。比如，定制化产品让消费者可以根据自己的喜好定制商品。 3VS 理论 价值主张（Value Proposition）：企业要明确能为消费者提供什么独特的价值和利益，这是吸引消费者的关键。比如，特斯拉的价值主张是提供高性能、环保的电动汽车，满足消费者对绿色出行和科技体验的需求。 价值获取（Value Capture）：企业要确定如何从为消费者创造的价值中获取回报，也就是如何盈利。例如，软件公司通过收取软件使用费、订阅费或提供增值服务来获取价值。 价值维护（Value Maintenance）：企业要持续维护和提升已创造的价值，以保持消费者的忠诚度和满意度。比如，苹果公司通过不断更新产品功能、提供优质的售后服务来维护其产品的价值。 以下是其他一些可以补充的营销理论：\n3W黄金圈法则 What（是什么）：明确产品或服务的具体内容和特点，这是营销的基础。例如，一家咖啡店的What就是提供各种口味的咖啡和舒适的用餐环境。 Why（为什么）：挖掘产品或服务背后的价值和意义，以及消费者购买的动机。比如，消费者选择星巴克不仅是为了喝咖啡，还为了享受其提供的“第三空间”体验。 How（怎么做）：制定具体的营销策略和方法，以实现产品或服务的推广和销售。例如，通过社交媒体宣传咖啡店的特色咖啡和优惠活动，吸引消费者前来消费。 5W2H分析 What（是什么）：明确营销活动的具体内容，如产品特点、服务内容等。 Why（为什么）：分析开展此次营销活动的原因和目的，比如提升品牌知名度、增加销售额等。 Who（谁）：确定营销活动的目标受众，包括消费者的年龄、性别、职业、消费习惯等。 When（何时）：选择合适的营销时机，如节假日、新品上市等。 Where（何地）：确定营销活动的开展地点或渠道，如线上平台、线下门店等。 How（怎么做）：制定具体的营销策略和方法，如广告宣传、促销活动等。 How much（多少）：预算营销活动的成本和预期收益，确保活动的可行性和盈利性。 SWOT分析 Strengths（优势）：分析企业内部的优势，如品牌知名度高、产品质量好、技术先进等。例如，苹果公司凭借其强大的品牌影响力和创新技术，在智能手机市场占据优势地位。 Weaknesses（劣势）：分析企业内部的劣势，如成本高、渠道有限、市场份额小等。比如，一些小型咖啡店可能在品牌知名度和资金实力上不如大型连锁品牌。 Opportunities（机会）：分析外部环境中对企业有利的机会，如市场需求增长、政策支持、技术创新等。例如，随着消费者对健康饮品的需求增加，茶饮市场迎来了新的发展机遇。 Threats（威胁）：分析外部环境中对企业不利的威胁，如竞争加剧、经济衰退、政策变化等。比如，咖啡行业竞争激烈，新品牌不断涌现，给现有企业带来了较大的竞争压力。 STP理论 Segmentation（市场细分）：根据消费者的需求、特征和行为等因素，将市场划分为不同的细分市场。例如，服装市场可以根据年龄、性别、风格偏好等细分为不同的细分市场，如青少年时尚市场、中年商务装市场等。 Targeting（目标市场选择）：从细分市场中选择一个或多个作为目标市场，集中资源进行营销。比如，某运动品牌选择年轻运动爱好者作为目标市场，针对他们的需求和喜好推出产品和营销活动。 Positioning（市场定位）：在目标市场中为产品或服务确定独特的定位，以区别于竞争对手。例如，沃尔沃汽车以“安全”为定位，通过强调产品的安全性能来吸引消费者。 HBG 大渗透理论 渗透率：提高产品的市场渗透率是品牌增长的关键。例如，可口可乐通过广泛的渠道铺货和广告宣传，使其产品在各个市场都有较高的渗透率。 想得起：品牌要通过持续的广告和营销活动，保持在消费者心目中的知名度和记忆度。比如，脑白金通过每年的广告轰炸，让消费者在需要礼品时能想起该品牌。 买得到：确保产品在消费者需要时能够方便地购买到。例如，蒙牛通过建立广泛的销售网络，使消费者在各大超市和便利店都能轻松买到其产品。 人货场理论 人：指目标客群，企业要深入了解消费者的需求、偏好和行为习惯。例如，美妆品牌要了解消费者的肤质、化妆习惯和对化妆品成分的关注点。 货：指产品，企业要根据消费者的需求开发合适的产品。比如，针对年轻消费者的时尚品牌会推出款式新颖、价格适中的服装。 场：指传播渠道和销售渠道，企业要选择合适的渠道将产品推广和销售给消费者。例如，电商品牌会通过淘宝、京东等电商平台进行销售，同时利用社交媒体进行推广。 AIPL模型 Awareness（认知）：提高品牌和产品的知名度，让消费者知道品牌和产品的存在。例如，通过广告、社交媒体宣传等方式，让消费者对新品牌或新产品有所了解。 Interest（兴趣）：激发消费者对品牌和产品的兴趣，使其愿意进一步了解和关注。比如，通过举办产品体验活动、发布有趣的内容等方式，吸引消费者的兴趣。 Purchase（购买）：促进消费者购买产品，通过优惠活动、便捷的购买渠道等方式，提高消费者的购买意愿和转化率。例如，电商平台的限时折扣、满减活动等。 Loyalty（忠诚）：培养消费者的忠诚度，使其成为品牌的忠实粉丝，愿意重复购买和推荐给他人。比如，通过会员制度、优质的售后服务等方式，提高消费者的满意度和忠诚度。 P/MF理论 Product/Market Fit（产品/市场契合度）：指产品能够满足市场需求，找到合适的市场定位。例如，瑞幸咖啡通过提供高品质、价格适中的咖啡产品，满足了消费者对咖啡的需求，迅速占领市场。 用更好的产品体验满足一个已有的市场：在已有的市场中，通过提供更好的产品体验来吸引消费者。例如，苹果公司通过不断创新，提供具有更好用户体验的智能手机，满足了消费者对高品质手机的需求。 用一个产品满足已有但部分需求未被满足的市场：针对市场中未被完全满足的需求，开发相应的产品。比如，Uber针对传统出租车服务的不足，提供了更加便捷、舒适的出行服务。 用一个产品满足一个新的市场：创造新的产品或服务，开拓新的市场。例如，微博的出现，满足了人们随时随地分享生活、获取信息的需求，创造了一个新的社交媒体市场。 数字时代的“超能力” 用户画像：通过收集和分析用户的各种数据，如浏览行为、购买记录、兴趣爱好等，企业可以精准地描绘出用户的特征和需求，从而实现个性化营销。例如，小红书通过分析用户的笔记和点赞等行为，了解用户是“宠物家长”还是“美妆控”，进而为用户推荐相关的产品和内容。 私域流量：企业将公域流量中的用户引导到自己的私域流量池中，如微信群、小程序等，通过精细化运营提高用户的复购率和忠诚度。比如，瑞幸咖啡通过微信群发优惠券，让用户在群内直接下单。 病毒传播：利用用户的社交网络和口碑传播，使营销信息像病毒一样迅速扩散。例如，蜜雪冰城的“你爱我我爱你”神曲，通过社交媒体的传播，极大地提高了品牌的知名度和影响力。 四、概念区分 营销 广告 推广 促销 公关 推销 定义和范围 营销是一个 broader 的概念，涉及通过市场调研、产品开发、定价策略、分销渠道、促销活动等手段，满足目标市场需求并实现企业目标的全过程。 广告是营销的一个组成部分，主要通过各种媒介（如电视、报纸、互联网等）向公众传递产品或服务的信息，以提高知名度和促进销售。 推广是通过各种手段宣传产品或服务，提高其知名度和影响力，以促进销售。 促销是在特定时间内，通过折扣、赠品、抽奖等方式，刺激消费者购买产品或服务。 公关是社会组织为了塑造良好形象，通过传播沟通手段，与公众建立和维持良好关系的活动。 推销是以现有产品为中心，通过推销技巧和促销手段，刺激消费者购买产品。 目标 目标是建立长期的客户关系，满足客户需求，实现企业的可持续发展。 目标是提高产品或服务的知名度，吸引潜在客户的注意力，促进短期销售。 目标是提高产品或服务的知名度，吸引更多潜在客户。 目标是短期内提高销售额，清理库存等。 目标是塑造组织形象，建立良好的公众关系，赢得公众的信任和支持。 目标是直接销售产品，实现短期销售增长。 成本 成本较高，需要长期投入，包括市场调研、产品研发、渠道建设等多个方面。 成本相对较低，主要集中在广告制作和投放上。 成本相对较低，主要集中在宣传渠道和物料制作上。 成本相对较低，主要集中在促销活动的策划和执行上。 成本较高，需要长期投入，包括活动策划、媒体关系维护等多个方面。 成本相对较低，主要集中在销售人员的培训和激励上。 策略 需要综合运用多种策略，包括产品策略、价格策略、渠道策略和促销策略等。 主要通过创意和媒介选择来吸引受众，传递信息。 主要通过各种宣传渠道和活动来提高知名度。 主要通过折扣、赠品、抽奖等方式吸引消费者。 主要通过传播沟通手段，如新闻发布会、公益活动等，塑造组织形象。 主要通过销售人员的推销技巧和客户关系维护来促进销售。 效果衡量 效果衡量更复杂，需要考虑市场份额、客户满意度、品牌忠诚度等多个指标。 效果衡量相对简单，主要通过曝光度、点击率、转化率等指标来评估。 效果衡量主要通过知名度、曝光度等指标来评估。 效果衡量主要通过销售额、销售增长率等指标来评估。 效果衡量主要通过公众满意度、组织形象等指标来评估。 效果衡量主要通过销售额、客户满意度等指标来评估。 互动性 更注重与客户的互动，通过市场调研、客户反馈等方式不断调整策略。 互动性相对较弱，主要是单向的信息传递。 互动性相对较弱，主要是单向的信息传递。 互动性较强，通过促销活动与消费者互动。 互动性较强，通过传播沟通手段与公众互动。 互动性较强，通过销售人员与客户互动。 时间跨度 是一个长期的过程，需要持续的努力和投入。 通常是短期的活动，有明确的开始和结束时间。 通常是短期的活动，有明确的开始和结束时间。 通常是短期的活动，有明确的开始和结束时间。 是一个长期的过程，需要持续的努力和投入。 通常是短期的活动，有明确的开始和结束时间。 内容 内容更全面，包括产品、价格、渠道、促销等多个方面。 内容更集中在产品或服务的宣传上。 内容更集中在产品或服务的宣传上。 内容更集中在促销活动上。 内容更集中在组织形象和公众关系上。 内容更集中在产品销售上。 目标受众 目标受众更广泛，包括潜在客户、现有客户、合作伙伴等。 目标受众主要是潜在客户。 目标受众主要是潜在客户。 目标受众主要是现有客户和潜在客户。 目标受众包括公众、媒体、政府等。 目标受众主要是现有客户和潜在客户。 创意 创意更多体现在整体策略的制定和执行上。 创意更多体现在广告内容和形式上。 创意更多体现在宣传渠道和活动形式上。 创意更多体现在促销活动的设计上。 创意更多体现在传播沟通手段和活动策划上。 创意更多体现在销售人员的推销技巧上。 案例 瑞幸咖啡的调研、研发、策略、渠道、活动全过程 电梯里的铂爵旅拍广告 小米的新品发布会 “双十一”购物节的折扣活动 可口可乐的公益活动 街边的产品推销 五、关于营销的常见误解 1. 营销 = 骗人 营销的本质是通过各种手段和策略，将产品或服务的价值传递给消费者，以满足其需求并实现企业的商业目标。过度营销或虚假宣传才是欺骗行为，而正常的营销是放大产品或服务的真实价值。比如 Lululemon通过建立“瑜伽文化社群”，成功地将品牌与健康、积极的生活方式联系起来，其产品本身也确实具有耐磨舒适的特点，因此能够获得消费者的认可和信任。此外，安踏通过收购FILA等品牌，打造品牌矩阵，满足不同人群的兴趣需求，这也是通过放大品牌的真实价值来实现营销的成功案例。\n2. 酒香不怕巷子深 在信息爆炸的时代，每天产生大量的广告和信息，即使产品再好，也需要主动进行推广和营销，才能在众多竞争者中脱颖而出。\n华为Mate 60在未发布前就因“国产芯片突破”的议题营销而爆火，这表明即使产品本身具有强大的竞争力，也需要通过有效的营销手段来吸引消费者的关注。此外，瑞幸咖啡通过与热门 IP 联名，如与线条小狗、TOM\u0026amp;JERRY、贵州茅台等品牌进行联名活动，成功吸引了大量消费者的注意力，提升了品牌知名度。\n3. 营销费用越高越好 营销费用的投入需要有明确的目标和策略，盲目增加营销费用并不一定能带来相应的回报。关键在于如何精准地定位目标市场和消费者，以及如何有效地利用营销资源。\n脑白金通过“今年过节不收礼”的洗脑广告，成功地在消费者心中建立了品牌形象，但其背后是对“礼品市场”的精准定位。教育机构 “学霸君” 在 2020 年因盲目烧钱投放广告导致资金链断裂，在2020年底被传欠薪、破产、人去楼空、退费难，有媒体根据公开信息总结出2020年教育机构倒闭跑路名单，位列其中的机构多达98个，说明营销费用的投入需要谨慎考虑。此外，趣多多在愚人节营销中，利用大数据成功吸引了年轻人的注意，制造了满满的热度与话题，获得了巨大的品牌曝光度，这表明通过精准的数据分析和创意营销，可以在较低的成本下实现高效的营销效果\n4. 营销只是广告和促销 营销是一个系统性的过程，包括市场调研、产品定位、品牌建设、渠道管理等多个环节，广告和促销只是其中的一部分。比亚迪在2023年下线第500万辆新能源车时，通过“在一起，才是中国汽车”的主题营销活动，成功地提升了品牌的知名度和美誉度。这一活动不仅包括广告宣传，还涉及到品牌定位、公关活动等多个方面。\n5. 营销是一次性的活动 营销是一个持续的过程，需要不断地进行市场调研、分析消费者需求、调整营销策略等，以适应市场的变化。洁柔在2024年因直播间输错价格而登上微博热搜，但其通过及时的危机公关和后续的营销活动，成功地将一次失误转化为营销机遇，提升了品牌的形象和消费者的忠诚度。\n6. 营销只关注短期效果 虽然营销活动往往需要在短期内看到效果，但真正的营销更关注长期的品牌建设和客户关系维护。可口可乐在2024年推出的AI人工智能广告，虽然在短期内引发了争议，但从长远来看，这是品牌在探索创新营销方式，以适应数字化时代消费者的需求。\n7. 营销只针对消费者 营销的对象不仅包括消费者，还包括合作伙伴、投资者、员工等利益相关者。麦当劳在2024年美国大选期间，通过特朗普在麦当劳餐厅打工的事件，成功地吸引了全球媒体的关注，这不仅提升了品牌的知名度，也向投资者和合作伙伴展示了品牌的影响力。\n六、什么是营销？ 营销就在提供价值的前提下建立和维护关系，通过价值匹配的方式，准确地对应到供应和需求的各方，将产品或服务提供给需要的客户。\n七、参考 收藏：一文读懂营销百年发展史 ↗ 市场营销学 ↗ 10p 营销理论 ↗ 特劳特定位 ↗ 菲利普·科特勒 ↗ 战略简史（上）：一文读懂迈克尔·波特的竞争战略 ↗ 市场营销组合 ↗ USP 理论 ↗ 弗雷德里克·温斯洛·泰勒 ↗ 福特生产流水线 ↗ 罗瑟·瑞夫斯 ↗ 营销的进化：从营销 1.0 到营销 4.0 ↗ 营销之父科特勒的7个新认知，关于品牌和营销 ↗ ","date":"2025-02-21","tags":["营销几何"],"title":"营销基础：什么是营销？","url":"/post/2025/02/fundamentals_of_marketing_what_is_marketing/"},{"content":"沟通的四个基本原则 结构、性质、目标、风格\n结构 定事之前先定势\n决定权在对方，对应的沟通策略是说服 决定权在他方，对应的沟通策略是辩论 决定权在双方，对应的沟通策略是谈判 谈判的第一个核心要素是利益要素，第二个核心要素是选项要素。\n性质 分歧的性质，分为两大类：\n利益分歧：对有形价值承载物的争夺，需要使用的方法是谈判。 认同分歧：在信仰、仪式、忠诚、价值观、情感上的重要经历产生了不同意见。 人们一旦进入认同分歧，情绪会被快速激活，对话的双方会迅速进入“眩晕”状态，在这种状态下，他们看不见别人，只能看见敌人，他们不认为对方提出了一个方案、想法的普通人，而是认为对方要摧毁自己。\n认同分歧的解决不依赖讲道理，而依赖叙事。\n目标 匡正错误的行为 对氛围影响和行为诱导 设定目标会帮你构建清晰的沟通策略，并匡正沟通中的行为偏差。沟通中澄清目标时，可以用 “不是\u0026hellip;\u0026hellip; 而是\u0026hellip;\u0026hellip;” 这一简单的表达结构，比如 “我们不是来吵架的，而是来解决问题的”\n其次一个开放性的愿景目标，将更有利于帮助你们达成沟通的共识。在解决问题的目标设定下，人们会表现出更多合作、理解和协同，而在博弈杀价的过程中，人们会表现出更多的对抗与冲突。\n所以设定一个善意的，强调共同的愿景，也就是强调作为共同体的 “我们” 的愿景目标，而不是用话语将 “我” 和 “你” 分隔开，这种愿景性的目标设定会帮助双方，架构一个更具建设性的对话场域。\n风格：你的沟通风格 沟通风格大致可以分为五种：竞争、合作、退让、妥协、回避。 风格无对错，但策略有高低。不同风格有不同的行事策略。 谈判不是妥协，是通过合作来创造价值增量，所以谈判是共赢的艺术， 利益不等于立场 熊浩的这套方法，其知识基础来自哈佛大学，它缘起于上世纪七、八十年代，一代冲突解决领域优秀学人的理论奠基。 哈佛谈判理论 ↗ ，也叫原则谈判理论。这套方法首先认为所有谈判的沟通，由四个基础要素构成，分别是利益要素（Interests）、标准要素(Criteria)、选项要素(Options)和 替代方案 ↗ (No-Agreement Alternative)要素。\n四个概念的首字母分别是I、C、O、N，所以我们也将它称为** ICON模型 ↗ **，这是谈判最核心的方法论框架，是一套具有普遍意义的理论工具。这个工具既可以帮助你理解大国之间的争议，例如说国际争端，也可以帮助你化解生活的小问题，比如家人口角。\n所谓利益，就是你的谈判对象内心真正的诉求。而所谓的立场，就是你设想、揣测、认为的对方想要什么。\n在谈判过程中，有时候，对一个行业经验越多反而会被束缚。当你真正了解对方的诉求，才有可能重新整合资源，创新解决方案，解决各自的诉求。\n提问 如何发现对方的利益？\n提问 =\u0026gt; 聆听 =\u0026gt; 反馈\n提问 横向问广度 开放式问题对信息搜集更有效率。 封闭式问题是一种立场性思维，背后隐藏了提问者的价值观。 开放式问题：为什么？怎么样？是什么？在哪里？这样的问题，所得到的答案不是是否，而会得到一个具体的信息。\n尽可能多收集信息：还有别的吗？有什么遗漏吗？有什么补充吗？还有什么要说的吗？\n在谈判的时候，一开始就要保持一个低调平和的提问姿态，并使用横向提问。\n纵向问深度 问原因：为什么？\n特别是在问价格的时候，绝大多数人在谈判的过程中，他的第一个报价是根本无法给你一个客观标准加以支撑的。\n聆听 注意力 积极聆听 不比较不判断 哈佛商学院谈判学的 William Ury 教授曾提出一个有趣的问题：在一个没有任何人的狂野，一棵树轰然倒下，那么现场有发出声响吗？\n聆听不是 “听到”，而是将注意力集中在 “听” 这个行为上。\n职业谈判者往往会花普通人两倍的时间来聆听提问和反馈，而普通人往往会花大量的时候来发表自己的意见，夸夸其谈。\n积极聆听 本质上，积极聆听的意思是保持和言说者的应和，与对方同频共振。在聆听的时候要保持身体前倾，不要切换话题，不要眼神交替，保持对对方的尊重和对话题的投入。\n如果在积极聆听中，你看上去很被动，实际上你是在主动构建一个更健康的对话氛围。\n沟通本质是一个互动构建的过程。如果一个人积极聆听对方大概率也会积极言说，好好听话，有时候比好好说话更重要。\n听觉正念 曾国藩说：“未来不念，即过不恋，当时不杂。” 这是一个享受的过程，史蒂芬·柯维说：“大多数人听的目的是为了‘怼回去’，而不是为了真正理解。”\n不比较，不判断 尽可能让对方的所有信息托盘而出。\n反馈 逐字反馈（重复） 这种方式通常用于客观信息确认\n逐字反馈在情绪爆发的时候不适合，这时候需要做的是语言的清洗。 逐字反馈不能证明反馈者真的听懂了。（重复只能证明信息收到了，不能证明信息已经被理解了） 同义转述 保证说话人发出的信息，和我接收到的信息，含义是一致的。\n意义重塑 把这个谈话的话语场，带到自己真正希望的方向。\n主动地介入对谈判意义的控制，上价值。让对方忘了自己的意义，按照我的意思来。\n所以，谁在冲突的现场，有能力为话题和词语注入内涵，谁就可以占据主动。\n构建对方的需求 对方需要什么可能对方并不知道，自己有能力的情况下，需要提供一个创新的解决方案，这个方案是对方可能想不到的。\n重新定义产品 奇葩说有一期的问题是 “该不该刷爆卡买包？”\n作为论点为 “应该” 的一方，大多数人能想到的都是：开心、快乐、升值，之类的常识和经验。但是辩手花希说：“我们今天讨论的是，人应不应该在自己还没准备好的时候，去为自己喜欢的东西付出一些代价，我认为是应该的。是因为人生很吊诡的地方在于，你非常心动的时刻，往往都是你还没准备好的时候遇到的。当你准备好一切的时候，却很难回到当时心动的那个瞬间了，所以贵的其实不是那个包，而是那个我心动的时刻。”\n如今，我们永远都可以退一步，如果我们可以构造一个新的内容，那么什么才是这个产品的崭新定义？\n选项 在对话过程中，通过对双方的理解和局势的研判，你的办法远远比你的问题要多。\n定额心智 一旦你关心输赢，你就会关心多少，而一旦你把多和少对立起来，你自然而然就进入了定额心智的思考模式。\n所以，商场如战场的隐喻，至少在谈判的维度里，是极具误导性的。它会让你把大量的精力都用在“如何把饼分好”也就是自己占到便宜这个问题上，而不是透过拓展格局、创造合作从而把饼做大。\n定额心智的具体解决方法，一个是打包，一个是创造\n谈判不是战场 我们应该反思把谈判比拟为“战场”的这个基础性隐喻，我们不应该把“谈判”的对话理解成战场，更不应该用输赢来标定谈判的成效，而应该用另外的词，例如更好的、有效率的、具有创造性的、具有建设性的、长期的、健康的、具有启发性的，这些替代性的概念来对谈判的成功进行评估与标定。\n打包 把对方的利益分成三种基本类型：共同利益、不同利益、利益冲突\n共同利益：彼此利益互相绑定，一荣俱荣，一损俱损。处理方式是合作。\n不同利益：对一方很重要，而另一方不关系。处理方式和交换。\n利益冲突：双方需要争取的。处理方式是博弈。\n满足对方需求，再要求对方让步，Give and Take，这就是打包这种工作方式的关键。只有发现了好几个战场，发现了“非冲突的利益类型”，才可能实现双赢。\n创造 即头脑风暴。\n要把这个过程分成两个阶段，第一是创意，第二是决策。这两个目标，相对独立。为什么要这样？因为人类的思考具有收敛性。\n思考的收敛性 在谈判的过程中，一旦出现一个不错的方案，我们往往会拥抱它，然后放弃进行更深入的创意。\n在谈判和沟通过程中，给予“创意”一个单独的目标、单独的时间。在这个时间里，我们集思广益，把脑洞打开，保证平权的讨论，让尽可能多的各种想法和盘托出，不要作指责、评价和判断。而到了决策环节，我们再进行比较和筛选，最终作出决定。\n所以，创意和决策的过程不要混为一谈。\n创意与决策要分开 进行创意的时候不要判断，真正好的点子不太可能是前面的几个，而更可能出现在很后面。意味着不要在刚刚有一点方案的时候就下定论。\n把创意看作一个单独的目标，只有这样你才能够用平权的讨论方法。让头脑风暴持续，一旦有了判断，一旦快速指责，思维就会收敛，好的想法也许你就听不见了。\n客观标准 这是解决利益冲突的方法，能够帮助你在得到利益的同时，也能维持关系。\n三种影响力 有三种影响你认知的和决定的影响力类型：\n正向：说服对方，这样做会给自己带来直接的好处。比如赞美式推销。 负向：跟对方沟通，如果不这样做，你会吃亏。比如恐吓式推向。 规范：你应该这样做，不能利好，也不能规避损失。 规范影响就是在谈判过程中，引入所谓客观标准，借助那些非主观因素 —— 客观要素，不由双方当事人的意志所转移的力量，说服对方做出让步。\n客观标准 谈判中引入客观标准，使用规范影响力，能更容易地说服对方，让对方做出让步。 日常生活中引用的客观标准有：法律，政策与规范，行业中的惯例，以及之前谈判中的先例。 客观标准可以帮助你吸收不满，在对方让步的同事，也能维持好与对方的关系。 当对方感受到自己被公平对待，他会接受你的标准，他会更容易接受你的开价。\n如果你提供一个客观的标准，对方将无话可说，因为你是在按照规则办事，而且保证了对方被公平对待，所以对方最多会对规则有意见，会避免对你个人产生意见 —— 他不会攻击你，因为这是标准的问题，而不是你的问题。\n替代方案 如果谈判谈崩了，你能怎么办？\n错误的底线思维 在设定底线之前，我们要知道，底线会让我们付出代价，当我们设置僵化的底线时，整个谈话的过程将会失去共创的弹性。并且我们设定的底线通常都不合理。\n真正能让你在谈判过程中保持强硬力量的，是你有一个很强的替代方案。\n在我们谈判的过程中，要不断寻找那个最好的替代方案，用这个替代方案来和正在谈判的局势做比较，用最好的态度面对最优的选择。\n说服 说服实际上是一种对影响力的调动。当我们没有控制权，我们便需要去使用说服。\n场景一：你没有独占的资源与能力 这种情况下你只能影响\n场景二：你没有控制的合法性 传统合法性：我对你的控制力量，来自某种传统中的 “继授”。 法理合法性：我对你的控制力量，来自于某种理性的规则框架。 超凡合法性：这是一种非理性的力量，来自于对某种力量的追随和信仰。 以上三种情况都不需要说服，而是可以直接使用命令的方式。所以说服也被称为 “非职权影响力”\n说服的策略 总体来说，我们要施加影响进行说服，我们有两个策略方向：\n中心路径，或者叫理性路径，调动理性的力量。它需要包含两个条件：前提为真和逻辑有效。 外围路径，或者叫边缘路径，调动感性的力量。 外围路径的方法 喜好 如果对方喜欢你，把么对方就更有可能被你说服。那么如何让对方喜欢你呢？这就是 3A 法则\n3A 法则 赏识 赏识其实是看待这个世界的积极视角。积极的视角去看待这个世界的时候，可以发现这个世界有非常多值得赞美的点。\n在真正沟通的过程中，在可以赞许对方的时候，其实我们都应该给对方加以赞许。\n授权自治 如果对方对局势完全没有控制，对方就会非常不舒适，也不会喜欢你。\n当我们创造选择的时候，其实是我们在尊重对方整个话语决定的控制，而如果对方获得了这种控制，他就会更喜欢你，也更容易被你说服。\n相似 我们更喜欢跟自己相似的人，如果你能跟你的沟通对象保持某种程度的顺应或雷同，对方将更喜欢你。\n重复对方的话，或者行为，和对方保持同步，会让对方感到融洽，对方会更喜欢你。\n一致的两个维度 结构相似：客观环境的相似 个体相似：主观选择的相似 当我们发现彼此有背景的交织或者喜好的重叠时，对方会更喜欢你。\n外围策略的 6 要素 喜好：实际上就是上面提到的 3A 法则。 权威：日常生活中的权威任务或者公众人物。 从众：我们不希望格格不入，而是顺应大多数。 一致：人们倾向于和自己之前做出的行为保持一致。 稀缺：损失厌恶心理。 互惠：礼尚往来，俗话说的 “吃人嘴软，拿人手短”。 说服的本质都是在处理两个问题：\n能量问题：人是有惰性的，所以说服的根本是避免对方思考。 人性问题：最重要的是呵护自尊。 辩论 辩论是在对抗情景中的问题论说，其目标是对第三方的争取\n所以，你发现自己要说服的不是对方而是第三方，那么这就是辩论的场景。\n辩论的情景有两种：价值辩论、政策辩论。\n价值辩论 大学做兼职是利大于弊还是弊大于利？ 超级英雄对世界是好事还是坏事？ 事业和家庭谁更重要？ 这样的问题没有绝对对错，双方都在推广自己的偏好，以获得你的支持。余秋雨先生曾说：“辩论双方其实都心知肚明，自己的观点是片面的，所以辩论实际上是在掩饰自己的片面，同时揭露对方的片面。”\n延伸 角色：谁再说？对谁说？有这种想法的人是什么人？ 前提：基于什么隐含的前提，才会有这样的认知？ 概念：我们讨论的概念是你说的这个意思吗？ 情景：什么场合说，什么状况说？ 推论：如果人人都按照你说的做，会有什么后果？ 政策辩论 政策辩论是一种优化沟通思考路径的整体方法。 四个步骤：需、根、解、损。 需求性：确定麻烦；我们有没有遇到麻烦或痛苦，以至于需要采取一个新的行动或对策？\n根属性：寻找原因；产生这个马方或痛苦的原因是什么？\n解决力：评估效益；这个新的行动，会在多大程度上解决我们所面临的麻烦？\n损益比：衡量得失；这个政策的优劣势是什么？利好利空是什么？\n调解 从冲突管理专家的角度来看，冲突解决的问题实际上是人的问题：影响人的心智、管理人的思路、控制人的情绪、强化人的执行。\n两类控制框架：看的见的结构和看不见的结构。\n看的见的结构 演讲者与观众在演讲前的肢体和眼神互动，实际上是在试图和尽可能多的受众建立具有关联性的人际接触。\n恰当的人际接触，会发生对人非常明显的影响。\n看不见的结构 三尺讲台实际上构建的是说话者的权威。\n这种构建不来自言辞，而是环境的暗示。\n作为解决冲突的专家，坐哪里并不重要，重要的是和产生冲突的双方保持一样的距离，始终如一地保持。保持这样的距离可以暗示双方局面的公平性。\n在沟通过程中，我们既要关注看的见的结构控制，比如言辞和行为，也要关注看不见的结构控制，比如氛围和座次。\n情绪控制 情绪的辨认与情绪的管理\n情绪的辨认 七种基本情绪：悲伤、愤怒、惊讶、恐惧、恶心、轻蔑、高兴\n情绪的管理 停顿 当情绪快要失控的时候，可以以自然的方式短暂离开，离开后双方都会回到友善理性的沟通方式中。\n饿 大脑最消耗能量的情况分别是：高度专注、节制自己、假装、保持平衡感。\n所以一般在谈判过后双方都会很疲劳。\n如果有能力称为主场，为了更好的谈判，可以在谈判过程中停顿休息、吃一点东西、到通风的地方走一走、户外逛一逛，都会让双方更加聚焦，更好地管理自己的情绪。如果作为客场，能达到至少一条也是很好的。\n情绪的问题在很多时候，并不是教养的问题，而是因为饿了。在谈判前，务必吃好睡好。\n问题外化 如何在对立的状况下解决问题？\n什么是外化？\n对于精神科的判断，医生通常不会说你得了什么病，而是会问你一些感觉是什么时候出现的。这就是问题外化，是一些现象出现，并不是得了病。\n问题外化的三个步骤 确定共同目标 确定沟通的对象是想合作的，合作是有价值的\n移动问题跟人的相对位置 共同解决问题，让彼此先达成合作，探讨解决问题的可能性。\n把问题从人身上抽离出来，共同面对这个外化的问题 谈判的双方是伙伴，利益抉择才是问题；医患是伙伴，病才是问题。\n对问题应该有原则，但是对人应该有弹性。\n有效承诺 做出公开承诺，让第三方见证 立即开始，哪怕是一个局部，让承诺立即履行 讨论可能出现的意外 沟通三角形\n马斯洛需求理论\n沟通中的坏习惯：\n利益和立场混同。任何迎面而来的对方的任何叙述，不妨都先假设那是立场，向后探问，去找利益；\n沟通开始时，提出很多封闭式问题。问就是问，不要变成猜；\n说得太多，听得太少，对话中双方的话语量明显失衡。常见的错误，自己一直在讲，对方成了陪衬；\n对自己的沟通风格缺乏觉察，经常会因关系牺牲利益，或者用利益压迫关系；\n谈判中不准备客观标准；\n自我感觉良好，树立绝对底线，而不是向外去寻找替代方案；\n高兴的时候给人承诺，愤怒的时候给人留言；\n对情绪缺乏觉察，完全没有阅读空气的意识；\n经常强调我与众不同，爱卖弄专业，把自己和他人快速区分开来；\n不能在沟通中将人和问题分开；\n重要的场合，天马行空自由发挥，既不凝练中心，也不总结要点；\n把沟通视为“神学”，认为沟通可以解决一切问题。\n","date":"2025-02-21","tags":["冲突解决","熊浩"],"title":"得到课程《跟熊浩学沟通30讲》课程笔记","url":"/post/2025/02/get_the_course_notes_of_the_course_30_lectures_on_communicating_with_xiong_haoxue/"},{"content":" 本期主要描述了冲突场景下的解决方案，方法来自复旦大学的熊浩老师。下一期将讲述哈佛谈判的细节，或者评论你想了解的内容或事件！\n在日常生活中，我们非常容易遇到冲突。比如在点餐判队的时候，遇到插队的，通常我们的解决方案是回避。有些时候我们很难回避，例如在餐厅中吃到异物。我们应该如何解决生活中的冲突？\n生活中的冲突 想象一下，你耐着饥饿，点餐后等待了漫长的时间，终于吃上第一口热腾腾的饭的时候，突然察觉到异样的东西在菜里，舀出来竟然是一个苍蝇。你的感觉如何？\n如果想要争取一些赔偿，在没有学习过冲突解决的人，唯一能做的就是和对方吵。\n但是学习过的人绝对不会和对方吵。这是一个典型的冲突场景，因为你要做一个决定，如果你不关心，你认为苍蝇很美味，专挑苍蝇吃，你绝对不会和对方吵。更多的情况是你关心这个事情，你希望对方能够赔偿你。如何解决这个冲突？\n首先要判断权力在哪里。\n如果你希望的是老板说 “抱歉，这单我们不收您费”，这时候权力就在对方，因为这句话要老板开口。我们要使用的方式就是说服。\n你说吃到苍蝇后，来的是一个服务生。你说 “我要免单”，对方说 “先生不好意思！这个\u0026hellip;\u0026hellip;”，你说 “叫你们老板来”，此时老板还没来。“叫你们老板来” 这句话的目的是什么？目的是想和老板喝两杯叙叙旧吗？肯定不是，言外之意，“如果这件事你处理不好，我要给你好看”，这是在提升自己的议价能力，有讨价还价的余地，这时候就是谈判。\n谈判是非诉讼纠纷中的一种最常用路径 谈判首先是沟通，是为了实现一个具体目标而实现的有效对话。既然有目标，也就意味这对方具备自己所需要的能力或资源，或者说，对方能够影响事件的结果。\n谈判一定会有一个需要作出的决定，如果不需要做决定，我们也不需要谈判。做决定的情形一般会有三种。\n说服：决定的权力在对方 当你是公司里一个可有可无的人的时候，你的情形叫 “大年三十的凉菜” ———— “有你也过年，没你也过年”。这时候，你给老板说 “我要加薪！”，老板说：“药家鑫判死刑了。” 你根本没有讨价还价的余地，决定的权力完全在对方，这种争议的解决方式叫说服。\n还有一个常见的场景是销售，如果你是购物者，销售人员要想方设法让你相信产品对你是有利的，他只能影响你的选择。\n最著名的是心理学家罗伯特·西奥迪尼的《影响力》，他将说服的力量分解为六个行动要素 —— 互惠、稀缺、从众、权威、一致和喜好。\n假设你在商场里看到一款新上市的智能手表，销售人员走过来，开始用《影响力》中的六大原则说服你购买：\n互惠：他先递给你一杯免费的咖啡，并让你试戴手表，让你感受到他的好意，从而产生一种“回报”的心理。 稀缺：他告诉你这款手表是限量版，只剩下最后几块，如果不赶紧买，可能明天就没了。 从众：他提到这款手表最近特别火，很多年轻白领都在戴，甚至你喜欢的某个明星也在用。 权威：他拿出了一份专业机构的测评报告，显示这款手表在同类产品中评分最高。 一致：他问你平时是否注重健康管理，当你回答“是”时，他立刻强调这款手表的心率监测和运动记录功能，让你觉得购买它符合你的生活方式。 喜好：他注意到你对手表的外观很感兴趣，于是夸赞你的品味，并说这款手表的设计特别适合你。 最终，你可能会被这些技巧打动，决定购买这款手表。这就是说服的力量 —— 决定的权力在你，但销售人员通过影响你的心理，让你做出了他期望的选择。\n谈判：决定权力在双方 这时候，决策的权力被你我双方分享。这时候的解决方式就是谈判。\n比如公司两个部门争夺项目资源，设计部说“这个客户池必须划给我们”，软件部拍桌子“我们半年前就开始跟进”。这时候既不能靠领导强压（说服），也不能找外人评理（辩论），只能在会议室里拉锯战：你让出 20% 客户资源，我分你两个销售骨干，最后握着手说“合作愉快”，这种带着计算器的拉扯就是谈判。\n最经典的就像夫妻商量春节回谁家过年，行李箱摊在客厅地上，一个举着高铁票说“我妈做了腊肠”，一个晃着视频通话说“我爸腿疼半年了”，最后达成 “先去湖南吃腊肠，初三飞东北看雾凇” 的双赢方案，这种相互妥协的艺术就叫谈判。一个更通俗的例子是菜市场砍价的过程。\n这个过程实际上是决定权被分享的过程，创造 1+1\u0026gt;2 的价值是最重要的。当谈判需要协助的时候就是调解。调解的本质就是为了双方获得最大回报的谈判。它是一个从更宏观的位置出发，不为某一方争取利益，而是为双方创造价值。\n辩论：决定权力在第三方 目标的实现依赖于第三方的决定。\n这种在决定权力在第三方的情形，最典型的场景是法庭。原告和被告没有决策的权利，只能为自己辩护，最终还得法官或陪审团作为第三方，根据法律和事实做出最终的裁决。\n就像投标现场，甲方翘着腿当裁判，张三的公司 PPT 翻出火星子：“我们方案能省 30% 成本！”，李四的公司激光笔直指痛点：“我们的交付周期缩短一半！”。两边唾沫横飞其实都在对评委喊话，毕竟招标的才是话事人。\n古罗马角斗场就是最原始的辩论场，两个角斗士刀剑相向不是为了杀死对方，而是要用喷溅的血花说服看台上的贵族竖起大拇指。当代职场也常见这类场景，比如部门会议上两个团队争预算，表面是互相扔数据报表，实际都在偷瞄总经理微微点头的幅度。\n你能影响的不是对方，因为各自都有各自的立场，并且各自都不关心真相，也自然就没有理解和妥协的可能。\n不要误用 想象一个场景，你和你朋友约晚上吃饭。他想吃川菜，而你想吃火锅。这时候决定权力是在对方，需要用说服，而不是辩论。\n不能说 “吃火锅有三点好处，\u0026hellip;\u0026hellip;”，这是辩论，你将这些道理没有人听。\n当对方掌握决定权时（比如请客的人、老板、客户），辩论逻辑反而会引发对抗。你越强调自己的合理性，对方越会觉得被冒犯（潜台词：你在质疑他的决策能力）。那么怎么做是正确的呢？\n这应该用说服，可以参考《影响力》的「喜好+互惠」原则。\n比如：“听说你特别会选餐厅，上次推荐的那家川菜绝了！不过最近我有点感冒，吃辣的嗓子疼……要不这次你帮我选个清淡点的火锅？下次我请你去试新开的湘菜馆！”通过赞美满足对方的权威感，用互惠承诺降低拒绝的概率。\n第二个场景，夫妻买房，丈夫想选学区房，妻子想选离公司近的公寓。如果妻子直接说：“学区房升值快，专家都这么说！” 这是权威原则，这就是误把说服当谈判。\n在双方共享决定权时，单方面使用说服技巧，如权威或者稀缺，会激化矛盾，因为隐含了 “我比你更正确” 的压制感。那么应该如何做呢？\n更好的做法是启动谈判的「利益交换」思维。例如：“选学区房的话，孩子上学方便，但通勤时间会增加2小时；如果选公司附近的房子，我们可以每天多陪孩子1小时。要不要先算算两种方案的时间成本？” 把对立立场转化为共同利益的计算，可以更好地创造出 “1 + 1 \u0026gt;2 ” 的选择。\n第三个场景，网友在社交媒体争论 “咸粽子 vs 甜粽子”，用大量数据证明咸粽子更受欢迎。\n辩论的本质是争取第三方支持（如法官、观众、评审），但在没有第三方的私人对话中，非此即彼的辩论、执着于逻辑胜利只会让关系恶化。\n这时候应该识别场景性质。如果是私人聊天，可以转化为谈判：“其实我两种粽子都会包，端午节要不要来我家？让你同时尝到甜咸CP组合！” 用共谋创造新选项，避开立场对抗。\n不难发现\n说服：权力单边倾斜 → 用 “心理柔术” 间接影响对方（如《影响力》六大原则） 谈判：权力双向制衡 → 用 “利益交换” 创造合作空间 辩论：权力归属第三方 → 用 “证据链” 争取旁观者支持 误区：把资源浪费在无权改变的事上（比如和老板辩论、和伴侣争输赢），却在该用权力时不敢主张（比如谈判中过度让步）。\n你在生活中处理冲突有更好的方法吗？欢迎评论！\n","date":"2025-02-20","tags":["冲突解决"],"title":"解决冲突：饭里吃到苍蝇应该如何获得应有赔偿？","url":"/post/2025/02/conflict_resolution_how_can_i_get_due_compensation_if_i_eat_flies_in_my_meal/"},{"content":"\n一、痛苦的本质：神经科学与行为经济学的双重证据 结账时的痛苦不仅是心理感受，更是大脑的生理反应。神经科学研究表明，当消费者支付现金时，大脑岛叶皮层（与身体疼痛相关的区域）活动显著增强，这种神经层面的“损失感”被行为经济学称为“支付疼痛”（Payment Pain）。\n一项经典研究发现，使用现金支付的消费者在购买高价商品时，决策时间比信用卡用户长 30%，且更容易放弃购买。这种差异源于心理账户（Mental Accounting）理论 —— 现金支付因“看得见的损失”而触发更强的痛苦感。例如，消费者在面对现金支付时，会更加感受到资金的减少，从而产生更强的支付疼痛感，导致他们在购买决策时更加谨慎，甚至放弃购买。而使用信用卡或电子支付方式时，由于支付过程相对抽象，消费者对资金减少的感受较弱，支付疼痛感也相对较轻，从而更容易完成购买行为。\n二、止痛策略：从理论到实践的四大维度 1. 抽象化支付：弱化“失去感”的神经机制 拉斯维加斯赌场将现金兑换为筹码，这会让赌客对金钱的观念变得淡薄。当赌客把现金兑换成筹码后，原本的一沓钱变成了一堆塑料片，赌客在下注和输钱时对金钱的感知会降低，从而更容易进行大额投注。同时，筹码的使用让赌客失去了对钱的概念。如果赌客输的是现金，他们可能会感到不舒服，从而停止赌博。但输的是筹码时，赌客的输钱感受会减少，这使得他们更容易继续赌博。另一方面，筹码的面额通常较大，使用和携带更方便，这也在一定程度上降低了赌客对金钱的敏感度。\n这种抽象化支付方式让赌客在心理上感觉不到直接的现金流失，从而更容易进行大额投注。类似地，亚马逊的“一键支付”通过保存信用卡信息，让付款动作简化为一次点击，用户大脑的疼痛反应显著减弱。\n这种不同的感受实际上时框架效应在作祟，即：人们对一个客观上相同问题的不同描述导致了不同的决策判断。因此，支付方式越抽象（如电子钱包、代币），消费者对损失的敏感度越低。这种效应在日常生活中随处可见，例如使用信用卡或电子支付时，消费者往往比使用现金时更愿意消费。\n2. 流程简化：减少认知负荷的心理学设计 邦阅网数据显示，将结账步骤从5步压缩至1步可提升转化率28%。简化结账流程不仅减少了消费者的认知负荷，还降低了因步骤过多导致的放弃率。40% 的消费者因强制注册放弃购买，而提供“匿名结账”选项后，放弃率下降至12%。这种设计减少了消费者的决策疲劳，使购买过程更加顺畅。\n认知资源有限理论指出，复杂的流程会耗尽用户注意力，导致决策逃避。当消费者在购物过程中遇到过多的步骤和信息时，容易产生疲劳和放弃的念头。例如，以色列假释委员会的研究显示，法官在经历全天候的决策消耗后，更倾向于选择“安全选项” —— 拒绝假释，致使假释批准率从上午的70%暴跌至下午的10%。类似地，购物时的决策疲劳也会导致消费者在面对复杂流程时选择放弃。例如，研究人员在购物中心发现，那些已经在购物时做了大量决定的顾客，在解答简单算术题时更容易放弃。\n3. 心理补偿：利用“获得感”对冲痛苦 在日常生活中，我们常常会遇到各种消费场景，商家通过巧妙的心理策略来吸引消费者，其中锚定效应和损失规避是两种常见的手段。\n锚定效应是指人们在做决策时，会过度依赖（或“锚定”）于第一次接收到的信息。例如，在超市促销活动中，商家先展示商品的高价标签，再展示折扣价，消费者会因为最初的高价“锚定”而觉得折扣价更具吸引力，从而更可能购买折扣商品。这种策略利用了消费者对低价选项的敏感性，增加了额外购买的可能性。\n损失规避是指人们对损失的敏感程度高于对同等收益的敏感程度。例如，Shein推出“分期免息”服务，将100美元的总价拆分为4期支付。消费者每次只需支付25美元，这种分期支付方式利用了心理账户分割的原理，降低了单次支付的痛感。消费者感觉每次支付的金额较少，从而减轻了支付的痛苦。\n4. 信任构建：社会认同与公平感知 你是否曾经因为看到很多人都在购买某件商品，而决定跟随购买？这种现象在心理学上被称为“羊群效应”，是一种社会认同感的体现。当我们看到其他人对某个商品或服务表示认可并购买时，我们也会倾向于跟随，以获得群体的认同感和归属感。\n例如，在一些网红主播的粉丝社群里，社群内经常会组织团购活动或者大家会一起讨论购买某款商品后的使用感受。个别成员如果不参与这些消费行为，可能会感觉自己与群体格格不入，所以即便对商品本身的需求不是特别强烈，也会出于群体认同的心理而做出购买决策，以此来强化自己在社群中的归属感。这种社会认同感不仅增强了消费者对平台的忠诚度，还促进了其消费行为的产生。\n在购物过程中，你是否曾经遇到过隐藏的运费或税费，导致最终支付的金额远高于预期？这种情况下，你可能会感到不公平，甚至会产生“心理背叛感”，从而放弃购买。\n透明的定价策略能够有效避免这种情况的发生。当企业在定价过程中对外公开其价格设定的依据和过程，包括成本与利润的公开、产品的生产过程、质量标准和市场定位等，消费者能够更加清楚地了解产品的价值，从而增强对企业的信任感。例如，某电商平台在结算页面提前展示全价（包括运费和税费），避免了消费者在最后一步因价格不透明而产生的“心理背叛感”，从而减少了因不公平感导致的放弃率。\n一些运动品牌在直播带货中，通过展示“已有10万+用户购买该系列运动装备”，吸引了更多新用户下单，转化率提升了约15%。同时，该品牌在网站上明确标示商品的全价，包括所有可能的费用，使得消费者在购买过程中更加放心，放弃率降低了约15%。这个案例表明，结合社会认同感和透明定价策略，可以有效提高消费者的购买意愿和信任感。\n三、科技赋能的“无感支付”革命 1. 生物识别支付：消除决策触点 在现代科技的推动下，支付方式经历了从现金到银行卡，再到移动支付的变革。而如今，随着人工智能和生物识别技术的发展，自动化决策在支付领域得到了广泛应用，其中支付宝的“刷脸支付”就是一个典型的例子。\n支付宝的“刷脸支付”通过人脸识别技术，将用户的面部特征与账户信息绑定，实现了无需携带手机或银行卡的便捷支付方式。用户只需在结账时面对摄像头，系统即可在几秒钟内完成身份验证和支付过程。这种支付方式不仅大大缩短了结账时间，还提升了用户体验。\n“刷脸支付”的便捷性在于其通过自动化决策绕过了大脑的理性评估环节。用户在使用“刷脸支付”时，无需进行复杂的思考或操作，支付过程几乎是在无意识中完成的。这种支付方式的快速和便捷性，使得用户在支付时的“疼痛感”降低，从而减少了对消费的犹豫和抵触。\n2. 动态定价与神经营销 经济学中最重要的一条定律是需求定律，需求定律指出，购买的某种商品的数量与其价格成反比，即价格上涨导致需求量下降，价格下降导致需求量上升。 优步在高峰时段采用“淡入式加价”策略，以应对供需不平衡的问题。当某个地区的乘客需求大于可提供服务的车辆时，系统会自动调整价格，以平衡供需关系。\n这种策略比直接显示高价订单接受率更高。这是因为“淡入式加价”利用了锚定效应，消费者会将初始价格作为参考点，逐步提高的价格让他们更容易接受。\n而 Netflix 则通过“会员分级定价”策略，提供不同档次的会员服务，引导用户选择中间档位。这种策略通过设置不同档次的价格，消费者会倾向于选择中间档位，因为他们认为这是性价比最高的选择，从而提高了整体的付费转化率。\n四、支付的痛感 从行为经济学的视角来看，支付体验确实会对消费者的支付意愿产生显著影响。\n支付痛感理论 现金支付的痛感：根据支付痛感理论，现金支付的透明度最高，消费者在支付时能够清楚地看到金钱的流失，这种直观的感受会增强支付痛感，从而抑制消费行为。例如，消费者在使用现金购买商品时，会更加谨慎地考虑是否真的需要该商品，因为支付过程中的“割肉感”更强烈。 电子支付的低痛感：相比之下，电子支付和信用卡支付的透明度较低，消费者在支付时感受不到金钱流失的直观感受，支付痛感相对较弱，因此更容易进行消费。例如，使用信用卡或移动支付时，消费者可能不会立即感受到金钱的减少，从而更容易进行大额消费。 支付过程中的不便和复杂性 支付方式的复杂性：如果支付过程过于复杂或不便，消费者可能会因为支付体验差而放弃购买。例如，一些网站或商家的支付流程繁琐，需要多次输入信息或跳转页面，这会导致消费者感到厌烦，从而降低支付意愿。 技术问题：支付过程中出现的技术问题，如支付系统故障、网络延迟等，也会严重影响消费者的支付体验。例如，消费者在使用移动支付时，如果遇到支付失败或系统崩溃的情况，可能会对支付方式失去信心，进而影响其支付意愿。 支付安全和信任问题 安全担忧：消费者对支付安全的担忧会显著影响其支付意愿。如果消费者认为支付方式不安全，例如担心个人信息泄露或资金被盗，他们可能会拒绝使用该支付方式。例如，一些消费者在使用公共Wi-Fi进行支付时，会担心支付信息被截获，从而选择放弃支付。 信任缺失：消费者对商家或支付平台的信任度也会影响其支付意愿。如果消费者对商家的信誉或支付平台的安全性存在疑虑，他们可能会选择其他支付方式或放弃购买。例如，一些小型电商平台由于缺乏知名品牌和安全保障，消费者可能会对其支付系统不信任，从而不愿意进行支付。 支付环境和服务态度 环境因素：支付环境的舒适度和便利性也会影响消费者的支付体验。例如，在一个嘈杂、拥挤的环境中进行支付，消费者可能会感到不愉快，从而影响其支付意愿。相反，在一个安静、舒适的环境中，消费者更愿意进行支付。 服务态度：商家或支付平台的服务态度也会影响消费者的支付体验。如果消费者在支付过程中遇到不友好的服务态度，他们可能会感到不满，从而影响其支付意愿。例如，收银员态度恶劣或不耐烦，可能会导致消费者放弃购买。 支付成本和收益的感知 成本感知：消费者对支付成本的感知也会影响其支付意愿。如果消费者认为支付成本过高，例如支付手续费过高或支付方式不划算，他们可能会选择其他支付方式或放弃购买。例如，一些跨境支付平台收取高额手续费，消费者可能会因此选择其他支付方式。 收益感知：消费者对支付后获得的收益的感知也会影响其支付意愿。如果消费者认为支付后获得的收益不值得，例如商品质量差或服务体验不佳，他们可能会拒绝支付。例如，一些消费者在购买到质量差的商品后，会感到后悔，从而影响其未来的支付意愿。 参考 “损失厌恶”，学有大用 ↗ Neuron：大脑如何编码疼痛？科学家揭示了大脑皮层中的新型神经元机制！ ↗ 心理账户理论：理解消费者决策背后的心理机制 ↗ 框架效应 ↗ 如何科学应对「决策疲劳」？从以色列法官到扎克伯格的选择策略 ↗ 决策疲劳的惊人诅咒 | 彬复分享 ↗ 营销拆解：转化率飙升，沉锚效应的利用案例和破解方法 ↗ 转型AI产品经理（10）：“羊群效应”如何应用在Chatbot产品中 ↗ 价格透明度对消费者购买意愿的双刃剑效应：产品涉入度的调节机制研究 ↗ 20个令人印象深刻的神经营销成功案例 ↗ 弹性定价原理及Uber动态定价模型 ↗ 移动支付开启“无痛消费”模式 ↗ 电子支付让我花了更多钱？丨电子支付 ↗ 消费者移动支付使用意愿影响因素及其作用机制研究 ↗ 利用心理学影响用户行为 ↗ 零售自助结账行业的消费心理分析 ↗ 基于行为经济学的客户服务优化研究 ↗ 优化用户友好的结账流程:提高转化率的最佳实践 ↗ ","date":"2025-02-20","tags":["暂无"],"title":"无痛支付：如何从行为经济学视角优化支付体验？","url":"/post/2025/02/painless_payment_how_to_optimize_the_payment_experience_from_a_behavioral_economics_perspective/"},{"content":" 原视频： https://youtu.be/Pf_8nZ3K3qU ↗ ![img](\n一、竞选背景与挑战 奥巴马作为美国历史上第一位黑人总统竞选人，当时他并没有足够的优势，尤其是缺乏在国家级政府机构的工作经历。然而，他通过电子商务和市场营销手段，成功赢得了总统选举。\n关于奥巴马总统竞选的一则广告可以在 Youtube 上通过关键字 “wassup OBAMA 8 years later” 搜索到。\n二、洞察社会趋势 奥巴马团队在短短两分钟的视频中，精准地描述了美国当时面临的困境，包括战争、经济等方面的问题。这在营销中被称为 PEST 分析（政治、经济、社会、技术）。视频中，观众在听到布什的演讲时表现出疲倦，而在听到奥巴马的演讲时则显得激动。这种对比鲜明的情绪反应，凸显了民众对“改变”的强烈诉求。\n三、竞争对手分析 奥巴马的竞争对手主要有两个，一是麦凯恩，二是希拉里。\n麦凯恩：年纪大，经验丰富，是布什时期的副手，参加过越战，有众多军人支持。 希拉里：出身政治世家，丈夫曾任总统，执政经验丰富，是位女强人。 面对这两个强劲的对手，奥巴马如何竞争呢？市场营销中有两个重要的概念：重新定位和贴标签。奥巴马团队巧妙地运用了这两个概念，将对手的优势转化为劣势。\n四、重新定位与贴标签 奥巴马在一次演讲中，使用贴标签的方式，拉低了麦凯恩的票数比例。他说：“美国之所以出现这样的困境是政府的问题，但政府是谁选出来的？是你们。如果你们还想过这种水深火热的生活，就投票给麦凯恩。”虽然没有直接说麦凯恩和布什之间的关系，但隐含了麦凯恩带着布什政府失败的影子，正所谓“爱屋及乌”。\n希拉里经常嘲笑奥巴马没有经验，但在一次演讲中，奥巴马说：“我很敬重希拉里，她有很丰富的政治经验，但面对例如911这样的黑天鹅事件时，我们的经验能帮助我们做些什么？”奥巴马的潜台词是给希拉里贴上了“经验主义”的标签，传递了“经验主义不能改变美国”的理念。奥巴马给自己的定位就是“改变”。\n五、价值营销框架 奥巴马的竞选策略实际上是价值营销的框架：\n我的价值在哪里：强调“改变”，以迎合民众对美国未来的期望。 我为谁服务：明确目标对象是中产阶级，因为美国的社会结构中中产阶级占了绝大部分。只要解决了中产阶级的利益，就能获得他们的支持。 我如何为他服务：在广告中一直强调经济问题，这是中产阶级的焦虑所在。 六、营销推广策略 从4P的角度来看，奥巴马的营销推广策略如下：\n定价：低价渗透，降低门槛。面向所有美国中产阶级，开展社区竞选活动，只要捐赠25美元，就能获得与奥巴马接触的机会。这个产品组合强化了曝光率和渗透率。 产品：捆绑销售。奥巴马的筹款活动大量吸引小额捐款，通过钥匙扣、T恤、鞋等快销品的渗透率很广，很多人都能通过购买这些产品来认识奥巴马。这实际上是曝光效应。 渠道：超越传播屏障。奥巴马引入了互联网思维，首先是搜索竞价排名，通过与谷歌的合作，让用户在搜索奥巴马名字时，可以列出他的所有消息，实际上是占据了人们获取信息的渠道。线下方面，他赞助了“超级碗”节目，其次是NBA，再是在游戏中植入广告和4G网络，最后是发动群众。在华人方面，奥巴马通过电子邮件找到华人领袖，进行病毒式扩散。 奥巴马的竞选成功，是数据驱动与营销策略完美融合的典范。他凭借对社会趋势的精准洞察、对竞争对手的有效定位、以价值营销为核心的一系列策略，以及数据驱动的决策支持，最终赢得了总统选举。\n七、参考 人人学点营销学 - 杜鹏 ↗ 2008年美国总统选举 - 百度百科 ↗ ","date":"2025-02-19","tags":["战略"],"title":"营销与竞选：奥巴马如何通过营销策略获得胜利？","url":"/post/2025/02/marketing_and_campaign_how_did_obama_win_through_marketing_tactics/"},{"content":"\n价格弹性是指在其他因素不变的情况下，商品或服务的价格变动百分之一所引起的需求量变动的百分比。它反映了需求量对价格变动的反应程度。\n消费者剩余是指消费者购买某种商品或服务时，愿意支付的最高价格与实际支付的市场价格之间的差额。简单来说，就是消费者在交易中 “赚到” 的部分。例如，消费者小张愿意为一本书支付最多 50 元，但实际上这本书的市场价格是 30 元，那么小张就获得了 20 元（50 - 30）的消费者剩余。\n价格歧视是指供给方在提供同等级、同质量商品或服务时，对不同消费者采用不同销售价格或定价策略，根据价格差异程度分为一级、二级和三级价格歧视。\n在日常生活中，我们常常会发现同一个产品针对不同消费者或不同情境有着多种定价，这背后涉及到价格歧视策略。那么，价格歧视背后的机制是什么呢？我们常见的价格歧视有哪些呢？\n一级价格歧视 即完全价格歧视，供给方针对每个消费者设定不同价格，实现对每个消费者消费剩余的全部占有。\n现实中，由于信息不完全，一级价格歧视难以完全实现，但在大数据时代，企业通过分析用户历史行为数据等，能够逼近这一理想状态，如滴滴打车和携程的“大数据杀熟”事件，企业根据用户画像，比如历史支付记录等，进行差异化定价，并通过发放红包和优惠券来降低用户敏感度。\n那么生活中最直观的一级价格歧视有哪些呢？\n按单次下载付费，百度网盘的会员价格对于不经常使用的人来说，价格昂贵，然而他们的边际成本几乎为零，近年，百度网盘通过“单次下载”付费的模式，实现一级价格歧视。同样的，房产中介在与客户的沟通中，获取客户的经济实力和意愿，对经济能力较强的收取更高的费用，对经济能力较差的收取更低的费用。\n一级价格歧视也并非是非之处，美国的大学学费就是如此，对于同一个学历和专业，每个人虽然缴纳同样的学费，但是每个人能享受的补贴福利是不一样的，以实现支付能力强的付费较多，能力弱的付费较少。\n二级价格歧视 又称数量歧视，供给方根据消费者购买量进行差别定价。\n常见形式有团购、满赠和满减等，消费者购买数量越多，单价越便宜，从而增加供给方利润比如积分卡或者会员卡。\n在二级价格歧视中有一个比较重要的点，即二步收费制：当消费者购买一件产品时，需要在购买这件产品前获得购买这件产品的“购买权”。比如迪士尼乐园，入园需要付一定的费用，在项目中还需要付费。另外还有，加入高尔夫球俱乐部需要付费，在使用的时候还需要付费。\n此外，还有逆向二级价格歧视，如阶梯电价和水价，购买量越多，价格越贵，但这种定价策略并非单纯为了获取更多利润，其背后有着资源合理利用、保障基本生活需求等多方面的考量，并非像一般二级价格歧视那样旨在增加供给方利润，且通常出现在供给方处于垄断地位的情况下。\n在生活中，常见的是套装售卖，比如一只笔卖一块，但是一盒装有十支笔套装卖九块，这就是二级价格歧视。电话卡的套餐也是如此，通过绑定不同的项目组合，可以更大幅度攫取消费者的剩余，其利润也会比单一利润更高，消费者在选择套餐的过程就是告诉企业支付意愿的过程。\n三级价格歧视 这是最常见的价格歧视，供给方根据消费者分类，针对不同类用户的需求价格弹性制定不同价格策略，需求价格弹性大的用户群定价较低，需求价格弹性小的用户群定价较高，从而在需求弹性小的用户群中获取更多消费者剩余价值。\n从消费者侧来看，同一个商品，对每一类消费者所支付的价格是不同的。但是实现三个价格歧视有两个条件：一是知道不同市场需求弹性的差异，二是能对市场进行有效区隔。\n这种定价方式涉及对消费者进行分类，常见方法包括优惠券发放和分享拉人降价等，以刺激消费者购买。\n最常见的是百度云盘，百度云盘对费非会员使用的是免费的策略，但是对会员收取比较高的价格。\n微软更是如此，针对不同市场，微软发布了家庭版、教育版、专业版等不同的版本，实施不同的收费策略。此外，微软在每个地区的低价也不同，比如美国和中国的定价，这样的定价可以避免产品跨国转售。针对每个用户特征的价格也不同，比如学生折扣，学生对价格比较敏感，更有可能复制软件，这样的策略还有一个好处，即锁定未来将以全价购买的用户。\n电影院通过不同时段，不同人群，设定不同的价格，实现三级价格歧视。飞机票也是，早定的价格更低，这是因为早定的人弹性比较大，可以选择的航司比较多，对价格比较敏感，而晚定的人对价格不敏感，弹性比较低。\n另外一个比较著名的例子是美国的优惠券案例。\n2004 年，美国制造业共发放 2750 亿张优惠券，面值超过 2800 亿美元，1906 亿美元用在日用百货销售中，另外 844 亿美元用在健康和美容产品销售中。然而，兑换的优惠券只有 33 亿美元，兑现率仅为 1.2%，一个有趣的营销问题是：为什么卖房不直接降价？兑现率如此低，直接降价可能是最好的促销方法。这两种方式最大的区别就是兑现优惠券需要花费时间和精力，在买方时间更为宝贵的时候，兑现的成本就越高。这实际上一个弹性问题。\n单个买者的需求价格弹性并不相同。在理想状态下，卖方应当通过定价从需求更富有弹性的买者身上获取较低的利润，而从需求弹性较低的买者身上获取较高的利润。如果时间更珍贵的买者需求弹性更低，卖方就可以通过优惠券的形式实现间接细分市场的差别定价。时间更珍贵的买者往往不会兑现优惠券，只有那些时间成本相对较低的人才会使用优惠券。通过优惠券，可以明确知道消费者是富有弹性的还是缺乏弹性的，反之，直接降价会导致收益变低。\n另外精装书和平装书也是三级价格歧视，精装书的价格会比瓶装书的价格更高，同时，精装书会比平装书早出一些时间。精装书的的目的人群是对价格不那么敏感的群体，而简装书则相反。\n如何实施三级价格歧视 知道不同市场需求弹性 实施价格歧视的前提是知道消费者的价格弹性，但在实践中生产者一般通过机制设计，让消费者显示自己的价格弹性。如何消费者不会显示怎么办？\n这里涉及到一个点：“价” 是什么？\n价，实际上是“代价”，包括了货币代价和非货币代价。为什么在一公里外的超市卖东西更便宜，而你还是会选择在超市楼下以更高的价格购买？因为在楼下卖东西的价格不一定比在超市购买的代价高。\n假设消费者的新价格弹性一样，同样的降价幅度，对哪类消费者的降价代价更大？\n生产者一般只能降低货币代价，而不能降低非货币代价，这个问题也就是同样的降价幅度，对哪类消费者的降低的总代价最大？答案是非货币代价较小的消费者。\n货币代价是指消费者为购买商品或服务所需要支付的货币金额。例如，购买一件商品花费 100 元，这 100 元就是货币代价。\n非货币代价包括时间成本、精力成本、心理成本等多种因素。比如，消费者为了购买一款限量版的产品，可能需要提前排队花费几个小时（时间成本），在购买过程中还要忍受拥挤的环境（精力成本），并且可能会因为担心买不到而产生焦虑情绪（心理成本）。\n以一个案例说明：\n对于非货币代价较小的消费者在购买商品时，非货币代价占总代价的比例相对较低。假设张三购买一件衣服，货币代价为 100 元，非货币代价（如时间、精力等）为 20 元，总代价为 120 元。当生产者降低货币代价，比如降价 20 元，新的货币代价为 80 元。此时，消费者 A 的总代价降低到 100 元（80 + 20）。\n对于非货币代价较大的消费者，比如李四购买同样的衣服，货币代价为 100 元，非货币代价为 80 元（因为其购买过程非常复杂，需要花费很多时间和精力），总代价为 180 元。同样降价 20 元，货币代价变为 80 元。消费者 B 的总代价降低到 160 元（80 + 80）。虽然货币代价同样降低了 20 元，但由于其非货币代价在总代价中占比较大，总代价的降低幅度相对较小。对于消费者 A 来说，总代价的降低幅度较大。\n进而可以得出一个结论：对非货币代价较高的消费者收取较高的费用，对非货币代价较低的消费者收取较低的费用。\n以电影票为例，为什么是对学生打折，而不是对成人打折？学生的非货币代价较低，因为他有充足的时间，而成人的时间没有那么灵活。所以对学生打折是理应的。\n超市中降价的产品目标客户是谁？退休人员，因为他们的时间成本比较低，\n对市场进行有效区隔 两个价格是不是区隔的并不是实施价格歧视的必要条件，因为厂商本身就能将一个市场区隔为两个相互之间不能套利的市场。\n为什么英伟达的消费级显卡要推出 “Ti” 版和普通版？在普通版通常是 “Ti” 版的阉割版本。显出的设计生产主要成本是在研发阶段，在生产阶段的边际成本并不高，另外我们知道定价与成本无关，而是取决于消费者的购买意愿和能力（需求曲线），又由于消费级显卡往往被绝大部分消费者所追捧，并且买新不买旧，具有很强的市场需求，按照企业利润最大化的单一原则，显卡的定价并不低。但因为 “Ti” 版显卡的价格较高，许多愿意出价高于 “Ti” 版显卡边际生产成本的消费者，因为定价高于其愿付价值而没有去购买 “Ti” 版显卡。如果英伟达公司能对两类消费者进行有效的区隔，就可以实行三级价格歧视。那么，英伟达如何实现市场区隔的？ 英伟达的区隔方式是通过品质，推出普通版和 “Ti” 版，对于需求价格弹性较低的消费者仍然会购买 “Ti” 版显卡，而需求价格弹性较高的消费者则会购买普通版，即：根据需求价格弹性进行不同定价的三级价格歧视。\n总结来说，英伟达的策略是：通过降低品质实现让高品质的显卡对一部分消费者对失去吸引力；其次是通过定价，使购买高品质显卡的消费者剩余至少和低品质的消费者一样多。\n关于前面提到的 “定价与成本无关” 可能会较难理解，以百度云盘的案例来说明。其下载速度有两种，一种是普通下载速度，比较慢，但它是免费的，还有一种是会员下载速度，特点是快，但是收费。如果是基于成本，哪一种理应定价高？免费版本，因为免费版本的速度是在普通速度上阉割的，意味着普通下载速度的研发成本是更高的。\n参考 经济学思维方式 - 俞炜华 ↗ 价格歧视 - 百度百科 ↗ ","date":"2025-02-18","tags":["价格歧视"],"title":"价格歧视：为什么一个产品要细分多个定价？","url":"/post/2025/02/price_discrimination_why_should_a_product_be_segmented_into_multiple_pricing/"},{"content":" 前几天和一个朋友聊天，谈到艺考机构对女同学的骚扰问题。感觉和薛兆丰老师谈到的政府公交系统补贴很相似，于是写了这篇文章。 但是这篇文章不够全面，仅从利益的角度考虑，而未考虑复杂的社会影响，比如当单方面使用权力 “独裁” 的时候，如何考虑优化问题、伪造情形下的利害关系以及腐败问题的解决方案等 注：这篇文章并不是控诉，而是从经济学角度，探讨组织行为优化的可能性问题。\n改变行为的底层逻辑是改变利益关系。\n一、背景 2022 年 9 月 19 日，北京电影学院学生施某实名举报艺考培训机构 “影路站台” 校长杜某某，在艺考培训过程中对学生实施性骚扰、性侵的行为。3天后，北京警方发布通报，涉嫌违法犯罪的杜某某已被依法刑事拘留。此类事件的曝光，揭示了艺术培训机构中骚扰问题的严重性。\n在艺考领域，女同学人数多于男同学这一现象，结合教师薪资与学生本人无关而与绩效指标、招生人数、名校升学人数等挂钩的情况，确实可能滋生犯罪的条件。中国人民公安大学治安系教授张弘老师提出的犯罪预防理论中的犯罪三角模式，客观的描述了犯罪的三要素：犯罪动机、犯罪机会、犯罪能力的关系。\n注：笔者没有充分的证据能证明骚扰情况是艺考机构的普遍现象，一部分原因是由于受害者不愿意揭露这个伤疤，致使实情难以获取。\n1. 犯罪动机 教师的薪资构成与学生的评价无关，而是与学生成绩、招生人数、名校升学人数等绩效指标挂钩，这样的模式会导致学生在教学过程中失去话语权。由于女同学在艺考领域人数较多，这种权责失衡的关系，让一些心术不正的教师利用自身的权力地位，产生满足个人私欲的动机，并以此满足自己扭曲的心理需求或巩固在学生群体中的权威地位。\n2. 犯罪机会 艺考培训机构或学校的管理也会存在不完善之处，例如对教师的教学行为、与学生的互动等缺乏（难以制定）严格的监督和约束机制。这使得一些教师有机会在培训过程中实施不当行为而不易被发现。比如，在一些小型的艺考培训机构中，可能存在教师单独辅导学生的情况，且没有安装监控设备或安排其他人员监督，这就为教师提供了实施犯罪行为的机会。\n同时，女同学在艺考领域人数较多，且在培训过程中往往处于相对弱势的地位，对教师的依赖性较强。她们可能因为担心影响自己的学业和考试成绩，而不敢轻易反抗或举报教师的不当行为，这在一定程度上为教师实施犯罪提供了机会。此外，艺考培训通常需要学生投入大量的时间和精力，与教师接触频繁，这也增加了教师实施犯罪行为的可能性。\n3. 犯罪能力 艺考教师通常具备专业的艺术知识和教学技能，这使得他们在与学生相处过程中，更容易获得学生的信任和依赖。他们可以利用自己的专业知识，以教学指导为幌子，实施一些不当行为。例如，在声乐教学中，教师可能会以纠正学生的发声姿势为由，进行不必要的身体接触，而学生可能由于对专业知识的不了解和对教师的盲目信任，而无法及时察觉和拒绝。此外，相对于学生，教师一般具有更丰富的社会经验和心理优势。他们更懂得如何利用各种手段来掩盖自己的犯罪行为，避免被发现。例如，一些教师可能会在实施犯罪行为后，利用自己的社会关系和经验，威胁或利诱学生保持沉默，或者销毁相关证据，从而降低自己被追究法律责任的风险。\n二、经济学角度的解决方案 无论左派经济学家，如詹姆士・托宾，还是右派经济学家，像弗里德曼，他们都拥有一个共同的共识，即如何有效帮助穷人。他们主张，援助穷人的最佳途径是直接以现金形式给予补贴，同时充分发挥市场自身的功能，而非直接干预商品价格，不去直接调控面包、住房以及交通工具的价格。\n倘若你给穷人一瓶牛奶，他只能获得这一瓶牛奶；若给予牛奶券，他便能从不同品牌的牛奶中挑选自己喜欢的；但若是直接给予现金，他不仅可以选择牛奶，还能选择鸡蛋、蔬菜、肉类，甚至可以选择不购买食品，转而改善居住环境或获取更好的教育条件。因此，经济学家始终坚信，直接给予穷人现金比提供食物更具帮助。\n那么，为何经济学家倡导通过这种方式来帮助穷人呢？\n1. 为什么直接给予穷人现金比提供食物更具帮助？ 原因众多。其一，若要给穷人发放现金，政府自身必须具备资金。然而，政府筹集资金并非易事，除了印钞和征税，别无他法，而这两者实施起来都面临诸多困难。相比之下，实施价格管制则显得 “简便易行”，政府无需出资，仅需下达一道命令，要求商品价格不得过高，便能看似达成帮扶穷人的目的，这种 “零成本” 的做法往往更受政府青睐。\n其二，政府存在 “父爱主义” 倾向。他们对穷人的自我管理能力缺乏信任，担心将现金直接给予穷人后，穷人会随意挥霍，甚至用于赌博等不良行为。因此，政府选择提供实物，他们自认为清楚穷人所需，如面包、牛奶、教育等，认为只要将这些实物发放给穷人，就能真正实现帮扶。\n还有一个更为微妙的原因，在实施实物补贴时，政府往往能够使与其关系密切的商人受益。例如，当政府决定向穷人发放牛奶时，牛奶的供应自然会倾向于与政府关系良好的供应商，这些供应商能够获得政府的大量订单。\n在以补贴穷人之名，实际上存在两种截然不同的补贴方式：一种是补贴商品的提供商，另一种则是以货币形式直接补贴受益人。\n2. 公交补贴：把钱交给公司还是交给市民？ 在公交补贴这一问题上，两种截然不同的补贴方式呈现出显著的效果差异。以某城市公交补贴为例，存在两种可行的补贴途径：其一，将补贴资金直接发放至每位市民手中；其二，将资金补贴给公交系统。\n在这两种迥异的补贴模式下，公交系统的行为逻辑有着天壤之别。当补贴资金直接源自政府时，公交系统的主要服务对象便锁定为政府，它只需集中精力进行公关，致力于让政府认可其工作成效，而对于乘客是否真正获得了应有的服务则缺乏关注。例如，在许多大城市中，随着城市的发展和人口流动，市民的居住区域发生了显著变化，按理说公交路线应随之调整，以更好地满足市民的出行需求。然而，实际情况却是，公交系统的路线多年未曾改变，无法及时响应市民的实际出行需要。\n反之，若政府将补贴公交系统的资金直接交给乘客，公交系统的目标受众将发生根本性转变，从讨好政府转变为取悦每一位乘客。在这种情况下，公交系统的行为方式必然发生巨大改变，其重新规划公交路线的积极性将大幅提升，因为只有满足乘客的出行需求，才能吸引更多的乘客，从而获得持续的补贴资金。\n而在实践中，政府往往将资金补贴给公交系统。\n二、校园食堂：补贴商家还是学生？ 在学校管理中，为了改善学生的就餐体验和保障学生的饮食健康，校方往往会对校园食堂进行补贴。然而，补贴的方式不同，带来的效果也会截然不同。\n假设一所学校要对食堂进行补贴，有两种做法，一是把补贴直接发放给食堂的经营商家，用于支撑商家的正常运转；二是把补贴以餐补的形式直接发放给学生，让学生在食堂就餐时可以享受到一定金额的减免。\n1. 发放给商家 就目前而言，几乎所有学校采用的方式都是补贴给食堂商家或者食堂供应链。\n在这种情形中，食堂商家可能会更关注如何从校方那里获取更多的补贴资金，用于扩大自己的经营规模或者提升利润空间。这时候经营的目的就变为了：讨好学校而不是学生。只要可以让学校相信他们的经营是正常的就可以了，而无需顾忌学生的反馈。公关面向了学校，二不是学生。进而致使在食材采购上选择更便宜的供应商，以降低成本来获取更高的利润，而不太在意食材的质量。在菜品设计上，也不太可能会充分考虑学生的口味和营养需求，因为无论菜品是否受学生欢迎，只要学校相信他们受欢迎，补贴资金都是相对稳定的。这就导致了学生可能吃不到满意的食物，就餐体验较差。以至于食品安全问题的发生也就不奇怪了。\n2. 发放给学生 在这种情形中，食堂商家为了吸引学生来就餐，获得更多的餐补收入，会更加注重提升菜品的质量和丰富度。他们会精心挑选新鲜优质的食材，根据学生的口味和营养需求设计多样化的菜单，努力提高服务水平，营造舒适的就餐环境。学生则可以根据自己的喜好和需求选择菜品，享受到更好的就餐体验。同时，由于学生对食堂的满意度提高，也会更愿意在食堂就餐，食堂的经营效益也会随之提升。\n补贴对象的不同会直接影响到食堂的运营方向和学生的就餐体验。将补贴直接交给受益人（学生），能够更有效地激发食堂商家提升服务质量的积极性，从而实现学校、学生和食堂商家的多方共赢。\n三、从春节红包看选择权与支配权 想象一下，你小时候收到长辈的压岁钱时，父母常说 “先帮你存起来”，实际上是将孩子对这笔货币的自主支配权转变为父母对这笔钱的实物支配权。因为此时资金流向取决于父母的决策偏好，比如父母可能会用这笔钱买文具和练习题等，父母是在行使对这笔钱的实物支配权。\n如果红包直接交给孩子，孩子拥有对这笔钱的支配权，他可以根据自己的意愿选择买书、买玩具等，这是孩子对这笔货币的自主支配权。\n父母的支配权可能导致孩子的需求被忽视，资金被用于父母认为“必要”的项目，而非孩子真正想要的东西。\n艺考机构的权力结构与此类似：当家长将高额学费交给机构时，学生作为服务接收方，却失去了对资金流向的监督权 —— 学生无法选择出优秀的教师，机构管理者与教师成为实际支配者。这种权力结构的失衡，类似于父母对压岁钱的支配，导致学生无法有效监督资金的使用。机构管理者可能将资金用于不符合学生利益的项目，甚至可能滋生权力滥用，如骚扰行为。\n四、艺考行业的“补贴错配”困境 当前艺考培训市场的利益链条存在三重扭曲，导致资源分配不公、学生权益受损，并进一步加剧了行业内的权力失衡问题。\n资金流向集中化 家长支付的学费直接流向机构账户，学生缺乏用脚投票的退出机制。即使遭遇骚扰，高昂的退费成本迫使许多学生选择隐忍。\n家长支付的高额学费直接流入机构账户，学生作为服务的直接受益者，却缺乏对资金使用的监督权和选择权。即使学生在学习过程中遭遇骚扰或不公正待遇，高昂的退费成本和沉没成本也迫使他们选择隐忍，而非主动退出。这种资金流向的集中化使得机构成为资金的绝对支配者，学生则沦为被动接受者，缺乏“用脚投票”的能力，进一步加剧了权力失衡。\n监督权与惩罚权分离 尽管《民法典》第1010条明确禁止性骚扰，但学生在实际维权过程中面临重重障碍。一方面，骚扰行为往往发生在封闭的教学环境中，举证困难；另一方面，机构利用信息不对称，淡化事件影响，甚至通过“名师资源”或“升学率”等噱头捆绑学生选择，变相压制学生的维权意愿。监督权与惩罚权的分离使得机构管理者能够规避责任，学生则因维权成本过高而选择沉默，导致骚扰行为难以得到有效遏制。\n竞争机制失效 当前艺考培训市场的竞争机制严重扭曲。头部机构通过打造“升学率神话”建立市场壁垒，吸引家长和学生趋之若鹜。然而，这种“结果导向”的竞争模式使得教学质量和师德监管沦为次要指标，机构更倾向于维护教师资源（尤其是所谓的“名师”）而非学生权益。竞争机制的失效导致行业整体质量下降，学生权益被忽视，甚至成为机构追求利润最大化的牺牲品。\n五、重构利益链：从“机构中心”到“学生中心” 弗里德曼创新性的教育券理论提出，政府发放教育券给家长，家长可以自由选择学校，当那些在市场中的优胜者由于更好的质量可以吸引到更多的学生，他们可以通过教育券向政府兑换教育经费。\n类似的，为了让市场发挥作用，可将艺考的学费从直接缴纳给机构转为发放 “培训券” 给学生。这时候老师要讨好的对象从机构变成了学生。在一定程度上可以倒逼教师教学能力和个人素质的的提升。在这种情况下，学生可以根据自己的需求和兴趣选择最适合的培训机构和课程，使得机构为了吸引更多学生，必须不断提高教师团队教学质量和服务水平，优秀的教育资源将得到更多的认可和支持，形成良性竞争环境。\n但是这样的理想终究是不现实的，例如机构作假，权力滥用等，无一不是需要解决的问题。比如，机构为了包庇名师，而伪造劣质教师为优异教师，以及教育券的发放和管理过程中可能出现腐败和权力寻租现象，学生和家长可能缺乏足够的信息来做出明智的选择，导致市场失灵。\n六、参考 薛兆丰的经济学课 ↗ 性骚扰、举报、刑拘，号称全国第一的艺考机构发生了什么？ ↗ 联合公告｜艺术行业性别歧视、性骚扰状况调查结果 ↗ 作弊、私改档案、北电硕士办艺考班骚扰未成年，艺考背后的阴影真不少 ↗ 21名艺考女孩实名血泪控诉：这桩“性侵案件”到底还有多少隐情？ ↗ 缴费容易退费难？小心这种“独家”培训 ↗ 试论犯罪三角模式中犯罪机会的控制 ↗ 艺考机构性骚扰学生犯法吗 ↗ 2025-2030年中国艺术培训教育行业深度调研及投资战略分析报告 ↗ 四川省高校后勤协会关于印发《四川省高校学生食堂饭菜价格平抑基金管理办法》的通知 ↗ 关于2024年1月-2024年3月 平抑资金分配情况的说明 ↗ 2024年度东北师范大学自营食堂档口招商公告 ↗ 江苏海洋大学2022部分学生食堂招标公告 ↗ 高校食堂“鼠头鸭脖事件”背后：10万能拿下一个档口？ ↗ ","date":"2025-02-16","tags":["补贴"],"title":"改变利益关系：如何解决艺考机构的骚扰问题？","url":"/post/2025/02/changing_interest_relationships_how_to_solve_the_harassment_problem_of_art_examination_agencies/"},{"content":"\n拼多多，这家在争议中野蛮生长的电商巨头，自诞生之日起便凭借低价策略和社交电商模式迅速崛起，成为中国电商行业的一匹黑马。然而，假货问题如影随形，始终困扰着其发展。尽管拼多多多次承诺加强监管、打击假货，但效果并不理想。\n这家曾被贴上“假货聚集地”“消费降级代表”标签的平台，一边承受着“砍一刀”的骂声，一边以火箭速度超越淘宝、京东，成为用户数第一的电商平台。拼多多的低价策略和社交电商模式，使其在下沉市场迅速崛起。2024年第三季度，拼多多总营收达到993.54亿元，同比增长44%。拼多多的净利润率高达24.24%，远超同期的好市多和阿里巴巴。这种高增长和高利润的背后，是拼多多对下沉市场的深度耕耘和对用户需求的精准把握，是一场关于中国商业底层逻辑的深刻博弈。本文将从拼多多的商业战略角度，深入分析其为何难以解决假货问题。\n一、用户画像 当一线城市白领在社交媒体痛批拼多多 “骚扰式营销” 时，平台上的 9 亿活跃用户正默默下单 —— 他们大多来自三四线城市、县城甚至乡村。QuestMobile 数据显示，拼多多 70% 用户分布在三线以下城市，超60%用户年龄在30岁以上。这些数据背后，是拼多多对下沉市场的精准定位和深度挖掘。拼多多的用户画像显示，其女性用户占比超过 70%，成为电商行业中的独特现象。\n这群被主流互联网长期忽视的 “下沉市场” 群体，构成了中国最庞大的消费基本盘。他们对价格极为敏感，更关注商品的性价比，不太关心品牌溢价。例如，他们更在乎 “5块钱的拖鞋是否包邮”，而不是品牌是否知名。他们不在意界面设计是否精美，但会为亲友发来的砍价链接熬夜助力。拼多多的争议本质，是城市中产与小镇居民消费观的激烈碰撞。\n拼多多的用户不仅数量庞大，而且忠诚度高。2023年，拼多多的年活跃买家数已达 9.1 亿，平均月活跃用户数达到 7.9 亿。这些用户大多来自三四线城市和乡村，他们通过拼多多平台购买各种商品，从日常用品到电子产品，从服装到食品。拼多多的社交电商模式，通过 “砍价” “拼单” 等功能，鼓励用户分享商品信息，实现裂变式增长。这种模式不仅降低了获客成本，还提高了用户粘性和活跃度。\n二、商业模式 C2M（用户直连工厂）模式 通过聚合海量小额订单，反向要求工厂以 “0库存风险” 生产极致低价商品。这种模式不仅降低了商品成本，还提高了生产效率。\n例如，拼多多平台上的“百亿补贴”频道，通过直接与工厂合作，提供大量低价商品，吸引了大量消费者。在袜子产业，拼多多的模式带来了显著的成本压缩效果。浙江诸暨的袜子工厂为了满足拼多多的低价需求，采取了一系列措施来降低成本。例如，八月酷暑时节，体感温度达到40度，诸暨的一家袜子工厂连空调都不敢开，以节省电费。袜子工厂的老板黄雄表示，开一个机器一天最多挣30块钱，最少挣15块钱，开30台机器也就不到500块钱，而开空调一天的电费就要300多，所以不敢开。袜子工厂的逻辑十分简单粗暴：将成本和利润压到最低，每个环节只挣1分钱，用几乎最低的价格将袜子供给客户。\n这种极端的成本控制措施，使得袜子的生产成本被压缩到极低的程度。2023年，拼多多的“百亿补贴”频道销售额达到了1000亿元，同比增长了50%。\n分布式农业革命 深入田间地头的“农地云拼”模式，让云南的紫皮大蒜48小时直达东北餐桌，价格比菜市场低30%。2022年，拼多多农产品GMV突破3000亿元，创造了独特的非标品供应链网络。2023年二季度为例，拼多多百亿补贴的涉农商家数量同比增长60％，农产品的销售额同比增长了80％。湖北洪湖的莲藕产业在拼多多的助力下，当地最大的莲藕类生产企业在拼多多的年销售额达到3000万元。\n这种模式不仅提高了农产品的流通效率，还降低了农产品的销售成本。例如，拼多多平台上的农产品销售额在2023年达到了4000亿元，同比增长了33%。这种“农村包围城市”的供应链改造，让拼多多在传统电商的成本结构中撕开缺口。\n三、商业战略 1. 低价 拼多多以低价商品吸引消费者，通过拼单模式进一步降低商品价格。这种低价策略在经济下行、消费萎缩的背景下，迎合了消费者对价格敏感的需求，使得拼多多在下沉市场迅速崛起。然而，低价策略也导致了一些不良商家为了追求高额利润，通过销售假货来降低成本，从而在拼多多平台上以低价吸引消费者。\n根据五粮液发布的《致五粮液消费者的告知书》，在对消费者在线上平台购买的148瓶五粮液产品进行鉴定时，发现其中有18瓶为假冒产品，占鉴定总数的12%。在这18瓶假冒产品中，有14瓶来源于某大型电商平台“百亿补贴”频道中的店铺，占假冒产品总数的77%。\n这种现象不仅损害了消费者权益，也影响了平台的声誉和形象。拼多多的低价策略虽然吸引了大量消费者，但也为假货提供了滋生的土壤。一些不良商家为了追求高额利润，通过销售假货来降低成本，从而在拼多多平台上以低价吸引消费者。这样的结果可能是之后将重点分析的 “柠檬市场” 的形成或者是“劣币驱逐良币”。\n除了此前提到的袜子市场，这种现象在卫生巾市场同样存在。一名女性消费者在青岛某商超内购买卫生用品。根据消费者调研数据显示，约60%的消费者在选择卫生巾时，价格是一个重要的考虑因素。记者分别从超市和网购平台购买了市场占有率较高的某知名品牌弹力贴身柔棉感30片日用卫生巾，在青岛某商超的售价为20多元，京东的价格为17.9元一包，淘宝的价格为19.9元一包，拼多多的价格为12.9元一包。从价格来比较，网购平台要比实体商超更有优势。\n即便是最便宜的渠道，一片知名品牌的卫生巾也就是0.43元，比普通不知名品牌卫生巾0.2元一片的价格贵了一倍还多。在市场竞争方面，卫生巾行业呈现出品牌众多、产品同质化严重的特征。根据市场调查数据显示，知名品牌如苏菲、高洁丝、护舒宝等通过大量广告和品牌建设，树立了较高的市场认可度，占据市场份额的60%—70%。而杂牌卫生巾则依靠低价策略，在占据剩余的市场份额。\n2.社交电商 拼多多借助社交平台的传播力量，通过“砍价”“拼单”等功能，鼓励用户分享商品信息，从而实现裂变式增长。这种社交电商模式虽然降低了获客成本，提高了用户粘性和活跃度，但也使得假货问题更容易被掩盖。消费者在购买商品时，往往更关注价格和社交分享，而忽视了商品的质量和真伪。\n由于损失厌恶心理，当用户为砍价投入一段时间后后，放弃意味着沉没成本归零，这种心理强迫使其不断拉新。加之对赌徒心理的把握，例如，转盘抽奖、现金红包等设计，用不确定奖励刺激多巴胺分泌。借助微信生态的裂变传播，让交易行为嵌入中国特有的“人情社会”网络。某个县城大妈发起的团购，可能瞬间激活整个亲友群的消费狂欢。\n3.开放平台 拼多多采用平台开放模式，允许大量商家入驻，提供丰富的商品种类。这种模式虽然丰富了商品供应，但也增加了平台对商品质量把控的难度。截至2024年，拼多多的商家数量已达到1420万家。拼多多不仅吸引了大量的中小商家，还为许多弱势群体提供了就业机会。例如，宝妈、夫妻店等活跃于拼多多的就业生态中。\n四、拼多多柠檬市场的形成 柠檬市场，也称次品市场或阿克洛夫模型，是指在信息不对称的情况下，产品的卖方对产品的质量拥有比买方更多的信息，导致低质量商品充斥市场，而高质量商品逐渐被挤出的市场现象。这个概念由美国经济学家乔治·阿克洛夫在1970年提出，并因此获得了2001年的诺贝尔经济学奖。\n1. 信息不对称 在拼多多平台上，卖方对产品的质量拥有比买方更多的信息，买方在交易之前无法准确了解产品的真实质量，只能通过市场上的平均价格来判断商品的平均质量，难以分辨商品的好坏。这种信息不对称导致了买方对产品的价值和质量存在不确定性，从而降低了市场的效率。例如，拼多多平台上的假货问题，使得消费者难以区分高质量和低质量产品，导致市场中低质量产品逐渐占据主导地位。根据2024年的数据，拼多多的投诉量高达42.83万宗，其中假货问题占比较大。\n2. 平均质量下降 由于买方无法区分高质量和低质量产品，卖方有动力在市场上提供低质量产品，而高质量产品的卖方可能因为无法获得更好的价格而退出市场。这种现象在拼多多平台上表现得尤为明显。例如，拼多多平台上的假货问题，使得消费者对平台的信任度下降，导致高质量产品的卖方逐渐退出市场，进一步加剧了假货问题。2024年，拼多多的人均订单数量仅从70涨到了80，而客单价甚至比两年前还下降了。\n4. 不完全交易 买方可能因为对产品质量的不确定性而对价格提出质疑或者在交易中遭遇风险，买家通常会压低价格以避免潜在的损失。导致交易难以达成或交易量下降。在拼多多平台上，消费者对假货的担忧使得他们在购买商品时更加谨慎，导致交易量下降。例如，拼多多平台上的假货问题，使得消费者在购买商品时更加谨慎，导致交易量下降。2024年，拼多多的 GMV 增速明显放缓，显示出市场交易活跃度的下降。\n5. 优质商品退出市场 由于买家只愿意支付平均价格，提供高质量商品的卖家会发现自己的商品无法获得应有的价值，从而逐渐退出市场。拼多多平台上，低价商品泛滥导致高质量商品的利润空间被压缩。一些商家为了降低成本，选择使用劣质材料或简陋工艺，这导致了一系列产品质量问题。此外，拼多多的低价策略也使得商家利润空间被大幅压缩，部分商家为了降低成本而牺牲产品质量。这些因素导致高质量商品的卖家逐渐退出市场。\n6. 市场质量下降 随着优质商品的退出，市场上的商品平均质量下降，进一步导致平均价格下降，最终市场上只剩下低质量商品。拼多多平台上的假货问题和产品质量参差不齐，直接影响了消费者的信任度。消费者在购买商品时更加谨慎，导致交易量下降。此外，拼多多的售后服务也被消费者频频诟病，退换货流程繁琐且标准不一，售后服务质量参差不齐。这些因素进一步加剧了市场质量的下降。\n五、假货问题的原因 1. 平台规模庞大，管理难度大 拼多多拥有庞大的用户群体和商家数量，这使得平台在管理上面临巨大的挑战。平台需要对海量的商品信息进行审核和监控，但人力和技术手段有限，难以做到全面覆盖。此外，拼多多的商家分布广泛，商品来源复杂，进一步增加了管理难度。例如，拼多多的月活跃用户数增长了30%，新增用户数超过1亿，这使得平台的管理难度进一步加大。\n2. 商业模式决定对假货容忍度高 拼多多的低价策略在迎合消费者对价格敏感需求的同时，也成为了假货滋生的温床。这一策略犹如潘多拉的魔盒，释放了消费者对低价的极致追求，却也引来了假货的幽灵。一些不良商家为了在价格战中占据优势，不惜以次充好，销售假货，以低价吸引消费者，追求高额利润，这种行为不仅损害了消费者权益，也影响了平台的声誉和形象。\n拼多多平台上的 “百亿补贴” 频道，本是吸引消费者的一大利器，却因假货问题而蒙上了阴影。据五粮液发布的《致五粮液消费者的告知书》显示，在对消费者在线上平台购买的 148 瓶五粮液产品进行鉴定时，发现其中有 18 瓶为假冒产品，占鉴定总数的 12%。在这 18 瓶假冒产品中，有 14 瓶来源于拼多多 “百亿补贴” 频道中的店铺，占假冒产品总数的 77%。\n拼多多的假货问题与其商业模式密切相关。拼多多的平台开放模式允许大量商家入驻，提供丰富的商品种类，但为了追求低价和高销量，在一定程度上放松了对商品质量的要求。一些商家为了降低成本，选择销售假货，而平台为了维护商家利益和用户活跃度，往往采取睁一只眼闭一只眼的态度。例如，拼多多的在线市场服务主要为商家广告收入，2023 年在线市场服务实现营收 1535.41 亿元，同比增长 49.5%，这表明拼多多对商家的依赖程度较高，对假货问题的容忍度也相对较高。\n这种模式虽然丰富了商品供应，但也增加了平台对商品质量把控的难度。截至 2024 年，拼多多的商家数量已达到 1420 万家。海量的商家和商品，使得平台难以对每个商家进行严格的资质审核和商品质量检测。一些不良商家利用平台的漏洞，销售假货牟利，而平台在发现假货问题后，往往采取下架商品、封禁店铺等措施，但这些措施并不能从根本上解决问题。\n3. 监管力度不足，处罚措施不严 拼多多对假货问题的监管力度不足，处罚措施不严。尽管拼多多声称对假货采取零容忍态度，但在实际操作中，平台对售假商家的处罚往往流于形式，难以起到震慑作用。一些商家在被处罚后，仍然继续销售假货，甚至通过更换店铺名称、重新注册等方式逃避监管。例如，拼多多的累计投诉量达42.83万宗，在全网位居榜首，但其回复量仅9.13万，完成量6.75万，约占投诉量的1/7，这表明拼多多对假货问题的处理效率较低。\n同时由于商家数量众多，拼多多难以对每个商家进行严格的资质审核和商品质量检测。一些不良商家利用平台的漏洞，销售假货牟利，而平台在发现假货问题后，往往采取下架商品、封禁店铺等措施，但这些措施并不能从根本上解决问题。例如，拼多多的运营主体上海寻梦信息技术有限公司共有27130份裁判文书，相关开庭公告37498份，法院立案信息23293起，合计约8.7万宗，创下中国互联网公司司法诉讼数量新记录。\n4. 用户对假货的容忍度较高 拼多多的社交电商模式，如同一层薄纱，既遮掩了商品的瑕疵，也模糊了消费者对质量的审视。消费者在购买商品时，往往更关注价格和社交分享，而忽视了商品的质量和真伪。这种模式下，商品的传播速度之快、范围之广，一旦假货问题被曝光，容易引发消费者的恐慌和不信任。\n拼多多的用户群体对价格敏感，对商品质量的要求相对较低，这使得用户对假货的容忍度较高。一些消费者在购买到假货后，往往选择忍气吞声，而不是积极维权。这种现象在一定程度上纵容了假货的存在，使得拼多多在解决假货问题上缺乏动力。例如，拼多多的用户反馈关键词中，好评主要集中在价格便宜和商品丰富等方面，而差评则集中在产品质量问题和虚假买卖等方面。\n六、不同平台比较 1. 淘宝的假货问题及解决方案 淘宝作为中国最大的C2C电商平台，商家众多，监管难度较大，假货问题也较为突出。淘宝通过建立信用评价体系、知识产权保护规则等措施来打击假货，但仍然难以完全杜绝假货问题。淘宝的假货问题主要集中在服装、名牌（含玉石、珠宝首饰）、美妆护肤等品类。例如，2024年，淘宝商城投诉量达108,922件，已回复16397件，已完成仅14959件。\n2. 京东的假货问题及解决方案 京东以自营模式为主，主打正品行货和高效物流服务，目标用户为追求品质和快速配送的中高端消费者。京东对商品质量有严格的把控，对商家进行严格的资质审核和商品抽检，确保商品的正品性和质量。尽管如此，京东第三方商家平台上也存在假货问题，消费者需要仔细辨别。例如，2024年，京东商城投诉量为116,025件，解决率高达84.17%。\n七、重塑下沉市场消费格局的颠覆者 拼多多的出现，恰似一颗石子投入平静湖面，泛起层层涟漪，影响力远超商业范畴，深刻重塑了中国下沉市场消费格局，为消费者带来前所未有的购物体验。\n需求分层并非消费降级。拼多多关注产品在低价下的极致功能表现，让消费者以最低价格享受最高性价比。它让偏远地区用户首次体验到电商服务，打破地域限制，是技术平权的体现，让被主流电商忽视的消费者也能享受便捷购物。\n克里斯坦森曾其著作《创新者的窘境》中提出 “破坏性创新总是从低端市场开始” 的观点。他认为破坏性创新通常从低端市场或新市场开始，通过提供更简单、更便宜、更便于使用的产品或服务，逐渐满足主流市场消费者的需求，最终颠覆现有市场格局。拼多多正是例证之一，其增长密码在于用技术手段实现商业民主化。当传统电商忙于消费升级时，拼多多俯身拥抱下沉市场，通过低价策略和社交电商模式，满足消费者需求，提升生活质量。\n拼多多通过 “拼工厂”“拼农货” 等模式，直接对接生产商，剔除多余中间商，缩短供应链，降低商品成本，提高流通效率，让消费者以更低价格购买心仪商品。同时，为同类目的最低价商品提供免费流量，筛选售价最低卖家，实现消费者利益最大化。零售业本质是连接生产与消费，拼多多提升消费体验，方便消费者找到所需商品，还通过缩短供应链，降低商品售价，提升零售效率。\n拼多多的团购模式使农产品规模化销售，降低单位成本，增加农民总收入。平台直接连接农产品生产者和消费者，减少中间环节，使农产品更快、更直接地到达消费者手中。“零佣金” 政策降低销售费用，提高农户收益。“百亿补贴”“多多果园”“限时秒杀” 等活动为农产品提供曝光机会和流量支持，促进销售，增加农户和商家收入。\n拼多多的崛起，为下沉市场消费者带来实惠、更多选择和更低价格，满足其需求，推动电商行业发展和创新。\n八、参考 3.15 消费者报告：拼多多 42 万投诉量居榜首，假货扫荡上百民族品牌 - 新浪看点 ↗ 拼多多：在争议中野蛮生长的商业密码 - 搜狐 ↗ 2024 年拼多多研究报告：国内基本盘稳固，海外业务打造公司第二增长曲线 - 长城证券 ↗ 假货屡禁不止的拼多多为什么大而不倒？- 腾讯网 ↗ 追赶拼多多的商人们：4块钱100包纸巾，10块钱10双的袜子，做吗？ - 36kr ↗ 如今你很难买到一双纯棉袜子，背后是拼多多的功劳 - 晰数塔互联网快讯 ↗ 拼多多的百亿研发，造福了谁？- 新浪财经 ↗ 任泽平：我被拼多多骗了！- 花椒财经 ↗ 出海再远，拼多多根都扎在中国农业与农村 ↗ 拼多多2023年年报数据解读-尖子生的“苦恼” - 网经社 ↗ “百亿补贴”售假？五粮液再打假：77%假酒出自“某电商平台”|双11观察 - 财联社 ↗ 记者探访低价爆款卫生巾源头，成本1毛一片钱被谁赚了？- 青岛财经网 ↗ 中国社科大报告：拼多多系统性激发电商就业生态二次繁荣，带动逾5500万人就业 - 电鳗快报 ↗ 淘宝系“霸榜”黑猫投诉黑榜！商家关店跑路，订单损失难追回 - 时间财经 ↗ 2024消费者怒火狂飙！投诉激增，涉诉金额超57亿！- 消费电子 ↗ 拼多多数据全面解析，揭开裂变“面纱” ↗ 柠檬市场 - 百度百科 ↗ 电子商务平台“拼多多”面临的诚信危机及其对策 ↗ 解码拼多多“新质供给”：产业带高质量转型的新电商实验 ↗ 拼多多暴跌背后的隐忧：低价策略与质量困境深度剖析 ↗ 克里斯坦森的破坏性创新理论：本源与发展 ↗ 克里斯坦森的颠覆性创新理论 - MBA智库 ↗ ","date":"2025-02-15","tags":["商业"],"title":"同一个世界：为什么拼多多的商业模式不能解决假货问题？","url":"/post/2025/02/becoming_a_bad_coin_why_didnt_pinduoduo_solve_the_problem_of_counterfeit_goods/"},{"content":" 这篇文章主要解释了上一篇文章提到的 “可口可乐的快乐绑定”\n为什么高级餐厅味道并不一定好？ 在美食的江湖中，高级餐厅往往被视为味蕾的圣地，然而，你是否有过这样的经历：怀着崇敬之心踏入一家价格不菲、装潢精美的高级餐厅，满心期待一场味觉盛宴，可当菜品端上桌，轻轻咬下一口后，却发现味道并不满意，甚至有些令人作呕？这究竟是味蕾的错觉，还是另有隐情？\n一、味觉的 “骗局” 2009 年美国 wine-economics 发布了一项名为《人们能区分肉酱和狗粮吗？》的研究。\n研究人员使用双盲测试，展示了五种未贴标签的混合肉制品给受试者，其中一种是准备好的狗粮。在根据口味对样品进行排名后，受试者被要求识别这五个样品中哪一个是狗粮。\n研究人员从该实验得出的结论是：尽管人类不喜欢吃狗粮，但他们也无法将狗粮的味道与其他供人类食用的肉类产品区分开来。\n这不禁让人对味觉的准确性产生了怀疑。我们的味觉并非如想象中那般敏锐，容易被一些表面的假象所迷惑。而这种味觉的局限性，在高级餐厅中，或许会被无限放大。\n或者，会说这是自己经验不足，那我们接下来看看美食家的表现如何？\n二、美食家也 “翻车” 波尔多大学的弗雷德里克・布罗切特曾进行过一项极具欺骗性的实验。他提供了两杯除颜色外完全相同的葡萄酒，一杯红色，一杯白色。结果，侍酒师们纷纷 “中招”，他们认为两杯酒的味道截然不同，白葡萄酒有蜂蜜和柑橘的清新，红葡萄酒则有覆盆子和桃花心木的醇厚。\n这一实验结果令人咋舌，即便是经过专业训练的美食家，也会在味觉上出现偏差。你也许会认为，色素可能会导致味道的改变，这是可能的。\n有两项研究，《投影增强现实系统，用于定制食物的外观和味道》和《移动的盛宴：颜色、形状和动画对味觉联想和味觉感知的影响》得出了同样的结论，正如《黑镜》所言：在虚拟世界中改变食物的颜色，那么现实世界中对食物味道的看法也会随之改变。\n日本兵库大学有一项名为《热汤的颜色调节年轻女性餐后饱腹感、热感觉和体温》研究了颜色对受试者购买汤羹的影响。结果现实，蓝色的汤羹降低了受试者的购买意愿，并且在口感、情绪方面都有消极的影响 ———— 受试者不满，只是因为它是蓝色的。\n这也许是进化或者生活经验的结果：蓝色的食物不安全，健康的食物一般不会是蓝色。\n这说明，味觉并非绝对的权威，它会受到各种因素的影响，包括视觉、心理预期等。\n三、高级餐厅的 “营销魔法” 那么，高级餐厅为何能让人对其味道产生过高的期望呢？这背后，是市场营销的巧妙运作。市场营销的基本策略之一，便是通过利用其他感觉来影响消费者的某种感觉。高级餐厅深谙此道，它们不仅提供美食，更注重营造整体的用餐氛围。从精致的餐具到优雅的音乐，从考究的装饰到周到的服务，每一个细节都在潜移默化中影响着消费者的心理。\n例如，某些价格高昂的主题餐厅，其内部设计独具匠心。餐厅的装饰、灯光、音乐等元素相互配合，营造出一种高雅、舒适的用餐环境。在这样的环境中用餐，消费者的心理预期自然会提高，对食物的味道也会产生更积极的评价。\n从更深的层次来说，市场营销改变了消费者对正在消费的东西的想法。只要消费者在心理上认同了餐厅的高端定位，那么即使食物的味道并非尽善尽美，也可能会被消费者所接受，甚至被美化。换句话说，感知总是和现实有一步之遥，因为我们感知到的是自己内心对世界的看法，而非世界本身。\n四、预期管理 既然高级餐厅如此注重营销，那么它们的味道为何会不尽如人意呢？一方面，一些高级餐厅过于追求形式上的创新和独特，却忽视了食物最本质的味道。例如，某些餐厅为了追求视觉效果，会在菜品上添加过多的装饰或采用过于复杂的烹饪技法，反而掩盖了食材本身的味道。另一方面，高级餐厅的成本较高，为了维持盈利，可能会在食材的选择和烹饪过程中有所妥协，导致味道下降。\n此外，消费者的心理预期过高也是一个重要原因。在高级餐厅用餐，消费者往往会对食物的味道抱有过高的期望。当实际味道未能达到这种期望时，消费者就会感到失望，甚至觉得味道不佳。\n五、营销策略 在竞争激烈的餐饮市场中，高级餐厅要想脱颖而出，必须综合运用创新、宣传和情景塑造等营销策略，以吸引消费者、提升品牌形象和增加市场份额。以下将结合实际案例，详细阐述这些策略的应用。\n1. 创新：开发独具特色的菜品 菜品创新是高级餐厅吸引消费者的关键。通过开发独具特色的菜品，不仅可以满足消费者对美食的追求，还能使餐厅在众多竞争对手中脱颖而出。例如，龙吟餐厅的 “龙吟草莓” 便是创新菜品的典范。这款售价高达 800 元人民币的草莓，通过多道工序将其变成一种复杂而奢华的体验，包括将草莓浸泡在香槟中，再裹上一层薄薄的白巧克力，最后撒上金箔。这种创新的烹饪方式和独特的口感，让消费者难以忘怀。\n此外，餐厅还可以结合当地特色食材，形成独特的菜品风格。郭红晓团队便是这方面的代表，他们将传统菜肴做得更加时尚、网红、爆款，同时结合当地特色食材，如将台山优质食材与分子料理技术相结合，创造出独具特色的菜品。这种创新的菜品不仅满足了消费者对美食的追求，还使餐厅在当地市场中占据了重要地位。\n2. 宣传：通过传播策略改变消费者认知 宣传是高级餐厅提升品牌知名度和吸引消费者的重要手段。通过有效的传播策略，可以改变消费者对餐厅的认知，使其对餐厅产生好感和信任。例如，可口可乐的 “快乐绑定” 方式便是一种成功的宣传策略。可口可乐通过将品牌与快乐、团聚等积极情感绑定在一起，使消费者在饮用可口可乐时，不仅享受到了饮料的美味，还感受到了快乐和团聚的氛围。这种宣传策略使可口可乐在全球范围内获得了极高的品牌知名度和市场份额。\n高级餐厅可以借鉴这种宣传策略，通过广告宣传、社交媒体推广等方式，将餐厅与积极的情感和体验绑定在一起。例如，味千拉面与星厨携手合作，推出全新联名新品拉面，并在中国市场进行了首发。通过广告宣传和社交媒体推广，味千拉面成功吸引了市场的广泛关注，使消费者对新品拉面产生了浓厚的兴趣和期待。\n3. 情景：通过情景塑造改变消费者认知 情景塑造是高级餐厅提升消费者用餐体验和改变消费者认知的重要手段。通过营造独特的用餐环境和氛围，可以使消费者在用餐过程中感受到不同的体验，从而改变其对餐厅的认知。例如，上海的 “南麓・荟馆” 主题餐厅便是一个成功的情景塑造案例。该餐厅将杭州的山水韵味与现代简约风格完美融合，通过精致的餐具、优雅的音乐、考究的装饰等元素，营造出一种高雅、舒适的用餐环境。在这样的环境中用餐，消费者的心理预期自然会提高，对食物的味道也会产生更积极的评价。\n此外，餐厅还可以通过举办各类美食活动，如美食节、品鉴会等，进一步提升消费者用餐体验。例如，味千拉面与星厨合作推出的新品拉面，通过举办品鉴会等活动，让消费者了解产品特色和优势，从而改变其对拉面的认知。\n4. 综合营销策略 除了上述创新、宣传和情景塑造策略外，高级餐厅还可以综合运用其他营销策略，以提升餐厅的市场竞争力和消费者的满意度。例如，餐厅可以制定有竞争力的价格策略，推出套餐、优惠券等活动，吸引消费者和中小型餐饮店。同时，餐厅还可以拓展线上线下渠道，通过电商平台、社交媒体等渠道进行销售和宣传。此外，餐厅还可以提供个性化服务，满足不同消费者的需求，建立会员制度，为会员提供优惠、特权等服务，增加顾客粘性。\n高级餐厅要想在竞争激烈的市场中脱颖而出，必须综合运用创新、宣传和情景塑造等营销策略。通过开发独具特色的菜品、通过传播策略改变消费者认知、通过情景塑造提升消费者用餐体验，以及综合运用其他营销策略，高级餐厅可以提升品牌形象、吸引消费者、增加市场份额，从而在激烈的市场竞争中立于不败之地。\n参考 《color of hot soup modulates postprandial satiety, thermal sensation, and body temperature in young womenProjective-AR system for customizing the appearance and taste of food》 《A Moving Feast: Effects of color, shape and animation on taste associations and taste perceptions》 《color of hot soup modulates postprandial satiety, thermal sensation, and body temperature in young women》\n","date":"2025-02-15","tags":["味觉"],"title":"为什么高级餐厅味道并不一定好？","url":"/post/2025/02/why_high-end_restaurants_dont_always_taste_good/"},{"content":"为什么可口可乐要创造快乐联想？ 在当今竞争激烈的市场环境中，品牌已不仅仅是产品的代名词，更是一系列联想的集合体。可口可乐作为全球饮料行业的领军品牌，其成功的关键在于深刻理解了品牌联想的力量，并将其与快乐紧密绑定。本文将探讨可口可乐为何要创造快乐联想，以及这一策略如何为其带来巨大的商业成功。\n品牌的本质：联想的集合 神经学家认为，品牌是一连串的联想。消费者在购买产品时，不仅仅是在购买其功能，更是在购买与品牌相关的情感和体验。可口可乐深知这一点，因此每年在广告营销和品牌推广上投入数十亿美元，旨在打造强大的品牌联想。根据 Interbrand 的品牌价值排行榜，可口可乐位列第五，仅次于苹果、谷歌、亚马逊和微软，这充分证明了其品牌战略的成功。\n快乐联想的商业价值 可口可乐选择将自己与快乐绑定，是因为快乐是人类最普遍、最强烈的情感需求之一。通过将产品与快乐联想在一起，可口可乐成功地激发了消费者的购买欲望。这种策略不仅提升了品牌的知名度，还增强了消费者对品牌的忠诚度。正如可口可乐的广告语 “畅爽开怀” 所传达的那样，消费者在饮用可口可乐时，不仅享受到了饮料的美味，更感受到了快乐的情感体验。\n心智模型的塑造 可口可乐通过广告和营销活动，巧妙地塑造了消费者的心智模型。可口可乐每年在联想设计上花费40亿美元，所有活动只为一个目的，向大脑灌输可乐=快乐，这样当你下一次想喝点什么时，你自然会选择可口可乐。当消费者想到可口可乐时，他们的大脑会自动联想到快乐、幸福和美好的时光。这种无缝的体验使得可口可乐在消费者心中占据了独特的位置。研究表明，消费者在饮用可口可乐时，大脑的颞叶区域会变得更加活跃，尤其是与语义和情绪相关的部分。这表明，可口可乐的快乐联想已经深深地烙印在消费者的大脑中。\n百事大挑战的启示 百事可乐在 1975 年推出的 “百事大挑战” 营销活动，进一步证明了品牌联想的重要性。在实验中，当消费者不知道品牌时，53% 的人更喜欢百事可乐的口味，而只有 47% 的人选择可口可乐。然而，当品牌被揭示后，80% 的消费者更倾向于选择可口可乐。这一结果表明，品牌联想对消费者的口味偏好有着显著的影响。可口可乐的铁杆粉丝在实验中也表现出对品牌的强烈忠诚，即使在盲测中，他们仍然坚信可口可乐更好喝。这种品牌忠诚度的形成，正是可口可乐长期塑造快乐联想的结果。\n结论 可口可乐通过创造快乐联想，成功地将自己与消费者的情感需求紧密相连。这种策略不仅提升了品牌的市场竞争力，还为消费者带来了更加丰富和快乐的体验。在当今竞争激烈的市场环境中，企业要想取得成功，必须深入了解消费者需求，不断创新营销策略，提升品牌价值和影响力。可口可乐的成功经验，无疑为其他企业提供了宝贵的参考和启示。通过将品牌与快乐等积极情感绑定，企业可以更好地满足消费者的需求，实现品牌的持续发展和市场领先地位。\n","date":"2025-02-15","tags":["上瘾"],"title":"为什么可口可乐要创造快乐联想？","url":"/post/2025/02/why_does_coca-cola_create_happy_associations/"},{"content":"一、1985 年新配方风波：情感共鸣的深刻洞察 1985 年，可口可乐公司经历了一次品牌历史上的至暗时刻，却也为我们呈现了一个关于消费者情感共鸣的深刻案例。面对百事可乐销量的快速增长，可口可乐的首位外籍 CEO 郭思达决定改变可口可乐原有配方，以面向更多用户群体。经过大规模的口味盲测，新配方以 61% 比 39% 的优势胜出，公司投入巨资进行研发和推广。然而，这一改变却引发了消费者的强烈不满，从抗议电话到示威游行，消费者们用行动表达了对新可乐的愤怒。百事可乐更是趁机火上浇油，将新可乐发布会当天定为 “百事可乐日”。最终，可口可乐不得不将配方改回来以平民愤。\n这一事件看似是一次营销失误，实则深刻揭示了消费者对可口可乐品牌的情感依赖。可口可乐已不仅仅是一种饮料，更是一种情感符号，承载着消费者对过去的回忆、对品牌的忠诚以及对美国文化的认同。正如一位消费者所说：“可口可乐的味道就是童年的味道，改变配方就是改变了我的童年记忆。” 这种情感共鸣的力量，让可口可乐公司意识到，消费者购买的不仅仅是产品本身，更是一种情感体验。在后续的营销中，可口可乐更加注重情感营销，通过唤起消费者的情感共鸣，巩固了品牌的市场地位。\n二、“冷启动” 阶段：把握机遇，奠定基础 在可口可乐的早期发展阶段，美国的禁酒令为其带来了绝佳的机遇。可口可乐以酒精替代品的身份出道，凭借产品本身的上瘾性，通过大规模营销迅速获得了亚特兰大乃至美国大部分地区的欢迎。当时的可口可乐，就像一位初出茅庐的勇士，在市场的舞台上挥舞着自己的利剑，斩荆披棘，一路向前。它通过在药店、冷饮店等终端销售渠道的合作，让消费者可以便捷地获得可口可乐；通过免费赠饮的方式，降低消费门槛，靠产品本身的上瘾性形成重复购买。这一时期的可口可乐，就像一颗刚刚种下的幼苗，在禁酒令的 “土壤” 中迅速生根发芽，为后续的成长奠定了坚实的基础。\n可口可乐的早期营销策略，充分体现了对市场机遇的敏锐把握和对消费者需求的深刻理解。在禁酒令的背景下，消费者对于酒精替代品的需求旺盛，可口可乐正好满足了这一需求。同时，通过免费赠饮和大规模广告投放，可口可乐迅速提升了品牌知名度和市场占有率。这种 “冷启动” 的方式，为可口可乐在碳酸饮料领域的领先地位奠定了基础，也为我们展示了在市场初期如何通过把握机遇和精准营销来实现品牌的快速崛起。\n三、瓶装模式的创新：标准化与全球扩张的基石 随着可口可乐销量的提高，不同城市的环境和商家的操作手法差异导致口感不一，影响了消费者的体验。为了解决这一问题，可口可乐引入了瓶装授权体系，将非标准化的杯装变成标准化瓶装。这一创新举措，犹如给可口可乐插上了全球扩张的翅膀，使其能够在全球范围内快速复制和推广。瓶装模式不仅保证了产品的口感一致性，还降低了运输成本，提高了生产效率。可口可乐的弧形瓶设计，更是成为了品牌的一部分，让消费者在众多饮料中一眼就能认出可口可乐。\n瓶装模式的创新，是可口可乐发展历程中的一个重要里程碑。它不仅解决了产品口感不一的问题，还为可口可乐的全球扩张提供了有力支持。通过瓶装授权体系，可口可乐能够与当地厂商合作，带动当地经济发展，获得政府和民众的支持。同时，标准化的瓶装产品也更容易进行大规模生产和销售，提高了可口可乐的市场竞争力。这一创新举措，让我们看到了企业在发展过程中如何通过技术创新和商业模式创新来实现品牌的持续发展和全球扩张。\n四、营销事件 1931 年圣诞老人形象的诞生：可口可乐与圣诞老人的渊源 1931年，可口可乐公司为了在冬季提升销量，聘请了著名插画师海顿·珊布（Haddon Sundblom）重新定义圣诞老人形象。珊布参考了1865年“哈珀斯”杂志中的圣诞老人画像以及克莱蒙特·摩尔的诗歌“圣诞节前夜”，描绘出了一个白胡子、胖肚子、慈祥的老人形象。最重要的是，珊布为圣诞老人设计了红色的外衣，首次将圣诞老人从传统的绿衣长袍形象中解放出来，赋予了他更加符合可口可乐品牌色调的红色服装。\n这一形象在可口可乐公司的广告中出现后，迅速深入人心。当时可口可乐公司希望在冬天增加可口可乐的销售，便将圣诞节结合广告，塑造一个有可口可乐红白标志，并且肥胖、有白色大胡子、看起来相当开心的老人当作产品的代言人。这样的广告成功地将圣诞老人的形象深植全世界人的心中。\n此后，圣诞老人和可口可乐的广告成为圣诞季的标志之一，每年通过不同的广告形式深入人心，推动销量在圣诞季节大幅增长。这一形象不仅改变了人们对圣诞老人的认知，也让可口可乐品牌成为了永不过时的节日符号。\n1993 年 “Always Coca-Cola” 活动：北极熊与可口可乐的温馨故事 1993 年，可口可乐公司推出了一项名为 “Always Coca-Cola” 的营销活动，其中最引人注目的是 “Northern Lights” 广告。这支广告将北极熊与可口可乐的品牌形象巧妙地结合在一起，通过温馨感人的故事，传递出可口可乐与快乐、温暖和家庭团聚的紧密联系。广告中，一只北极熊在寒冷的北极夜晚，为了给家人带来温暖和快乐，不惜跋涉千里，只为那一瓶可口可乐。当北极熊一家围坐在一起，分享着可口可乐时，那种温馨和幸福的氛围，让无数消费者为之动容。\n这一活动不仅成功地将北极熊这一可爱形象与可口可乐品牌紧密相连，还进一步强化了可口可乐在消费者心中的情感地位。通过这种温馨感人的故事营销，可口可乐成功地触动了消费者的心弦，让他们在享受可口可乐的同时，也感受到了品牌所传递的温暖和快乐。这种情感营销策略，不仅提升了消费者对品牌的认同感和忠诚度，还进一步巩固了可口可乐在全球饮料市场的领先地位。\n2010 年 “The Happiness Machine” 活动：互动体验的快乐传播 2010 年，可口可乐在新加坡推出了一项名为 “The Happiness Machine” 的营销活动，通过一台充满创意的自动售货机，为消费者带来了意想不到的快乐体验。这台售货机不仅能够出售可口可乐，还能通过各种互动方式，如拥抱、跳舞、唱歌等，为消费者带来免费的可乐和其他惊喜礼物。活动期间，售货机前排起了长队，消费者们纷纷参与其中，享受着这份意外的快乐。这一活动不仅在新加坡引起了轰动，还通过社交媒体的传播，迅速在全球范围内引发了关注。\n“The Happiness Machine” 活动的成功，源于其对消费者互动体验的深刻理解和创新应用。通过这种独特的互动方式，可口可乐成功地将品牌与快乐、惊喜和互动体验紧密相连，让消费者在享受可口可乐的同时，也感受到了品牌所带来的快乐氛围。这种互动体验营销策略，不仅提升了消费者对品牌的参与度和忠诚度，还进一步扩大了品牌的影响力和市场份额。\n2014 年 “Share A Coke” 活动：个性化营销的典范 2014 年 6 月，可口可乐在美国发起了 “Share A Coke” 活动，使用 250 个最常见的美国千禧一代名字向个人消费者推销其产品。这一活动就像一把神奇的钥匙，打开了消费者的心扉，让他们与可口可乐之间建立了一种更加亲密的联系。消费者们纷纷在社交媒体上分享自己与 “专属” 可口可乐的合影，活动在短时间内获得了巨大的吸引力。据《华尔街日报》报道，在 2014 年 6 月至 7 月期间，超过 125,000 条社交媒体帖子提到了 “分享一杯可乐” 活动，而当时有关可口可乐的 12% 的在线对话可归因于该活动。\n“Share A Coke” 活动的成功，源于其对消费者个性化需求的精准把握。在当今社会，消费者越来越注重个性化和定制化的产品与服务，可口可乐通过在瓶身上印上消费者的名字，满足了他们的这一需求。这种个性化营销方式，不仅提高了消费者的参与度和品牌忠诚度，还通过社交媒体的传播效应，扩大了品牌的影响力。这一活动让我们看到了在数字化时代，企业如何利用个性化营销和社交媒体的力量来与消费者建立更紧密的联系，实现品牌的年轻化和持续发展。\n在活动期间，可口可乐通过市场调研和数据分析，精心挑选了各个国家和地区最常见的名字，确保瓶身上的名字能够覆盖广泛的消费者群体。这种个性化的包装设计，让消费者在购买和饮用可口可乐时，感受到一种独特的归属感和认同感。正如一位消费者在社交媒体上分享的那样：“当我看到瓶身上印着我的名字时，感觉这瓶可乐就是专门为我准备的，这种感觉真是太棒了！”\n此外，可口可乐还巧妙地利用了社交媒体平台，鼓励消费者分享自己与“专属”可口可乐的合影。这种用户生成内容（UGC）不仅丰富了品牌的社交媒体页面，还通过消费者的社交网络进行了二次传播，进一步扩大了活动的影响力。据数据显示，在“Share A Coke”活动期间，可口可乐的社交媒体粉丝数量显著增加，相关话题的讨论量也达到了历史新高。\n这一活动的成功，不仅在于其创意和执行，更在于其对消费者心理的深刻理解和对市场趋势的敏锐把握。在数字化时代，消费者不再满足于千篇一律的产品和服务，他们渴望个性化和定制化的体验。可口可乐通过“Share A Coke”活动，成功地满足了消费者的这一需求，不仅提升了品牌的市场竞争力，还为其他企业提供了宝贵的营销借鉴。\n2014 年世界杯营销活动：全球体育盛事的营销盛宴 作为 2014 年巴西国际足联世界杯的官方赞助商，可口可乐再次向世界展示了其卓越的营销实力。这次活动不仅是一场足球盛宴，更是一次品牌传播的狂欢。可口可乐通过一系列创意广告和互动活动，将品牌与足球的激情和快乐紧密相连。例如，他们推出了 “The World’s Cup” 广告，展示了来自不同国家和文化的人们通过足球团结在一起的温馨场景，传递出 “足球无国界，快乐共分享” 的品牌理念。同时，可口可乐还在全球范围内开展了 “Share the Joy” 活动，鼓励消费者通过社交媒体分享自己的世界杯观看体验和可口可乐相伴的快乐时刻。\n这一系列营销活动，不仅提升了可口可乐的品牌知名度和美誉度，还进一步巩固了其在全球消费者心中的地位。通过与世界杯这样的全球顶级体育盛事合作，可口可乐成功地将品牌与足球的激情、快乐和团结精神相结合，让消费者在享受足球盛宴的同时，也感受到了可口可乐带来的快乐体验。这种借助全球体育盛事进行品牌营销的方式，不仅扩大了品牌的影响力，还增强了消费者对品牌的认同感和忠诚度。\n2015 年 “Hello Happiness” 公益活动：社会责任与品牌情感的融合 2015 年，可口可乐在迪拜发起了一项名为 “Hello Happiness” 的公益活动，旨在帮助东南亚劳工与家人联系。这些劳工每天的工资只有 6 美元，而给家里打个电话就要 0.91 美元，因此很多人为了省钱，强忍着思念情绪不和家人联系。可口可乐通过搭建电话亭，并让可口可乐的瓶盖化身货币，用户只需要拿着可口可乐瓶盖来到特殊的电话亭，就可以和家人远程相聚。这一活动不仅体现了可口可乐的社会责任感，还进一步增强了消费者对品牌的信任和忠诚度。\n2016 年 “快乐重生” 活动：可持续发展的创意传播 2016 年，可口可乐推出了 “快乐重生” 活动，通过创意瓶盖将饮用完的塑料瓶变身为实用物品，鼓励消费者对饮料瓶的再循环利用。这一活动不仅传递了环保理念，还延续了品牌的快乐精神。可口可乐的这一创意举措，不仅有助于减少塑料瓶的浪费，还通过有趣的方式吸引了消费者的参与，进一步提升了品牌的形象和影响力。\n2017 年 “我们在乎” 可持续发展报告发布会：公益营销的创新实践 2017 年，可口可乐中国举办了 “可口可乐中国 2014 - 2016 可持续发展报告发布会”，旨在让公众、媒体和员工了解可口可乐在可持续发展方面的努力和成就。活动通过视频化、图片化的立体式报道，以及现场参与、直播互动等形式，让内部员工、媒体和大众共同参与。此外，活动还邀请了创作型歌手王啸坤献唱为本次发布会创作的歌曲《我们在乎》，进一步提升了活动的影响力和参与度。\n2019 年包装焕新：可持续发展的设计创新 2019 年，可口可乐公司在中国市场陆续推出了全新包装的可口可乐产品，这是自 2016 年发布 “同一品牌” 全球营销策略以来，又一次全球规模的包装升级。新包装在设计上进行了大胆简化，删除了部分视觉元素，同时将可口可乐标志上移，瓶身局部留白。此外，新包装还首次融入了 “回收我” 可持续包装标志，鼓励消费者在饮用后将饮料瓶进行回收，共同参与到可口可乐公司 “天下无废” 全球可持续包装愿景行动中来。\n2023 年“世界需要更多的圣诞老人”活动：传递善意与温暖 2023年，可口可乐推出了以“世界需要更多的圣诞老人”为主题的圣诞广告活动。该活动由可口可乐公司与WPP旗下的OpenX合作推出，将在全球80多个市场传播。广告召集了一支圣诞老人大军，传递慷慨和善意的信息，并将其延伸到互动数字元素中，包括在线测验和人工智能节日明信片。\n广告名为“世界需要更多的圣诞老人”，展示了整座城市中的所有圣诞老人所做的善举，从在洗衣店找回丢失的红袜子，到在健身房帮助正在做卧推的圣诞老人，最后发现，原来人人皆可成为圣诞老人，每一个普通人都可以心怀热忱，传递善意。通过这支广告，可口可乐希望延续品牌的一致性，同时也保持新鲜感，让消费者感受到圣诞老人形象的与时俱进。\n此外，该品牌还要求消费者通过可口可乐手机应用程序和手机浏览器上的“寻找你心中的圣诞老人”问答活动参与进来。这个由五个问题组成的小测验将决定一个人属于哪个圣诞老人“部落”。例如，快乐的圣诞老人、慷慨的圣诞老人或富有同情心的圣诞老人。测试结果可以发布到社交媒体上。包装和数字户外广告上的可扫描代码也将解锁“找到你内心的圣诞老人”测验。扫描包装还有机会赢得奖品，包括前往芬兰罗瓦涅米与圣诞老人在他的家乡见面。\n2024 年 “New Guy” 活动：多产品营销的新尝试 2024 年，可口可乐推出了 “New Guy” 活动，这是品牌首次在一则广告中同时推广可口可乐、雪碧和美汁源三种产品。广告通过讲述一个关于友谊和成长的故事，将三种产品的特点巧妙地融入其中，展现了可口可乐在产品创新和多样化方面的努力。这一活动不仅提升了品牌的市场竞争力，还为消费者带来了更加丰富和快乐的体验。\n2024 年巴黎奥运会营销活动：体育营销的新高度 2024 年巴黎奥运会期间，可口可乐与国际奥委会合作推出了主题曲《Hello World》，在全球范围内引起了广泛关注。针对中国市场，可口可乐特别推出了 “拥抱此刻，让我们赢在一起” 活动，进一步加深了品牌与消费者之间的情感联系。通过这些活动，可口可乐成功地将品牌与体育精神相结合，提升了品牌的知名度和影响力。\n2024 年“每个人都可以是圣诞老人”活动：延续温暖与分享 2024年，可口可乐继续延续圣诞老人的主题，推出了“每个人都可以是圣诞老人”的圣诞广告。短片打破了传统的只有一位圣诞老人的概念，极具创意地让所有人都化为圣诞老人，通过一系列派送圣诞礼物、共进晚餐、分享饮料机最后一瓶可口可乐等等画面，营造出温馨浪漫的圣诞氛围。\n最后，短片通过恰到好处的转场，将画面从充满奇幻色彩的世界过渡到真实世界中，并定格在渐行渐远的可口可乐卡车镜头。通过这支短片，可口可乐成功地将其品牌与温暖、分享、欢乐的圣诞精神紧密相连，使消费者看到广告时，不仅感受到浓浓的节日氛围，更能在情感上与品牌产生深刻共鸣，进而让消费者潜意识里将可口可乐视为传递爱与快乐的象征，激发购买欲望，达到极佳的营销效果。\n五、可口可乐营销成功的持续创新 可口可乐始终坚持以消费者为中心，不断创新和优化营销策略。通过情感营销、个性化营销、社会责任、可持续发展和体育营销等多种方式，可口可乐成功地与消费者建立了更紧密的联系，实现了品牌的持续发展和市场领先地位。\n可口可乐的营销案例，不仅展示了其在不同领域的创新能力和市场洞察力，还为我们提供了宝贵的营销借鉴。在当今竞争激烈的市场环境中，企业要想取得成功，必须深入了解消费者需求，不断创新营销策略，提升品牌价值和影响力。可口可乐的成功经验，无疑为其他企业提供了宝贵的参考和启示。\n","date":"2025-02-15","tags":["经典案例"],"title":"可口可乐：百年营销传奇与创收型营销新篇","url":"/post/2025/02/coca-cola_a_century-old_marketing_legend_and_a_new_chapter_in_revenue-generating_marketing/"},{"content":" 当商旅人士拖着行李箱穿过陌生的城市街道，总有一盏黄色笑脸灯牌在暮色中温暖等待——如家酒店如何用二十年时间，让这个充满人文关怀的符号成为中国经济型酒店的代名词？\n一、在红海中发现\u0026quot;蓝海绿洲\u0026quot; 2002 年的中国酒店市场，高端酒店如金字塔尖的明珠，招待所则似散落戈壁的砾石。如家创始人季琦敏锐捕捉到中端市场的真空地带，将定位精准锚定 \u0026ldquo;商务客的第二个家\u0026rdquo;。当时，国内五星级以下酒店大多处于亏损状态，尤其是三星级中等酒店，投入产出比低，客房空置率奇高。而旅社、招待所目标客户为收入层次较低人群，酒店设施和卫生条件差、服务质量难以令人满意。\n如家通过舍弃豪华大堂、宴会厅等冗余配置，聚焦 \u0026ldquo;干净、舒适、便捷\u0026rdquo; 三大核心价值，成功在每间客房成本上实现 30% 的降幅，却将床品质量提升至四星级标准。这种 \u0026ldquo;减法哲学\u0026rdquo; 正如中国水墨画的留白艺术，在服务精简与品质坚守间找到黄金分割点。\n比如，如家的客房设施仅满足客人最关键的舒适淋浴和温馨床的需求，在卫生上达到甚至超越传统酒店卫生条件，同时保持较早的服务，房间增添色彩改变，增加温馨感。而物业多为租赁，选址避开闹市区，租用厂房或普通房屋，剔除星级酒店过多豪华装饰，舍弃投资巨大、利用率低的商场、康乐中心、游泳池和桑拿店，门不设迎宾人员，改为自助。\n二、标准化体系的\u0026quot;基因密码\u0026quot; 如家酒店在构建竞争优势的过程中，凭借服务标准化、成本控制和品牌符号化这三把钥匙，成功地打开了成功之门。其中，服务标准化形成了可复制的“基因链”，成本控制锻造了精钢般的运营体系，而品牌符号化则构建了情感认知护城河。\n例如，在前台接待方面，如家酒店规定了从问候与招呼、确认客人预订、登记入住信息到制作房卡钥匙、向客人介绍房间位置等一系列步骤。这些步骤要求前台工作人员在接待过程中做到主动、热情、耐心、细致、准确、高效，以确保客人能够享受到良好的入住体验。在客房清洁方面，如家酒店也有严格的标准。客房服务员需要按照规定的流程进行清洁，包括更换床品、清洁卫生间、擦拭家具等。如家酒店对每一个环节都有详细的要求，以确保服务的质量。\n这种近乎严苛的标准化操作，使得如家酒店的千家门店能够像精密钟表一样协调运转，为客人提供始终如一的高品质服务。\n在成本控制方面，如家酒店通过一系列创新举措实现了高效运营。例如，如家酒店的物业多为租赁，选址避开闹市区，租用厂房或普通房屋，从而降低了物业成本。在装修风格上，如家酒店追求简单温馨，不追求奢华，剔除了豪华酒店中的桑拿、KTV、酒吧等设施，进一步降低了装修成本。此外，如家酒店还通过扁平化组织结构，减少了管理层级，降低了人力成本。例如，如家酒店的员工与客房数的比例一直控制在0.3~0.35之间，而普通酒店的这一比例通常在1以上。这些举措不仅有效降低了运营成本，还提高了运营效率，使得如家酒店能够在保持低价格的同时，提供高质量的服务。\n品牌符号化方面，如家酒店通过一系列情感化设计，成功构建了情感认知护城河。例如，如家酒店的会员体系“家宾俱乐部”为会员提供了多种独享优惠，如优先预订入住、无偿订房专线电话、积分奖励等。这些举措不仅增强了会员的忠诚度，还提升了品牌的辨识度。此外，如家酒店还通过一系列情感化营销活动，如“书适如家”等，为客人提供了更加温馨、舒适的住宿体验。这些情感化设计使得如家酒店在客人心中留下了深刻的印象，进一步提升了品牌的竞争力。\n三、从攻城略地到心智占领 在营销策略的演变过程中，如家酒店展现了从快速扩张到深入消费者心智的转变。初创期，如家酒店采用了“闪电战”策略，通过特许经营模式实现了年均新增200家门店的扩张速度。这一策略的选址逻辑非常严格，遵循“三公里内有交通枢纽+商业中心”的原则，确保了酒店的便利性和商业潜力。这种快速扩张的策略使得如家酒店在短时间内占据了市场的重要份额。\n到了2015年，如家酒店开始数字化转型，会员体系与场景营销的融合成为其营销策略的亮点。\u0026ldquo;家宾会\u0026quot;会员体系累计吸纳了1.2亿会员，通过情感化设计如“睡不够退房费”和“延迟退房不收费”等措施，将客户忠诚度转化为68%的复购率。这些情感化设计不仅提升了客户的满意度，还增强了品牌的竞争力。\n2020年疫情期间，如家酒店推出了“安心住”计划，将标准化服务升级为防疫安全IP。这一计划包括了严格的卫生标准和安全措施，确保客人在特殊时期也能享受到安全舒适的住宿体验。通过这些措施，如家酒店不仅在疫情期间保持了业务的稳定，还进一步提升了品牌的形象和客户的信任度。\n五、如家模式 如家酒店相较于汉庭的科技驱动、锦江之星的国资背景，其核心竞争力确实在于服务颗粒度与情感渗透力的独特平衡。从纵向发展来看，如家酒店在2006年于纳斯达克上市，成为“中国酒店业第一股”，这为其后续发展奠定了坚实基础。2016年，首旅酒店通过一系列复杂的资本运作，以110亿元的价格完成了对如家酒店的私有化收购，这一举措进一步推动了如家酒店的生态重构。在整个发展过程中，如家酒店始终紧密围绕“标准化服务运营商”的战略定位，通过精细化的服务和情感化的营销策略，成功提升了品牌溢价能力。据相关数据显示，如家酒店的品牌溢价能力较同业高出15-20%，这一优势使其在激烈的市场竞争中脱颖而出。\n六、行业启示录：可复制的成功密码 如家案例揭示现代服务业三大定律：\n精准定位是破局利刃：在消费升级与降级并存的年代，找到\u0026quot;够得着的品质\u0026rdquo; 标准化不等于冰冷：用服务温度融化工业标准化可能带来的机械感 品牌是动态进化的生命体：从功能满足到情感共鸣的持续跃迁 当亚朵酒店用\u0026quot;人文情怀\u0026quot;开辟新赛道，OYO以资本闪电战搅动市场，如家的启示显得愈发珍贵：在标准化与个性化之间，始终存在通过精细化运营创造价值的广阔天地。这盏亮彻中国大地的黄色灯牌，仍在书写着服务业的东方智慧。\n七、参考 经济型酒店案例分析-如家快捷的商业模式 ↗ 首旅如家\u0026quot;年度会员日\u0026quot;，为这届年轻人搭建美好生活 ↗ 如家酒店前台服务手册 ↗ 如家酒店连锁-前台操作及服务标标准 ↗ 如家酒店的战略成本管理 ↗ 如家快捷酒店服务营销案例分析 ↗ 如家快捷酒店案例分析 ↗ 如家酒店 CIS 案例浅析 ↗ 连锁酒店服务创新分析 —— 以如家为例 ↗ 案例分析：收购如家，首旅酒店进一步实现战略聚焦和市场扩张 ↗ “转型中高端”的首旅如家，给出一份怎样的半年报？ ↗ ","date":"2025-02-14","tags":["暂无"],"title":"如家酒店：以标准化为琴键，谱就中国连锁酒店业的交响华章","url":"/post/2025/02/home_inn_the_marketing_legend_of_standardized_services_and_brand_building/"},{"content":"\n一、危机中的机遇：香港“自由行”政策的诞生 1997年香港回归中国后，亚洲金融风暴及“非典”袭港，导致经济整体低迷，2003年香港的国内生产总值（GDP）仅为12340亿港元，是1997年回归以来最低的一年，香港旅游业更是受到重创。旅游业对香港经济影响巨大，不仅是香港四大支柱产业之一，而且是香港赚取外汇的第二大行业。2003年5月，赴港游客同比下降68%，仅旅游收入就减少123亿港元。这一损失很快波及零售业和消费业，导致失业率达到香港特别行政区政府成立以来的新高。\n然而，从2004-2006年开始，香港经济强劲复苏，扭转香港经济衰退的三大直接驱动力是：引入内地一批优质企业在香港上市拉升资本市场；开启香港“自由行”旅游带旺香港的消费市场；以及启动“香港与内地更紧密的经贸关系”(CEPA)计划，分享中国内地的蓬勃商机。本文仅介绍香港“自由行”的市场策略如何捕捉到市场机会，拉动了香港旅游、零售和服务业等消费市场。\n二、突破政策瓶颈：香港“自由行”政策的实施 2003年6月23日，世界卫生组织(World Health Organization)宣布将香港从“非典”疫区名单中除名，这一天香港有关方面立即推出“全球旅游推广计划”，之后又推出“好客月”推广活动，刺激旅游者和市民的消费欲望。但是，香港政府很快发现，仅凭香港一己之力，很难在短时间内挽救颓势。\n香港政府需要捕捉新的市场机会，并把目光瞄准中国内地市场。首先，内地经济表现强劲，消费力越来越强，中产阶层人数持续增加，内地居民出境旅游的需求量越来越大，2002年中国国内居民出境总人数近1700万人次。其次，访港的内地游客数量增加速度最快，消费能力也十分强劲。2002年，内地游客总人数达46万，占访港游客总数的35.1%。内地游客消费达281亿港元，占访港游客总消费的50.6%。也能为香港带来丰厚的外汇收入。另一方面，香港的知名度和神秘感，文化、地理和交通优势，购物天堂的口碑，等等，都能成为吸引内地人赴港的魅力所在。\n要想抓住内地游客的商机，有两个关键点：首先要突破政策的“瓶颈”。香港特区政府向中央政府建议，希望允许内地居民以更方便的形式赴港旅游。“自由行”这一名称就反映了该计划的特点；其次，必须针对内地消费者进行直接市场推广，要让内地游客对来香港有足够强的兴趣。此前，香港旅游产品的推广，多数是针对旅行社进行的，需要转变推广的思路。而且，中国获准的境外游目的地正在全球日益增加，内地居民境外游的选择机会已越来越多，香港面临激烈的竞争。\n中央政府很快同意了香港特区政府这一要求，决定开放部分内地城市居民以个人身份赴香港旅游。即不必跟随旅行团，只要办理港澳通行证，就可以个人身份到香港旅游。这就是后来大家俗称的“自由行”。这一政策让出入境手续一下子变得简单了，令赴港短暂旅游，享受购物、饮食及娱乐的乐趣，开展跨境的周末旅游以及商务、展览和会议的旅游客群迅速增长。\n三、市场策略与推广活动 为成功开拓内地市场，香港旅游发展局实施了一系列推广香港的市场策略和整合营销传播计划。瞄准最具旅游潜力的多个地区，深挖年轻白领、商务客群和家庭游客这三个潜力市场，使香港成为他们的旅游目的地。强调香港多层面的吸引力，致力提升游客留港期间的旅游体验，并鼓励他们再次来访。例如，大规模、全方位、多媒体的整合营销传播活动。“2006精彩香港旅游年”，以“时刻发现精彩香港”(Moment of \u0026ldquo;Discovery)为推广主题，推出了九集电视专题片《星星细语香港情》，以及名人推介、杂志软文推广、图片巡回展、巡回路演、专车展示、抽奖活动赢取免费香港游、香港购物节、美食之最在香港、香港亲子游、“自创路线，发现精彩香港”网络大赛等丰富多彩的活动。\n此外，香港旅游发展局还推出了一系列特色旅游体验项目，如“旧城中环”、“绿色郊野全接触”等，从多个维度展示香港的地道风情。这些活动不仅吸引了大量内地游客，还提升了香港在国际上的知名度和美誉度。\n四、经济影响与成果 “自由行”成功地拉动了香港的消费和经济。香港的旅游业、零售业、酒店业、运输业、金融服务业等相关产业纷纷受益。香港旅游发展局的调查显示，个人游促成的额外游客消费2006年为93亿港元（2003年是35亿港元，2004年是65亿港元），其带来的消费净额会令香港本地生产总值增加65亿港元或增长0.44%，同时也为2.5万多人创造了就业机会，失业率降至6年来的最低。\n香港旅游总收益从2001年的618亿港元大幅增加到2006年年底的1194.3亿港元，其中由内地游客所贡献的旅游收益由2001年的158亿港元增长到2006年的397亿港元。2003-2006年，香港零售业销售额年均增长8.3%。由于实施零关税政策，在香港购买进口商品的价格一般都要比内地价格低，服装、首饰、化妆品，尤其是名牌产品，是内地居民赴香港旅游选购的重点商品。据香港旅游发展局的统计，“自由行”内地居民平均每人在香港消费超过6100港元。而在香港全部零售企业的销售额中，游客消费的比例超过20%，其中内地游客的消费占一半以上。“自由行”犹如一股“活水”，为香港的旅游业、零售业和服务业带来了巨大的商机，强劲地刺激和推动了香港经济的复苏，使香港重新焕发了活力。\n五、营销分析 5.1 市场定位与目标客户群体 香港“自由行”政策的市场定位非常明确，即瞄准内地市场，特别是经济发达地区的中产阶层。这些地区的居民消费能力强，对旅游的需求旺盛，且对香港的购物、美食、文化等具有浓厚兴趣。目标客户群体主要包括年轻白领、商务客群和家庭游客。年轻白领追求时尚和个性化体验，商务客群注重高效和便捷，家庭游客则更关注亲子互动和家庭乐趣。\n5.2 推广策略与渠道 香港旅游发展局采用了多种推广策略和渠道，以确保“自由行”政策的成功实施。首先，通过大规模、全方位、多媒体的整合营销传播活动，如电视专题片、名人推介、杂志软文推广等，提升香港在内地市场的知名度和吸引力。其次，针对不同地区和客户群体，推出定制化的旅游产品和线路，如“亲子游”、“美食游”、“购物游”等，满足不同游客的需求。此外，还利用互联网和社交媒体平台，开展在线推广和互动活动，如网络大赛、在线抽奖等，增强游客的参与感和体验感。\n5.3 产品策略与服务提升 为提升游客的旅游体验，香港旅游发展局推出了一系列特色旅游体验项目，如“旧城中环”、“绿色郊野全接触”等，从多个维度展示香港的地道风情。同时，还注重提升旅游服务的质量和水平，如加强旅游基础设施建设，提升交通、住宿等服务的承载能力。此外，还通过培训和管理，提高旅游从业人员的专业素养和服务意识，确保游客在香港的旅游过程中能够享受到优质的服务。\n六、社会影响 “自由行”政策不仅在经济上带来了显著的成效，还在社会层面产生了深远的影响。首先，大量内地游客的涌入，促进了香港与内地的文化交流，增进了两地居民的相互了解和友谊。其次，自由行游客的多样化需求，推动了香港旅游服务的多元化发展，提升了香港作为国际旅游目的地的竞争力。\n七、参考 市场营销案例分析：香港“自由行”捕获市场机遇 ↗ 从2003年开放香港自由行，带动香港旅游业呈跨越式发展 ↗ 回归25年大事记|2003：SARS在港爆发 “自由行”救经济 ↗ “自由行”究竟给香港带来了什么 ↗ 港报告称内地客去年在港消费撑起香港1/3零售业 ↗ 头啖汤、申办潮与活水：港澳“自由行”二十周年的个体记忆 ↗ 四个旅游营销经典案例：印象丽江、香港、天台山、大理 ↗ 十大营销经典案例 ↗ 十大营销经典案例之十－－浴火重生　香港旅游业V型复苏 ↗ 香江走笔：内地居民“个人游”让香港既喜且忧 ↗ 内地赴港澳“个人游”政策的由来 ↗ 香港2003 ↗ ","date":"2025-02-14","tags":["暂无"],"title":"香港“自由行”营销奇迹：化危机为转机，重振经济的策略解析","url":"/post/2025/02/hong_kong_free_travel_seizes_market_opportunities/"},{"content":" 迷信行为不仅在人类中存在，动物也会表现出类似的 “迷信”。心理学家伯尔赫斯・弗雷德里克・斯金纳（B.F. Skinner）通过实验揭示了这一现象背后的心理学原理。\n一、生活中的“迷信”行为 在我们的生活中，处处充满“迷信”的东西，在大多数时候我们都把它当做讨彩头的方式，作为一种积极暗示。比如考试前吃一根火腿肠和两个鸡蛋，又或是新买的东西主人先用。这样的事情我们屡见不鲜。\n让我们来看看数字迷信在营销中的运用。你是否注意到，在很多产品的价格设置中，常常会出现诸如 “8”“6” 等被认为吉祥的数字？比如，一款商品定价为 88 元或 168 元，而不是 90 元或 170 元。这是为什么呢？难道仅仅是因为这些数字听起来比较好听吗？其实不然，这背后是商家对消费者数字迷信心理的巧妙利用。在很多文化中，数字 “8” 被认为代表着发财和好运，而 “6” 则象征着顺利。商家通过设置这些带有吉祥寓意的数字价格，让消费者在心理上产生一种积极的暗示，觉得购买这样的产品可能会给自己带来好运和财富。那么，这种数字迷信的心理是如何形成的呢？它是否真的会对消费者的购买行为产生实质性的影响呢？\n再来说说颜色迷信。你有没有发现，在一些特定的节日或场合，商家会推出特定颜色的产品或包装？比如，在中国的春节期间，红色成为了主打颜色，从红色的包装袋到红色的促销海报，无处不在。这是为什么呢？红色在我们的文化中究竟代表着什么？它又是如何影响我们的消费心理的呢？研究表明，颜色会对人的情绪和行为产生潜移默化的影响。在中国文化中，红色象征着喜庆、吉祥和繁荣。商家通过使用红色元素，营造出浓厚的节日氛围，让消费者在心理上感受到一种愉悦和兴奋的情绪，从而更容易产生购买的冲动。那么，除了红色之外，还有哪些颜色在营销中被赋予了特殊的含义呢？这些颜色又是如何影响消费者的购买决策的呢？\n黄道吉日等传统习俗在营销中的运用也是一个值得探讨的话题。你是否曾经在一些重要的节日或黄道吉日收到过商家的促销信息？比如，在春节期间，很多商家会推出 “新年特惠” 活动；在西方的黑色星期五，商家也会进行大规模的促销。这是为什么呢？商家为什么会选择这些特定的日子进行促销呢？这背后是否有什么玄机呢？其实，商家选择在这些特定的日子进行促销，是基于消费者对黄道吉日等传统习俗的迷信心理。在消费者的心目中，这些日子被认为是吉祥的日子，适合购物和消费。商家通过在这些日子推出促销活动，迎合了消费者的心理需求，让消费者觉得在这些日子购物会更加吉利和划算。那么，除了黄道吉日之外，还有哪些传统习俗被商家运用到了营销中呢？这些习俗又是如何影响消费者的购买行为的呢？\n二、斯金纳的鸽子实验 注意：\n斯金纳的小白鼠实验主要研究了操作性条件反射。在固定时间奖励实验中，小白鼠学会了间隔一定时间按一次按钮；在概率型奖励实验中，小白鼠学会了不停按钮，即使奖励概率很低，小白鼠的学习行为也没有立即消失。\n斯金纳的鸽子实验主要研究了迷信行为的形成。新出现的迷信行为在建立条件反射前都是未被观察到的。虽然新行为和得到食物之间没有实际联系，但鸽子表现得就好像那种行为会产生食物似的。\n斯金纳的鸽子实验主要研究了迷信行为的形成。他选择了8只鸽子作为实验对象，将它们置于特制的“斯金纳箱”中。箱内设有食物分发器，实验前连续几天减少喂食量，使鸽子在测试时处于饥饿状态。食物分发器被设定为每隔15秒便自动放出食物，无论鸽子在做什么，每隔15秒它都将获得一份食物。让每只鸽子每天都在实验箱里待几分钟，对其行为不作任何限制，但会由两个独立的观测者来观测记录鸽子的行为表现，尤其是两次食物放出期间的行为表现。在实验过程中，8只鸽子中的6只产生了非常明显的行为变化。\n一只鸽子形成了逆时针转圈的条件反射，一般在两次强化间转2-3圈；另一只鸽子反复将头伸向箱子上方的一个角落；第三只呈现上举动作，好像将头放到一个看不见的杆下面反复抬起。另外两只鸽子头和身体呈现出钟摆似的动作，还有一只鸽子形成不完整的啄击行为。这些新的行为在建立条件反射前都是未被观察到的。虽然新行为和得到食物之间没有实际联系，但鸽子表现得就好像那种行为会产生食物似的。\n斯金纳的实验揭示了迷信行为源于 偶然强化 。当某种行为恰与奖励同时出现，动物或人会误认为该行为是获奖励的原因，进而重复。例如，某只鸽子在食物投喂前转圈，便误将转圈视为获食原因，不断重复。这在心理学上称为 “操作性条件反射”。人类中也有类似现象，如学生因穿红色衣服考试取得好成绩，便视其为 “幸运符”，坚持穿着。\n三、斯金纳箱原理在营销中的应用 斯金纳箱原理在营销中的应用也十分广泛。你是否思考过，为什么一些游戏中的随机奖励机制会让玩家如此着迷？例如，在一些角色扮演类游戏中，玩家杀死怪物后，有时会获得珍贵的装备或道具，而这些奖励的掉落是随机的。这种随机奖励机制就像斯金纳箱中的随机食物投放，让玩家不断地进行游戏行为，以期待获得奖励。\n四、斯金纳原理的错误应用：迷信 北京万维之道信息技术有限公司的风水课广告 案情简介 ：2024 年 6 月，北京市市场监督管理局发现北京万维之道信息技术有限公司在推广 “3 天零基础风水实战课” 的广告中发布 “趋吉避凶、化解厄运”“一起趋吉避凶，改变人生运势” 等内容，构成发布含有迷信内容广告的违法行为。\n分析 ：该公司利用人们对风水等迷信内容的好奇和信仰，试图通过宣传风水能改变运势来吸引消费者购买课程。这种行为不仅违反了广告法，也利用了消费者的迷信心理，误导消费者认为风水能对他们的生活产生实际影响，而实际上这些内容并无科学依据。\n江西省某人力资源有限公司的迷信广告 案情简介 ：江西省某人力资源有限公司在微博发布配有 “国考必过，文殊菩萨赐福，成功上岸，逢考必过！” 文字的菩萨动态图等迷信内容，在微信视频号发布配有 “你注定是公务员” 文字、背景为中国共产党党徽的短视频，同时还存在以受益者名义作宣传的情况，上述行为违反了《中华人民共和国广告法》有关规定，被南昌市市场监管局依法罚款 25 万元。\n分析 ：该公司通过将考试成功与迷信的菩萨赐福等概念相联系，误导消费者认为其服务能带来超自然的力量，帮助他们通过考试。这种行为不仅违背了广告法，也利用了消费者在面对重要考试时的焦虑和迷信心理，使他们可能对这种无根据的宣传产生信任，从而选择该公司的服务。\n北京吉象万合科技有限公司的虚假宣传 案情简介 ：2024 年 6 月，朝阳区市场监督管理局对北京吉象万合科技有限公司作虚假和引人误解的宣传行为立案调查。经查，当事人运营 “讲真” 手机短视频剪辑 “0 元 5 天手机剪辑线上训练营” 客户微信群运营过程中，在群中发布 “老师带你第一视角逛讲真集团总部”“老师抖音账号总收益 69 万多一点” 的视频，实际不存在 “讲真集团总部”，账号也非老师本人账号。此外，当事人发布的 “宝妈月平均挣 5 - 6w”“老太太 11 月份收入过万” 等视频无法提供真实出处。当事人上述行为构成虚假宣传的违法行为，被处罚款 45 万元。\n分析 ：该公司通过虚构事实和夸大宣传来吸引消费者，使消费者误以为参加其培训课程能轻松获得高收入。这种行为不仅侵犯了消费者的知情权，也利用了消费者对成功和财富的渴望，可能导致消费者在没有充分了解课程内容和实际效果的情况下盲目报名，最终遭受经济损失。\n五、正确应用斯金纳原理：随机 以下是一些实际运用斯金纳原理的营销案例：\n1. 电商平台的积分奖励机制 案例 ：许多电商平台都设置了积分奖励机制，如淘宝、京东等。用户在平台上的每一次购物、评价、分享等行为都会获得相应的积分，这些积分可以用于兑换商品、抵扣现金或参与平台的专属活动。这种积分奖励机制就是运用了斯金纳的正强化原理，通过给予用户即时的奖励，强化他们的购物行为和平台互动行为，使他们更愿意在该平台上进行消费和参与活动，从而提高了用户的忠诚度和活跃度。 2. 游戏中的随机奖励机制 案例 ：在许多游戏中，如《王者荣耀》《原神》等，都设置了随机奖励机制。玩家在游戏过程中，通过完成任务、击败敌人、开启宝箱等行为，有机会获得随机的奖励，如游戏道具、皮肤、经验值等。这种随机奖励机制就像斯金纳箱中的随机食物投放，让玩家不断地进行游戏行为，以期待获得更好的奖励，从而提高了玩家的游戏黏性和活跃度。 数据 ：《王者荣耀》的随机奖励机制使得玩家的平均在线时长增加了 30%以上，玩家的活跃度和留存率也得到了显著提升。 3. 品牌的广告宣传与形象塑造 案例 ：万宝路香烟通过多年的广告宣传，将品牌与美国西部牛仔的形象紧密联系在一起。广告中展现出的牛仔形象粗犷、豪迈、自由，吸引了众多男性消费者。这种广告宣传就是运用了斯金纳的强化原理，通过不断地将品牌与积极的形象进行关联，强化消费者对品牌的认知和好感，从而影响他们的购买决策。 数据 ：万宝路香烟在全球市场的销量多年来一直名列前茅，其品牌价值也高达数百亿美元，这与其成功的广告宣传和形象塑造密不可分。 4. 宜家的购物体验设计 案例 ：宜家的商场布局和购物体验设计充分运用了斯金纳原理。宜家商场的布局通常是一个单向的、迂回的路线，消费者需要沿着这条路线走过所有的展厅和商品区域，才能到达出口。在这个过程中，消费者会不断地接触到各种商品和展示，这种设计就像斯金纳箱中的环境设置，通过不断地刺激消费者的感官和行为，强化他们的购物欲望和行为。此外，宜家还在出口处设置了 1 元钱的冰淇淋等小惊喜，让消费者在购物结束时获得一个愉悦的体验，从而强化他们对宜家品牌的正面认知。 数据 ：宜家的这种购物体验设计使得消费者的平均购物时间增加了 40%以上，消费者的满意度和忠诚度也得到了显著提高。 5. 拼多多的社交裂变营销 案例 ：拼多多通过 “砍价”“拼团” 等社交裂变营销方式，迅速获得了大量用户。用户在拼多多平台上发起砍价或拼团活动，邀请好友帮忙砍价或参与拼团，成功后可以获得商品的折扣或免费商品。这种营销方式就是运用了斯金纳的正强化原理，通过给予用户即时的奖励，强化他们的社交分享和邀请行为，从而实现了用户的快速增长和平台的广泛传播。 数据 ：拼多多在短短几年内就获得了数亿用户的增长，其社交裂变营销方式功不可没。 六、斯金纳原理与营销 迷信行为是普遍存在的，但是我们可以加以利用，打到增长的目的。\n利用数字迷信 在营销中，可以根据不同文化背景下消费者对数字的迷信心理，选择具有吉祥寓意的数字来命名产品、设置价格或进行促销活动等，以吸引消费者。比如，在中国文化中，数字 “8” 被认为是吉祥的数字，代表着发财和好运。因此，许多品牌在命名产品或进行促销活动时会巧妙地运用这个数字。例如，某品牌在推出一款新的手机时，将其型号命名为 “888”，并在价格上也设置了多个与 “8” 相关的档次，如 888 元、1888 元等，以此来吸引消费者购买，让消费者在心理上觉得这款手机能给自己带来好运和财富。\n借助颜色寓意 不同颜色在不同文化中具有不同的象征意义，营销者可以根据目标市场的文化特点，选择具有积极寓意的颜色来设计产品包装、广告宣传等，从而影响消费者的心理和购买决策。\n在中国文化中，红色象征着喜庆、吉祥和繁荣。因此，在春节、婚礼等重要节日和场合，红色元素被广泛应用。许多品牌会推出红色包装的产品，如红色的饮料瓶、红色的食品包装等，以迎合消费者的心理需求，增加产品的销量。例如，某饮料品牌在春节期间推出红色包装的限量版饮料，瓶身设计上融入了传统的中国元素，如福字、鞭炮等，让消费者在购买和饮用时感受到浓厚的节日氛围和吉祥的寓意，从而提高了产品的市场竞争力。\n结合黄道吉日等传统习俗 在一些重要的传统节日或黄道吉日，消费者往往会有更强的消费意愿和购买行为。营销者可以提前策划相关的营销活动，推出特别的产品或服务，以满足消费者在这些特殊日子的需求和心理期望。\n在春节期间，许多商家会推出 “新年礼盒”“春节特供” 等产品，这些产品通常会在包装设计上融入春节的元素，如生肖、福字、中国结等，并在价格上给予一定的优惠。此外，一些商家还会在春节期间举办促销活动，如满减、赠品等，吸引消费者购买。这种结合传统节日的营销方式，不仅能够满足消费者在春节期间购买礼品和年货的需求，还能够让消费者感受到浓厚的节日氛围和传统文化的魅力，从而提高消费者的购买意愿和品牌忠诚度。\n利用品牌命名寓意 品牌名称是消费者对产品或服务的第一印象，一个具有吉祥寓意或符合消费者迷信心理的品牌名称，可能会更容易吸引消费者的关注和喜爱。在市场上，一些品牌在命名时会考虑到消费者的吉利性偏好。\n斯金纳的鸽子实验为我们理解迷信行为提供了重要启示。通过认识偶然强化作用，我们能更好理解迷信行为产生原因，并学会用理性和科学方法看待世界。下次遇到 “幸运仪式” 时，不妨思考：这是否只是 “迷信的鸽子” 的表现？\n七、参考 迷信的消费者（未完待续） ↗ 江西公布一批广告违法典型案例 一公司广告中含迷信内容被罚25万元 ↗ 数字迷信与消费行为:影响机制及边界 ↗ 消费者迷信研究综述与展望 ↗ 用「斯金纳箱」分析：为什么有的产品设计会让人上瘾？ ↗ 行为主义学习理论在市场营销中的应用 ——以万宝路和宜家的品牌创建为例 ↗ 经典心理学实验之迷信的鸽子 ↗ ","date":"2025-02-14","tags":["心理"],"title":"好彩头：为什么随机投喂会让鸽子产生迷信行为？","url":"/post/2025/02/good_luck_why_does_random_feeding_cause_superstitious_behavior_among_pigeons/"},{"content":" 在《哪吒》之前，四二（笔者）最喜欢的是《功夫熊猫》，那还是我在小学的时候看的。\n《哪吒》系列与《功夫熊猫》系列可谓是中美两国动画电影的代表，两者不仅在票房和口碑上取得了巨大成功，更在视觉符号、角色塑造、叙事风格等方面展现了相似类型动画中，两国文化的底层差异。\n一、视觉符号 首先是《哪吒》中的文化东方，根植于中国传统文化，以中国古代神话故事《封神演义》为蓝本，对哪吒这一经典神话人物及其相关故事进行了改编与延续，其中融入了大量中国传统文化元素，如结界兽的造型灵感来源于三星堆青铜面具，展现了中国文化的深厚底蕴。\n影片构建了具有中国传统纹饰和文化遗产的视觉体系：太乙真人的水墨画卷、敖丙的万鳞甲、陈塘关的青铜纹饰，乃至山河社稷图里的蓬莱仙岛，均源自《山海经》《封神榜》的古典意象。这些符号不仅是美学装饰，更是文化身份的宣言。\n在《功夫熊猫》中更多的是形式东方，虽然融入了众多中国文化元素，但其本质上是好莱坞对中国文化的挪用与再创作。它将中国功夫、熊猫、中式建筑等元素与西方的叙事结构和幽默风格相结合，形成了一种独特的文化融合。这种\u0026quot;泛东方主义\u0026quot;处理，本质是将文化符号降维为视觉奇观。正如阿宝用筷子夹包子的滑稽场景，中国元素成为服务剧情的工具，其深层文化意义被悬置。\n虽《功夫熊猫》在文化呈现上是成功的，但是其内的文化底蕴始终是抽离的，是一种对 “神秘东方” 的幻想，影片以中国元素为外壳，内核却是典型的美式个人英雄主义，可以视作是好莱坞叙事结构下的一种中国文化的视觉产物。\n二、角色塑造 从 “我命由我不由天” 到 “我偏要踏出一条自己的路”，哪吒的形象极具传奇色彩，从出生到成长都充满了神话色彩。从出生开始，哪吒就及其不同，这与中国传统有关。中国古代神话深受传统文化和宗教信仰的影响，如道教、佛教等。这些宗教强调天命、宿世因缘等观念，认为伟大的人物出生时往往伴随着天象异变、神灵显现等超自然现象，以彰显其非凡的来历和使命。例如，释迦牟尼佛出生时，天地异变，九龙灌顶，预示着其将成为伟大的觉者。\n哪吒的叛逆与悲剧性命运体现了中国文化中 “宿命论” 与 “抗争精神” 的冲突。哪吒的成长不仅是个人英雄的崛起，更是对集体利益的捍卫，体现了中国传统文化中 “舍生取义” 的价值观。在中国神话中，哪吒与孙悟空都是极具反抗精神的角色。孙悟空大闹天宫，哪吒则大闹东海，两者都体现了对权威的反抗。\n而《功夫熊猫》中阿宝的形象更贴近现实生活，美国文化强调个人主义、自由、平等价值观，英雄人物的出生更多地被赋予了个人奋斗、自我实现的意义。例如，超人、蝙蝠侠等英雄人物的出生并没有特别的传奇色彩，但他们通过自身的努力和奋斗，成为了拯救世界的英雄。\n他憨厚、幽默，甚至有些笨拙，但通过努力和坚持最终成为英雄。阿宝的成长路径更注重个人奋斗与自我实现，体现了美国文化中“个人主义”与“平等竞争”的精神。他的成功并非命中注定，而是通过努力争取而来。阿宝和乌龟大师在圣桃树下的聊天中展现的也尽是个人迷茫。在美国文化中，蜘蛛侠也是一个通过个人奋斗成为英雄的典型例子。彼得·帕克原本是一个普通的高中生，通过意外获得超能力后，他选择成为超级英雄。与阿宝一样，蜘蛛侠的成功并非命中注定，而是通过不断努力和自我提升实现的。\n简单来说，《哪吒》的人物塑造更为委婉复杂，而《功夫熊猫》的人物塑造则更单一固定，最明显的就是情感的表达。《哪吒》更注重情感与冲突的深度挖掘，通过哪吒与敖丙的友情、哪吒与父母的亲情以及哪吒与命运的抗争等情节，展现了人物内心的复杂情感和成长历程，人物更为立体。《功夫熊猫》偏向于直接得表达。这两种表达方式都符合了原始创作团队的本土文化传统设定，直直接的感受就是《哪吒》的感受会更情意绵绵，而《功夫熊猫》的感觉会更单一。\n《哪吒》的角色塑造更加立体和复杂，哪吒、敖丙、李靖、殷夫人等角色都具有鲜明的个性和丰富的情感。哪吒的叛逆、敖丙的善良、李靖的严厉与关爱、殷夫人的温柔与坚强，都通过细腻的情节和对话展现得淋漓尽致，使观众能够深刻感受到角色的内心世界和情感变化。\n而《功夫熊猫》中的角色塑造相对较为简单和直接，阿宝、大师、盖世五侠等角色虽然具有一定的个性和特点，但其形象和性格相对较为单一和固定。影片更注重通过角色之间的互动和情节的发展，来展现角色的成长和变化，而不是深入挖掘角色的内心世界和情感复杂性。\n三、叙事形式 《哪吒》在叙事上采用了传统神话与现代改编的结合，既有中国古典戏剧的浪漫主义色彩，又融入了现代动画技术的视觉冲击。影片通过丰富的特效和精美的画面，展现了东方美学的独特魅力。其中，其中，影片在叙事上更注重情感与冲突的深度挖掘，通过哪吒与敖丙的友情、哪吒与父母的亲情以及哪吒与命运的抗争等情节，展现了人物内心的复杂情感和成长历程。\n在艺术表现上，不仅在视觉特效上展现了中式美学，如陈塘关的古建筑、昆仑山的仙气缭绕、东海龙宫的神秘瑰丽等，增强了影片的感染力和沉浸感。《功夫熊猫》的画面风格虽然借鉴了中国古典美学，但其整体表现更符合好莱坞动画的工业化标准。\n《功夫熊猫》系列电影不仅在外形动作上借鉴了中国传统武术，更深入地试图传达与中国武术相关的传统思想内蕴。例如，在第一部中，无字武功秘籍象征着领悟和悟性的重要性，暗示着真正的武学精髓不在于外在的形式和文字，而在于内心的领悟和实践。第二部中，关于“烟火”（火药）的观点则体现了中国传统文化中对自然力量的敬畏和利用，同时也暗示了科技与传统之间的关系。第三部中，“气”的真正内涵则展现了中国哲学中的生命能量和宇宙万物之间的联系，强调了内在力量的培养和运用。\n除了功夫之外，《功夫熊猫》系列对于中国山水、建筑、食物、风俗等元素的运用，也体现了其灵活的“拿来主义”。这些元素的使用并非简单地堆砌，而是在尊重中国传统文化的基础上，进行了适当的改编和创新，使其更符合国际观众的审美和理解。例如，影片中的中国山水画风格的背景、具有中国特色的建筑和服饰、以及各种中国传统食物的描绘，都为影片增添了浓厚的中国文化氛围，同时也让国际观众更容易接受和理解。\n从叙事结构来看，《功夫熊猫》系列采用了经典好莱坞叙事与超级英雄电影的结合。在经典叙事方面，熊猫阿宝作为主角，沿用了好莱坞常见的以有缺陷的普通人作为主角的模式，使其具有强烈的移情功能。阿宝在一开始并不具备学武的天赋，但他对功夫的迷恋与向往却十分强烈，这种强烈的欲望推动了整个叙事的发展。影片通过设置各种障碍和挑战，使阿宝的欲望实现过程变得曲折，从而形成了丰富的故事情节。电影的弧光由此形成：一个资质平庸的无名小卒，通过不断的努力和成长，最终成为了功夫盖世、拯救世界的英雄。\n除了经典叙事之外，《功夫熊猫》系列还借鉴了好莱坞超级英雄电影的类型惯例。在每一部影片中，都会设置一个超级大反派，阿宝与大反派的较量过程与经典叙事紧密交融在一起。这种超级英雄电影的类型惯例，不仅为影片增添了紧张刺激的情节，也为系列电影的持续生产提供了丰富的灵感和资源。\n","date":"2025-02-14","tags":["文化差异"],"title":"东方表达：同样是中国文化《哪吒》和《功夫熊猫》的不同之处是什么？","url":"/post/2025/02/oriental_expression_what_is_the_difference_between_nezha_and_kung_fu_panda_which_are_also_china_cultures/"},{"content":"营销人必备网站：6大类，41个网站 从去年到现在，很多小伙伴会问到宿言如何才能提升自己的营销能力。其实提升营销能力主要分为两部分，那就是“不停学习+各种实践”。\n关于学习，我们可以通过各类网站及资讯平台来不断的获取知识，毕竟营销这个职业太瞬息万变了，我们需要不断的吸收新的知识，才能做到百战不殆。关于实践，我们需要用到各种 营销人 ↗ 必备的营销工具来提升自己的工作效率，这样才能最大程度的节省自己的脑力，把自己的脑子用在刀刃上。\n一、营销资讯类 1、 数英 ↗ 数英这个网站相信很多营销人都不陌生了，记得很多很多年前宿言还在做广告人时，就经常会去数英找灵感。在数英可以学到不少的广告创意、 营销技巧 ↗ 、文案干货，包括一些能帮你打开思路的最新营销资讯等等。\n数英绝对可以称之为营销人的充电站，网站上内容的更新速度比较快，适合每天在办公室吃早餐时配套食用，边吃边看好吸收~\n2、 广告门 ↗ 广告门 ↗ 绝对称得上是创意+案例网站中的航空母舰，内容更新速度很快，每天都有新内容可看，并且内容的质量也不错。如果你刚入职了一家新公司，想找一下相关领域的营销或广告案例，那么你可以在广告门的案例库里寻找，按行业分类，总能找到适合你的案例来带你飞~\n3、 鸟哥笔记 ↗ 鸟哥笔记是宿言近几年比较喜欢的一个网站，网站主要以干货内容为主，包含了运营、推广、 广告营销 ↗ 及一些综合类内容。没事儿的时候可以多看看，内容质量也不错呀~\n4、 梅花网 ↗ 梅花网 ↗ 也是非常非常老的网站了，也是宿言好多年前就开始关注的网站。这个网站相信营销人和广告人都应该知道吧？在这里就不多介绍了，看就完了！\n5、 首席营销官 ↗ 首席营销官主要专注于 数字营销 ↗ 和品牌创新，是宿言去年开始关注的网站。网站内容包含了营销的最新资讯以及案例，同时还有一些营销类的干货内容。多看看，长见识。\n6、 市场部网 ↗ 市场部网也是宿言很久很久前开始关注的网站，网站分为知识库、商学院、异业合作以及线下活动等分类。其中 异业合作 ↗ 这个板块很适合营销人去看看，里面有大量的寻求异业合作的企业发布的需求，极有可能促成一些异业合作。\n7、 领英 ↗ 严格意义上来说，领英不能算是资讯类网站，应属于职场人社交平台。不过 宿言 ↗ 认为领英真的是香，在 领英 ↗ 有很多国内外的行业大咖在平台上分享自己的干货，同时领英的职场导师也很适合新手去咨询。说简单些就是即能交到一些行业内的朋友，又能学习很多干货的宝藏网站。\n8、 TOPYS ↗ 宿言当年第一次接触 顶尖文案 ↗ 这个网站的时候，直观的感受就是“洋气”，网站里充斥着大量的“创意内容”。如果你觉得脑子不够用了，实在想不出创意了，那么这个网站就是你的“创意”加油站。\n9、 新媒体之家 ↗ 新媒体之家的内容还是很全面的，包含了产品、运营、营销的干货内容以及行业快讯，每一个大分类都被拆解成了一小块一小块的细分板块，内容质量也不错，能学到不少东西哦~\n10、 虎嗅 ↗ 虎嗅 ↗ 这个网站不仅仅有营销内容，更是充斥着大量关于“商业”及“科技”的资讯。早期也是因为内容足够“深度”而知名。虎嗅是宿言基本上每天早餐或午餐时都会看的网站，可能没那么多的干货，但却能打开你的思维。\n11、 人人都是产品经理 ↗ 这个网站可不仅仅是产品经理可以看，营销人也是非常值得一看的，网站里包含了业界动态、产品设计、产品运营、用户研究、营销推广、数据分析等多个板块内容，内容也是够硬，值得推荐。\n二、创意文案类 1、 文案迷 ↗ 文案迷这个网站适合我们在写文案时脑子短路或者需要些灵感时使用，文案的分类还是很多的，包含了公益广告文案、纪录片解说语、互联网广告文案、电子产品广告文案、餐饮文案、生活用品广告文案、汽车广告文案等等，借鉴即可，切勿抄袭哦~\n2、文案狗（ https://www.addog.vip/ ↗ 这个网站主要以谐音工具为主，可以自己设定谐音字，网站可以通过设定的谐音字来组成谐音成语、诗句和俗语等等。适合做海报文案及一些短的广告语使用，不建议多用，毕竟“谐音梗是要扣钱的”。\n3、 句易网 ↗ 句易网是一个在线广告禁用词查询平台，如果你不想被互联网上那些专门找事儿的人盯上，那么你最好把你的广告语用这个网站查一下，以防万一。\n4、 its nice that ↗ 这个网站就是创意集合站，各类创意综合体，包含广告、时尚、艺术、插图、摄影、产品设计等等一些列的创意内容。不仅能让你灵感爆棚，也能让你的审美上一个台阶呢。\n5、 luerzer’s Arch ↗ 学习广告创意或文案，还是要学“经典”的。这个网站罗列了近30年全世界最好的广告。同时每周都会更新新的广告案例，多学多看多应用。这个网站必不可少。\n三、图片视频类 1、 花瓣 ↗ 花瓣可以说是平面设计师的干饭必备网站，2019年花瓣升级维护1个月，造成无数设计师都快失业了的场面。作为营销人而言，有时候简单处理一些图片或者找一些图片素材也是必备的职业技能，那么这个网站就能满足你的需求了~\n2、 Unsplash ↗ 这个网站的图片都是可以免费下载的，高清又文艺，如果你正在被“配图”所困扰，那么用这个网站就对了，非常好用，且一点都不LOW~\n3、 StockSnap ↗ 这个网站和上面的网站类似，也是全世界的免费摄影作品，逼格还挺高的~\n4、 pngpix ↗ 超级香的PNG图片网站，无论是做PPT还是用PS做个简单的图片，这个网站都太适合不过了。省去了自己抠图的时间，大幅提升工作效率！并且\u0026hellip;免费~~~\n5、 freepik ↗ 免费的矢量图和PSD格式的图形资源网站。妈妈再也不用担心用PS的时候没素材了呢~\n6、 mixkit ↗ 免费高清视频素材下载网站。可用于剪视频使用，宿言在平时工作中用到剪视频的软件相对少一些，但偶尔还是会用到，后期宿言的内容也会用长视频和短视频的形式产出，那时候应该会用的比较多，如果你有用处的话，可以在这个网站下载素材。\n四、热榜指数类 1、 百度指数 ↗ 百度指数可用于测试某个热点或关键词在百度内的热度使用，比如你的产品是某品牌口红，那么你就可以搜索这个关键词，查看有多少人在百度搜索这个关键词，他们搜这个关键词时还会搜索哪些其他关联词，并且还可以查看他们的人群属性，比如性别、地域、年龄等等。非常时候用于基础的数据分析。\n2、 百度风云榜 ↗ 百度风云榜常用于查看热点使用，毕竟一个热点火起来一定是有原因的，之前宿言在其他文章有提到过，追热点很可能是很多中小企业免费获客的绝佳手段，所以追逐下热点没毛病。\n3、 头条指数 ↗ 此网站是基于头条系产品的数据监测，网站的功能和使用方式和 百度指数 ↗ 极为类似，常用于监测某类关键词在头条产品里的热度使用。\n4、 微热点 ↗ 微热点是微博数据监测平台，用于监测某关键词在微博内的热度等数据。用法和上方其他网站类似。同时此网站还可以用于观察微博最新热点使用，还是分类的那种。\n5、 新榜 ↗ 宿言在新塝上主要用于查询各平台的KOL实际情况，包含公众号、视频号、抖音号、快手号、B站号等等。能看到各KOL的用户画像、粉丝数、账号资料和大概的数据表现。如果你们公司想投放KOL，那么这个网站至少能帮你辨别下KOL的实际质量。仅用于参考哦~\n五、数据洞察类 1、 艾瑞咨询 ↗ 如果你刚刚进入一个新行业，对行业了解的极少，那么你就可以登录这个网站上去查询相关行业的数据报告。有助于你快速了解这个行业，内容极其丰富，并且大多数数据都是免费的。\n2、 199IT互联网数据 ↗ 各行各业的数据报告下载，就一句话概括一下吧。如果你在艾瑞上没有搜到你想要的数据，那么你就在这里搜吧！\n3、 报告查一查 ↗ 报告查一查这个网站是可以直接搜索关键词的。比如你正在从事婚庆行业，那么你就可以在搜索框搜索“婚庆”两个字，你就可以得到近几年大量关于婚庆行业的各种数据啦，并且还会有很多关联的数据，当然，依然是免费的。\n4、 普华永道 ↗ 和上一个网站类似，也是可以通过搜索来查找相关行业数据的网站，内容相当的硬。如果以上3个网站你都没查到你想要的数据，你就拿这个网站继续查！\n六、提升效率类 1、 ADGuider 营销日历 ↗ 如果你是做新媒体运营的，那么这个网站绝对算得上是宝藏网站了啊！在这里你可以查询到每个月中每一天的节气、节日、纪念日、重要事件等等热点事件。超级好用！\n2、 麦克表单 ↗ 麦克表单这个网站相信大多数营销人都不陌生吧？这个工具可以根据自己的需求生成表单，可用于收集客户信息或用于收集客户的反馈等等，非常方便且基础版不需要花钱就能用~\n3、 创客贴 ↗ 创客贴是在线设计平台，可用于紧急的海报、长图、自媒体用图的在线设计。分类分的非常精细，很多基础版的素材也都是免费的，如果你正在做自己的自媒体，那么这个网站则能大幅提升你的工作效率，这个网站也是宿言到现在依然经常使用的网站之一。\n4、 草料 ↗ 草料是一个二维码生成工具，可以将文字、网址、文件、图片、表单等等不同形式的内容生成为二维码使用。\n5、 XMind ↗ XMind是宿言使用时间比较久的思维导图工具，主要用于头脑风暴和理清思路使用，比如在做一个方案之前，宿言会先用 思维导图 ↗ 把基本的框架梳理好之后再着手开始制作方案，这样更加高效。\n6、 Convertio ↗ Convertio是一款在线格式转换工具，不仅可以转文字内容，还可以转音频、视频和图片哦！再也不用在网上疯狂搜索格式转换工具了！\n7、 美图秀秀PC版 ↗ 美图秀秀PC版完美解决了电脑端简单处理图片的需求，有了它，再也不用拿PS做简单的修图了！！！也不用把电脑里的图片传到手机里修图了！\n8、 石墨文档 ↗ 石墨文档是可以团队协同使用的文档编辑工具，可多人同时在线编辑一个文档，效率大大提升。尤其适合紧急型工作，多人贡献自己的力量，能够快速完成工作，可下载APP直接在手机端使用。\n9、 印象笔记 ↗ 一个人的脑容量是极其有限的，所以很多知识我们都需要有个空间用来寄存。宿言用 印象笔记 ↗ 已经很久很久了，手机端和PC端都在使用，内容可同步。在印象笔记中，宿言会把很多在网上学到的知识分类存储，设置了很多内容分类，比如 市场调研 ↗ 、消费心理、营销技巧、商业观察等等，在需要的时候就会调出来查看，方便使用。\n10、 Noun Project ↗ noun project是一个以黑白图标为主的素材网站，可下载黑白图标使用，使用场景多在视频插图和PPT插图中。不得不说，图片还都挺有逼格的。\n","date":"2025-02-13","tags":["暂无"],"title":"营销人必看网站 ","url":"/post/2025/02/marketing_must-see_website/"},{"content":"为什么在茶叶、粮油这些大市场中出现不了大品牌、大公司呢？ 简单来说就是：低壁垒 + 弱规模经济 + 强需求分化\n同样是与“喝”相关的行业，白酒、红酒、啤酒都有市场认知度极高的品牌，甚至“股王”级上市公司。咖啡领域有星巴克和瑞幸，后者拥有国内最大的直营网络，如今颇有东山再起的架势。但规模超万亿的茶行业，强势的品牌或公司却不多。新华社 2008 年曾提出疑问：“七万中国茶厂，为何不抵一家立顿”。14年后的今天，行业依然缺少一个响亮的“大品牌”。问题出在哪里了？\n在探讨为何茶叶、粮油等大市场中难以出现大品牌和大公司之前，我们需要从市场规模和市场集中度两个基本维度进行分析。一个企业要想做大，首先需要一个规模巨大的市场，其次这个市场不能过于分散。茶叶、粮油等行业虽然市场规模庞大，但市场结构却高度分散，缺乏具有统治力的品牌。这种分散的市场结构背后有多重原因，理解这些原因并找到解决方案，可能会让你成为行业的巨头。\n市场分散的根本原因 进入壁垒不高 根据迈克尔·波特的《竞争战略》，进入壁垒不高的行业意味着新竞争者可以轻易进入市场，抢夺市场份额。茶叶、粮油等行业的技术门槛相对较低，导致市场上存在大量小型企业和个体经营者，难以形成规模效应。\n缺乏规模经济或经验曲线 在某些行业中，规模扩大并不能显著降低成本或提高竞争力。例如，美国的龙虾捕捞行业，拥有1艘船和100艘船的成本几乎相同。茶叶和粮油行业也存在类似问题，生产规模的扩大并不能显著降低单位成本，导致企业难以通过规模经济建立竞争优势。\n运输成本高 运输成本高的行业，即使企业能够形成规模效应，也难以将产品销往全国。例如，石头开采行业由于运输成本高，企业通常只能服务于本地市场。茶叶和粮油行业也存在类似问题，尤其是粮油产品，运输成本限制了企业的市场扩展。\n存货成本高或销售波动大 存货成本高或销售波动大的行业，规模效应带来的好处会被抵消。例如，电影行业的销售波动极大，企业难以预测销售量。茶叶行业也存在季节性波动，导致企业难以通过规模效应稳定盈利。\n规模不经济 在某些行业中，规模扩大反而会导致效率下降。例如，广告行业主要依赖创意，规模扩大并不能保证创意质量的提升，甚至可能导致平均创意质量下降。茶叶和粮油行业也存在类似问题，尤其是茶叶行业，手工制作和个性化需求使得大规模生产难以满足消费者需求。\n顾客需求过于分散 顾客需求过于分散的行业，难以通过单一产品满足所有消费者。餐饮行业是最典型的例子，尤其是中国餐饮行业，由于各地口味差异巨大，没有任何一家企业能够满足所有消费者的需求。茶叶行业也存在类似问题，不同地区、不同消费者对茶叶的口感、香气等需求差异巨大，导致市场高度分散。\n新兴行业 新兴行业通常处于激烈竞争和发展阶段，尚未形成行业集中。茶叶和粮油行业虽然历史悠久，但在现代化、标准化方面仍处于发展阶段，尚未形成高度集中的市场结构。\n供应链与标准化问题 供应链的复杂性和产品的非标准化也是导致行业难以集中的重要原因。茶叶、粮油等行业的产品难以实现工业化和标准化，导致企业难以通过大规模生产降低成本并提高效率。产品越标准化，企业越有可能做大。例如，饮料行业虽然竞争激烈，但产品高度标准化，使得大品牌能够通过规模效应迅速占领市场。\n营销背景补充 从营销角度来看，茶叶、粮油等行业的市场分散还与消费者行为和文化背景密切相关。茶叶在中国有着悠久的历史和文化底蕴，消费者对茶叶的需求不仅限于口感，还包括文化认同和情感价值。这种多元化的需求使得市场难以通过单一品牌满足所有消费者。此外，粮油作为日常生活必需品，消费者对价格敏感度高，品牌忠诚度较低，进一步加剧了市场的分散性。\n分散市场的机会与挑战 虽然分散的市场对志在成为行业巨头的企业缺乏吸引力，但对新进入者却是福音。分散的市场没有巨头，进入门槛较低，允许许多小型企业共存。然而，新品牌在分散市场中虽然容易生存，但很快就会遇到增长天花板。要想突破这一天花板，企业需要在产品标准化、供应链优化、品牌建设等方面进行创新。\n结论 茶叶、粮油等行业虽然市场规模巨大，但由于进入壁垒低、缺乏规模经济、运输成本高、顾客需求分散等多重原因，市场结构高度分散，难以出现大品牌和大公司。然而，正是这种分散的市场结构为新进入者提供了机会。通过解决供应链问题、推动产品标准化、满足消费者多元化需求，企业有望在分散的市场中脱颖而出，成为行业巨头。\n《营销笔记》 \u0026ndash; 小马宋\n","date":"2025-02-13","tags":["战略"],"title":"为什么在茶叶、粮油这些大市场中出现不了大品牌、大公司呢？","url":"/post/2025/02/why_cant_big_brands_and_big_companies_appear_in_big_markets_such_as_tea_and_grain_and_oil/"},{"content":" 转载 文章作者：左耳朵耗子 出处： 酷 壳 – CoolShell ↗ 非商用\n分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：\n1）分享内容的保鲜期是很长的，\n2）会被大范围的传递。我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。\n首先，我们先扪心自问一下，我们自己觉得读到的好的技术文章是什么？我不知道大家的是什么，我个人认为的好的文章是下面这样的：\n把复杂的问题讲解的很简单也很清楚。比如我高中时期读到这本1978年出版的《 从一到无穷大 ↗ 》，用各种简单通俗通懂的话把各种复杂的科学知识讲的清清楚楚。还有看过的几本很好的书，有一本是《 Windows程序设计 ↗ 》，从一个hello world的程序开始一步一步教你Windows下的原生态编程。 有各种各样的推导和方案的比较，让你知其然知其所以然。有了不同方案的比较，才可能让人有全面的认识。这个方面的经典作著是《 Effective C++ ↗ 》。 原理、为什么、思路、方法论会让人一通百通。这里面最经典的恐怕就是《 十万个为什么 ↗ 》了，在计算机方面也有几本经典书，有《 Unix编程艺术 ↗ 》、《 设计模式 ↗ 》、《 深入理解计算机系统 ↗ 》等书，以及《 The C10K Problem ↗ 》等很多技术论文。 其实，从教科书，到专业书，再到论文，都有上面这些不错的特质。\n所以，如果你想做一个好的技术分享的话，下面是我总结出来的方法，供你参考。\n先描述好一个问题。这样能够听众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来就说What，或是直接冲进答案里。这样的分享是在灌输和填鸭。把Why说清楚。没有Why，直接谈What的技术分享，通常来说价值不大。\nHow 比 What 重要\n。在讲 How 的时候，也就是如何解这个问题。\n先要把问题模型说清楚，有了问题模型这个框框后，方案才有意义。 然后要有不同技术的比较。有了比较后，听众才会更相信你。 直接上 What 的技术细节，其实没有太大意义。 一定要有Best Practice或方法论总结，否则上不了档次的。也就是分享中大家可以得到的重要收获。\n说明了这个模型就是：问题 –\u0026gt; 方案 –\u0026gt; 总结。这其中是有一定的心理学模型的，具体表现如下：\n用问题来吸引受众，带着受众来一起思考 用问题模型来框住受众的思考范围，让受众聚焦 给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。 最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。 整个过程会让受众有强烈的成长感和收获感。 这里有几个示例，也是我在我司 MegaEase 内部的技术分享，供你参考（ 我个人的YouTube频道 ↗ ）\n技术分享： Prometheus是怎么存储数据的 ↗ （Youtube）\n技术分享： Distributed Lock Manager ↗ （Youtube）\n下面是我写在我们公司内的Knowledge Sharing中的Best Practice，供参考\nSharing Guideline Please follow the following sharing protocols\nUnderstand Sharing Sharing is the hard way to learn knowledge. The presenter gains the biggest advantages. not audience. 分享是学习知识的最难的方式。分享者获得的好处最最多的，而不是观众。 Sharing can open the knowledge door for the audience, but you have to walk to knowledge by yourself. 分享可以为听众打开知识的大门，但你能不能获得知识还要靠你自己。 Best Practices To perform a great sharing, please follow the below practices.\nDo not share a big topic, a small topic is better. A big topic could make the audience lose focus. Remember, Less is More! ↗ Sharing time less than 60 mins is the best. English language for slides is preferred. While prepare the sharing contents, it’s better to discuss with the senior people to help you to see the whole picture, understand the good side and bad side, know what you don’t know … etc. Strong Recommend Materials Outlines What’s the Problem? How to Solve the Problem? The Best Solution or Practice. The Mechanism, Key Techniques, and Source Code Pros/Cons References (Further reading) For example, if you want to sharing a topic about Docker. the following outlines would be good one:\nWhat’s the major problems need to solve. (Provision, Environment, Isolation etc.) The Alternative solutions. (Puppet/Chef/Ansible, VM, LXC etc.) The Best Solution – Docker. Why? Docker’s key techniques – image, cgroup, union fs, namespace… Docker’s Pros/Cons Further reading list. （全文完）\n","date":"2025-02-12","tags":["暂无"],"title":"【转载】如何做一个有质量的技术分享","url":"/post/2025/02/how_to_make_a_quality_technology_sharing/"},{"content":" 说服一个人很难，说服一群人很容易。要敦促个体改变行为，就把它扔到一群人中。\n爱德华·伯尼斯\n**爱德华·伯尼斯（Edward L.Bernays）**被称为公关之父（美国一共有三个人得到这个称号，其他两个是巴纳姆、艾维·李）。出身维也纳，著名心理学家佛洛伊德的外甥，是公共关系学科化的先驱者，纽约大学教授。\n伯奈斯的舅舅是弗罗伊德。他从舅舅对人性的研究处获得了许多灵感。 他在1928年出版的《宣传》书中提出：“人们的思想和行为是出于对被压制欲望的补偿性替代，我们对一件事情的欲望并非因其内在的价值或用处，而是由于我们无意识的在其中看到了另外一些事情的象征，或者从中看到了我们羞于承认的另一种欲望。”\n20世纪20年代末，香烟公司开始有选择地向女性群体打造广告。爱德华·伯内斯（Edward Bernays）策划了 “自由火炬” 游行活动，让女权主义者高举香烟品牌在第五大道进行游行，并说出最著名的那句话：“我们抽的不是香烟，而是自由的火炬。” 这一运动成为公共关系史上的传奇里程碑。伯内斯的成功在于，他将当时仍处于 “我需要所以我购买” 的消费心理转变为 “我想要所以我购买”。\n一、女性与香烟 历史禁忌 1908 年的纽约，一个警察跑向了一位女士，并且边跑边劝阻对方「女士，你不能这样做。」但对方并没有听从他的警告停止自己的行为，而是对警察喊了一句「Alderman Sullivan 说的吗？」随后，警察逮捕了这位女士。\n这位被捕的女性朝对方所喊的 Alderman Sullivan 也并非是一个人名，其指代的是在 纽约市参议会通过的一项市政法 ↗ ，公共场所管理人员应该禁止妇女在其管辖场所内吸烟。\n不过这个短暂的法令只存在了两个星期，之后便被市长否决。被警察逮捕的 Katie Mulcahey 是唯一因违反条例而被捕的人。她被罚款了 5 美元，又因拒绝支付罚款而被捕。\n在20世纪之前，吸烟被视为一种腐败且不适合女性的行为。17世纪的荷兰画家将香烟视为人类愚蠢的象征，而在19世纪，香烟更是被视为“堕落妇女”和妓女的道具。1904年，一位名叫珍妮·拉舍尔（Jennie Lasher）的妇女因在孩子们面前吸烟而危及孩子们的道德，最终被判处30天监禁。\n此外，国际烟草联盟游说电影制片人不要让吸烟的女性出现在电影中，除非所描绘的女性是具有“不光彩”的性格。以上一系列的行为，都将吸烟视为一种不道德的活动和潜在威胁。\n社会变革 第一次世界大战期间，因男性大部分上战场打仗，女性逐渐开始参与到社会工作中以填补劳动力，自此女性的社会地位开始被重视。尽管如此，对于当时社会而言，吸烟是男性才能被允许做的行为，女性则被排除在外，背后无不反映社会地位和分工不平等。\n二、自由火炬运动 1928 年，美国烟草公司总裁 George Washington Hill 就意识到了女性身上可能存在的潜在市场。在他看来，未被突破的女性市场就是开在前院的一座金矿。\n紧接着，针对女性的营销活动到来了。由于大部分的女性始终都在追求光滑的脸蛋和纤瘦的身材。因此，为了吸引那些注重自己外表的女性，香烟的第一个营销活动是围绕着帮助减肥展开了。\n虽然该系列的海报仅有一张是专为女性而设计，但整个战略的宣传效果却非常出色。Lucky Strike 成了美国排名第一的卷烟品牌，其销售额在短短一年内增长 300％。美国女性吸烟者的比例也从 5 ～ 6％（1924 年）跃升至女性的 12 ～ 16％（1929 年），至少增加了 400 万新女性吸烟者。\n但这只是开始，在公共关系之父 Edward Bernays 的策划下，未来两年最畅销的烟草品牌 Lucky Strike 接下来的一步就把香烟和女权运动紧紧地联系在了一起。\n策划与执行 1929年，时值美国女权运动的高潮，女性开始争取自身的社会权利和地位。著名的美国公关之父爱德华 · 伯内斯得到了著名精神心理学家弗洛伊德的学生 A.A. Brill 的建议，Brill 表示“女性的解放抑制了她们许多欲望。香烟，让女性可以获得和男性一样的平等地位，成为自由的火炬。” 受此启发， 1929 年，伯内斯决定付钱给妇女，让她们在纽约复活节周日游行时吸烟，让她们抽着一根又一根“自由火炬”。这一场面让大众颇为惊讶，因为在那之前，女性只被允许在某些私密场所吸烟，绝不可能如此的 “光明正大”。\n媒体效应 随后，各大媒体纷纷以这句话作为标题，配上很酷的女性吸烟照片，把这件事当做 “女权运动” 的里程碑报道。伯内斯在挑选参加游行的女性时也非常小心，尽量让她们看起来不要太 “模特化”。他还聘请了自己的摄影师，以确保拍摄出好的照片，然后在世界各地发布。在活动当天，女权主义者露丝·黑尔（Ruth Hale）呼吁女性加入游行，她大喊，“女性，在点燃自由的火炬对抗另一种性禁忌！” 这段视频发布后被视为是对平等的抗议，并引发了全国范围的热议。\n三、消费心理的转变 从 “Need” 到 “Want” 第一次世界大战结束后，1920年开始出现经济急剧衰退。美国巨头面临的众多问题之一是普通公民的消费该如何提高。许多人只购买他们真正需要的东西，而真正需要的东西却非常有限，因此品牌商家们希望改变这种行为。华尔街银行家保罗·马祖尔（Paul Mazur）用一种特别直接的方式总结了这一点，“我们必须将美国从需求文化转变为欲望文化。人们必须被训练去渴望，甚至在旧事物被完全消耗之前就想要新事物。”\n伯内斯出身维也纳，是著名心理学家弗洛伊德的侄子。他从舅舅对人性的研究处获得了许多灵感。他在1928年出版的书中提出，“人们的思想和行为是出于对被压制欲望的补偿性替代，我们对一件事情的欲望并非因其内在的价值或用处，而是由于我们无意识的在其中看到了另外一些事情的象征，或者从中看到了我们羞于承认的另一种欲望。”因此，伯内斯得出结论：人性偏见和欲望是脆弱的，也极其容易被利用以达到商业目的。\n自由火炬的象征 回到 “自由火炬” 案例。伯内斯首先不是直接推销香烟，因为当时香烟作为一种非刚需产品对于大部分人来说，特别是女性而言，并没有强烈的购买欲望。相反，伯内斯先是跳出香烟本身，找到女权主义这个思潮，然后从思潮中感知有越来越多的女性想要更独立，迫切地想去打破男人的控制，以得到自由的心理需求，去找出女性对香烟需求背后的 “欲望动机”。吸烟，不再是一种女性的需要，而是女性对自由向往、人权平等欲望的具体表象化。\n随后，伯内斯再通过夺人眼球的事件策划，将香烟打造为寓意自由的象征符号 “自由火炬”。最终，女性蜂拥而至购买香烟，并纷纷希望通过香烟而得到自由的 “仪式感行为”。伯内斯之所以能把需求文化转变为欲望文化，关键在于把具体诉求融入普遍人性或宏大的语境，再从普遍人性或宏大语境中重返具体形式，打造现实的仪式感。\n四、利用权威信息创造需求 伯内斯相信，如果操纵所谓独立的象征人物来利用无意识的愿望和恐惧，人类的行为就可以被有效地操纵。比如，以健康的名义推荐早餐。\n培根是现在美式早餐中很常见的一个组成部分，但在 20 世纪初的时候，培根还主要在午餐和晚餐中食用。培根销量的下降让 Beech-Nut 在 1925 年找到了伯内斯，想要他为提高自家的培根销量献计献策。\n做了一番调查之后，伯内斯发现美国人大多在早餐时吃得非常清淡，就一杯咖啡、或者一个面包卷加橙汁。如何改变人们现有习惯让他们在早餐里加上培根？成为了至关重要的一点。老套的宣传方式是不断重复对消费者的某种刺激从而让他们改变习惯，比如轰炸式的全页广告加上各种优惠信息。但是，伯内斯却想出了利用 “专家权威宣传” 的创新方法。\n他利用话术访问了 4500 位医生，问他们丰盛的早餐是否比简陋的早餐更好？以及有培根的早餐是否算是丰盛的？结果，医生给出的答复是：丰盛的早餐较为健康，搭配上培根算得上是一顿丰盛的早餐。随后，伯内斯在全国的报纸上刊登了 “4500位医生建议更丰盛的早餐” 的消息，并另外发表文章表明培根和鸡蛋应该是一顿早餐的核心。自此，培根的销量果然上去了，美国人也摈弃了只有咖啡面包的清淡早餐，逐渐让培根成为美式早餐的经典配套。\n伯内斯这种策略在当时很新颖，联合果品公司、宝洁公司或通用电气等大公司的老板们对伯内斯的这一方法着迷，纷纷涌向他位于曼哈顿的公关公司，甚至不惜花费巨资寻求他的建议。\n五、制造公众认可 “改变民意” 伯内斯经常与弗洛伊德通信，并受到他的影响，开始了解无意识、渴望、情感和本能的力量。他利用它们来宣传任何他面向大众销售的东西，包括人造花、留声机、政客团体，甚至是意识形态。不管是什么，他都总能按照某种创新手法进行宣传，作家拉里 · 泰伊曾这样描述他，“他创造了事件，事件产生了新闻，而新闻又产生了对他出售的东西的大众需求。”\n在伯内斯看来公关顾问最重要的任务，他将其称为 “事件的创造”，即根据客户的目标，策划一系列的事件以影响消费者的购买行为。这一手法，在当时确实是创新，在此之前商业广告相对简单，只需大力宣传其产品及其功能优势。受古斯塔夫 · 勒庞大众心理学原理的影响，伯内斯相信，如果利用无意识的欲望和恐惧，人类的行为就可以被有效地操纵。比如，像上文提到的以健康的名义出售培根丰盛早餐、以平等的名义出售女权主义香烟。\n此外，伯内斯的公关策略迅速扩展到了 “第三方” 组织的利用，即雇用第三方机构作为舆论的引导者。这种策略在当时很新颖，他开始组建 “前线团体”，看似独立的组织声称支持共同利益，如食品和饮料卫生分配研究和促进委员会、广播声音艺术学院、温度研究基金会等等所有看似无害的协会，实际上都是伯内斯为了公关目的而设立的。他将自己描述为 “为宣传而进行的宣传者”，甚至在第一次世界大战后也试图恢复这个词的负面含义。当时 37 岁的伯内斯写道，“聪明人必须认识到，宣传是一种现代工具，他们可以通过它为各种目标而奋斗。”\n然而，伯内斯对公共关系有着更广阔的视野，超越了营销活动的狭隘范围对他来说，公关是保证社会平稳运转的工具。由于 “群众” 无法做出理性决策，因此 “有意识地、明智地操纵群众的习惯和意见是民主社会的一个重要因素”。他的女儿、小说家安妮·伯奈斯（Anne Bernays）在 2002 年 BBC 纪录片中回忆道，“民主对我父亲来说是一个很棒的概念，但他并不认为所有公众都有可靠的判断力。”\n这种立场，是在 20 年代是非常典型的美国精英情绪：他们相信，由于第一次世界大战的宣传经验，公众变得非常不理性，因此必须要控制起来。如果香烟、培根和留声机可以让大众接受，那么意见、意识形态或政客思想也同样可以 “卖给” 大众。对于伯内斯来说，他将这种公关技巧称为 “制造公众认可”。\n受到伯内斯 “制造公众认可” 一说的影响，公关行业从业者开始陆续 “效仿” 1990 年 10 月，在国会山，一名名叫 “Nayirah” 的15岁科威特女孩在国会人权核心小组的公开听证会上表示，她在科威特一家医院做志愿者时，看到伊拉克士兵将婴儿从保温箱中取出，让他们 “在冰冷的地板上等死”。700 多家电视台播出了 “纳伊拉护士” 的露面，震惊了美国公众并最终说服其对萨达姆侯赛因领导下的伊拉克采取军事行动。三个月后，背后的真相开始被揭示。这位15岁的“护士”原来是科威特驻美国大使的女儿，纽约公关公司伟达（Hill and Knowlton）是这个事件的幕后黑手，它想借此事件说服美国公众对伊拉克发动打击。\n这一事件具体来说，就是利用大众一种情绪（在本例中是恐惧）塑造一个可信的象征人物（15岁的护士），并将其置于一个明显的自然事件（她出现在国会）中，从而一步步制造一系列的新闻，再通过新闻反过来影响更多目标受众。\n伯内斯的职业生涯跨越了 80 多年，在这 8 个十年中，他的思想改变了现代西方社会的结构。什么是真实的事件，什么只是表面上真实的事件？什么是信息，什么是伪装成信息的操纵？一代又一代的公共关系从业者延续了伯奈斯的思想精华。自此，伯内斯也被越来越多人熟知，并于 1990 年被美国权威媒体评选为 20 世纪 100 位最重要的美国人之一。\n六、学科视角 伯内斯的策略深刻挖掘了人类的潜意识欲望。他利用弗洛伊德的理论，认为人类的行为往往受到无意识欲望的驱动。通过将香烟与自由、平等这些深层次的心理需求联系起来，伯内斯成功地激发了女性的购买欲望。这种策略不仅改变了女性的消费行为，也深刻影响了整个社会的消费心理。\n“自由火炬” 运动反映了当时社会对女性角色的重新定义。通过将吸烟行为与女权主义联系起来，伯内斯不仅打破了传统的性别角色限制，还推动了女性在社会中的地位提升。这一运动不仅是商业上的成功，也是社会变革的一个重要标志。\n伯内斯的策略展示了如何通过媒体和事件策划来影响公众舆论。他不仅利用了传统媒体的力量，还通过精心策划的事件和象征性的人物来制造新闻，从而达到了广泛传播的效果。这种策略在现代传播学中仍然具有重要的参考价值。\n七、伯内斯的遗产与当代启示 公关与消费主义的兴起 伯内斯的“自由火炬”运动不仅是公共关系史上的里程碑，更是消费主义兴起的重要标志。通过将香烟与女性解放、自由等宏大主题绑定，伯内斯成功地将一种非必需品转化为象征身份和价值观的消费品。这种策略为后来的品牌营销提供了范本，尤其是在奢侈品、时尚和生活方式领域。今天的品牌依然在利用类似的手法，将产品与情感、身份认同和社会地位挂钩，激发消费者的“我想要”心理。\n公关与信息操控的边界 伯内斯的成功也引发了对信息操控边界的深刻反思。他利用心理学、媒体和权威信息来塑造公众认知，这种方法在当代依然被广泛使用，尤其是在政治宣传和社交媒体营销中。然而，随着信息的透明度和公众批判意识的提高，这种操控手段的伦理问题也日益凸显。如何在商业利益与社会责任之间找到平衡，是现代公关从业者必须面对的挑战。\n数字化时代的公关挑战 在数字化时代，信息传播的速度和广度远超伯内斯的时代。社交媒体、算法推荐和用户生成内容（UGC）使得公众舆论更加复杂和多变。品牌不仅需要应对正面宣传，还要时刻警惕负面信息的迅速扩散。此外，虚假信息（Fake News）和深度伪造（Deepfake）技术的出现，使得辨别真实与虚假变得更加困难。这要求现代公关从业者不仅要具备传统公关技巧，还要掌握数据分析、危机管理和技术工具。\n社会责任与道德公关 伯内斯的策略虽然成功，但也引发了关于公关道德性的争议。他利用人性弱点和潜意识欲望来推动消费，这种行为在当代可能会被视为操纵和剥削。随着社会对可持续发展、社会责任和道德消费的关注增加，品牌越来越需要将道德价值观融入公关策略中。例如，许多品牌现在强调环保、公平贸易和多样性，以赢得消费者的信任和支持。\n八、现代公关的演变 伯内斯的公关策略对现代社会产生了深远的影响。他的“制造公众认可”理念在现代公关中得到了广泛应用。例如，现代企业通过社交媒体和KOL（关键意见领袖）来影响公众舆论，这与伯内斯利用“前线团体”和象征性人物的策略如出一辙。\n苹果公司的产品发布会是一个典型的现代公关案例。通过精心策划的发布会和媒体宣传，苹果不仅成功吸引了全球的关注，还塑造了其产品的独特形象。这种策略与伯内斯的 “事件创造” 理念高度相似，都是通过制造新闻来影响公众的购买行为。耐克的 “Just Do It” 是另一个成功的现代公关案例。通过将运动与个人成就、自由等深层次的心理需求联系起来，耐克不仅提升了品牌形象，还成功激发了消费者的购买欲望。这种策略与伯内斯的“自由火炬”运动有着异曲同工之妙。\nDove 的 “Real Beauty” 通过展示不同体型、年龄和肤色的女性，成功地挑战了传统的美容标准，并引发了广泛的社会讨论。这种策略不仅提升了品牌形象，还赢得了消费者的信任和忠诚。这与伯内斯通过社会运动来影响公众舆论的策略高度相似。\n当下的公关现状 纵观当下，今天的公关其实比伯内斯那个时代更复杂也更有趣。与伯内斯时代相比，现代公关营销在数字化转型和社交媒体的影响下发生了巨大变化。现在，企业可以利用互联网和社交媒体平台直接与受众互动，而不仅仅依赖传统媒体。这带来了更多的互动和反馈机会，但也增加了管理声誉和传播信息的复杂性。\n其次，现代公关和营销更加注重个性化。通过数据分析和定位技术，企业可以更精确地了解其目标受众，以提供定制化的内容和广告。这与伯内斯时代的广告和宣传方法相比，更加精细和针对性。此外，互联网和社交媒体使信息传播更加迅速，因此危机管理变得更为关键。现代公关团队需要在短时间内迅速应对负面事件，这要求更加迅速和敏捷的反应能力。\n现代社会中的公关营销在技术、互动性、个性化和社会价值观等方面与伯内斯时代的理念都有着明显的不同。尽管伯内斯的基本原则仍然适用，但公关和营销领域已经适应了数字时代的挑战和机遇，并采取了更加现代化和多样化的方法来与受众互动和塑造品牌形象。\n公关的反思 在此刻，我们可以回顾并重新思考，“公共关系之父”伯内斯对人类心理的理解和说服做出的重大贡献，并从他身上吸取许多丰富的经验，如宣传和说服的力量、挖掘潜意识欲望、创造公众舆论、利用专家和权威的作用等等。此外，在使用营销技巧时，我们还要注重道德问题，考虑我们行为可能给社会及大众带来的的道德影响。而社会下的一切公关手段，都值得有关责任的广告主、媒体和传播专业人员反思，其背后是否符合道德的准则。\n回望伯内斯过去的成就和经验，可以帮助我们更好地理解说服人的力量、潜意识欲望的作用以及道德在沟通中的重要性。有效地利用伯内斯的这些经验，可以让我们未来成为对信息更具知情权的消费者，并在事件的传播过程中也会优先考虑是否违反道德标准等问题。\n随着社会发展和科技进步，伯内斯的行为很容易被“无限放大”。作为一个聪明的消费者，我们应该将他过去的事迹作为一种警惕，避免掉入“消费陷阱”。同时，作为一名优秀的商人，如何将自身品牌做到可持续性发展，而不是采用“利用人性弱点而进行获利”的营销手段作为目的，是当今品牌发展至关重要的一环。\n九、结语 爱德华·伯内斯的“自由火炬”运动不仅是公关史上的经典案例，更是消费主义和文化变迁的重要标志。他的策略揭示了人性欲望与消费行为之间的深层联系，同时也引发了关于信息操控和公关道德的深刻反思。在数字化和全球化时代，公关行业面临着前所未有的机遇和挑战。如何在商业利益与社会责任之间找到平衡，如何利用新技术和新平台与消费者建立更紧密的联系，将是未来公关从业者需要不断探索的课题。\n十、参考 “我们抽的不是香烟，而是自由的火炬” 的营销背后 ↗ 香烟曾被包装为女性的「自由之火」，事实上它是「自由的枷锁」 ↗ Reach For A Lucky: The Lucky Strike Cigarette Diet (1928) ↗ 普勒剖析公关之父经典案例：“香烟点燃自由的火炬” ↗ 女人为何抽烟？背后其实有一个营销大策略 ↗ 《大众传播媒介》 《公关之父：爱德华·伯内斯与现代公关的诞生》（The Father of Spin: Edward L. Bernays and the Birth of Public Relations） 《消费主义的崛起：从伯内斯到数字化时代》 ","date":"2025-02-11","tags":["公关"],"title":"自由火炬运动：从“我需要所以我购买“到”我想要所以我购买“","url":"/post/2025/02/freedom_torch_movement_from_i_need_it_so_i_buy_it_to_i_want_it_so_i_buy_it/"},{"content":" 我的一个朋友在做蛋糕，口味非常好，我每次去玩总会吃到免费的蛋糕，但是每只最多只能吃两个，但那远远还未到饱腹感，为什么？\n分析部分：快乐为何转瞬即逝的秘密 快乐总是转瞬即逝。回想一下上次吃美味的蛋糕时的情景：蛋糕摆在面前，糖霜闪闪发光，味蕾兴奋不已，期待着即将品尝到的味道。当你用叉子叉起一口蛋糕放入口中时，那种满足感瞬间达到顶峰，甚至让你闭上眼睛细细品味。然而，这种快乐持续了多久？几分钟后，快乐感逐渐消退，甚至可能被其他情绪所取代。\n快乐的生物学基础：进化与神经机制 从生物学角度来看，快乐感往往在首次体验某件事情时达到顶峰。例如，第一口芝士蛋糕、第一次驾驶新车、第一次穿上新运动鞋跑步，这些体验带来的快乐感最为强烈。然而，随着重复体验，快乐感会逐渐减弱。第二次尝试时，快乐感已经不如第一次强烈，到了第三次，可能已经索然无味。这种现象被称为“享乐适应”（Hedonic Adaptation），即人们对重复刺激的反应逐渐减弱。\n从进化心理学的角度来看，这种机制有助于人类的生存。许多带来快乐的事物，如食物、性和安全感，都是生存所必需的。如果我们在获得这些资源后感到长期的满足，可能会失去继续追求的动力。因此，大脑通过短暂的快乐感来激励我们不断追求新的目标，从而保持生存和繁衍的动力。正如心理学家丹尼尔•内特尔（Daniel Nettle）在《幸福：追求比得到更快乐》一书中所指出的：“幸福感是进化的根基，它充当的不是实际的奖赏，而是一个想象中的目标，给我们提供方向。”\n心理学视角：快乐水车效应与目标追求 心理学中的 “快乐水车”（Hedonic Treadmill）理论进一步解释了这种现象。该理论认为，人们在追求目标时会感到兴奋和满足，但一旦目标实现，快乐感会迅速消退，转而追求下一个目标。例如，小时候你可能会恳求父母数月，希望得到一辆新自行车。当你在圣诞节终于得到它时，快乐感达到了顶峰。然而，几天后，这种快乐感逐渐消退，你开始寻找下一个目标，比如一个新的玩具或游戏。\n哥伦比亚大学商学院的一项研究为这一现象提供了实证支持。研究人员分析了 300 多部丢失的 iPhone 数据，发现就在新机型发布之前，丢失数量出现了显著增加。此外，对 600多台iPhone丢失和损坏的自我报告分析显示，新机型发布后，iPhone 的丢失数量小幅上升。这一现象表明，人们可能会在潜意识中为自己寻找借口，以便购买最新款的手机。这种行为反映了 “快乐水车” 效应：人们在追求新目标时感到兴奋，但一旦目标实现，快乐感迅速消退，转而追求下一个目标。\n行为经济学视角：适应性偏好与决策偏差 从社会心理学的角度来看，快乐感的短暂性也与“社会比较”有关。人们往往会将自己的生活与他人进行比较，尤其是在社交媒体时代，这种比较变得更加频繁和直接。当我们看到他人拥有更好的物质条件或更高的社会地位时，我们可能会感到不满足，从而产生新的欲望。这种社会比较机制进一步推动了“快乐水车”效应，使人们不断追求新的目标。\n行为经济学中的“适应性偏好”（Adaptive Preferences）理论也与此相关。该理论认为，人们的偏好会随着环境的变化而调整。例如，当我们获得某种物质财富时，最初会感到快乐，但随着时间的推移，我们会逐渐适应这种状态，并开始追求更高的目标。这种适应性机制解释了为什么物质财富的增加并不一定会带来长期的幸福感。\n社会心理学视角：社会比较与期望管理 社会心理学强调，社会比较和期望管理在快乐的短暂性中扮演重要角色。人们往往通过与他人比较来评估自己的幸福感，而这种比较会导致“相对剥夺感”（Relative Deprivation）。例如，即使收入增加，如果周围人的收入增长更快，个体的快乐感也可能下降。\n此外，期望值的升高也会削弱快乐的持久性。研究表明，高收入者往往因更高的期望而感到不满足，而低收入者可能因较低的期望而更容易感到快乐。\n实证研究与实际案例 丹尼尔•卡尼曼（Daniel Kahneman）与安格斯•迪顿（Angus Deaton）在2010年的一项研究中探讨了收入与幸福感之间的关系，结果显示：收入增加带来的快乐感是短暂的。尽管收入的增加会带来短期的幸福感提升，但随着时间的推移，人们会逐渐适应新的收入水平，幸福感也会回归到基线水平。\n另一个实际案例是“彩票赢家研究”。心理学家菲利普•布里克曼（Philip Brickman）及其同事在1978年进行的一项研究发现，彩票赢家在赢得大奖后的几个月内，幸福感显著提升，但随着时间的推移，他们的幸福感逐渐回归到中奖前的水平。这一研究进一步证实了“享乐适应”现象的存在。\n保持渴望 快乐感的短暂性源于人类的心理和进化机制。从生物学角度看，短暂的快乐感能够激励我们不断追求生存所需的资源。如果人类在实现目标后长期满足，可能会失去继续前进的动力，因为此时会觉得进一步的探索和追求失去了必要性。从进化角度看，长期的满足或满意状态并不利于生存，因此大脑演化出了这样一种机制：在获得满足的瞬间，反而不会体验到强烈的快乐或满足感，而是迅速将其淡化。\n这得以让我们始终保持对新目标的渴望，从而推动我们不断追求，以确保生存和繁衍的持续进行。换句话说，大脑通过短暂地体验满足或快乐，促使我们不断寻找新的“诱饵”，维持内心的渴望，进而保证人类在进化过程中始终保持积极的探索和追求行为。\n实践部分：营销实践分析——利用快乐短暂性的策略 快乐的短暂性为营销实践提供了重要启示。通过理解消费者心理和行为机制，品牌可以设计出更具吸引力的营销策略。以下是几种常见的策略，结合现实案例进行详细分析：\n1. 产品迭代与创新：耐克的 “Just Do It” 与运动鞋文化 耐克（Nike）是产品迭代与创新的典范。通过不断推出新款运动鞋，耐克成功利用了消费者的“享乐适应”心理。例如，耐克的 Air Jordan系列每年都会发布新款，每一代产品都在设计、技术和性能上有所突破。消费者在购买新款球鞋时，会感受到强烈的兴奋和满足，但这种快乐感往往在几周或几个月后逐渐消退。\n耐克通过限量发售和联名合作（如与设计师、艺术家或明星的合作）进一步激发了消费者的渴望。例如，2019年耐克与说唱歌手Travis Scott合作的“倒钩”Air Jordan 1，一经发布便引发抢购热潮。这种策略不仅利用了消费者的“快乐水车”效应，还通过稀缺性强化了产品的吸引力。\n耐克的成功在于它深刻理解消费者对新目标的追求。通过不断推出新产品，耐克让消费者始终处于“追求”状态，从而维持品牌忠诚度和市场份额。\n2. 体验营销：迪士尼的魔法王国 迪士尼（Disney）是体验营销的经典案例。迪士尼乐园不仅仅是一个游乐场，而是一个充满魔法和故事的沉浸式体验。游客在乐园中不仅可以体验游乐设施，还能与迪士尼角色互动、观看表演、参与主题活动。这种全方位的体验将短暂的快乐转化为持久的记忆。\n例如，迪士尼的“魔法手环”（MagicBand）技术让游客能够无缝体验乐园的各项服务，从入园到购物再到餐饮，全程无需现金或门票。这种便捷的体验不仅提升了游客的满意度，还延长了他们的快乐感。\n迪士尼还通过季节性主题活动（如万圣节派对、圣诞庆典）和限量周边商品，不断为游客创造新的体验目标。这种策略让游客每次到访都能感受到新鲜感，从而避免“享乐适应”带来的快乐消退。\n3. 期望管理：特斯拉的科技与未来感 特斯拉（Tesla）通过管理消费者的期望值，成功塑造了高端电动汽车品牌形象。特斯拉的广告宣传不仅强调产品的性能（如续航里程、加速能力），还突出其科技感和未来感。例如，特斯拉的自动驾驶功能（Autopilot）被宣传为“改变未来出行方式”的技术，这种高期望值让消费者对品牌充满向往。\n然而，特斯拉并没有过度承诺。相反，它通过逐步推出新功能（如OTA软件更新）来满足消费者的期待。例如，特斯拉车主可以通过软件更新获得新功能或性能提升，这种“持续交付价值”的策略让消费者始终保持对品牌的兴趣和忠诚。\n特斯拉还通过限量发售和高端定位（如Model S Plaid版）来维持消费者的长期满足感。这种策略不仅避免了因期望过高导致的失望，还让消费者感到自己拥有的是独一无二的产品。\n4. 激发社会比较：奢侈品牌的社交媒体营销 奢侈品牌如路易威登（Louis Vuitton）和古驰（Gucci）通过社交媒体激发消费者的社会比较心理，促使他们追求更高的目标。例如，路易威登在Instagram上发布明星和网红佩戴其产品的照片，营造出一种“理想生活方式”的氛围。消费者在看到这些内容后，往往会将自己与明星或网红进行比较，从而产生购买欲望。\n此外，奢侈品牌通过限量发售和高端定位，进一步强化了社会比较的效果。例如，路易威登与艺术家草间弥生合作的限量系列，一经发布便引发抢购热潮。消费者购买这些产品不仅是为了满足物质需求，更是为了获得社会认同和身份象征。\n这种策略利用了消费者的“相对剥夺感”，即当看到他人拥有更好的物质条件时，自己也会产生追求更高目标的动力。\n方法论总结 利用“享乐适应”机制：通过不断推出新产品或新体验，避免消费者对现有产品产生适应性偏好。例如，耐克通过限量发售和联名合作，让消费者始终保持对新目标的追求。 创造独特体验：将产品消费转化为品牌体验，延长消费者的快乐感。例如，迪士尼通过沉浸式体验和季节性主题活动，让游客每次到访都能感受到新鲜感。 管理期望值：通过合理的宣传和定位，避免消费者因期望过高而产生失望情绪。例如，特斯拉通过逐步推出新功能和高端定位，维持消费者的长期满足感。 激发社会比较：利用社交媒体和广告，激发消费者的社会比较心理，促使他们追求更高的目标。例如，奢侈品牌通过明星代言和限量发售，强化消费者的购买欲望。 假设案例：以川菜品牌为例 假设有一个名为“川味坊”的川菜品牌，虽然菜品口味正宗，但销量一直不佳。通过分析快乐的短暂性及其背后的心理机制，我们可以为“川味坊”设计一套全新的营销策略，帮助其提升品牌吸引力和市场份额。\n1. 产品迭代与创新：推出季节性限定菜单 “川味坊”可以通过不断推出季节性限定菜单，激发消费者的新目标追求。例如，在夏季推出“麻辣凉面系列”，在冬季推出“暖锅系列”。每一季的新菜单不仅要在口味上创新，还要在摆盘和食材搭配上突出独特性。\n这种策略利用了消费者的“享乐适应”心理。当消费者尝试新菜品时，会感受到强烈的快乐感，但随着重复消费，这种快乐感会逐渐减弱。通过定期推出新菜单，“川味坊”可以让消费者始终保持对品牌的新鲜感和期待感。\n此外，“川味坊”还可以推出限量版菜品，例如“每日限量50份的秘制麻辣香锅”。这种稀缺性策略不仅能够激发消费者的购买欲望，还能通过社交媒体的传播提升品牌热度。\n2. 体验营销：打造沉浸式川菜文化体验 “川味坊”可以通过打造沉浸式川菜文化体验，将单纯的餐饮消费转化为独特的品牌体验。例如，在餐厅内设置川菜文化展示区，展示川菜的历史、食材和烹饪工艺。消费者在用餐的同时，可以了解川菜背后的故事，甚至参与互动活动，如“DIY麻辣调料”或“川菜烹饪小课堂”。\n此外，“川味坊”还可以定期举办主题活动，例如“川味美食节”或“麻辣挑战赛”。消费者在参与这些活动时，不仅能够享受美食，还能获得独特的体验和记忆。这种策略将短暂的用餐快乐转化为持久的品牌印象，从而提升消费者的忠诚度。\n3. 期望管理：通过故事化营销塑造品牌价值 “川味坊”可以通过故事化营销管理消费者的期望值。例如，在广告宣传中突出品牌的“匠心精神”，讲述主厨如何精选食材、传承川菜技艺的故事。这种宣传不仅能够提升品牌的高端感，还能让消费者对菜品产生更高的期待。\n然而，“川味坊”需要注意避免过度承诺。例如，在宣传中可以强调“每一道菜都是用心制作”，但不要夸大菜品的口味或效果。通过合理的期望管理，消费者在用餐时会感到满意甚至超出预期，从而提升复购率。\n此外，“川味坊”还可以通过会员制度或积分奖励，让消费者感受到持续的回报。例如，消费满一定金额后赠送限量版川味调料或定制餐具，这种策略不仅能够延长消费者的快乐感，还能增强品牌粘性。\n4. 激发社会比较：利用社交媒体制造话题 “川味坊”可以通过社交媒体激发消费者的社会比较心理。例如，在抖音或微博上发布消费者用餐的照片和视频，并配上有趣的文案，如“今天你麻辣了吗？”或“谁能挑战我们的超级辣锅？”。\n此外，“川味坊”还可以邀请美食博主或网红到店体验，并分享他们的用餐感受。当消费者看到这些内容时，往往会将自己与博主或网红进行比较，从而产生“我也要去试试”的冲动。\n为了进一步强化社会比较的效果，“川味坊”可以推出“打卡挑战”活动。例如，消费者在店内拍照并发布到社交媒体上，即可获得折扣或赠品。这种策略不仅能够提升品牌的曝光度，还能通过消费者的自发传播吸引更多潜在顾客。\n方法论总结 利用“享乐适应”机制：通过定期推出新菜单和限量版菜品，避免消费者对现有产品产生适应性偏好。例如，“川味坊”可以每季度推出季节性限定菜单，并设置每日限量菜品，激发消费者的新鲜感和期待感。 创造独特体验：将餐饮消费转化为品牌体验，延长消费者的快乐感。例如，“川味坊”可以通过川菜文化展示、互动活动和主题节日，为消费者创造独特的用餐体验。 管理期望值：通过故事化营销和合理的宣传，避免消费者因期望过高而产生失望情绪。例如，“川味坊”可以通过讲述品牌故事和主厨匠心精神，塑造高端形象，同时通过会员制度和积分奖励，让消费者感受到持续的回报。 激发社会比较：利用社交媒体和话题营销，激发消费者的社会比较心理。例如，“川味坊”可以通过网红打卡、用户生成内容和挑战活动，提升品牌的热度和吸引力。 ","date":"2025-02-11","tags":["快乐"],"title":"快乐为何转瞬即逝？多学科视角下的短暂性解析与营销启示","url":"/post/2025/02/why_does_happiness_pass_so_quickly/"},{"content":"分析篇 在20世纪90年代中期，两位来自底特律的顾问 —— 鲍勃•莫埃斯塔和他的合伙人瑞克•佩迪 —— 专程前往哈佛商学院，拜访了当时刚刚提出颠覆性创新理论的克莱顿•克里斯滕森教授。他们的目标是深入了解这一理论，并探讨如何将其应用于他们的利基业务：为面包店和零食公司提供新产品开发建议。\n颠覆性创新理论在当时已经显示出其强大的预测能力，尤其是在解释根基稳固的企业如何应对来自小型竞争者的威胁时。然而，莫埃斯塔和佩迪发现，尽管这一理论能够清晰地解释因果关系，但它并未为他们的客户提供具体的行动路线图。换句话说，理论虽然能解释“为什么”，但并未明确告诉企业“怎么做”才能成功防御或发起颠覆性创新。\n克里斯滕森教授也意识到，即便企业有意颠覆市场，成功的概率依然低于 25%。这引发了他的进一步思考：为什么有些企业能够成功？他们是如何找到正确的发展路径的？这一问题的对立面——成功企业的秘诀——成为了他新的研究焦点。\n奶昔案例 几个月后，莫埃斯塔与克里斯滕森分享了一个有趣的案例：一家快餐连锁品牌试图通过改进奶昔产品来提升销量。该公司花费数月时间，细致地研究了消费者的需求，询问了典型奶昔消费者的意见，试图通过调整价格、口感、口味等来满足他们的期望。然而，尽管公司根据反馈进行了多次创新，奶昔的销量却毫无起色。\n这一现象促使克里斯滕森从全新的角度思考问题：消费者购买奶昔的真正动机是什么？他们是在“雇用”奶昔来完成生活中的某项任务。这一视角的转变，彻底改变了研究的思路。\n为了深入理解消费者的行为，营销团队在餐厅里进行了长达 18 小时的观察。他们发现，大部分奶昔是在上午 9 点之前售出的，购买者通常是独自一人，且会将奶昔带走。通过进一步询问，团队发现，这些消费者购买奶昔的目的是为了在漫长的通勤途中提神解闷。奶昔的浓稠质地和长时间饮用体验，使其成为比其他选项（如香蕉、甜甜圈或贝果）更优的选择。\n然而，故事并未就此结束。团队还发现，奶昔在下午和晚上也有一定的销量，但消费者购买奶昔的动机却截然不同。这一次，奶昔被“雇用”来完成一项完全不同的任务：父母们用它来安抚孩子，并在忙碌的生活中找到一个可以轻松说“是”的时刻。此时的奶昔不再与早餐食品竞争，而是与玩具店或家庭活动竞争。\n这一发现揭示了产品创新的关键：消费者在不同的情境下会“雇用”同一款产品来完成不同的任务。因此，企业不能简单地通过改进产品本身来满足所有消费者的需求，而必须深入理解消费者在特定情境下的任务，并针对这些任务设计不同的解决方案。\n最终，克里斯滕森得出结论：成功的创新不在于将产品做得“更好”，而在于理解消费者在特定情境下的需求，并为他们提供最合适的解决方案。对于快餐店而言，奶昔的成功并非依赖于单一的改进，而是需要根据不同情境下的任务，设计出两种截然不同的产品策略。这一洞察不仅适用于奶昔，也为其他行业的产品创新提供了宝贵的启示。\n消费者消费一个产品或者服务的时候，不实在消费这个产品本身的属性，而是为了帮助他完成一件生活中的任务，即：消费者任务。\n消费者选择 在早晨的情境中，消费者选择奶昔是因为它在众多选项中提供了最高的边际效用。奶昔的浓稠质地和长时间饮用体验，使其成为通勤途中提神解闷的最佳选择。这种选择不仅满足了消费者的生理需求，还满足了心理需求。消费者通过比较不同选项的成本和收益，最终选择了奶昔。\n此外，奶昔的市场需求并非单一，而是由不同的消费者群体在不同情境下驱动的。\n市场需求 早晨的消费者和下午的消费者对奶昔的需求动机完全不同，这意味着市场实际上被分割为多个细分市场。经济学中的“市场细分”理论可以解释这一点：企业需要通过识别不同消费者群体的需求差异，提供差异化的产品或服务，以最大化市场份额和利润。如果企业试图用“一刀切”的方式满足所有消费者，可能会导致产品无法满足任何群体的需求，从而降低整体效用。\n社会角色 早晨的消费者选择奶昔是因为它在功能上优于其他选项，而下午的消费者选择奶昔不仅是为了满足孩子的口腹之欲，更是为了履行作为“好父母”的社会角色。这种行为反映了家庭文化中的情感表达和亲子互动模式：父母通过满足孩子的需求来建立情感联系，同时也在社会中展现自己的责任感和关爱。社会学中的“角色理论”可以解释这一点：个体的行为往往受到其社会角色的驱动，而消费行为则是履行这些角色的一种方式。\n这种差异表明，市场需求不仅由经济因素（如价格、效用）驱动，还由社会因素（如角色期望、文化符号）塑造。因此，企业在设计产品或服务时，不仅需要考虑经济层面的竞争力和效率，还需要关注社会层面的文化意义和情感价值。\n实践 以剪刀为例\n在企业市场营销中应用\u0026quot;消费者任务\u0026quot;理论，首要任务是要跳出传统的产品属性思维，转而关注消费者在不同情境下想要完成的具体任务。以剪刀为例，传统营销可能过度关注剪刀的锋利度、手柄舒适度等产品特性，而忽视了消费者使用剪刀时所处的具体情境和需要完成的实际任务。\n第一步：识别消费者的核心任务 在传统的市场调研中，企业可能会问消费者：“您希望剪刀有哪些改进？”这种问题往往只能得到表面化的回答，例如“更锋利”或“更耐用”。然而，从“消费者任务”的角度出发，企业需要深入挖掘消费者购买剪刀的真正动机：他们是在什么情境下使用剪刀？他们试图通过剪刀完成什么任务？\n例如，消费者购买剪刀可能出于多种不同的任务：\n家庭日常使用：用于剪开包装、修剪植物或进行手工制作。 办公室使用：用于裁剪文件、制作海报或整理资料。 户外活动使用：用于露营时剪绳子或修剪树枝。 每种任务对应的消费者需求和期望完全不同。例如，家庭用户可能更关注剪刀的安全性和多功能性，而办公室场景则更关注剪刀的便捷性和灵活性。\n第二步：分析任务情境与竞争替代品 在明确了消费者的核心任务后，需要进一步分析消费者在完成任务时所处的具体情境，以及他们可能选择的其他替代品。例如：\n家庭用户：在剪开包装时，消费者可能会选择使用剪刀、美工刀甚至徒手撕开。剪刀的竞争对手不仅包括其他品牌的剪刀，还包括其他工具。 办公室用户：在裁剪文件时，剪刀的竞争对手可能是裁纸机或打孔器。消费者选择剪刀的原因可能是其便捷性和灵活性。 户外用户：在露营时，剪刀的竞争对手可能是多功能刀具或锯子。消费者选择剪刀的原因可能是其轻便性和易用性。 通过分析任务情境和竞争替代品，企业可以更清晰地定位产品的独特价值，并找到差异化的市场机会。\n第三步：设计针对任务的产品和营销策略 基于对消费者任务的分析，企业可以设计出针对不同任务的产品和营销策略。以下以剪刀为例，说明如何针对不同任务进行产品设计和营销。\n家庭用户： 产品设计：开发一款安全剪刀，配备儿童锁和圆头设计，同时具备多功能性（如附带开瓶器或螺丝刀功能）。 营销策略：强调产品的安全性和多功能性，通过家庭场景的广告展示其日常实用性。例如，广告中可以展示一位妈妈用剪刀轻松剪开食品包装，同时用附带功能打开罐头。 办公室用户： 产品设计：开发一款轻便剪刀，附带收纳盒，方便携带和存放。 营销策略：通过办公场景的广告展示其便捷性和高效性。例如，广告中可以展示一位上班族用剪刀快速裁剪文件，同时轻松收纳到抽屉中。 户外用户： 产品设计：开发一款耐用剪刀，采用防锈材料，附带多功能工具（如开瓶器或锯子）。 营销策略：通过户外场景的广告展示其耐用性和多功能性。例如，广告中可以展示一位露营者用剪刀剪断绳子，同时用附带工具打开罐头。 消费者任务回顾 通过“消费者任务”理论，企业可以从更深层次理解消费者的需求，并设计出真正满足这些需求的产品和营销策略。以剪刀为例，企业可以通过识别消费者的核心任务、分析任务情境与竞争替代品、设计针对任务的产品和营销策略，以及持续优化与反馈，实现精准的市场定位和高效的营销推广。\n参考 《与运气竞争》 ","date":"2025-02-10","tags":["心理"],"title":"消费者任务: 分析与实践","url":"/post/2025/02/consumer_task_analysis_and_practice/"},{"content":" 奥威尔在《1984》警告人们将会受到外来压迫的奴役，而赫胥黎则认为，人们失去自由、成功和历史并不是 “老大哥” 之过。在他看来，人们会渐渐爱上压迫，崇拜那些使他们丧失思考能力的工业技术。\n《娱乐至死》\n一、未完成的故事与心理效应 想象一个场景：你的朋友正在给你讲一个故事，但还没讲完就匆匆离开。你会有什么感受？大多数人会感到焦虑和好奇，迫切想知道故事的结局。在不知道结局之前，你很难专注于其他事情。这种对未完成事情的执着，正是心理学中的蔡格尼克效应。\n蔡格尼克效应由立陶宛心理学家布鲁玛·蔡格尼克（Bluma Zeigarnik）发现。她通过实验发现，人们在被打断的任务上表现出更强的记忆力和更高的完成欲望。这一效应不仅在心理学领域具有重要意义，也在现代社会的注意力经济中得到了广泛应用。\n二、蔡格尼克效应的早期实验 蔡格尼克的早期实验与记忆测试有关。她让学生们记忆一系列单词，但在任务进行到一半时打断他们，转而让他们完成另一项任务。结果发现，学生们对被打断的单词记忆更加深刻，并且表现出强烈的愿望，希望尽快完成这项任务。无论任务本身多么无聊，被打断的学生们都对未完成的任务念念不忘。\n图源：百度百科\n这一实验揭示了人类心理中的一个重要特点：我们天生对未完成的事情有一种强烈的执着感。这种心理机制在现代社会中，尤其是在数字平台上，被广泛利用。\n三、奥威尔与赫胥黎的预言 在乔治·奥威尔的《一九八四》中，他描绘了一个令人窒息的恐怖世界：独裁者以追逐权力为最终目标，人性被强权彻底扼杀，自由被剥夺，思想受到严酷钳制，人民的生活陷入了极度贫困。奥威尔警告人们，外来压迫将奴役我们。\n然而，奥尔德斯·赫胥黎（Aldous Huxley）在《美丽新世界》中提出了另一种恐惧。他认为，人们失去自由、成功和历史并不是因为“老大哥”的压迫，而是因为人们会逐渐爱上压迫，崇拜那些使他们丧失思考能力的工业技术。\n奥威尔害怕的是那些强行禁书的人，赫胥黎担心的是失去任何禁书的理由，因为再也没有人愿意读书； 奥威尔害怕的是那些剥夺我们信息的人，赫胥黎担心的是人们在汪洋如海的信息中日益变得被动和自私； 奥威尔害怕的是真理被隐瞒，赫胥黎担心的是真理被淹没在无聊烦琐的世事中； 奥威尔害怕的是我们的文化成为受制文化，赫胥黎担心的是我们的文化成为充满感官刺激、欲望和无规则游戏的庸俗文化。 赫胥黎的预言似乎更接近我们今天所面临的现实。我们并没有被强制剥夺信息，而是自愿沉浸在信息的海洋中，逐渐失去了深度思考的能力。\n四、标题党与吸引注意力的艺术 在这个信息爆炸的时代，利用蔡格尼克效应吸引注意力已经变得无所不用其极。标题党便是其中的典型代表。通过抛出疑问或制造悬念，标题党鼓励用户点击文章，保持关注。\n例如：\n“马上回来，精彩继续！” “一个村民在树林发现惊天秘密\u0026hellip;\u0026hellip;” “男生的秘密，女生勿入！” “门口不能放这个，不然可能引发很严重的问题！” 这些标题通过制造未完成的感觉，激发用户的好奇心，迫使他们点击以获取更多信息。美版 “今日头条” BuzzFeed 便是利用蔡格尼克效应的典型代表。BuzzFeed 的钓鱼式标题和悬念式内容使其每月内容观看量达到 90 亿次，访问量 2.5 亿次，估值约为 17 亿美元。\n1. 未完成的感觉 诱饵广告的原理就是制造一种未完成的感觉，迫使我们点击文章以解决问题。然而，如今的在线平台，尤其是社交媒体，并不会提供明确的解决方案。相反，它们通过创造一种持续不断的需求，使用户反复操作，寻找难以捉摸的解决方案。\n例如，当你不断刷新小红书或微博时，你很难停下来，因为这些平台没有提供任何明确的“终点目标”。你永远处于一种未完成的状态，无法获得满足感。\n2. 无限滚动的心理陷阱 欢迎来到蔡格尼克记忆炼狱 —— 一个不断让你上瘾的数字牢笼。在日常生活中，我们通常会把生活划分成令人满意的“节点”，以此获得满足感。比如，看书时我们会设定在离开咖啡馆之前读完一章；工作时我们会设定在午饭前写完一封邮件。\n然而，在数字平台上，这种“节点”消失了。无论是在微博上不断滑动，还是刷新无穷无尽的动态信息，用户在心理上都没有完成的“节点”，没有里程碑，也没有终点。用户永远无法放心地认为 “我已经完成了”。\n业界熟知的 “持续刷新” 滚动模式不仅限于社交媒体平台。2015年，美国《时代》周刊对网站进行改版，增添了持续滚动刷新界面，用户参与度几乎立即提高，网站跳出率（仅浏览一页后离开访问站点的用户百分比）下降了15%。体育新闻网（Bleacher Report）取消传统首页，替换为无限滚动刷新后，网站跳出率同样出现了下降。\n数字媒体巨头 Mashable 在 2012 年重新设计了移动端和电脑端的访问网站，开始使用持续更新显示新闻。跳转到 Mashable.com ，然后不断向页面底部滑动。如果你对滚动刷新的设计感到熟悉，那么你可能是 Pinterest 的深度用户。Pinterest 通过随机性和蔡格尼克记忆效应的有效组合呈现图像，大小合适且间隔一定的正方形图像无穷无尽地呈现，为你带来无限观感乐趣。难怪 Pinterest 是历史上最快拥有 1000 万用户的网站，上市速度如此之快。目前其市值近 130 亿美元。\n3. 数字老虎机 —— 下拉刷新 移动设备上的 “下拉刷新” 机制就像老虎机，其设计者洛伦·布里切尔曾谈到：“下拉刷新会让人上瘾。推特会让人上瘾。这些不是好东西。在我设计之初还不够成熟进行全面思考。现在也不够成熟，但起码强过当时，反思这个设计时我深感遗憾。”\n在 Facebook 推出信息流将近十年之后，公众开始意识到技术平台变得过于强大。我们每天花费数小时在社交媒体上，不断下拉刷新，寻找新的信息，却永远无法满足。\n4. 使用时长、参与度与戒瘾的可能 在现实生活中，我们看到超速的标志会被突然惊醒，因为我们公认超速是危险行为，并且会受到惩罚。然而，在社交媒体中，“超速”并不会带来什么坏处。而 “APP使用时长” 就是这样的，它只能让一小部分人停下来，而大多数人还是会呼啸而过。\n成瘾不仅仅是指对物理产品的依赖，在数字化方面指的是“参与度”，也就是注意力的集中应用。赌博对年龄有所限制，因为我们知道赌博会导致失控行为。然而，社交媒体却没有什么限制，甚至也没有像音乐或电影提示需要家长陪同。全世界越来越多的人使用社交媒体平台，注意力的价格只会日益抬高，平台也会变得更加善于劫持我们的注意力。\n社交平台有动力降低用户的使用时长吗？很大程度上是没有的，因为用户的使用时长和他们的收入息息相关。降低产品的用户使用时长，等于降低自己的利润，这是不符合企业本质的。同样，当用户可以用注意力“支付”的时候，他们不会用金钱“支付”，至少现在用户不会为了不上瘾的 APP 付费。\n正如哈里斯所说，“互联网系统比人类更强大，也只会越来越强大”。很难想象，明天人们醒来会对科技和在线平台不为所动。同样，大型科技公司也不会愿意降低平台的吸引力，放弃数十亿美元的广告收入。\n五、社会心理学视角：未完成任务的执着与心理需求 1. 蔡格尼克效应的心理机制 蔡格尼克效应源于人类对 “完成感” 的心理需求。社会心理学家布鲁玛·蔡格尼克通过实验发现，未完成的任务会在记忆中占据更显著的位置，并激发更强的完成欲望。这种心理机制可能与以下因素有关：\n认知闭合需求：人类天生倾向于追求闭合感，即希望事情有一个明确的结局。未完成的任务会引发认知失调，促使我们采取行动以恢复心理平衡。 目标导向行为：根据目标设定理论，未完成的任务会激活我们的目标追求机制，使我们更专注于完成任务，以获得成就感。 2. 社会认同与从众心理 在数字平台上，蔡格尼克效应被放大，部分原因在于社会认同（Social Proof）和从众心理（Conformity）。当我们看到他人对某个未完成的任务或悬念内容表现出兴趣时，我们也会不自觉地被吸引。例如：社交媒体上的 “热搜” 话题往往通过制造悬念吸引用户点击，或者视频平台在关键时刻插播广告，利用“未完待续”的效果留住用户。\n这种社会认同效应进一步强化了蔡格尼克效应，使我们在群体行为中更容易陷入未完成任务的执着。\n3. 自我效能感与挫败感 未完成的任务不仅会激发我们的完成欲望，还可能影响我们的自我效能感（Self-efficacy）。如果任务长期无法完成，用户可能会感到挫败，但平台通过设计 “无限滚动” 或 “下拉刷新” 机制，使用户始终处于 “接近完成” 的状态，从而维持用户的参与度。\n六、行为经济学视角：注意力经济与用户行为操控 1. 稀缺性与损失厌恶 行为经济学中的稀缺性（Scarcity）和损失厌恶（Loss Aversion）原理与蔡格尼克效应密切相关。数字平台通过制造 “未完成感”，使用户感到如果不继续参与，就会错过重要信息或机会。例如：社交媒体上的 “限时动态” 或 “24小时消失的内容” 利用稀缺性激发用户的紧迫感，以及新闻标题中的 “惊天秘密” 或 “未解之谜” 利用损失厌恶，使用户害怕错过重要信息。\n2. 即时奖励与多巴胺循环 蔡格尼克效应与多巴胺驱动的即时奖励机制密切相关。行为经济学研究表明，人类对即时奖励的偏好远高于延迟奖励。数字平台通过以下方式利用这一机制：\n首先是下拉刷新机制，每次刷新都可能带来新内容，这种不确定性激发了多巴胺的释放，使用户不断重复操作。其次是无限滚动机制，用户永远不知道下一个内容是什么，这种随机性创造了类似赌博的 “间歇性奖励” 机制。\n3. 沉没成本效应 蔡格尼克效应还与沉没成本效应（Sunk Cost Fallacy）有关。当用户花费大量时间在某个平台上时，他们会因为已经投入的时间而难以放弃。平台通过设计 “未完成感”，使用户感到如果现在退出，之前的投入就会白费。例如，视频平台的“自动播放下一集”功能，让用户觉得“既然已经看了这么多，不如再看一集”，或者社交媒体上的 “未完待续” 内容，让用户觉得 “既然已经看到这里，不如继续看完”。\n4. 选择过载与决策疲劳 行为经济学中的选择过载（Choice Overload）和决策疲劳（Decision Fatigue）现象也在数字平台中得到了体现。当用户面对大量未完成的任务或信息时，他们可能会感到不知所措，从而选择继续浏览以逃避决策。例如，新闻网站通过无限滚动展示大量未读文章，使用户陷入“信息过载”状态，类似的还有社交媒体通过算法推荐大量未完成的内容，使用户难以停止刷新。\n六、蔡格尼克效应与注意力经济的结合 在当代注意力经济中，数字平台巧妙地运用蔡格尼克效应来吸引和留住用户。这种结合主要体现在平台的精心设计和用户行为的深层变化上。\n数字平台采用了一系列精密的设计策略，包括通过制造悬念和未完成感，平台让用户难以离开。例如，抖音的 \u0026ldquo;猜你喜欢\u0026rdquo; 算法不断推送相关内容，让用户期待下一个可能更有趣的视频。新浪微博的热搜榜单则通过不断更新的话题清单，让用户感觉总有未读完的重要信息。无限滚动的设计消除了自然的停止点，而即时的社交反馈系统则强化了用户的参与感。\n这些设计策略显著改变了用户的行为模式。用户发展出了持续检查更新的习惯，不断寻找新的信息刺激。致使在不知不觉中花费大量时间在平台上，难以自拔，还将其作为获取信息或满足好奇心的主要渠道。这种频繁的使用模式逐渐演变成一种心理依赖，用户即使在工作或休息时也会不自觉地查看手机。\n这种结合对社会产生了深远影响。人们的阅读和思考方式变得更加碎片化，习惯于快速浏览未完成的内容，难以进行深度思考。工作效率受到影响，因为注意力经常被社交媒体打断，难以专注于单一任务。更严重的是，这种持续的未完成感和信息的积累导致了普遍的社会焦虑。人们总觉得自己错过了什么，无法真正放松和专注。\n七、被设计的欲望 蔡格尼克效应揭示了人类心理中的一个重要特点：我们对未完成的事情有一种天然的执着。这种心理机制在现代社会中，尤其是在数字平台上，被广泛利用。我们每天花费大量时间在社交媒体上，不断下拉刷新，寻找新的信息，却永远无法满足。\n从社会心理学和行为经济学的角度来看，蔡格尼克效应揭示了人类对未完成任务的执着心理，而数字平台通过精心设计，将这一效应与注意力经济结合，成功吸引了用户的注意力并延长了使用时间。然而，这种设计也带来了负面影响，如信息过载、注意力分散和心理依赖。\n我们需要意识到，蔡格尼克效应不仅是心理学现象，更是现代数字经济的核心策略之一。如何在享受数字便利的同时，避免陷入“数字牢笼”，是我们每个人都需要思考的问题。通过提高自我意识、设定明确的目标和时间限制，我们可以更好地掌控自己的注意力，避免被平台设计所操控。\n正如赫胥黎在《美丽新世界》中所警告的那样，我们可能不会因为外部的压迫而失去自由，而是因为自愿沉浸于感官刺激和未完成的任务中，逐渐丧失了深度思考和自主选择的能力。\n八、参考 马斯克称Twitter限制浏览量是在帮用户戒网瘾？网友：大可不必！ ↗ 为了人类文明进步而努力！马斯克：TikTok浪费时间，而推特就要改变这个问题 ↗ 从《1984》到《美丽新世界》，为什么波兹曼说赫胥黎的预言正在实现？ ↗ 《上瘾》 《娱乐至死》 ","date":"2025-02-09","tags":["蔡格尼克"],"title":"下拉刷新：社交娱乐平台有诚心想过帮用户戒 “瘾” 吗？","url":"/post/2025/02/zeigarnik_effect/"},{"content":"2024最全自媒体平台封面图片尺寸合集 01 小红书图片尺寸 小红书以生活分享和种草内容著称，是年轻人寻求时尚、美妆、旅行等资讯的首选平台。\n●小红书头像：400 * 400 PX\n●小红书个人背景图：1000 * 800 PX\n●小红书圈文封面（坚版）：1242 * 1660 PX （3：4）\n●小红书图文封面（方版）：1080 * 1080 PX （1：1）\n●小红书图文封面（横版）：2560 * 1440 PX （16：9）\n●小红书视频封面（竖版）：1080 * 1440 PX（3：4）\n●小红书视频封面（微版）：1440 * 1080 PX（3：4） 小红书封面设计 ↗ 应注重细腻、精美、时尚感，迎合用户的视觉偏好，同时小红书的用户注重图片的审美和氛围感，因此建议使用明亮、干净的色调，突出产品或内容的高品质感。图文封面应避免过多文字，重点突出图片视觉效果。\n02 抖音图片尺寸 抖音是一款以短视频为核心的娱乐和社交平台，用户以年轻人群体为主，内容风格多样。\n抖音头像：400 * 400 PX\n抖音个人背景图：1125 * 633 PX\n抖音封面（竖版）：\n1242 * 1660 PX (3:4) 1080*1920 PX (9：16) 1241 * 2208 PX (9:16) 抖音封面（横版）：\n1080 * 608 PX (16:9) 1920 * 1080 PX (16:9) 抖音图片设计需抓人眼球，封面要有强烈的视觉冲击力，以增加用户点击率，抖音封面图通常会选用视频的最精彩部分，搭配简洁的文字说明，竖屏封面是主流，图像元素应简明且集中，突出内容主题，以迅速吸引用户注意。\n03 微信图片尺寸 微信作为中国最广泛使用的社交和商务平台，内容涵盖个人社交、商业推广和企业品牌。\n微信公众号头像：240 * 240 PX 微信公众号封面：900 * 383 PX 微信公众号小图：200 * 200 PX (1:1) 微信公众号二维码名片：600 * 600 PX (1:1) 微信公众号内容引导图：1080 * 300 PX 微信视频号封面（坚版）：1080 * 1260 PX (6:7) 微信视频号封面（横版）：1080 * 608 PX (16:9) 小程序封面：520 * 416 PX 朋友圈封面：1280 * 1184 PX 微信图片设计应追求简约、大气，与品牌形象一致，封面图设计应简洁、具备明确的视觉焦点，特别是在公众号和视频号中，封面图要能够传递清晰的信息，同时保持一定的品牌一致性。\n04 微博图片尺寸 微博是开放性极强的社交媒体平台，信息传播速度快，用户广泛。\n微博头像：180 * 180 PX 微博主页封面：980 * 300 PX 微博头条封面：980 * 560 PX 微博焦点图片：540 * 260 PX 微博长图：800 * 2000 PX 微博上的图片设计要注重视觉冲击力和易于传播的特点，设计需要有强烈的视觉吸引力，特别是在长图和焦点图片中，内容要突出主题，简洁而富有视觉冲击力。\n05 Bilibili图片尺寸 Bilibili作为年轻用户群体聚集的二次元社区，内容多元化，包括动画、游戏、Vlog等。\n头像：400 * 400 PX 首页眉头：2048 * 320 PX 视频封面：1146 * 717 PX B站图片设计风格多为ACG元素和创意感十足的视觉表达，封面设计注重创意和主题表达，适合色彩丰富且具有动态感的图片，封面应具备吸引力，能与年轻人产生共鸣。\n06 快手图片尺寸 快手是一款偏向大众化、生活化的短视频平台，用户多为普通人，内容以接地气和真实生活为主。\n快手头像：400 * 400 PX 快手主页封面：980 * 300 PX 快手封面（竖版）：1080 * 1920 PX 快手封面（横版）：1080 * 1440 PX 视频全屏：1280 * 720 PX 快手的封面图设计应突出内容的真实感和情感共鸣，画面风格相对自然朴实，以生活化和情感化的表达打动观众。\n07 其他常见图片尺寸 除了上述平台，还有一些在特定场景下常见的图片尺寸需求：\n知乎文章封面：690 * 280 PX 百家号封面：500 * 330 PX 600 * 400 PX 头条封面：1175 * 667 PX 1024 * 678 PX ●手机广告BANNER图：720 * 390 PX\n●电商全屏海报（竖版）：1920 * 900 PX\n●电商全屏海报（横版）：1200 * 1920 PX\n●手机海报：1242 * 2208 PX\n●超链接配图：600 * 200 PX\n●表情包：240 * 240 PX\n这些尺寸主要用于特定场景下的广告、推广或电商展示，根据不同场景，设计风格需灵活调整，确保内容信息传达清晰。\n","date":"2025-02-09","tags":["尺寸","自媒体"],"title":"自媒体平台封面图片尺寸合集","url":"/post/2025/02/images_size/"},{"content":"1. pexels ↗ 个人最常用的一个图片网站，优点就是图片质量高，相对比较全，不适合抽象词汇的搜索。\n2. Beautiful Free Images \u0026amp; Pictures | Unsplash ↗ 这个站主要搭配上面的站作为补充使用，基本上可以找到合适的素材。\n3. pixabay ↗ 这个站也不错，只不过个人常用的就上面两个，不是因为什么原因，是因为它们俩是搜藏夹的头两个，找到图片就不会再去翻其他站了。以下的推荐也是这个原因。\n4. magdeleine ↗ 相较于前三个，此站打开较慢一些。使用时要注明出处。\n5. 100 000+ Free PNG images ↗ 免抠图的PNG素材网站。\n6. WallpapersWide ↗ 在没找到头两个站的时候，用的这个站。图片有点土。可能我的使用方法不对。\n7. shutterstock ↗ 每月免费十张图片。\n8. Free stock photos - Kaboompics ↗ 这个站还给出了每张图片配色方案。\n9. Free Stock Photos (CC0) - StockSnap ↗ 选中一键免费下载。尝试下了一张图片有32Mb大，尺寸7800x5200px。\n10. Awesome Wallpapers - wallhaven.cc ↗ 桌面壁纸网站。\n11. bodiesinmotion.photo ↗ 绘画3D扫描与建模。此网站收费，有需要的可以试试。对相关领域来说，确实挺实用的。我之前的工作会用到，但是那时候并未找到此站。\n12. ZEDGE - Everything you ↗ 这个站不错，版权不清楚，有收费项目，但是部分内容免费下载，需要等10秒。\n下载后的内容建议私用。有铃声和手机壁纸。\n13. picjumbo: Free Stock Photos ↗ 需要邮箱下载，下载的链接需要发送到邮箱点击下载。\n14. https://www.foodiesfeed.com/ ↗ 食物类照片免费下载。\n15. Free high resolution photography - Life of Pix ↗ 免费高分辨摄影图。\n16. 探索 300,000 多张免费素材和免版税图像 - FreeImages.com ↗ 明了的介绍，30万张免版权照片，可用于商业用途。\n17. Free Nature Stock ↗ 告诉你尺寸，文件类型，大小，很贴心了，还能直接一键免费下载。\n此站主要为自然风景素材。\n18. freerangestock ↗ 口号就是，用就行了。不要给他们说。\n19. pickupimage ↗ 这个网站需要注册。看了下内容，比较接地气。\n20. ISO Republic - Free High Resolution Photos \u0026amp; Videos ↗ 建筑类图片素材。\n21. splitshire ↗ 直接下载。\n22. Subtle Patterns | Free textures for your next web project ↗ 可延展图案素材。\n22. New Old Stock ↗ 老照片，貌似打不开~\n","date":"2025-02-09","tags":["资源","图片"],"title":"免费图片网站","url":"/post/2025/02/free_images_website/"},{"content":" 在信息极大丰富的时代，唯一稀缺的资源是注意力。 —— 赫伯特 · 西蒙\n移动出行市场 双边市场 移动出行市场是一个典型的双边市场，乘客和司机是市场的两端。双边市场的特点是网络效应显著，即一方的用户数量和质量直接影响另一方的用户体验。没有足够的司机，乘客难以叫到车；反之，没有足够的乘客，司机也难以获得订单。这种 “鸡生蛋，蛋生鸡” 的关系使得平台必须在两端同时发力，才能形成良性循环。\n“单栖” 和 “多栖” 在经济学和平台竞争的研究中，\u0026ldquo;单栖\u0026rdquo;（Single-homing）和\u0026quot;多栖\u0026quot;（Multi-homing）是用来描述用户或供应商在不同平台之间选择行为的术语。\n单栖指的是用户或供应商只在一个平台上进行活动，而不在其他平台上参与。例如，某个乘客可能只使用滴滴打车，而不使用优步或其他打车平台；某个司机可能只在滴滴平台上接单，而不在优步或其他平台上接单。单栖用户对平台的忠诚度较高，平台可以通过锁定这些用户来增强市场地位。单栖行为通常发生在平台具有显著优势的情况下，如更好的服务、更低的价格或更高的效率。对于平台来说，单栖用户是其核心用户群体，平台会通过补贴、奖励等手段来维持这些用户的忠诚度。\n相比之下，多栖指的是用户或供应商同时在多个平台上进行活动。例如，某个乘客可能同时使用滴滴和优步，根据具体情况选择更合适的平台；某个司机可能同时在滴滴和优步上接单，以最大化自己的收入。多栖用户对平台的忠诚度较低，平台需要通过持续优化服务或提供差异化优势来吸引这些用户。多栖行为通常发生在平台之间竞争激烈、用户切换成本较低的情况下。对于平台来说，多栖用户是其潜在的增长点，平台需要通过创新和差异化策略来吸引这些用户。\n在双边市场中，单栖和多栖行为对平台的竞争策略和市场结构有着重要影响。单栖的优势在于平台可以通过锁定单栖用户来建立稳定的用户基础，单栖用户通常对平台的依赖性较高，平台可以通过这些用户实现规模经济。然而，多栖的挑战在于多栖用户的存在增加了平台的竞争压力，平台需要不断优化服务以留住用户。多栖行为可能导致平台之间的“搭便车”现象，即用户在一个平台上获取信息或服务，而在另一个平台上完成交易。\n以滴滴和优步的竞争为例，许多司机同时注册了滴滴和优步，根据订单的利润选择接单平台。这种行为使得平台之间的竞争更加激烈。部分乘客同时使用滴滴和优步，根据价格、等待时间等因素选择平台。这种行为迫使平台不断优化服务以吸引用户。用户的多栖行为反映了市场的竞争程度和平台的相对优势，平台需要通过差异化策略（如价格、服务质量、技术创新等）来吸引单栖用户，同时通过补贴和奖励来减少多栖行为。\n注意力经济：从 N 到 2 在市场竞争中，一个常见的现象是“老大老二打架，老三老四消失”。这种现象的背后，是市场上资源和注意力的有限性。受众往往只能注意到头部的两个正在激烈竞争的厂商，而其他厂商由于无法吸引足够的注意力，逐渐被边缘化甚至退出市场。这种“赢家通吃”的现象在平台经济中尤为明显，尤其是在同质化竞争激烈的市场中。\n注意力经济的稀缺性 注意力经济（Attention Economy）理论认为，在信息爆炸的时代，用户的注意力是一种稀缺资源。平台之间的竞争本质上是对用户注意力的争夺。当市场上有多个同质化平台时，用户往往只会关注最突出的两个平台，而忽略其他竞争者。\n外卖市场的“双雄争霸” 一个典型的案例是外卖市场。在中国，美团和饿了么的竞争几乎垄断了整个外卖市场。尽管市场上曾经存在百度外卖、口碑外卖等其他平台，但由于美团和饿了么的激烈竞争和大量资源投入，其他平台难以吸引足够的用户和商家。美团和饿了么通过补贴、技术创新和精细化运营，成功占据了用户的注意力，而其他平台则因为无法获得足够的市场份额，逐渐退出竞争。\n注意力分配的马太效应 注意力分配的马太效应（Matthew Effect）进一步加剧了这种现象。马太效应指的是“强者愈强，弱者愈弱”的现象。在平台竞争中，头部平台通过吸引更多的用户和资源，进一步巩固了自己的市场地位，而其他平台则因为资源不足和用户关注度低，逐渐被边缘化。这种效应在互联网行业中尤为明显，因为互联网平台的网络效应（Network Effect）使得头部平台的用户基础越大，其价值越高，从而形成正向循环。\n滴滴快的同质竞争：合二为一 快的和滴滴 在市场竞争中，当两个头部平台的交易撮合策略和竞争优势高度相似时，最终的结局往往是合并。这种合并不仅是为了结束激烈的竞争，更是为了整合资源、降低成本、提高效率，从而在市场中占据绝对的主导地位。滴滴和快的的合并正是这一现象的典型案例。\n滴滴和快的曾经是中国打车市场的两大巨头，它们的背后分别站着腾讯和阿里这两大互联网巨头。滴滴由腾讯投资，快的则由阿里支持。两家平台在市场竞争中采取了几乎相同的策略：通过巨额补贴吸引用户和司机，通过技术创新优化用户体验，通过品牌营销提升市场知名度。这种高度同质化的竞争使得双方陷入了长期的消耗战，不仅烧掉了大量资金，也使得市场格局陷入了僵局。\n在双方竞争最激烈的时候，滴滴和快的每天都要投入数亿元用于用户和司机的补贴。这种补贴大战虽然短期内吸引了大量用户，但也让双方承受了巨大的财务压力。与此同时，用户和司机也因为两家平台的激烈竞争而受益，他们可以在两个平台之间自由切换，选择更优惠的价格和更好的服务。然而，这种竞争模式显然不可持续，因为长期的高额补贴不仅对平台的财务状况造成了巨大压力，也使得市场陷入了低效的重复竞争。\n最终，滴滴和快的在2015年宣布合并。这一合并的背后，既有市场竞争的压力，也有资本力量的推动。腾讯和阿里作为两家平台的主要投资方，意识到继续竞争只会导致资源的浪费和市场的低效。通过合并，滴滴和快的不仅结束了补贴大战，还整合了双方的用户基础、技术资源和运营能力，从而在市场中占据了绝对的主导地位。\n合并后的滴滴迅速成为中国打车市场的霸主，市场份额超过了90%。这一合并不仅改变了中国打车市场的格局，也为其他行业的竞争提供了重要的借鉴。在高度同质化的市场竞争中，当两个头部平台的策略和优势相似时，合并往往是最优的选择。通过合并，平台可以整合资源、降低成本、提高效率，从而在市场中占据绝对的主导地位。\n滴滴优步异质竞争：败者为寇 滴滴的定价策略：效率优先 滴滴采用的是一种效率优先策略。在这种策略下，乘客输入目的地后，平台将叫车信息发送给附近的司机。司机可以根据乘客的位置和目的地判断订单的利润，从而选择是否接单。这种机制实际上赋予了司机挑单的权利，使得长途订单（通常利润更高）更容易被司机接受。\n从经济学的角度来看，首先是价格机制与资源配置，在滴滴平台上长途订单价格更高，司机更愿意接单，从而实现了资源的有效配置。这种“价高者得”的原则在经济学中被视为效率的体现。其次是信息不对称与市场效率，滴滴允许司机看到乘客的目的地，减少了信息不对称，提高了市场效率。司机可以根据订单的利润做出理性选择，避免了资源的浪费。再者是消费者剩余与生产者剩余：长途乘客愿意支付更高的价格，司机获得更高的利润，双方都从中获益。这种策略增加了消费者剩余和生产者剩余，提升了整体社会福利。\n优步的定价策略：公平优先 优步采用的是公平优先策略。在这种策略下，司机只能看到乘客的出发地，而无法预先知道目的地。这种 “派单不挑单” 的机制类似于传统的“招手即停”模式，旨在为所有乘客提供公平的打车机会。\n这样的机制对短途的乘客来说是有利的，然而却产生了其他问题：公平与效率的权衡，优步的策略强调公平，但在经济学中，公平与效率往往存在权衡。优步的机制虽然保证了短途乘客的打车机会，但可能导致长途订单的供给不足，因为长途旅客在优步平头的优势没有了，降低了整体市场效率。其次是逆向选择与道德风险，优步的机制可能导致司机对订单的逆向选择。由于司机无法预先判断订单的利润，他们可能会倾向于拒绝短途订单，或者通过其他方式规避低利润订单。这种道德风险会进一步加剧市场的不均衡。最后是消费者剩余与生产者剩余的损失：短途乘客虽然获得了更多的打车机会，但长途乘客可能面临打车难的问题。司机由于无法选择高利润订单，可能导致司机的收入下降。这种策略会减少消费者剩余和生产者剩余，降低整体社会福利。\n优步的算计与失算 优步的算计 优步的策略在短期内可能吸引大量短途乘客，因为短途乘客在滴滴平台上可能难以打到车。优步通过 “派单不挑单” 机制，确保了短途乘客的打车机会，从而在短途市场中占据优势。\n优步的失算 然而，优步的策略在长期中暴露了其局限性。长途乘客更倾向于选择滴滴，因为滴滴的机制确保了他们的订单能够被快速接单。而司机在优步平台上无法选择高利润订单，导致他们逐渐转向滴滴平台。这种司机的流失进一步加剧了优步的困境，最终导致乘客难以打到车，形成恶性循环。\n深入分析 在双边市场中，平台的外部性对竞争结果有着重要影响。外部性分为正外部性和负外部性。正外部性体现在更多的司机吸引更多的乘客，反之亦然。滴滴通过效率优先策略，吸引了大量长途乘客和高利润订单，进一步吸引了更多司机，形成了正向循环。而优步的公平优先策略虽然吸引了短途乘客，但由于司机无法选择高利润订单，导致司机流失，进而减少了乘客的打车机会，形成了负向循环。\n其次，滴滴通过多种方式增强了用户黏性。在司机端，司机可以通过挑单选择高利润订单，提高了收入预期，增强了司机对平台的依赖。在乘客端，长途乘客能够快速打到车，提升了用户体验，增加了乘客对平台的忠诚度。相比之下，优步的 “派单不挑单” 机制虽然短期内吸引了短途乘客，但由于司机流失，长期来看降低了平台的用户黏性。\n滴滴和优步的竞争实际上是一种隐性的价格歧视 —— 根据不同用户的需求弹性，制定不同的价格策略。滴滴通过允许司机挑单，实现了对长途乘客（高需求弹性）和短途乘客（低需求弹性）的隐性价格歧视。长途乘客支付更高价格，获得更快服务；短途乘客支付较低价格，但可能面临打车难的问题。而优步通过“派单不挑单”机制，试图消除价格歧视，为所有乘客提供公平的打车机会。然而，这种策略未能有效满足司机和长途乘客的需求，导致市场分割。\n滴滴占据了长途乘客市场，司机和乘客形成了高效匹配。而优步主要服务于短途乘客市场，但由于司机流失，未能形成稳定的市场均衡。这种市场分割现象在经济学中被称为 “市场细分”，是平台竞争中常见的现象。\n在滴滴和优步的竞争中，司机和乘客也是博弈。司机的策略体现在滴滴平台上，司机可以选择接单或拒单，这是一种非合作博弈。司机根据订单的利润最大化自身收益。乘客的策略则是根据平台的服务质量和价格选择平台，这是一种合作博弈。长途乘客选择滴滴，短途乘客选择优步。在博弈论中，纳什均衡是指在一个博弈中，每个参与者的策略都是对其他参与者策略的最佳反应。在滴滴与优步的竞争中，滴滴的纳什均衡表现为司机选择接长途订单，乘客选择滴滴平台，形成稳定的均衡。而优步的纳什均衡则是司机逐渐流失，乘客转向滴滴，优步平台无法维持均衡。\n参考 “五分钟经济学”之九（互联网时代的经济逻辑：应用3）：优步，生于公平，死于效率 ↗ “多栖”平台竞争：滴滴如何击败优步 ↗ ","date":"2025-02-08","tags":["打车"],"title":"注意力与策略之争：在早期的竞争中滴滴做对了什么？","url":"/post/2025/02/platform_competition_why_did_didi_defeat_uber/"},{"content":" 在普通拍卖中，人们总是倾向于压低自己的实际心理价位，生怕出价太高导致利润太少，或出价太低导致拿不到商品。\n二价拍卖又叫维克里拍卖、第二价格密封拍卖、二价拍卖、第二高价格拍卖，由维克里提出。这个理论的应用并不广泛，曾经在谷歌广告有大量的应用，但是由于投资回报率太低就放弃了。即便没有规模性应用，但不可否认其在诚实报价的研究方面有着重要的作用。\n下文统称为 “二价拍卖”。\n从拍卖过程说起 想象一下，你正在参与一场拍卖会。拍卖品是一件明代青花瓷器，每位参与者都会收到一张投标单，在上面写下愿意支付的价格。但这里有个规则：获胜者虽然是出价最高的人，但他只需要支付第二高的价格。在这场拍卖中，张三认为这件青花瓷值 10 万元，于是写下这个数字；李四觉得值 12 万元，也如实写下；而王五则出价 8 万元。最终，李四会以 10 万元（张三的出价）获得这件瓷器，尽管他原本愿意支付 12 万元。\n为什么我们需要二价拍卖？ 让我们回到传统拍卖会场景：一件珍贵的玉器正在竞拍，拍卖师不断抬高价格。现场的竞买者们面临着一个困境：如果出价太高，可能会付出超出物品实际价值的代价；如果出价太低，又可能错失心仪的藏品。\n这种情况下，人们往往会采取保守策略。想象一位收藏家，他心里认为一件文物值100万元，但担心竞争激烈，可能最终要支付120万才能得到，于是在竞价时故意压低出价到80万，希望能用更低的价格拿下。当所有人都这样做时，市场就无法反映物品的真实价值。\n二价拍卖巧妙地解决了这个问题。通过让获胜者支付第二高的价格，这种机制创造了一个重要的心理安全网：你的出价仅决定是否能够得到物品，而不直接决定你需要支付的金额。\n例如，在拍卖行中，一幅画正在进行二价拍卖。参与竞拍的有三位收藏家：\n老张是一位资深收藏家，经过仔细评估后认为这幅画值得85万元 小李是一家画廊的老板，基于市场行情，判断这幅画值90万元 老王是这位画家作品的忠实收藏者，愿意出价100万元 在传统拍卖中，这三位可能都会下调自己的出价，期望利益最大化。但在二价拍卖中，他们都选择如实报价。最终，老王以90万元（小李的出价）获得了这幅画。这个结果既确保了画作归于最珍视它的收藏家，又避免了过度竞价带来的市场扭曲。\neBay 的故事 eBay 在在线艺术品拍卖领域已经积累了不少经验。2022 年 10 月，该公司联合 150 家北美实体拍卖行，正式推出艺术品拍卖专区。据 eBay 网络市集总裁 Devin Wenig 介绍，新平台获得了全球用户的热烈响应，多件高价拍品成功成交，其中埃尔维斯·皮礼士利（Elvis Presley）的首张唱片就以 30 万美元的价格售出。\n在这个平台上，采用了一种独特的拍卖机制：最高出价者获得拍品，但只需支付第二高的价格。这看似违反直觉的规则，实际上是经济学家威廉·维克里精心设计的方案 —— 第二价格密封拍卖，这种方案在一定程度上解决了传统拍卖的困境。\n传统拍卖的困境 想象一下北京798艺术区的一场小型艺术品拍卖会。一位收藏家王先生正在考虑竞拍一幅当代艺术作品，他内心认为这幅画值 15 万元。但在传统的第一价格拍卖中，他面临着一个两难困境：\n如果他如实出价 15 万，万一其他人都出价较低（比如最高只到 12 万），他就要多付 3 万元。 如果他战略性地压低出价到 13 万，可能会错失这幅他真心喜欢的作品。 这种情况在艺术品市场非常普遍。拍卖师经常观察到，参与者们往往不愿表达真实的心理价位，导致市场信息不透明，资源配置效率低下。\n拍卖有哪些种类？ 从拍卖的基本类型来看，主要可分为英式拍卖、荷兰式拍卖和密封拍卖三类。其中密封拍卖又可细分为第一价格密封拍卖和第二价格密封拍卖（维克里拍卖）。\n英式拍卖采用递增价格机制，从保留价格起拍，买家依次加价竞标。每轮加价必须高于上一轮报价的最小增量。当无人继续加价时，最高出价者获得标的物。这种方式最为常见，尤其适用于艺术品、古董等独特物品的交易。其优势在于价格发现功能强、信息充分公开，但也容易出现恶意竞价、哄抬价格的问题。\n荷兰式拍卖则采用递减价格机制，从高价开始，价格逐步下调，直到第一个接受当前价格的买家出现并成交。这种方式特别适用于鲜花、农产品等需要快速处理的商品。其优势是交易效率高、时间成本低，但可能因买家观望导致实际成交价偏离市场价值。\n密封拍卖中，买家同时提交密封报价。第一价格密封拍卖要求最高价者按自己的报价支付，而第二价格拍卖（第二价格密封拍卖、维克里拍卖）则要求最高价者按第二高的报价支付。二价拍卖因其独特的激励机制，能有效避免投标人战略性压低报价，促使其报出真实估值。\n之所以取名 “维克里”，是为了纪念 William Vickrey，他对拍卖的开创性研究帮助他获得了 1996 年的诺贝尔经济学奖。\n二价拍卖的运作方式 二价拍卖通过一个简单的规则改变了这一切。想象一下下方的拍卖会：\n三位收藏家对一件青花瓷器进行密封竞价：\n张先生出价 80 万元 李先生出价 65 万元 王先生出价 50 万元 按照二价拍卖规则：\n张先生以最高价胜出，获得这件青花瓷器 他只需支付第二高的价格：65万元 其他竞买者无需支付任何费用 既然是使用第二价格购买，那么竞拍者虚报价格有好处吗？\n答案是，竞拍者虚报价格是没有任何好处的，原因如下：\n假设某竞买者对藏品的心理价位是 70 万元(即他愿意支付的最高价格)，但他故意报价 100 万元：\n如果其他竞买者的最高出价低于 70 万元： 他以真实心理价位 70 万元出价就能中标，而且支付金额（第二高价）相同 报 100 万元没有任何额外收益 如果其他竞买者出价在 70～100 万元之间： 他会中标，但要支付超出自己心理价位的金额 这种情况下他会亏损，因为要支付超出自己愿付金额的价格 如果其他竞买者出价超过 100 万元： 无论他报 70 万还是 100 万都不会中标 抬高出价没有任何意义 同样地，竞买者也没有动机报低价：\n如果报价低于真实愿付价格，可能错失以合适价格（第二高价）获得心仪拍品的机会 即便中标，支付的金额仍是第二高价，与自己的出价无关 因此，在这种机制下，每个竞买者的最优策略就是诚实报出自己的真实估值：\n报高了可能导致亏损 报低了可能错失机会 只有如实报价才能最大化自己的利益 这就是二价拍卖的巧妙之处 —— 通过切断出价与支付价格的直接关联，\n这个机制的精妙之处在于，它切断了\u0026quot;出价\u0026quot;和\u0026quot;实际支付\u0026quot;之间的直接联系。它创造了一个激励相容的机制，使得参与者自然而然地选择诚实出价 —— 参与者们知道自己最终支付的是他人的出价，没有动机去歪曲自己的真实估值。\n维克里的洞察 维克里在研究中将国际通行的拍卖方式分为四种类型：英格兰式拍卖（English auction）、荷兰式拍卖（Holland auction）、第一价格拍卖（First-price auction）和第二价格拍卖（Second-price auction）。在这些类型中，维克里重点研究了第二价格拍卖，也被称为二级密封价格拍卖或维克里拍卖。\n在二价拍卖制度下，竞拍采用密封投票方式进行，出价最高者获得拍卖物，但只需支付第二高的价格。这种机制的独特之处在于它能够激励参与者揭示真实意愿：\n如果竞买者出价高于自己实际愿意支付的价格，就可能因其他人相似行为而不得不承担损失。 如果出价低于真实意愿，则可能失去以理想价格获得物品的机会。 因此，在这种拍卖制度中，按照真实支付意愿出价成为一种\u0026quot;优胜\u0026quot;策略——无论其他竞争对手如何行事，这都是参与者的最佳选择。这种机制具有两个重要特征：\n激励相容性：促使竞买人\u0026quot;说真话\u0026quot;，即按真实支付意愿出价 帕累托效率：确保拍卖品最终由支付意愿最高的竞买人获得 维克里的研究挑战了传统经济学观点。此前认为信息不对称会导致市场均衡无效率，但维克里证明，关键在于拍卖规则是否能有效引导参与者展示真实支付意愿。他认为拍卖是一种具有重要实践意义的市场交易制度，通过系统性的规则来决定资源配置和出清价格。\n在比较分析四种拍卖方式的基础上，维克里提出了\u0026quot;收益等价定理\u0026quot;。他特别研究了单物品拍卖机制，指出在英式拍卖中，竞买人的最优策略是持续竞价直至达到自身估价。最终，估价最高的竞买人将以接近次高估价的价格获得拍卖品，这一结果也实现了帕累托效率。\n想象你正在参加一场古董家具拍卖会。在传统拍卖中，如果你认为一张明式圈椅值 50 万元，你可能会犹豫是否要出这个价，因为担心最终要付出这么多。但在二价拍卖中，你可以大胆地写下 50 万，因为你知道：\n如果其他人的出价都低于你，你只需支付第二高的价格 如果有人出价高于你，你本来也不会得到这件家具 如果你刻意压低出价，反而可能与心仪的物品失之交臂 帕累托效率与诚实报价 在现实拍卖中，拍卖方通常无法获知投标人的真实估值（心理价位）。这种信息不对称的情况下，如何实现帕累托效率呢？我们先明确：帕累托效率意味着商品应该由估值最高的人获得，确保资源得到最优配置。\n让我们从英式拍卖开始分析：假设有一件商品，两位投标人的真实估值分别是 100 元和 80 元，最小加价幅度为 5 元。在竞价过程中，估值较低的投标人（80 元）不会超过自己的估值出价，而估值较高的投标人（100 元）只需出价 85 元（第二高估值加上最小加价幅度）就能获得商品。这种机制下，商品最终会被估值最高的人获得，似乎实现了帕累托效率，但存在投标人之间相互影响的问题。\n二价拍卖通过创新的支付规则解决了这个问题：最高出价者获得商品，但按第二高的出价支付。这个设计的精妙之处在于消除了投标人之间的策略性影响。我们用一个双人投标模型来分析：\n设两位投标人的真实估值分别为 v1 和 v2，出价为 b1 和 b2。投标人 1 的期望收益可表示为： $$P(b1≥b2) × (v1-b2) $$ 其中 $$P(b1≥b2)$$ 为投标人 1 赢得拍卖的概率，$$(v1-b2)$$ 为其获得的剩余价值。\n分析投标人 1 的最优策略：\n当 v1\u0026gt;b2 时，为最大化中标概率，最优出价应为 v1 当 v1\u0026lt;b2 时，为避免超出估值中标，最优出价同样是 v1 分析最优策略可知，无论 v1 是大于还是小于 b2，投标人的最优选择都是诚实报价（出价等于真实估值）。这自然实现了帕累托效率。\n这表明在二价拍卖中，诚实报价（出价等于真实估值）是每个投标人的最优策略，从而自然实现帕累托效率。\n而在考虑利润最大化时，情况会更复杂。以下面的例子说明： 假设两个投标人的估值只可能是 10 元或 100 元，概率各为 1/2，最小加价为 1 元。在四种可能的估值组合\n(10,10)\n(10,100)\n(100,10)\n(100,100)\n英式拍卖的最终成交价分别为 10、11、11、100 元，拍卖方的期望收益为 33 元。\n通过设置保留价格可以提高期望收益。例如，将保留价格设为 100 元时，拍卖方的期望收益可达 75 元（成交概率为 3/4）。但这会导致部分有效交易无法达成，违背帕累托效率。因此，只有保留价格为 0 时，才能实现真正的帕累托效率。这也说明了为什么商品若未被估值最高者获得，总是存在后续交易的可能：双方可以在两个估值之间找到一个价格进行交易，实现双赢。\n二价拍卖的创新之处在于，它通过规则设计消除了投标人之间的策略性影响，使得诚实报价成为最优选择。\n什么是好的拍卖机制设计？ 拍卖机制的优劣评估需要建立在严谨的理论模型基础上，而不是主观臆测。以二价拍卖为例，其优越性是通过机制设计理论得到了科学论证。这种基于模型的分析方法不仅适用于商业规则的制定，也适用于各类经济机制和政策的设计，因为良好的制度设计有助于在社会效率和公平之间取得平衡。\n让我们通过一个具体的拍卖场景来分析：假设有一件商品要拍卖，n 个投标人对该商品的估值分别为 p1、p2\u0026hellip;pn。为简化分析，我们设定卖方的保留价格为 0。在这种情况下，如何设计一个既能实现社会效率又能让参与各方满意的拍卖机制呢？\n从机制设计的角度看，我们通常关注两个核心目标：帕累托效率和利润最大化。利润最大化的含义直观明确，即使拍卖方获得最大收益。而帕累托效率则体现为资源的最优配置：确保商品最终由出价最高的投标人获得，从而实现物尽其用。\n为了理解资源配置效率的重要性，让我们考虑一个反例：假设估值最高的投标人 1（估值为 p1）未能得到商品，而估值较低的投标人 2（估值为 p2）获得了商品。这种情况下，资源配置并未达到最优状态，因为投标人 1 对商品的估值更高，商品在其手中能产生更大的社会价值。如果允许后续交易，投标人 2 可以以一个介于 p1 和 p2 之间的价格将商品转售给投标人 1。虽然这种交易能使双方获益（投标人 2 获得超过其估值的收益，投标人 1 以低于其估值的价格得到商品），但它暴露了拍卖机制的缺陷：商品未能直接配置给估值最高的投标人，导致资源配置的低效。\n因此，一个优秀的拍卖机制应当避免这种低效的资源配置。具体而言，最优的拍卖机制应满足以下两个条件：\n帕累托效率：商品直接售予估值最高的投标人，确保资源的最优配置。 利润最大化：成交价格尽可能接近最高估值，从而使拍卖方的收益最大化。 通过这样的设计，拍卖机制不仅能够实现社会效率，还能在公平性和经济效益之间取得平衡。\n效用分析 社会心理学的角度 在传统的实时竞价广告系统中,广告主们能够看到竞争对手的出价。这种透明度表面上看起来很公平，但实际上往往导致非理性的竞价行为。比如张三看到竞争对手为黄金广告位出价 8万/天，即使自己对这个位置的实际估值只有 6万，也可能出于竞争心理追加到 9万。这种从众效应不仅推高了广告成本,还容易造成广告主的决策疲劳和后悔。\n而在采用第二价格机制的程序化广告购买（RTB）系统中，广告主只需要提交自己的最高心理价位。假设有三家广告主竞争同一个优质广告位，他们根据自己的营销预算和预期转化效果分别报价 7万、5万 和 4万。最终出价 7万 的广告主会以 5万 （第二高价）获得这个位置。这种机制巧妙地降低了广告主的心理负担 —— 他们不需要揣测竞争对手的策略，只需要诚实地反映自己的真实预期价值。\n从社会认同的角度看，第二价格机制也更容易被接受。获胜的广告主不会感觉自己 “吃亏”，因为他实际支付的金额是由市场其他参与者共同决定的“公允价格”。同时，失利的广告主也不会感到沮丧，因为他们确实是按照自己的真实估值参与竞争的。这种机制还能有效避免 “赢者诅咒” —— 在传统竞价中，过度竞争可能导致中标价格超出广告位的实际价值。\n特别值得注意的是这种机制对群体动力学的积极影响。它将广告主们从 “你死我活” 的竞争对手转变为独立的理性决策者。每个广告主都在为自己的营销目标负责,而不是为了打压竞争对手。这种良性的竞争环境有助于建立更健康的广告生态系统。\n行为经济学的角度 想象一个场景：一个节目的广告位正在进行拍卖。多家品牌广告主参与竞价，其中包括张三、李四和王五。\n从有限理性与决策简化的角度来看，传统拍卖要求广告主不断权衡竞争对手可能的出价以及自己的最优策略，这个过程极其复杂。而在二价拍卖中，广告主只需要根据这个广告位对自己品牌的实际价值来出价即可。比如张三评估这个时段的广告价值是 100 万元，它就可以直接出价 100 万，而不用担心是否出价过高。\n关于损失规避，假设张三最终以 80 万元（第二高价）获得了广告位。虽然它出价 100 万，但实际只需支付 80 万，这种机制很好地缓解了广告主对 “成本过高” 的担忧。即使最终没有得到广告位，也不会产生因出价过高导致的损失。\n在禀赋效应方面，广告主往往会对自己品牌的广告效果产生过高评估。二价拍卖通过市场机制来确定最终支付价格，避免了单个广告主的主观估值偏差。例如李四可能会高估其品牌影响力，但最终支付价格将由其他广告主的估值来决定。\n从框架效应看，这种机制将广告位竞拍从 “你死我活” 的竞争转变为一个价值发现的过程。广告主不是在玩 “以高价击败对手” 的游戏，而是在思考 “这个广告位对我的品牌价值如何”。\n在过度自信方面，一些新兴品牌可能会对广告效果抱有过高期望。二价拍卖通过市场反馈机制，帮助他们逐步建立更准确的价值判断。如果一个新品牌盲目出价远高于市场水平，虽然可能赢得广告位，但支付的价格仍将由市场决定，避免了过度自信带来的损失。\n这种拍卖机制也很好地解决了市场效率问题。它能确保广告位最终由最需要、最有效益的品牌获得，同时价格又维持在一个合理水平，促进了广告资源的优化配置。\n二级价格拍卖机制的局限性 二级价格拍卖主要是两个方面的不足：\n收入考虑 对卖家而言，第二价格机制可能带来收入的不确定性。比如，在一场拍卖中，最高价是 100 万，而第二高价只有 60 万，这种差距会让卖家感到不安。解决方案是设置合理的底价，在保护卖家利益的同时维持机制的优势。 操纵风险 存在竞买者串通或卖家方虚假竞价的可能。这需要通过严格的资格审查和监管来防范。 二级价格拍卖比一级价格拍卖对卖家而言风险更大 在买家们的估值独立同分布且风险中性的情况下，二级价格拍卖比一级价格拍卖对卖家而言风险更大。\n假设有一幅油画要拍卖，几位买家希望将其买回家欣赏。他们对油画的估值完全基于个人偏好，与其他买家的估值无关。买家们知道这幅油画的市场价值可能在0到500万元之间，但具体值多少并不确定。（假设买家风险中性，估值独立同分布）\n二级价格拍卖：在这种拍卖中，买家会直接按照自己对油画的真实估值出价，因为最终支付的价格是第二高的出价，而非自己的出价。因此，买家没有动机压低出价。此时，买家的出价分布会在0到500万元之间。 一级价格拍卖：在这种拍卖中，买家需要支付自己的出价。为了避免支付过高，买家会策略性地压低出价，出价通常会低于自己的真实估值。因此，买家的出价分布会在0到一个小于500万元的数值之间。 根据收益等价原理，在买家风险中性和估值独立同分布的假设下，一级价格拍卖和二级价格拍卖的期望收益是相同的。然而，二级价格拍卖的收益波动性更大，因为买家出价更接近真实估值，导致卖家的实际收益可能偏离期望值更远。相比之下，一级价格拍卖中买家压低出价，卖家的收益更加稳定。\n因此，如果卖家是风险厌恶型的，即更倾向于稳定的收益而非高波动性，那么一级价格拍卖是更优的选择。从数学上看，二级价格拍卖的收益分布是均值保留展形，即其期望收益与一级价格拍卖相同，但方差更大。\n一级价格拍卖对卖家收益更高 在买家们的价值独立同分布，且风险厌恶的情况下，一级价格拍卖对卖家收益更高。\n一级价格拍卖的规则决定了买家的策略：如果出价较低，获胜时的收益会更高，但获胜的概率也会降低。相反，如果出价较高，获胜的概率会增加，但收益会减少。\n例如，一个投机者可能会选择出价极低（比如1块钱），期望其他买家不感兴趣，从而以极低成本获胜。然而，这种行为风险极高，因为获胜概率极低。\n另一方面，风险厌恶的买家倾向于出价较高。他们更注重获胜的确定性，而不是最大化收益。对他们来说，即使收益减少，只要能确保获胜，也比冒险出低价更有吸引力。\n而在二级价格拍卖中，买家的出价策略与风险偏好无关，所有买家都会按照自己的真实估值出价。因此，二级价格拍卖不会区分“投机者”和“风险厌恶者”。\n对于卖家而言，如果参与拍卖的买家大多是风险厌恶型（例如稳打稳扎的投资者），一级价格拍卖会更有利。因为风险厌恶的买家倾向于出价较高，从而推高成交价格，增加卖家的收益。相比之下，二级价格拍卖的成交价格更接近买家的真实估值，对卖家的收益提升有限。\n因此，在买家普遍风险厌恶的情况下，卖家应优先选择一级价格拍卖。\n二价拍卖与升价拍卖的等价性 在买家们的价值独立同分布的情况下，二价拍卖与升价拍卖的等价性。\n升价拍卖是一种动态拍卖形式，其特点是价格逐步上升，买家根据自身估值决定是否继续参与。当价格上升到某个买家的心理价位时，该买家会选择退出，而最后剩下的买家获胜，并支付前一个退出者所接受的价格。\n例如，在电视上常见的拍卖场景中，拍卖师逐步提高价格，买家依次喊价（如“50万”“60万”），直到只剩下一位买家。这种拍卖形式可以建模为升价拍卖。\n在买家们的价值独立同分布的假设下，升价拍卖与二价拍卖是等价的。具体来说：\n在升价拍卖中，价格逐步上升，买家会在价格达到其心理价位时退出，因为继续参与可能导致亏损。 获胜者支付的价格是最后一个退出者的报价，即第二高的价格。 在二价拍卖中，获胜者同样支付第二高的报价。 因此，在特定假设下，升价拍卖与二价拍卖的结果是一致的。这一等价性表明，升价拍卖在现实中广泛应用的现象并非偶然，而是由其与二价拍卖的内在一致性所支撑。\n二价拍卖收益比升价拍卖低 在买家价值关联的情况下，二价拍卖收益比升价拍卖低。\n现在我们来考虑一个拍卖场景：几家公司竞拍一片海域的油田。每家公司都进行了勘测，并对油田的潜在价值进行了评估。由于油田的实际储油量是固定的，各公司的勘测结果虽然可能存在差异，但总体上具有相关性。例如，如果一家公司勘测到油田储油量较高，其他公司勘测到的储油量也可能较高。这种相关性被称为“关联价值”。\n在关联价值的情况下，二价拍卖（即维克里拍卖，出价最高者以第二高价成交）的收益往往会低于升价拍卖（即英式拍卖，价格逐步上升直至只剩一位买家）。这是因为在二价拍卖中，买家倾向于以接近其真实估值的价格出价，而升价拍卖则可能通过竞争将价格推高至接近最高估值。\n数学上可以证明，在关联价值的假设下，升价拍卖能够更好地激发买家的竞争心理，从而推高最终成交价格，而二价拍卖则由于缺乏这种竞争机制，导致收益较低。因此，在关联价值的情况下，升价拍卖的收益通常高于二价拍卖。\n二价拍卖中卖家有造假的动机 在我们的讨论中，卖家似乎是一个严格执行拍卖规则、毫无私心的人。然而，实际上卖家也有私心，毕竟拍卖藏品的目的是为了赚钱。\n由于特殊的原因，拍卖转为线上进行。首先考虑的是线上二价拍卖。王总觉得这幅画非常好，毫不犹豫地输入了 500 万，他认为这幅画值 500 万，并且他知道自己不需要支付 500 万。结果公布后，王总果然赢了，收到的账单是 499 万。王总很高兴，发现第二高价是一个叫 Jack 的美国人，他出价 499 万。王总开心地让秘书把钱打了过去。然而，卖家更高兴，为什么呢？实际上，Jack 的出价是 300 万，但卖家估计王总一辈子也不会遇到地球另一边的 Jack，更不会知道 Jack 在这场拍卖中的出价。所以卖家为了实现利益最大，有动机调整第二价格。\n王总对此有意见吗？他乐在其中，以为自己险胜了 Jack 。Jack 对此有意见吗？他当然没有，因为他知道自己出价 300 万，肯定输了。这个卖家的造假行为，根本没人发现，也没人在意，而他自己却多了 199 万的收入。\n因此，二价拍卖存在卖家造假的动机，这使得它不可信。\n那么一级价格拍卖呢？现在考虑的是线上一级价格拍卖。王总觉得这幅画非常好，他认为这幅画值 500 万，但他肯定不会出价 500 万，因为出价 500 万和赢不赢是一样的。“那我出价 400 万吧。”结果公布后，王总赢了，发现第二高价是一个叫 Jack 的美国人，他出价 200 万。\n卖家在这种情况下能造假吗？不能，因为在一级价格拍卖中，赢家需要支付自己的出价。王总出价 400 万，卖家只能收取 400 万，不能收取 499 万。如果王总收到 499 万的账单，他肯定会报警。\n因此，一级价格拍卖是可信的。\n二价拍卖在多物品拍卖中的计算复杂度较高 在买家数量多、商品数量大以及存在复杂约束的情况下，二价拍卖在多物品拍卖中的计算复杂度较高。\n这是因为在多物品二价拍卖中，需要考虑所有可能的物品分配方案，并为每个买家计算其对不同物品组合的估值。同时，还需要解决一个复杂的优化问题来确定最优分配方案和支付价格。具体来说，计算最优分配需要求解一个整数规划问题，而计算支付价格则需要为每个中标者重新求解一次没有该买家参与时的优化问题。随着买家数量和物品数量的增加，可能的分配方案会呈指数级增长，这使得精确计算变得极其困难。\n在单物品拍卖中，二价拍卖机制相对简单直观 —— 最高出价者获得物品，但只需支付第二高的出价金额。然而，当拍卖涉及多个物品时，计算最优分配和支付价格的复杂度会呈指数级增长。\n让我们通过在线广告拍卖的场景来具体说明。假设一个广告平台需要在一个网页上分配 3 个广告位置。有 5 个广告商参与竞价，每个广告商对不同位置组合都有不同的估值。例如，广告商 A。可能愿意为顶部横幅出价 100 元，但如果同时获得侧边栏位置，其总估值可能会增加到 140 元而不是 200 元,这反映了边际效用递减的特点。\n为了确定最优分配，平台需要考虑所有可能的分配方案。对于 3 个位置和 5 个广告商，需要评估的组合数量已经相当可观。此外，在确定每个广告商应支付的二价金额时，还需要通过反事实分析计算：如果没有某个中标的广告商参与，其他广告商的最优分配方案会是什么样。这个过程需要重复进行多次计算。\n随着物品数量和竞价者数量的增加，这种组合爆炸会使得精确计算变得极其困难。在实际的大规模广告系统中，往往需要采用启发式算法或近似算法来在合理时间内得到可接受的解决方案,而不是追求完全精确的二价机制。\n参考 最后一刻竞标和结束第二价拍卖的规则：来自互联网上的eBay和Amazon拍卖的证据 ↗ ebay 第二高价拍卖，ebay 第二分类价格 ↗ “第一价格密封拍卖” 和 “第二价格密封拍卖” 在互联网广告生态中的运作模式 ↗ 好好的二价拍卖，为什么谷歌等一众Adx逐步转向一价？ ↗ 维克里拍卖（Vickrey auction）为什么得不到广泛应用？ ↗ 看懂维克里拍卖，也就看懂了此次诺奖 ↗ 刘双舟：威廉•维克里对拍卖经济学的贡献 ↗ ","date":"2025-02-06","tags":["拍卖"],"title":"二价拍卖：如何让诚实报价成为最佳选择？","url":"/post/2025/02/second_price_auction/"},{"content":"原文：https://zhuanlan.zhihu.com/p/61432788\n一、4P 的内涵与应用\n4P营销理论(The Marketing Theory of 4Ps)，4P理论产生于20世纪60年代的美国，随着营销组合理论的提出而出现的。1953年，尼尔·博登（NeilBorden）在美国市场营销学会的就职演说中创造了“市场营销组合”（Marketingmix）这一术语，其意是指市场需求或多或少的在某种程度上受到所谓“营销变量”或“营销要素”的影响。\n1967年，菲利普·科特勒在其畅销书《营销管理：分析、规划与控制》第一版进一步确认了以4Ps为核心的营销组合方法，即：\n产品（Product）：注重开发的功能，要求产品有独特的卖点，把产品的功能诉求放在第一位。\n价格 (Price）：根据不同的市场定位，制定不同的价格策略，产品的定价依据是企业的品牌战略，注重品牌的含金量。\n渠道 (Place）：企业并不直接面对消费者，而是注重经销商的培育和销售网络的建立，企业与消费者的联系是通过分销商来进行的。\n促销（Promotion）：企业注重销售行为的改变来刺激消费者，以短期的行为（如让利，买一送一，营销现场气氛等等）促成消费的增长，吸引其他品牌的消费者或导致提前消费来促进销售的增长。\n产品( product) 、价格( price)、地点( place）、促销( promotion)\n在市场营销组合中 4P 分别是产品( product) 价格( price) 地点( place) 促销( promotion) 。\n产品的组合：主要包括产品的实体、服务、品牌、包装。它是指企业提供给目标市场的货物、服务的集合 包括产品的效用、质量、外观、式样、品牌、包装和规格 还包括服务和保证等因素。\n定价的组合：主要包括基本价格、折扣价格、付款时间、借贷条件等。它是指企业出售产品所追求的经济回报。\n地点通常称为分销的组合：它主要包括分销渠道、储存设施、运输设施、存货控制 它代表企业为使其产品进入和达到目标市场所组织 实施的各种活动 包括途径、环节、场所、仓储和运输等。\n促销组合是指企业利用各种信息载体与目标市场进行沟通的传播活动，包括广告、人员推销、营业推广与公共关系等等。以上4P ( 产品、价格、地点、促销) 是市场营销过程中可以控制的因素 也是企业进行市场营销活动的主要手段 对它们的具体运用 形成了企业的市场营销战略。\n企业要满足顾客，实现经营目标，不能孤立地只是考虑某一因素和手段，必须从目标市场需求和市场营销环境的特点出发，根据企业的资源和优势，综合运用各种市场营销手段形成统一的、配套的市场营销战略 使之发挥整体效应 争取最佳效果。\n从4P 的组合特点分析:\n(1) 具有可控性。构成市场营销组合的各种手段 是企业可以调节、控制和运用的因素 如企业根据目标市场情况 能够自主决定生产什么产品 制定什么价格 选择什么销售渠道 采用什么促销方式。\n(2) 动态性。市场营销组合不是固定不变的静态组合而是变化无穷的动态组合。企业受到内部条件、外部环境变化的影响 必须能动地做出相应的反应。\n(3) 具有整体性。市场营销组合的各种手段及组成因素 不是简单的相加或拼凑集合 而应成为一个有机的整体 在统一目标指导下 彼此配合 相互补充 能够求得大于局部功能之和的整体效应。\n二、4C的内涵与应用\n消费者( consumer) 、成本( cost) 、便利( convenience) 、沟通( communication)\n营销学家菲利普*科特勒认为，企业所有部门为服务于顾客利益而共同工作时，其结果就是整合营销。其意义就是强调各种要素之间的关联性要求它们成为统一的有机体。具体地讲，整合营销更要求各种营销要素的作用力统一方向，形成合力，共同为企业的营销目标服务。4C的营销观念: 4C分别是: 消费者( consumer) 、成本( cost) 、便利( convenience) 、沟通( communication) 。4C强化了以消费者需求为中心的营销组合 其内涵与应用是:\n(1) 消费者(consumer) 指消费者的需要和欲望( The needs and wants of consumer) 。企业要把重视顾客放在第一位 强调创造顾客比开发产品更重要 满足消费者的需求和欲望比产品功能更重要 不能仅仅卖企业想制造的产品 而是要提供顾客确实想买的产品。\n(2) 成本(cost) 指消费者获得满足的成本( Cost and value to satisfy consumer needs and wants) 或是消费者满足自己的需要和欲望所肯付出的成本价格。这里的营销价格因素延伸为生产经营过程的全部成本。包括: 企业的生产成本即生产适合消费者需要的产品成本; 消费者购物成本 不仅指购物的货币支出还有时间耗费 体力和精力耗费以及风险承担。新的定价模式要求: 消费者支持的价格—适当的利润= 成本上限。因此企业要想在消费者支持的价格限度内增加利润 就必须降低成本。\n(3) 便利(convenience) 指购买的方便性( Convenience to buy) 。比之传统的营销渠道 新的观念更重视服务环节在销售过程中 强调为顾客提供便利 让顾客既购买到商品也购买到便利。企业要深入了解不同的消费者有哪些不同的购买方式和偏好 把便利原则贯穿于营销活动的全过程 售前做好服务及时向消费者提供关于产品的性能、质量、价格、使用方法和效果的准确信息。售后应重视信息反馈和追踪调查 及时处理和答复顾客意见对有问题的商品主动退换 对使用故障积极提供维修方便 大件商品甚至终身保修。\n(4) 沟通(communication) 指与用户沟通( Communication with consumer) 。企业可以尝试多种营销策划与营销组合 如果未能收到理想的效果 说明企业与产品尚未完全被消费者接受。这时 不能依靠加强单向劝导顾客 要着眼于加强双向沟通 增进相互的理解 实现真正的适销对路 培养忠诚的顾客。\n三、4S 的内涵与应用\n满意( satisfaction)、服务( SERVICE)、速度( speed)、诚意( sincerity)\n4S的行销战略强调从消费者需求出发，打破企业传统的市场占有率推销模式，建立起一种全新的“消费者占有”的行销导向。要求企业对产品、服务、品牌不断进行定期定量以及综合性消费者满意指数和消费者满意级度的测评与改进，以服务品质最优化，使消费者满意度最大化，进而达到消费者忠诚的“指名度” 同时强化了企业的抵御市场风险经营管理创新和持续稳定增效的“三大能力”。\n从4P 的组合特点分析:\n(1) 具有可控性。构成市场营销组合的各种手段 是企业可以调节、控制和运用的因素 如企业根据目标市场情况 能够自主决定生产什么产品 制定什么价格 选择什么销售渠道 采用什么促销方式。\n(2) 动态性。市场营销组合不是固定不变的静态组合而是变化无穷的动态组合。企业受到内部条件、外部环境变化的影响 必须能动地做出相应的反应。\n(3) 具有整体性。市场营销组合的各种手段及组成因素 不是简单的相加或拼凑集合 而应成为一个有机的整体 在统一目标指导下 彼此配合 相互补充 能够求得大于局部功能之和的整体效应。\n4S 的行销战略意义是:\n1.满意( satisfaction) 。指顾客满意强调企业以顾客需求为导向 以顾客满意为中心 企业要站在顾客立场上考虑和解决问题要把顾客的需要和满意放在一切考虑因素之首要以他人利益为重的真诚 古人云: “感人心者 莫先乎情”。要想赢得顾客的人 必先投之以情用真情服务感化顾客 以有情服务赢得无情的竞争。\n2.服务微笑服务待客( SERVICE) 。指随时以笑脸相迎客人 因为微笑是诚意最好的象征 服务包括以下几个内容:\nE—即精通业务上的工作 企业营销人员 为顾客提供更多的商品信息 经常与顾客联络 询问他们是否需要次日送货或更紧急的要求 此举会使顾客感谢你的提醒所带来的便利;\nR—即对顾客态度亲切友善 实行“温馨人情”的用户管理策略 用体贴入微的服务来感动用户;\nV—将每位顾客都视为特殊和重要的人物 顾客是我们的主人 不是我们的佣人 顾客是上帝 我们只有与之友好相处 才能生存发展;\nI —即要邀请每一位顾客下次再度光临 企业要以最好的服务、优质的产品、适中的价格来吸引顾客多次光临;\nC—要为顾客营造一个温馨的服务环境 要求企业文化建设加大力度 从厂容厂貌以及大型商场的环境氛围更要建成现代化的超一流的环保市场 舒适、温馨、超时代水平;\nE—行销人员用眼神表达对顾客的关心 用眼睛去观察 用头脑去分析 真正做到对顾客体贴入微关怀的服务。\n3.速度(speed)指不让顾客久等，而能迅速的接待、办理。\n4.诚意(sincerity) 指以具体化的微笑与速度行动来服务客人。\n总之 4S 要求企业行销人员 实行“温馨人情”的用户管理策略 用体贴入微的服务来感动用户 向用户提供“售前服务”敬献诚心 向用户提供“现场服务”表示爱心 向用户提供“事后服务”以送谢心。\n四、4R的内涵与应用\nRelevance(关联)、Reaction(反应)、Relationship(关系)、Reward(回报)\n4R营销理论是由美国学者唐*舒尔茨在4C营销理论的基础上提出的新营销理论。4R分别指代Relevance(关联)、Reaction(反应)、Relationship(关系)和Reward(回报)。该营销理论认为，随着市场的发展，企业需要从更高层次上以更有效的方式在企业与顾客之间建立起有别于传统的新型的主动性关系。\n紧密联系顾客 企业必须通过某些有效的方式在业务、需求等方面与顾客建立关联，形成一种互助、互求、互需的关系，把顾客与企业联系在一起，减少顾客的流失，以此来提高顾客的忠诚度，赢得长期而稳定的市场。\n2.提高对市场的反应速度\n多数公司倾向于说给顾客听，却往往忽略了倾听的重要性。在相互渗透、相互影响的市场中，对企业来说最现实的问题不在于如何制定、实施计划和控制，而在于如何及时地倾听顾客的希望、渴望和需求，并及时做出反应来满足顾客的需求。这样才利于市场的发展。\n3.重视与顾客的互动关系\n4R营销理论认为，如今抢占市场的关键已转变为与顾客建立长期而稳固的关系，把交易转变成一种责任，建立起和顾客的互动关系。而沟通是建立这种互动关系的重要手段。\n4.回报是营销的源泉\n由于营销目标必须注重产出，注重企业在营销活动中的回报，所以企业要满足客户需求，为客户提供价值，不能做无用的事情。一方面，回报是维持市场关系的必要条件;另一方面，追求回报是营销发展的动力，营销的最终价值在于其是否给企业带来短期或长期的收入能力。\n(二)4R营销的特点\n4R营销以竞争为导向，在新的层次上提出了营销新思路 根据市场日趋激烈的竞争形势，4R营销着眼于企业与顾客建立互动与双赢的关系，不仅积极地满足顾客的需求，而且主动地创造需求，通过关联、关系、反应等形式建立与它独特的关系，把企业与顾客联系在一起，形成了独特竞争优势。\n2.4R营销真正体现并落实了关系营销的思想\n4R营销提出了如何建立关系、长期拥有客户、保证长期利益的具体操作方式，这是关系营销史上的一个很大的进步。\n(三)总结\n当然，4R营销同任何理论一样，也有其不足和缺陷。如与顾客建立关联、关系，需要实力基础或某些特殊条件，并不是任何企业可以轻易做到的。但不管怎样，4R营销提供了很好的思路，是经营者和营销人员应该了解和掌握的。\n五、4V营销理论\n差异化(Variation)、功能化(Versatility)、附加价值(Value)、共鸣(Vibration)\n21 世纪以来，高科技产业迅速崛起，高科技企业、高技术产品与服务不断涌现， 互联网、移动通讯工具、发达交通工具和先进的信息技术使整个世界面貌焕然一新，原来那种企业和消费者之间信息不对称状态得到改善。沟通的渠道多元化，越来 越多的跨国公司开始在全球范围进行资源整合。\n在这种背景下，4V营销理论应运而生。\n4V是指差异化(Variation)、功能化(Versatility)、附加价值(Value)、共鸣(Vibration)的营销理论。\n4V 营销理论首先强调企业要实施差异化营销，一方面使自己与竞争对手区别开来，树立自己独特形象;另一方面也使消费者相互区别，满足消费者个性化的需求。其 次，4V营销理论要求产品或服务有更大的柔性，能够针对消费者具体需求进行组合。最后，4V营销理论更加重视产品或服务中无形要素，通过品牌、文化等以满 足消费者的情感需求。\n六、4I理论\nInteresting趣味原则、Interests利益原则、Interaction互动原则、Individuality 个性原则\n网 络时代，传统的营销经典已经难以适用。消费者们君临天下，媒体是传统传播时代的帝王，而YOU才是网络传播时代的新君!在传统媒体时代，信息传播是 “教堂式”，信息自上而下，单向线性流动，消费者们只能被动接受。而在网络媒体时代，信息传播是“集市式”，信息多向、互动式流动。声音多元、嘈杂、互不 相同。网络媒体带来了多种“自媒体”的爆炸性增长，博客、论坛、IM、SNS……借助此，每个草根消费者都有了自己“嘴巴”和“耳朵”。面对这些“起义的 长尾”，传统营销方式像“狩猎”要变成“垂钓”：营销人需要学会运用“创意真火”煨炖出诱人“香饵”，而品牌信息作为“鱼钩”巧妙包裹在其中。如何才能完 成这一转变?奥美的网络整合营销4I原则给出了最好的指引。\n网络整合营销4I原则：Interesting趣味原则、Interests利益原则、Interaction互动原则、Individuality 个性原则。\nInteresting\n趣 味原则：八卦是火爆的通行证，《馒头》是《无极》的墓志铭。当芙容姐姐大S身材火爆网络时，当越来越多的信息都带好“泛娱乐化的假面”时，一个娱乐至死的 年代来临了。中国互联网的本质是娱乐属性的，在互联网这个“娱乐圈”中混，广告、营销也必须是娱乐化、趣味性的。当我们失去权力对消费者说“你们是愿意听 啊，是愿意听啊，还是愿意听啊绝不强求”之时，显然，制造一些趣味、娱乐的“糖衣”的香饵，将营销信息的鱼钩巧妙包裹在趣味的情节当中，是吸引鱼儿们上钩 的有效方式。“伟大的网络营销，他身上流淌着趣味的血液!他不是一则生硬的广告，他不是一则生硬的广告!娱乐因子在他身上灵魂附体!”\nInterests\n利益原则：没错，利益!天下熙熙，皆为利来，天下攘攘，皆为利往。网络是一个信息与服务泛滥的江湖，营销活动不能为目标受众提供利益，必然寸步难行。将自己变身一个消费者，设身处地、扪心自问一句，“我要参加这个营销活动，为什么呢?嚎!”\n但这里想跟大家强调的是，网络营销中提供给消费者的“利益”外延更加广泛，我们头脑中的第一映射物质实利只是其中的一部分，还可能包括\n1、信息、咨讯\n广告的最高境界是没有广告，只有资讯。消费者抗拒广告，但消费者需要其需求产品的相关信息与资讯。直接推销类的广告吃到闭门羹的几率很大，但是化身成为消费者提供的资讯;面对免费利益，消费者接受度自然会大增。\n2、功能或服务\n3、心理满足，或者荣誉\n4、实际物质/金钱利益\n5、……等待你来填写，相信你能发现更多!\nInteraction\n互动原则：网络媒体区别于传统媒体的另一个重要的特征是其互动性，如果不能充分的挖掘运用这个usp，新瓶装旧酒，直接沿用传统广告的手法手法，无异于买椟 还珠。再加上网络媒体在传播层面上失去了传统媒体的“强制性”，如此的“扬短避长”，单向布告式的营销，肯定不是网络营销的前途所在，只有充分挖掘网络的 交互性，充分地利用网络的特性与消费者交流，才能扬长避短，让网络营销的功能发挥至极致。\n不要再让消费者仅仅单纯接 受信息，数字媒体技术的进步，已经允许我们能以极低的成本与极大的便捷性，让互动在营销平台上大展拳脚。而消费者们完全可以参与到网络营销的互动与创造中 来。在陶艺吧中亲手捏制的陶器弥足珍贵，因为融入自己的汗水。同样，消费者亲自参与互动与创造的营销过程，会在大脑皮层回沟中刻下更深的品牌印记。把消费 者作为一个主体，发起其与品牌之间的平等互动交流，可以为营销带来独特的竞争优势。未来的品牌将是半成品，一半由消费者体验、参与来确定。当然，营销人找 到能够引领和主导两者之间互动的方法很重要。\nIndividuality\n个性原则：YOU，已经被钉在了无以复加的高度，那么YOU高大的身影在营销中投射的映相，就是I!Individuality 个性在网络营销中的地位也因此凸现!对比“大街上人人都在穿”，“全北京独此一件，专属于你!”，你就明白专属、个性显然更容易俘获消费者的心。因为个 性，所以精准，因为，所以诱人。个性化的营销，让消费者心理产生“焦点关注”的满足感，个性化营销更能投消费者所好，更容易引发互动与购买行动。但是在传 统营销环境中，做到“个性化营销”成本非常之高，因此很难推而广之，仅仅是极少数品牌品尝极少次的豪门盛宴。但在网络媒体中，数字流的特征让这一切变得简 单、便宜，细分出一小类人，甚至一个人，做到一对一行销都成为可能。天赐良机，怎能不用?\n","date":"2025-02-04","tags":["理论"],"title":"营销学理论 4P、4C、4S、4R、4V、4I","url":"/post/2025/02/marketing_theory_4p_4c_4s_4r_4v_4i_full_version/"},{"content":" 注：\n这里只讨论被作为产品品牌传播的名称，对于腾讯、米哈游这样的名称不讨论，原因有两点：\n一是幸存者偏差，这类名称在同一时期可能有很多，但是大多数都没能传播开来，而现存的只是幸存者。\n二是他们是企业名不是产品名，这些名称不是传播的，比如别人问你在用什么软件聊天的时候，你会说“我用 QQ”，而不会说“我用腾讯 QQ”。\n一、为什么需要一个好名字？ 名字不仅是品牌和标签，更是传播效率，在品牌命名的时候名称一定是一个关键点。\n案例：一个人名字是林芪（qi），另一个人的名字是林茂，谁的名字更容易被记住？\n两个简单的层面：\n记忆成本：“芪”这个字虽算不上生僻，但也是不常用汉字。你会有个认知“噢，这个名字很特别”，所以我能记住，但是当你尝试复现的时候，无非是把那一块在脑海里模糊的东西变得更模糊了。芪这个字能组的词非常少。所以你很难通过其他的词去记住这个名字。或者通过更多的信息去记住这个字，对记忆的负担非常大。\n传播成本：你会如何介绍自己？别人会如何介绍你？“芪是芪苓的芪”，“啊？麒麟？”在多数情况下，你甚至没法在输入法中快捷地输入这个名字。\n这是个真实的案例，我几年前有一个老师的名字就是 “x芪x”，后来在登记的时候，由于工作人员没法输入这个字，就改成了 “x茂x”。这何尝不是一种悲剧呢？\n通过这两个层面算是完成了一个品牌传播的流程，但是要取一个好的名字，远不是用小学生词典组词那么简单，况且以上的解释还是比较片面的。\n但是这并不是说给人取名的文章。言归正传，如何给你的品牌取名？\n从库里肖夫效应说起 苏联电影工作者库里肖夫在十九岁的时候发现一种电影现象：\n他给一个演员的特写镜头分别在后面接上三种不同的内容。结果是观众在看的时候，根据后面出现的那个镜头的内容来断定那个特写镜头中的人的情绪。\n图源：IB FILM STUDIES\n比如后面接的是一个欢乐的的场面，于是观众觉得那人的脸上露出了笑容。如果接的是一个悲伤的内容的镜头，则观众会觉得那个特写中的人脸是悲伤的。从心理学来说，这是观众把他自己的感觉投射到那个人的脸上。其实那几个不同性质的例子里的特写镜头是一样的，是同样的镜头后面接了不同内容的镜头。观众认为那个特写镜头中的人的表情变了。\n这就是库里肖夫效应，这对品牌名有什么启示吗？\n不要随便用英文简写，特别是可能含有负面解释的时候，例如：TCL、HTC、BYD，消费者永远只会选择最便捷的记忆方式，而不会在意品牌的愿景。但是消费者会如何记住你的品牌呢？答案是使用不那么优雅的描述，所以很多时候一个不明所以的品牌使用容易记忆的昵称的时候往往是比较通俗甚至粗俗的。这种可能存在的负面信息对品牌来说是一种伤害。\n名称背后的含义是否符合品牌自身定位和当地文化背景，比如：运动品牌 mizuno 中文名“美津侬”、服装品牌 PlayBoy 中文名“花花公子”，审计咨询机构KPMG中文名叫“毕马威”、雪碧刚进入中国时的“势必利”、女装品牌 Girdear 的中文名哥弟。这样的名称，在消费者脑海中产生的画面和品牌态度是有较大冲突的，这样的形象也必定不是品牌方愿意接受的。\n那么为什么名称解释的改变会导致消费者态度的改变呢？\n菲利普·津巴教授在《态度改变与社会影响》的「自我辩解心理学：认知不协调理论」部分同样提到：当人们的态度与行为或环境信息不一致时，人们会改变行为或修正态度，从而改变对世界的看法。\n这不难理解，举个例子，医生给你开了一副药，比较苦：\n医生建议你喝药后喝点水。 医生建议你喝药后吃颗糖。 哪个药更苦？相信你也会认为“喝药后吃颗糖”的药更苦。为什么呢？因为使其达到一致。即：药更苦（负面预期）所以需要吃更甜的东西（正面奖励）。否则就不用。所以你会相信需要吃糖的药更苦。\n预期和奖励往往越是呈现反比，越能达到想要的效果。为什么呢？因为做对的事情不需要奖励，如果有奖励，那么一定是因为这件事本身就不好 —— 认知和行为的不一致会让我们修正其一。\n所以当消费者认为品牌传递的信息是负面的时候，消费者会修正自己的行为或者修正自己之前的评价以匹配目前的状态。\n再举一个例子，蒙牛和安佳，那个品牌名称对你的画面更强一点？\n我相信是蒙牛，这是个本土化的描述，而安佳是新西兰的品牌。想到蒙牛的时候你是不是可以想到一头牛呢？它俯下头在湖边饮水，而它的背后的阳光被白云遮住，蓝天和绿茵形成了一幅美丽的画面。这就是库里肖夫效应。\n这警示我们，在取名字的时候一定不能脱离情景，你的名字在普遍情景下是什么含义？是否会对别人的态度造成影响？这很重要。\n记忆成本 史玉柱说：“一个名字如果不上口，不容易记，往往就要花上几十倍的广告力度才能达到让别人记得住的效果。”\n“广告狂人”叶茂中在《冲突》一书中提到：\n决定品牌名能否解决传播冲突的关键：\n第一是好记，\n第二是好记，\n第三还是好记。\n\u0026hellip;\u0026hellip;\n又熟悉又有形象感的品牌名，自然是最能解决传播冲突的品牌名。\n不约而同，小马宋老师在文章中提到：\n名字最基本的功能是要让人记住，其他的意义都是在记住基础上才能有的。\n华与华在《华与华方法》中也同样提到：\n检验好名字的 3 个标准\n1.命名的第一原则是低成本\n要传达成本低，传播成本低，理解低成本，使用成本低，营销成本低的名字。\n2.命名的本质，第二在召唤性、指令性。\n命名要传递价值,传递购买理由，召唤顾客。如果名字本身能传达价值,召唤顾客,就能降低传播成本，降低消费者选择成本。\n3.命名必须是听觉词语\n因为传播是口语现象,是听觉行为。不仅要一看就明白,关键要一听就明白。\n借用华与华和小马宋同样提到的一个案例：\n“兰德酷路泽”还是“陆地巡洋舰”？\n关键在于哪个名字的记忆成本更低，答案自然就是“陆地巡洋舰”。\n在 SEO（搜索引擎优化）中，这同样重要，一个名字好不好往往就决定你会不会被点击。不同的是，SEO 常常是用户主动搜索，而实体品牌往往是品牌被展示。\n回到品牌命名，如何测试你的名字是否好记呢，小马宋的方法是：电话测试和输入法测试。\n电话测试法就是打电话告诉对方你的品牌名字，然后看对方能不能写下来，如果他能直接正确的写出来，那这个名字就非常好非常容易传播和记忆。对方想写下来，需要问你的东西越多，就说明这个名字越不好记忆。\n搜狗输入法测试。如果一个名字使用输入法更容易输入，那它让消费者找到它更加方便。简单来说，在没有提前云存储的情况下，搜狗输入法一次性打出来的名字才是更好的名字。比如苹果手机，就是个好名字，但第一次输入魅族或者一加手机，就略微有点复杂；酷派手机，输入就更加复杂。像章光 101 这种品牌，它中间还需要切换输入法；而有些更奇葩的名字，甚至普通输入法都打不出来，我就不再举例子了。\n其实个人还认为建议加上 SEO 的部分（小马宋老师曾经也做过 SEO）：\n一个名字被搜索的频率长期处于热榜，能说明这个名字对应的需求比较旺盛。我们可以反推，如果一个产品的需求旺盛，那么它的搜索关键字也会比较活跃，应该加以关注。 品牌名称不应该只专注于故事，还要着眼于你的消费者如何记忆和传播。\n这里有一个案例，来自叶茂中老师的《冲突》一书：\n著名的奢侈品牌 Yves Saint Laurent，大多数女孩并不会称呼他的全名或者中文名“圣罗兰”，而是叫它“杨树林（YSL）”，当消费者无法快速理解和记忆品牌名称的时候，他们就会以自己的理解去记忆。\n有时候在名称上想创意的时候就想到用生僻字，看不懂的就是“差异化”。\n实际上，这不但让用户看不懂，还增加了记忆和传播成本，让人描述名称的时候很难一句话说明白，相对于那些两个字就能知道品牌是做什么的、名称怎么写的品牌，复杂的品牌就吃了很多亏。\n比如“犇鱻羴”，你怎么介绍？\n“犇””就是三个牛组成，读bēn，鱻就是三个鱼，读……“\n这样介绍起来费劲不说，记忆成本还高得可怕。你的品牌也会失去了很多潜在的用户。即便你的菜是顶级的。\n记忆成本的降低可以带来传播效率的提高。\n传播效率 总的来说就是如何给别人描述。对于简单信息，记忆的难度越低，那么输出的难度也就越低。不难理解，每一个名称都是有意义的。\n前百度和滴滴的产品经理俞军老师在《俞军产品方法论》中提到：“用户不是人，而是需求的集合”，品牌名称对于消费者来说也是同样的，消费者可以通过品牌名称了解这个品牌，进而匹配自己的需求，这种情况是最好的，比如“淘宝”“去哪儿”“微信”“三只松鼠”“奔驰”。现在又存在一个问题，即：信息的压缩能力。\n你可能遇到过这样的情况，你问别人问题的时候，发觉答非所问，但是你换一个更详细或者易懂的描述，对方就能理解了。这个换之前和换之后的词，就是对信息压缩能力的改变。从传播的角度来说，信息的压缩能力越强，名称的传播效率就越高。注意这里是传播效率不是传播概率。\n有一家做餐饮的品牌叫做俏江南，你可以想象一下这个品牌是做什么菜系的，比如：川菜、湘菜、粤菜、闽菜、苏菜、浙菜、徽菜和鲁菜。\n你很可能猜不对，首先是这个名称所传达的信息无外乎江浙一带的菜系，这是这个名称所压缩的信息，问题就出在这里，它做的是川菜。想吃川菜的人看见这名字不会进去，想吃江浙菜的进去之后发现是川菜，消费者会混乱，只有做大量的营销传播，才能让消费者知道这是一家川菜，大大增加了营销成本。\n品牌名称和产品相关是建议的，至少不要牛头不对马嘴。\n传播概率 为什么标题党总是能获得更高的点击率？\n这其实是信息熵的问题，这是这一部分主要说明的。\n信息熵是一个物理学和信息论中的概念，用于描述某个系统或信源中包含的信息量的大小或不确定性的程度。在信息论中，熵是一个随机变量的平均信息量，表示在一组离散概率分布中随机选择一个元素所得到的平均信息量。信息熵越高，意味着信息的不确定性越大，反之则越小。\n比如，“太阳从西边升起了”，这句话的信息熵很高，因为太阳通常情况都是从东边升起，但是从东边升起是极不可能的，它会需要更多的信息才能解释“太阳为什么从西边升起”。\n而”太阳从东边升起了“，这句话的信息熵很低，因为这个现象太常规了，根本没有必要解释。\n例如：旅游品牌 “飞猪”、Dior 旗下的香水 “毒药”、做单词记忆的品牌“不背单词”，它们的信息熵是不是很高？\n这样的名称从传播概率的角度来说是很好的案例。这样的名字来自于叶茂中老师的《冲突》一书中「逆时针取名」所提到的方法。\n情景反馈 1921 年 white elephant 开始生产电池，畅销全国，八十年代国门打开，但是国外的消费者怎么都不肯买。同样是八十年代，日产有一款车叫蓝鸟，在广东地区死活卖不出去。\n为什么？\n在英语语境下，white elephant 有累赘的意思，而广东部分地区，蓝鸟读音普遍有不雅之意，这就是语境对品牌名称及其品牌价值的冲击。\n在考虑一个名字的时候不仅要考虑名字本身在本土的寓意，更要考虑名称在目标市场的寓意。\n我们在宣传自己品牌的时候，往往会因为对自己的价值观和愿景的长期信念而误以为品牌本身就包含了它；而消费者往往是因为品牌的行为对品牌进行价值定义，正如《态度改变与社会影响》在「自我觉知与自我归因」中提到的：我们是我们行为的产物。\n二、品牌名的历史演变 回想百年前的小农经济，人和人之间的关系很近，抬头不见低头见，谁家干什么，几乎都知根知底，自己有什么需求酒找那个人就好了。哪怕是现在，较为落后的农村地区，也一样保持着这种比较稳定的人际关系。那时候不会有一个打铁的张老头说：“我要做个张铁匠品牌”。而是有一个人打铁的技术很好，又懂顾客需求，找他打铁的人越来越多，别人为了方便叫他，而不是叫 “村头那个门口有一个石狮子的人家”，于是给他取了个名字 —— “张铁匠”，这就是最初的品牌。现在的吴裕泰、内联升、王麻子都是这样的方式来的。\n还有一种就是区域性的品类，这种产品在当地不算出名，但是在更大的范围比较起来就很好，比如西湖龙井、德州扒鸡、中宁枸杞、阳澄湖大闸蟹。这算区域性的优势品类，严格还说，这不是品牌，毕竟在垄断的情况下它才有机会成为品牌。\n这个阶段的品牌是口碑演化的结果，而不是被设计的。\n后来，有资源禀赋的人开个店，不满足于做好产品，更新去发扬一种精神，比如同仁堂意为“同修仁德，济世养生”，庆余堂取自“积善之家，必有余庆”。现在的老字号基本都是以上的方式保留下来的。包括我们说开个公司什么的都是资源禀赋的具像化。\n上世纪70、80年代，改革开放，品牌的取名方式开始出现转折，总的来说是两个方向的变化，一是发扬本土文化，二是追逐外来文化\n发扬本土文化，主要是往实现历史使命和家国情怀方向发展。比如中国、中华、东方等词汇和东风、解放、红旗这样的红色话语的品牌名。\n比如1987年成立的华为，1985年成立的中兴，1991年成立的格力，以及华润、万洲、世茂、华菱、华夏幸福等名字都是如此。\n追逐外来文化，主要是当时海外品牌大举进入中国市场，加之缺失的民族自信，影响了一代人的消费观念。\n一场跨越半世纪的中国品牌大突围 ↗ 可口可乐、肯德基、麦当劳进入一线城市，在普通人仅十几块钱工资时，一杯可乐卖4毛钱，去肯德基搓一顿无异于过年；\n日化品牌里联合利华、宝洁长驱直入；时尚潮流由皮尔卡丹、花花公子、鳄鱼等引领；家电领域，索尼、西门子、松下、LG等横扫千家万户……\n在很长一段时间，中国品牌虽然主场作战，却狼狈不堪。\n在很多人心目中，产品用上洋名就是大品牌、高品质、有面子的象征。包括现在，还有老一辈的人称呼火柴为“洋火”、称呼铁铲为“洋铲”、称呼铁钉为“洋钉”这些都是外来产品入侵本土文化的历史。\n于是开始有本土品牌开始包装自己，取一个“洋名”，听上去有档次，比如美特斯邦威、卡尔丹顿、拉夏贝尔、隆力奇、海尔；以及直接用英文做品牌名：TCL 的前身 TTK 家庭电器有限公司于 1981 年成立。\n但是这个时候能完全说是不自信吗，也不是，英文名在国际化方面确实是优势。\n在号称“中国现代公司元年”的1984年，张瑞敏当了青岛冰箱厂（海尔前身）的厂长，接过一个严重亏损、资不抵债的烂摊子。\n那时一台冰箱卖800元，超过工人两年的工资。76台不合格冰箱全被愤怒的张瑞敏用铁锤砸掉，全国轰动。\n这一锤，让质量为王的理念，从此生根发芽。\n1990年，海尔第一次向“制造强国”德国出口冰箱，结果有8000台滞留海关无法过检。\n张瑞敏请质检员揭去在场德国冰箱、海尔冰箱的商标，放到一起重新检验，结果海尔冰箱获得的优秀比“老师”利勃海尔还多。\n这一战后，海尔打入了一向以高标准、高质量闻名的欧洲市场，中国品牌在世界上有了名头。\n后来互联网出现，以前回到了最原始的状态，开始在传播上下功夫，“好记”成为标准。\n互联网品牌的命名方式有三种：\n一是用具象的物或动作命名：阿里巴巴、巨人、搜狗、虎牙、斗鱼、飞猪、盒马、小米、西瓜、瓜子、花椒、土豆等\n二是叠词：QQ、钉钉、当当、滴滴、人人、脉脉、陌陌、探探、转转、拼多多、货拉拉、哔哩哔哩等。\n三是口语化：去哪儿、好吃点、花呗、饭否、知乎、饿了么。\n这个阶段主要是迎合互联网用户 —— 无需说明，一触即达。\n这个阶段也是品牌最活跃的时候，层出不穷的品牌出现，很快简短的名称就不够用了，于是被迫朝着三个字、四个字，甚至五个字发展。同时命名也更聚焦于行业和产品特性。\n比如：三只松鼠、完美日记、元气森林、卤味研究所。\n如今的品牌命名更多朝着“品牌能给消费者带来什么”的方向命名，即视角开始从抽象的理想转到具象的消费者。\n三、什么是不好的名字 《孟子》说到：“君子不立危墙之下”，当我们决定创造一个名字的时候，我们没有办法创造一个一鸣惊人的名称，我们的目标不是好，而是不差。至于如何好，那是消费者、时代和运气的共同选择。\n不容易记住 我们取名的首要目的不是为了表达理想，而是为了让人记住，名字越长、使用的词汇越陌生、字越生僻，名字就不容易记忆。\n多数人们能记住的都是简短的朗朗上口的。\n需要切换输入法 打字不方便的，特别是有不同类型字符的，甚至是有特殊字符的，这样的名字从搜索的角度来说都是很不方便的。比如 “漾·19Club”，这样的名称在输入的时候需要切换输入法，对于用户来说是很麻烦的。\n中文、英文、数字和符号，任何组合都会影响到输入。用苹果手机的用户可能感受比较明显：打字的时候经常没有办法快速输入标点符号，导致表达受限。\n有生僻字 生僻字可谓是大忌，记忆和传播都是，更不要说理解了。\n比如“大龙燚（yi）”，这个名字很难认识，并且在输入的时候，往往不能直接选中，有时翻页都找不到 “燚” 字，特别是这个字的同音字还特别多。那么就意味着这个品牌在传播的时候需要费更大的精力。\n一个小学生都能理解的字词是最好的。我们通过听能识别的字也就是常用的三千字。有些新锐品牌为了追求标新立异而违背这个原则，往往要在传播上花费更大的精力。\n方言歧义 对于部分地区 HF、NL 不分，识别起来也会存在困难。\n比如“黄鹤楼”，对于部分方言来说，读起来就很费劲，更不要说听者明不明白了。\n字音差异 比如冬奥会雪容融没有冰墩墩火。单从名字上来讲，“墩”这个字虽然不好写，却是北方常用口语，比如胖胖的男孩就被称为“胖墩儿”。墩加上叠字效果，更让人联想到憨态可掬、天真可爱。而 “雪容融” 这个名字，为什么同样读“rong”，却要搞出来两个汉字、两种写法呢？打字多了一层麻烦，还很容易拼错，不如直接叫“雪融融”。\n使用谐音 这很容易想到，有时也能起到让人眼前一亮的效果，比如钟薛高、进京敢烤等。\n不过用谐音梗要注意，看它是否会增加传播成本，也就是别人能不能快速检索到你。\n罗振宇就曾说过，他最初给自己的公众号取名“罗辑思维”，后来发现这个名字有一定问题。比如很多人会搜索“逻辑思维”，平白浪费了流量；而且多数人在微信里打这四个字，会先用拼音打出来“逻辑思维”，然后将光标移到“逻”字后面将“逻”删除，再打一个“罗”字，别说打字，听起来就很麻烦。还有茶颜悦色、茶理宜世这些名字，就存在这样的问题。\n不用本国语言 比如在中国的品牌，用纯粹的英文，这样的名字消费人群同样限制了人群。\n比如 “一緒に寿喜烧” 即便是日本元素，也不建议这样命名，在搜索的时候非常困难。\n使用英文缩写时的歧义 比如朝天门火锅这个品牌，中文名还停不错，但是在设计 LOGO 的时候画蛇添足地加上了 “CTM” 这三个字母，实在是令人困惑。\n比亚迪的缩写 BYD，也有歧义，但是后来官方解释为 “build your dream”。\n意大利奢侈品牌 D\u0026amp;G 在辱华事件以前，中国市场里东北卖得最好。为什么呢？因为东北人认为“DG”两个字代表“大哥”。\n标致雪铁龙集团的新世代豪华品牌 DS，虽然在法国荣耀加身，备受法国政要欢迎，被誉为“总统座驾”，但在中国却遭遇了滑铁卢。这是因为 DS 法文全称为 Déesse，在法语中是“女神”之意，但在中国却变成了“屌丝”，\n滥俗名字词 小说家詹姆斯·斯科特·贝尔在《这样写出好故事》谈到小说创作中，有一个令人拍案的观点叫做：只展示，别说明。\n展示是呈现一幅画面和场景，让读者看到角色的动作与对话，从而自行推理故事情节，感受角色的个性和内心情绪，而不是直接说明角色内心发生了什么。\n贝尔举了一个例子 —— 写小说时，你可以描写：“马克瞪大眼睛，嘴巴张得老大，他试图呼吸，却吸不到气……”读者马上可以感受到角色的情绪，这比平铺直叙地说明“马克既震惊又害怕”好多了。\n取名字也是这样，不要试图通过品牌名称直接去说明产品的好，而是要让消费者感受好产品。\n取名时要少用美、好、优、品这些被用烂了的说明性词汇，诸如无印良品、小米有品、聚美优品、名创优品、凡客诚品，网易严选、顺丰优选、橙心优选、美团优选，完美中国、完美日记、丸美，这些名字实在是太多了。\n四、如何取一个好名字 一言以蔽之，好名字的基础是好记的名字，然后才是文化原型、品类属性、暗示映射、好听、好联想、好寓意、好玩、好延展等附加价值。\n名字是一个符号，在《华与华超级符号》中，首先是看有没有可以嫁接的文化，试图通过已有的事物让消费者记住你。下面就简述一下这些方法。\n通俗口语 比如“滴滴”“花呗”“饿了么”，这些名字经常会被说，容易理解，记忆成本很低，而传播效率又很高。\n这样的名称有两个特点：\n叠词：比如“拼多多” “货拉拉” “企查查” “转转” “旺旺”，这样的词有快速传播的特性。 口语：比如 “去哪儿” “扫呗”，这样的口语词具备快速记忆的特性。 语句：“交个朋友”“认养一头牛”，这样的语句没有过于口语化，但是仍然没有提高很多记忆成本。其实这样的名字就是动词+名词的组合，关于这样的技巧，后面再聊。 但是不要太语句，比如 2019 年 4 月，宝鸡一家网络公司因为公司名在网络上走红。这家公司号称中国名字最长的公司，企业名称足足有39 个字 —— 宝鸡有一群怀揣着梦想的少年相信在牛大叔的带领下会创造生命的奇迹网络科技有限公司。这样的名称很有创意，但是很难不想到国外的一个名叫 “Uvuvwevwevwe Onyetenvewve Ugwemubwem Ossas” 的人，这样的名字别说听，就是抄写也不容易记下来。一般来说两个字最好，不要超过五个字，一眼就能完全识别的状态是最好的。\n文化寄生 竞争战略之父 Michael Porter：“基于文化的优势是最根本的、最难以替代和模仿、最持久的和最核心的竞争优势”\n熊猫、长城、龙这些都是中国文化的标志性符号。这样的名字几乎都被注册了，如果非要用，也无非是添加更多的描述词。\n既然是符号，创始人本身也可以是符号，“Are You OK” “遥遥领先” “抽烟喝酒烫头” 会让你分别想到谁？\n这些就是符号本身，即：创始人有没有什么标签？\n比如罗永浩砸西门子劣质冰箱后命名的“锤子”科技，而后又因为“交个朋友”的口头禅，成立“交个朋友”科技。这样的名字是一种非常好的标签，更是一种可被描述的理想。\n五、取名的方法 符号心智 椰树 斑马 苹果 小米 这样的名字一般不会单独出现，而是会附带品类，不难理解，单名词作为品牌名，注册也是很难的。一般会加定语描述\n跨品类描述\n功夫恐龙\n瓜子二手车\n一只酸奶牛\n逆认知描述\n飞猪 三个爸爸 蓝月亮 网易考拉 不难发现这样的名称都是定语描述：xxx的xxx，然后只保留名词作为名称。\n行为复合 叫了只炸鸡 认养一头牛 交个朋友 淘宝 百词斩 这样的名称大多是动词+名词的组合，这种复合句最大的优势就是可以关联场景。其实像动名词的组合也是很好的，对于名词我们可能会生疏，但是对于动词就活灵活现。\n用户绑定 好孩子 太子奶 帮宝适 贝亲 将品牌名称和用户绑定在一起，这样的名称可以绑定用户的一个阶段。\n联想 泛化使命 华为 中兴 红旗 解放 这些品牌都是在当时的时代背景下诞生的，现在这样的名字较为罕见。\n模糊身份 红星美凯龙 元気森林 奈雪の茶 华伦天奴 马克华菲 这样的名称会有“洋品牌”的感觉，在市场上会获得一定的关注，但是也容易被反噬。\n产品品类 小罐茶 每日黑巧 七分甜 小仙炖 椰树 全棉时代 根据产品自身的功能取名是较为常见的，消费者可以通过产品名联想到品牌，相等于是用品牌名确立了一个品类，辨识度非常高，就像是看到“谭木匠”这样的名字，从名字听上去就专业。\n联想用途 立白 飘柔 汰渍 舒肤佳 佳洁士 通过产品用途确定品牌名称，这样的名字听上去就能感受到它是做什么的\n积极寓意 瑞幸 喜茶 福临门 完美日记 百事可乐 吉利 好利来 红双喜 消费者买东西，特别是送礼的时候，都希望有吉祥的寓意。但是不要矫枉过正，过于在乎文字的寓意，在取名时，搞得特别复杂，最后消费者记不住\nIP 塑造 康师傅 老干妈 王守义十三香 老妈兔头 沪上阿姨 王老吉 谭鸭血火锅 将品牌 IP 化，听上去历史感十足，在老字号品牌上比较常见，用户可以从名字感受到品牌的温度，即是专业，也是亲切。\n具象场景 农夫山泉 良品铺子 百果园 如家 三只松鼠 好名字能给消费者创造画面感，这样的名字也容易被记住，特别是在广告语的配合下，活灵活现。比如“农夫山泉” 你是不是也会感觉到山腰的一个农夫带着草帽，在农田里劳作的场景呢？\n传递情绪 百事可乐 可口可乐 爽歪歪 太太乐 积极的情绪的传播效率更高。\n宣扬理念 特步 keep 蔚来 得力 这样的名字有憧憬的空间。\n六、命名的深层追求 品类属性 从品牌名称就能知道这个产品是什么。\n比如“东鹏特饮”和“魔爪”，东鹏特饮停名字就知道是饮料，但是魔爪呢？实际上也是，但是在传播的过程中后者往往会需要更高的营销成本，才能和前者达到类似的消费者认知。\n其他类似的还有途牛、蚂蚁金服、货拉拉，零食有鸣等，从名字就可以确定产品是什么。\n暗示品质 小罐茶，这个名字就抓住了一个关键特征，茶叶用铝罐包装，充氮保鲜。当然小罐茶也有别的卖点，但是如果你要在品牌名中既体现小罐包装，又体现精选茶叶、大师制茶、送礼有面，那么还能想出来小罐茶这个名字吗？\n而最后为什么选择体现小罐呢？因为这个特征最直观，一目了然，小罐不仅代表了便捷的产品体验，而且体现了品牌的精致与品位。\n六个核桃，消费者很容易关联到补脑和核桃，还是六个核桃，这个名字一听就是品质高。\n七分甜，这个品牌则暗示低糖。\n暗示，是这个品牌和其他品牌差异的具体点，而这个点是通过那个唯一的词汇去表现的。这是精简信息后仍然保留的大量的想象空间。\n展示态度 比如“亚洲吃面公司”、“不方便面馆”和“超级植物有限公司”，初次听到这个名字的时候多少有点无厘头，但是你取看它们的产品的时候更能发现它们的态度非常明确，这算是品牌和理念的言行一致。\n一个比较知名的案例还有“太二酸菜鱼”，在曾经的官网它是这样描述自己的：全宇宙“第二”好吃的酸菜鱼，有全餐饮最霸道最奇葩的规矩： 不拼桌、不加位、不外卖，超过4个人还不接待，却每次排队都要2小时。\n设计延展 一个好名字当应该好设计延展。比如 LOGO 和文宣，作为具象物体命名的品牌，设计起来就比较容易，但是比较抽象的品牌名称就比较难了。\n比如华为，人们常常叫菊厂就是因为 LOGO 的设计。Paula Scher 为 IBM 创作的 LOGO 是字体设计，这都是从品牌文化去抽象的。\n七、参考： 怎么给品牌取个好名字？ ↗ 创业失败，可能是公司名字起得太烂？ ↗ 小马宋：普通人如何取一个营销学上的好名字？ ↗ 品牌名称：如何起一个好的品牌名？ ↗ 梳理近20年，国内品牌命名的流行趋势 ↗ 十年经验谈：为外国品牌起中文名那些事 ↗ 中国营销大变天，《超级符号原理》给我的启示 ↗ 研究完500+品牌名，我们发现了这11个规律（上） ↗ 研究完500+品牌名，我们发现了这11个规律（下） ↗ 品牌取名指南：这样取名字，能帮你减少50％以上的广告费用 ↗ 做品牌前先把名字取好｜8个品牌命名公式 ↗ ","date":"2025-01-30","tags":["取名","品牌名"],"title":"好听好记：如何取一个容易传播的名字？","url":"/post/2025/01/how_to_choose_a_good_name/"},{"content":"简述 这是一款即时设计的插件，使用 ts/react 开发，代码是官方的，这里只是解析， GitHub 地址 ↗ 一、前置条件 即时设计客户端 https://js.design/download ↗ vscode https://code.visualstudio.com/Download ↗ code 快捷命令（可选）\nmacOS 系统快捷键：⌘ + ⇧ + P （command + shift + p）\nWindows/Linux 快捷键: Ctrl + Shift + P\n搜索安装 shell command\nnodejs/npm https://nodejs.org/en/download/ ↗ react npm install @types/react @types/react-dom 启用类型提示 在 vscode 按 Ctrl + Shift + b 开发即时设计类型提示\n效率工具 webpack 关于 webpack 的简介，可以查看 这篇文章 https://webpack.docschina.org/guides/getting-started/ ↗ # 安装 webpack npm install webpack webpack-cli --save-dev # 安装 TypeScript 编译器和 loader npm install --save-dev typescript ts-loader 开发依赖 开发依赖 (devDependencies)\n@jsdesigndeveloper/plugin-typings\n作用: 提供 jsd 插件开发的 TypeScript 类型定义。\n安装命令:\nnpm install --save-dev @jsdesigndeveloper/plugin-typings @types/node\n作用: 提供 Node.js 的类型定义，用于 TypeScript 开发。\n安装命令:\nnpm install --save-dev @types/node css-loader\n作用: 让 Webpack 能够处理 CSS 文件，并将其转换为 JavaScript 模块。\n安装命令:\nnpm install --save-dev css-loader html-webpack-inline-source-plugin\n作用: 将 JavaScript 和 CSS 文件内联到 HTML 文件中。\n安装命令:\nnpm install --save-dev html-webpack-inline-source-plugin html-webpack-plugin\n作用: 自动生成 HTML 文件，并将打包后的 JavaScript 和 CSS 文件注入到 HTML 中。\n安装命令:\nnpm install --save-dev html-webpack-plugin ts-loader\n作用: 让 Webpack 能够处理 TypeScript 文件，并将其转换为 JavaScript。\n安装命令:\nnpm install --save-dev ts-loader typescript\n作用: TypeScript 编译器，用于将 TypeScript 代码编译为 JavaScript。\n安装命令:\nnpm install --save-dev typescript url-loader**\n作用: 将文件（如图片、字体）转换为 Base64 编码的 URL，并内联到 JavaScript 或 CSS 中。\n安装命令:\nnpm install --save-dev url-loader webpack\n作用: 前端项目的模块打包工具，用于将 JavaScript、CSS、图片等资源打包成一个或多个文件。\n安装命令:\nnpm install --save-dev webpack webpack-cli\n作用: Webpack 的命令行工具，用于运行 Webpack 命令。\n安装命令:\nnpm install --save-dev webpack-cli 生产依赖 (dependencies)\n@types/react**\n作用: 提供 React 的类型定义，用于 TypeScript 开发。\n安装命令:\nnpm install @types/react @types/react-dom\n作用: 提供 React DOM 的类型定义，用于 TypeScript 开发。\n安装命令:\nnpm install @types/react-dom react\n作用: React 核心库，用于构建用户界面。\n安装命令:\nnpm install react react-dev-utils\n作用: 提供一些 React 开发工具，例如 Webpack 插件和实用函数。\n安装命令:\nnpm install react-dev-utils react-dom\n作用: 将 React 组件渲染到 DOM 中。\n安装命令:\nnpm install react-dom 二、开发示例 这是一个自动生成矩形的插件\n创建项目 在 即时设计 软件中，在菜单中，选择插件 \u0026gt;插件开发 \u0026gt; 创建新插件，输入插件名称，选择有交互插件。随即打开即时设计创建的这个插件文件。\n创建的文件结构如下：\nplugin ├── code.js ├── manifest.json ├── package.json └── ui.html 在 vscode 中打开创建的这个插件\ncode 插件名称，输入你自己创建的插件名称\n在项目根目录下生成 ts 配置文件\nnpx tsc --init 在项目根目录下创建 webpack 配置文件\ntouch webpack.config.js 现在文件中是空的，一会儿再加代码\n现在目录结构如下\nplugin ├── /src └── code.js ├── manifest.json ├── package.json ├── package-lock.json ├── webpack.config.js ├── tsconfig.json └── ui.html 处理插件逻辑 项目依赖文件： { \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;code.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@jsdesigndeveloper/plugin-typings\u0026#34;: \u0026#34;^1.0.12\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^16.7.1\u0026#34;, \u0026#34;css-loader\u0026#34;: \u0026#34;^6.2.0\u0026#34;, \u0026#34;html-webpack-inline-source-plugin\u0026#34;: \u0026#34;0.0.10\u0026#34;, \u0026#34;html-webpack-plugin\u0026#34;: \u0026#34;^5.3.2\u0026#34;, \u0026#34;style-loader\u0026#34;: \u0026#34;^3.2.1\u0026#34;, \u0026#34;ts-loader\u0026#34;: \u0026#34;^9.2.5\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.3.5\u0026#34;, \u0026#34;url-loader\u0026#34;: \u0026#34;^4.1.1\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;^5.51.1\u0026#34;, \u0026#34;webpack-cli\u0026#34;: \u0026#34;^4.10.0\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;@types/react\u0026#34;: \u0026#34;^19.0.8\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^19.0.3\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^19.0.0\u0026#34;, \u0026#34;react-dev-utils\u0026#34;: \u0026#34;^12.0.1\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^19.0.0\u0026#34; } } TS 配置文件 在 tsconfig.json 输入\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, // 编译后的代码将符合 ES6 (ES2015) 标准。 \u0026#34;jsx\u0026#34;: \u0026#34;react\u0026#34;, // 将 JSX 转换为 React.createElement 调用。 \u0026#34;noEmit\u0026#34;: false, //编译器会生成编译后的 JavaScript 文件。如果设置为 true，则只进行类型检查，不生成输出文件。 \u0026#34;typeRoots\u0026#34;: [ // 类型定义文件（.d.ts 文件）的查找路径 \u0026#34;./node_modules/@types\u0026#34;, \u0026#34;./node_modules/@jsdesigndeveloper\u0026#34; ] }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;] // 需要编译的文件或目录。 } webpack 配置文件 在 webpack.config.js 输入\nconst InlineChunkHtmlPlugin = require(\u0026#39;react-dev-utils/InlineChunkHtmlPlugin\u0026#39;); // 用于将 JavaScript 代码内联到 HTML 文件中。 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) //用于生成 HTML 文件，并自动注入打包后的 JavaScript 文件。 const path = require(\u0026#39;path\u0026#39;) // Node.js 的内置模块，用于处理文件路径。 const webpack = require(\u0026#39;webpack\u0026#39;) // Webpack 的核心模块。 module.exports = (env, argv) =\u0026gt; ({ // 导出配置 (环境，命令行参数) mode: argv.mode === \u0026#39;production\u0026#39; ? \u0026#39;production\u0026#39; : \u0026#39;development\u0026#39;, // 设置 Webpack 的构建模式： // This is necessary because jsDesign\u0026#39;s \u0026#39;eval\u0026#39; works differently than normal eval devtool: argv.mode === \u0026#39;production\u0026#39; ? false : \u0026#39;inline-source-map\u0026#39;, // 控制是否生成 source map，用于调试代码： entry: { // 定义项目的入口文件： ui: \u0026#39;./src/ui.tsx\u0026#39;, // UI 的入口 code: \u0026#39;./src/code.ts\u0026#39;, // 插件逻辑的入口 }, module: { rules: [ // 定义模块的加载规则： // Converts TypeScript code to JavaScript { test: /\\.tsx?$/, use: \u0026#39;ts-loader\u0026#39;, // 将 TypeScript 文件转换为 JavaScript。 exclude: /node_modules/ }, // Enables including CSS by doing \u0026#34;import \u0026#39;./file.css\u0026#39;\u0026#34; in your TypeScript code { test: /\\.css$/, use: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;], // 允许在 TypeScript 中导入 CSS 文件。 }, // Allows you to use \u0026#34;\u0026lt;%= require(\u0026#39;./file.svg\u0026#39;) %\u0026gt;\u0026#34; in your HTML code to get a data URI // { test: /\\.(png|jpg|gif|webp|svg|zip)$/, loader: [{ loader: \u0026#39;url-loader\u0026#39; }] } { test: /\\.svg/, type: \u0026#39;asset/inline\u0026#39; // 将 SVG 文件作为内联资源（Base64 编码）嵌入到代码中。 } ] }, // Webpack tries these extensions for you if you omit the extension like \u0026#34;import \u0026#39;./file\u0026#39;\u0026#34; resolve: { extensions: [\u0026#39;.tsx\u0026#39;, \u0026#39;.ts\u0026#39;, \u0026#39;.jsx\u0026#39;, \u0026#39;.js\u0026#39;] }, // 设置模块解析的扩展名。 output: { // 定义输出文件的配置： filename: \u0026#39;[name].js\u0026#39;, // 输出文件的名称，[name] 会被替换为入口名称（如 ui.js 和 code.js）。 path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), // 输出文件的目录，这里是项目根目录下的 dist 文件夹。 // Compile into a folder called \u0026#34;dist\u0026#34; }, // Tells Webpack to generate \u0026#34;ui.html\u0026#34; and to inline \u0026#34;ui.ts\u0026#34; into it plugins: [ // 配置 Webpack 插件： new webpack.DefinePlugin({ // 定义全局变量，这里用于修复 global 变量的缺失问题。 \u0026#39;global\u0026#39;: {} // 修复在开发者 VM 中运行时的全局变量错误 }), new HtmlWebpackPlugin({ // 根据模板 ./src/ui.html 生成 ui.html 文件，并自动注入 ui.js。 inject: \u0026#34;body\u0026#34;, template: \u0026#39;./src/ui.html\u0026#39;, filename: \u0026#39;ui.html\u0026#39;, chunks: [\u0026#39;ui\u0026#39;] }), new InlineChunkHtmlPlugin(HtmlWebpackPlugin, [/ui/]), // 将 ui.js 内联到 ui.html 中。 ], }) 插件逻辑文件 创建 src/code.ts 文件\njsDesign.showUI(__html__); // 显示插件的用户界面（UI）。__html__ 是一个特殊的变量，通常用于嵌入 HTML 内容。在这里，它表示插件的 UI 界面（通过 HtmlWebpackPlugin 生成的 ui.html 文件）。 jsDesign.ui.onmessage = (msg) =\u0026gt; { // 从 UI 发送过来的消息对象。 if (msg.type === \u0026#34;create-rectangles\u0026#34;) { // 消息的类型，用于区分不同的操作。 const nodes = []; // 创建矩形的逻辑 for (let i = 0; i \u0026lt; msg.count; i\u0026#43;\u0026#43;) { // 从 UI 传递过来的参数，表示需要创建的矩形数量。 const rect = jsDesign.createRectangle(); //创建一个矩形节点。 rect.x = i * 150; // 设置矩形的水平位置（每次递增 150，避免矩形重叠）。 rect.fills = [{ type: \u0026#34;SOLID\u0026#34;, color: { r: 0.8, g: 0.8, b: 0.8 } }]; // 置矩形的填充颜色（这里是浅灰色）。 jsDesign.currentPage.appendChild(rect); // 将矩形添加到当前页面。 nodes.push(rect); // 将创建的矩形节点保存到数组中。 } jsDesign.currentPage.selection = nodes; // 将创建的矩形设置为当前选中的对象。 jsDesign.viewport.scrollAndZoomIntoView(nodes); // 将视图滚动并缩放到适合查看所有矩形的位置。 } jsDesign.closePlugin(); // 在处理完消息后关闭插件。 }; ui 逻辑文件 src/ui.tsx\n// 通过 React 实现了一个简单的表单，允许用户输入矩形的数量并触发创建矩形的操作。 import * as React from \u0026#39;react\u0026#39; // React 核心库，用于构建组件。 import * as ReactDOM from \u0026#39;react-dom\u0026#39; // 用于将 React 组件渲染到 DOM 中。 import \u0026#39;./ui.css\u0026#39; // 引入样式文件，用于美化 UI。 declare function require(path: string): any // 这是一个 TypeScript 声明，用于告诉编译器 require 函数的存在。通常用于加载静态资源（如图片、字体等），但在这里并未实际使用。 class App extends React.Component { textbox: HTMLInputElement // 一个类属性，用于保存输入框的 DOM 元素引用。 countRef = (element: HTMLInputElement) =\u0026gt; { // 一个回调函数，用于绑定输入框的 DOM 元素。当输入框渲染完成后，会将其默认值设置为 5，并保存到 textbox 属性中。 if (element) element.value = \u0026#39;5\u0026#39; this.textbox = element } onCreate = () =\u0026gt; { // 点击“创建”按钮时触发的函数。 const count = parseInt(this.textbox.value, 10) // 从输入框中获取用户输入的值（矩形数量）。 parent.postMessage({ pluginMessage: { type: \u0026#39;create-rectangles\u0026#39;, count } }, \u0026#39;*\u0026#39;) // 向 JSD 插件主逻辑发送消息，消息类型为 create-rectangles，并传递 count 参数。 } onCancel = () =\u0026gt; { // 点击“取消”按钮时触发的函数。 parent.postMessage({ pluginMessage: { type: \u0026#39;cancel\u0026#39; } }, \u0026#39;*\u0026#39;) // 向 JSD 插件主逻辑发送消息，消息类型为 cancel。 } render() { // 渲染组件的 UI。 return \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;创建矩形\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;数量： \u0026lt;input ref={this.countRef} /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;create\u0026#34; onClick={this.onCreate}\u0026gt;创建\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.onCancel}\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } } //--- ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#39;react-page\u0026#39;)) // 将 App 组件渲染到 DOM 中，挂载到 id 为 react-page 的元素上。 //--- // 对于 React 18\u0026#43;，你需要使用 createRoot() 替换 ReactDOM.render()： // 替换如下 // import { createRoot as createReactRoot } from \u0026#39;react-dom/client\u0026#39;; // function createRoot(element: HTMLElement) { // return createReactRoot(element); // } // root.render(\u0026lt;App /\u0026gt;) 插件模板 webpack 会自动注入 js\nsrc/ui.html\n\u0026lt;div id=\u0026#34;react-page\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; mainfest.json jsd 插件识别文件 manifest.json 是 ssd 读取插件的配置文件，只改 main 和 ui\n{ \u0026#34;name\u0026#34;: \u0026#34;your_plugin_name\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;your_plugin_id\u0026#34;, \u0026#34;api\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;dist/code.js\u0026#34;, // code.js 的位置 \u0026#34;ui\u0026#34;: \u0026#34;dist/ui.html\u0026#34; // ui.js 的位置 } 三、构建插件 pnpm run build 四、在 jsd 中运行插件 在菜单中，选择插件 \u0026gt;插件开发 顶部会出现你创建的插件，如果没有，就在 通过 manifest 导入插件（通过即时设计创建的插件，会自动生成这个文件）\n现在插件的开发就结束了\n","date":"2025-01-24","tags":["插件"],"title":"即时设计插件开发","url":"/post/2025/01/jsdesign_plugin_dev/"},{"content":"==fds==\n一、简述 这是一个专注于编程的 Hugo 博客主题。\n参考了我此前为 Typora 开发的 Thompsgo 主题 ↗ 二、特性 1. 运行代码 支持的语言：\npython (wasm) lisp (JavaScript 实现的 Common Lisp (JSCL) 解释器) cpp (playground) rust (playground) go (playground) ts (TypeScript 的 JavaScript 实现) js (原生) 代码运行示例 Rust\nfn main() { println!(\u0026#34;Hello from Rust!\u0026#34;); } 运行 Go\npackage import \u0026#34;fmt\u0026#34; func main(){ fmt.print(\u0026#34;hello\u0026#34;) } 运行 Lisp\n(progn (format t \u0026#34;Hello from Lisp!\u0026#34;) \u0026#34;Hello from Lisp!\u0026#34;) 运行 Python\nprint(\u0026#34;test\u0026#34;) 运行 TypeScript\nconsole.log(\u0026#34;hello\u0026#34;) 运行 C++\n#include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;; return 0; } 运行 2. mermaid 图表 sequenceDiagram 张三-\u003e\u003e李四: 我是张三！ 李四--\u003e\u003e张三: 我是李四! 张三-)李四: 好的! 3. 数学公式 $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\ \\end{vmatrix} $$\n4. 效果 文字 彩色标签 抖音字 空心字 闪烁字 黑底字 彩虹字 隐藏文本 提示块 图片 单色 模糊 半透明 反色 圆角 边框 5. 多语言 参考 hugo 的多语言配置，默认使用路径语言参数（例如/en）\n6. 目录 在移动端支持折叠和展开，并支持目录标题跳转\n7. 搜索 使用模糊搜索库 fuse.js 实现搜索功能\n8. 博客统计 博客文章基础统计 标签云 热门文章 归档 9. 日/夜模式 参考 Hugo-Paper\n10. 评论 参考 Hugo-Paper\n11. 时间线 2021.1 ~ 2022.2 开发 dev 2022.4 ~ 2023.3 设计 des 12. 折叠菜单 I have keys but no locks. I have space but no room. You can enter but can't leave. What am I? A keyboard. 13. 嵌入 三、基本编辑 Markdown以下称作md\nThompsgo主题以下称作主题\nmermaid，一种编辑和渲染器，可以编辑并展示思维导图、流程图、序列图、甘特图等多种矢量图形的，typora可直接使用\n部分markdown不支持的样式比如带下划线文字或者 带颜色的文字可以通过html实现\n1. 基础语法 1.1 md语法 markdown语法-菜鸟教程 ↗ 如果不起作用请检查是否有空格或者尝试换行 $$ f(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d\\xi $$\n标题\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 字体样式\n斜体： *斜体文本* _斜体文本_ 粗体： **粗体文本** __粗体文本__ 斜粗体： ***粗斜体文本*** ___粗斜体文本___ 删除线： ~~BAIDU.COM~~ 示例\n斜体文本 粗体文本 粗斜体文本 BAIDU.COM\n分割线\n以下任意一种都可以 *** ***** --- ---------- 示例\n脚注\n[^要注明的文本] 您可以像这样创建脚注[^footnote]. - 示例 创建脚注格式类似这样 [^注]。 [^注]: 这是一个注释 5. 列表（可嵌套） ```markdown 普通列表 字符 空格 * 第一项 * 第二项 * 第三项 \u0026#43; 第一项 \u0026#43; 第二项 \u0026#43; 第三项 有序列表：数字 点 空格 1. 第一项 2. 第二项 3. 第三项 - 第一项 - 第二项 - 第三项 嵌套列表：数字/字符 点 空格 数字/字符 点 空格 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 示例 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 区块（引用）\n单层饮用：尖括号 空格 \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 嵌套饮用：尖括号 空格 尖括号 空格 \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套 复合使用： 区块中使用列表： \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; \u0026#43; 第一项 \u0026gt; \u0026#43; 第二项 \u0026gt; \u0026#43; 第三项 列表中使用区块 * 第一项 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 示例\n第一项 区块（引用）\n第二项 代码\n使用符号： ` `代码` 代码块： ```代码语言 代码 ``` 示例\n代码 链接\n[链接名称](链接地址) [菜鸟教程](https://www.runoob.com) 或者 \u0026lt;链接地址\u0026gt; \u0026lt;https://www.runoob.com\u0026gt; 示例\n菜鸟教程 ↗ https://www.runoob.com ↗ 图片\n图片地址可以是本地或网络地址 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;) 使用HTML标签指定图片高度和宽度 \u0026lt;img decoding=\u0026#34;async\u0026#34; src=\u0026#34;http://static.runoob.com/images/runoob-logo.png\u0026#34; width=\u0026#34;50%\u0026#34;\u0026gt; 示例\n表格\n| 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 示例 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 任务列表\n- [ ] 未完成 - [x] 完成 示例 未完成 完成 html支持\n\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt; 例如： \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;\u0026#43;\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;\u0026#43;\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt;重启 示例\nCtrl+Alt+Del重启\n转义\n\\ 反斜线 支持的符号 （这些符号在md中有意义，可以进行一些格式操作，反斜线可以让它们以文本显示） ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 \u0026#43; 加号 - 减号 . 英文句点 ! 感叹号 示例\n# - !\n公式\n支持 KaTeX ↗ 或者 MathJax ↗ 公式渲染器 $$ \\begin{Bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{Bmatrix} $$ 示例 $$ \\begin{Bmatrix} a \u0026amp; b \\ c \u0026amp; d \\end{Bmatrix} $$\n$$ \\begin{CD} A @\u0026gt;a\u0026gt;\u0026gt; B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} $$ $$ \\begin{CD} A @\u0026gt;a\u0026raquo; B \\ @VbVV @AAcA \\ C @= D \\end{CD} $$\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\ \\end{vmatrix} $$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\ \\end{vmatrix} $$\n$\\lim_{x \\to \\infty} \\exp(-x) = 0$ $\\lim_{x \\to \\infty} \\exp(-x) = 0$\n表情\n:smile: 示例 :smile:\n:tent:\n:hand:\n:camera:\n目录\n自动依据‘#’标签生成目录 [toc] YAML\nTypora 现在支持 YAML Front Matter 。 在文章顶部输入 --- 然后按 Enter 键将引入一个，或者从菜单中插入一个元数据块。 Typora支持 YAML\n这是一种编写元数据的数据序列化语言\n为什么使用\n我们来看markdown的#其实表示的是header，严格意义上来说是一级标题而不是文章标题title，放在论文里来说就是header 1可以是前言、方法、结果、讨论等，但不是论文的题目。如此一来我们就需要一个用来存放title的地方，这就是metadata的存在的意义，当然它不仅仅能容纳title，还可以加上author、keywords、abstract等信息1。这些数据可以在文件的详细信息里面看到。\n实际上YAML还可以保存用于脚本的变量，以实现各种导出时的特殊要求\n使用方法\n在文章顶部输入 --- 然后按 Enter 键将引入一个，或者从菜单中插入一个元数据块。 添加文章作者和关键字等信息 --- title: \u0026#34;This is the title: it contains a colon\u0026#34; author: - Author One - Author Two keywords: [nothing, nothingness] abstract: | This is the abstract. It consists of two paragraphs. --- 例如\n--- # 注释：导出的yaml设置 title: Thompsgo使用方法 author: 曹洋 creator: 曹洋 subject: Usage keywords: [使用方法、markdown、HTML、YAML] info: 这是一本关于thompsgo主题的手册，内含markdown、mermiad、html等语言和的基础语法。本主题由 @曹洋 开发，开源地址：https://github.io/caoyang2002 --- \u0026lt;!--注释：导出的html设置--\u0026gt; \u0026lt;meta title=\u0026#34;title\u0026#34; content=\u0026#34;${title}\u0026#34;\u0026gt; \u0026lt;meta info=\u0026#34;info\u0026#34; content=\u0026#34;${info}\u0026#34;\u0026gt; \u0026lt;meta author=\u0026#34;author\u0026#34; content=\u0026#34;${author}\u0026#34;\u0026gt; \u0026lt;div id=\u0026#39;_export_cover\u0026#39; style=\u0026#34;height:100vh;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#39;_export_title\u0026#39; style=\u0026#34;margin-top: 10%;text-align: center;font-size: 10rem;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#39;_export_info\u0026#39; style=\u0026#34;margin-top: 4%;text-align: center;font-size: 1.5rem;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p style=\u0026#34;margin-left:10%;font-size: 1.8rem\u0026#34;\u0026gt; \u0026amp;#128187; Mac专用 \u0026amp;#129412;\u0026lt;/p\u0026gt; \u0026lt;div id=\u0026#39;_export_author\u0026#39; style=\u0026#34;margin-left: 80%;font-size: 2.5rem;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var $cover = document.querySelector(\u0026#34;#_export_cover\u0026#34;); var title = document.querySelector(\u0026#34;meta[title=\u0026#39;title\u0026#39;]\u0026#34;).getAttribute(\u0026#34;content\u0026#34;); var info = document.querySelector(\u0026#34;meta[info=\u0026#39;info\u0026#39;]\u0026#34;).getAttribute(\u0026#34;content\u0026#34;); var author = document.querySelector(\u0026#34;meta[author=\u0026#39;author\u0026#39;]\u0026#34;).getAttribute(\u0026#34;content\u0026#34;); if(!title || title == \u0026#34;${title}\u0026#34; || !author || author == \u0026#34;${author}\u0026#34; || !info || info == \u0026#34;${info}\u0026#34;) { // no title author info $cover.remove(); } else { document.body.insertBefore($cover, document.body.childNodes[0]) $cover.querySelector(\u0026#34;#_export_title\u0026#34;).textContent = title; $cover.querySelector(\u0026#34;#_export_info\u0026#34;).textContent = info; $cover.querySelector(\u0026#34;#_export_author\u0026#34;).textContent = author; } \u0026lt;/script\u0026gt; 嵌入动画\n\u0026lt;iframe height=\u0026#39;265\u0026#39; scrolling=\u0026#39;no\u0026#39; title=\u0026#39;Fancy Animated SVG Menu\u0026#39; src=\u0026#39;http://codepen.io/jeangontijo/embed/OxVywj/?height=265\u0026amp;theme-id=0\u0026amp;default-tab=css,result\u0026amp;embed-version=2\u0026#39; frameborder=\u0026#39;no\u0026#39; allowtransparency=\u0026#39;true\u0026#39; allowfullscreen=\u0026#39;true\u0026#39; style=\u0026#39;width: 100%;\u0026#39;\u0026gt;\u0026lt;/iframe\u0026gt; 示例\n嵌入视频\n\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=12178417\u0026amp;bvid=BV1Ux411q7qd\u0026amp;cid=20076875\u0026amp;page=1\u0026#34; height=\u0026#34;770\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 嵌入音频\n\u0026lt;iframe frameborder=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; marginwidth=\u0026#34;0\u0026#34; marginheight=\u0026#34;0\u0026#34; width=330 height=450 src=\u0026#34;//music.163.com/outchain/player?type=0\u0026amp;id=2870133096\u0026amp;auto=1\u0026amp;height=430\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 示例 ","date":"2025-01-21","tags":[],"title":"Hugo-Focus 主题介绍","url":"/post/2025/01/hugo-focus-info/"},{"content":" 有时候独立开发者想做一个产品，总觉得缺个 UI/UX 设计师，但囊中羞涩，想了想自己八字挺硬，于是做起了设计。\n但是，你为什么觉得自己需要一个设计师？\n我认为这是作为一个独立项目开发者需要想明白的问题。\n有时候，甚至是大多数时候你都不需要设计师。\n相反你应该花更多的时间想想这个产品为什么而存在。但这不是一篇教你挖掘需求或者产品设计的文章。所有的方法都只是设计的见解。\n设计产品 当我们认为自己需要一个产品的时候，往往是因为觉得目前市面上的产品设计得不够好。为什么？\n不符本土的用户习惯？自己不喜欢？市场上的产品逻辑存在缺陷？无论如何，你此时一定有一个明确的目标，尽管它可能不符合市场实际需求。现在，你需要考虑的问题就是：\n设计什么？ 如何设计？ 大多数身兼产品经理的独立开发者总想找一个 UI/UX 设计师，实际上你可能还达不到要考虑设计的时候，你只需要想清楚你的产品是什么？定位是什么？你希望用户如何使用？这并不是逃避设计，而是清晰定义你的产品，以便实现你的设计。\n设计并不是一个高高在上的、超俗的艺术，相反设计是贴近生活的，它和所有人都很近，它是审美，是可能性，更是一种选择。\n我们需要明确的是，每个人对用户和产品之间关系的理解都不同。\n无论是我接触到的设计需求还是自己的产品，最棘手的问题无外乎这个产品是什么？你希望他像什么？\n有时候我会遇到个别需求方已经有明确对标的产品，可是对方总有绕不完的弯，又希望你创造出一个为他量身定制的产品，并且！他还希望有那个产品的交互体验。这个问题几乎是无解的，因为你哪怕多问两个“为什么”，对方就描述不清了。一般我遇到这个情况，都绝不反驳，直接去抄。\n做设计，怕的就是拿着答案找问题。人有一种对自己行为进行合理化的心理，作为设计师，你应该看更多的设计，为客户提供好的解决方案，如果各自认为自己的想法都是对的，那么都应该问对方几个为什么，直到你们找到意见出现分歧的根本问题。\n同样的，作为独立开发者，设计一个产品时，你最好写下你的需求细节，否则在设计的途中容易当初忘记为什么出发。\n假设 -\u0026gt; 实践 -\u0026gt; 反馈 我们有一个共识：好的东西就是需要要你付出成本的，比如时间成本、经济成本、社交成本等。\n做设计的时候也是如此，要承认自己的局限性。\n比如在设计的过程中，你认为有多个解决方案，但是你又无法直接对比出优劣，怎么办？此时要避免“全都要”的想法，而是回到根本问题，假设子问题，然后设计方案，此时可能仍然会有多个方案，你只需要选择一个方向，实现他，然后获取反馈。反馈中可能会有很多类似于“更快的马”的建议，根据反馈重新思考假设的子问题，直到出现“一辆车”的方案。\n如果没有反馈怎么办？放心，这往往不是因为你的产品好，而是产品“令人发指”。不要沮丧，优化产品，重新出发。\n设计的术 这一部分主要讲设计的方法（平面构成），如何设计一个非交互的纯视觉的页面。这些内容在 Zcool 上非常多，我在这里仅略微说明。平面构成的形式有：近似、重复、对比、渐变、分割、对称、平衡、肌理、错视、密集、发射、变异、特异、空间与矛盾空间，看不懂？这不重要，因为立体构成和色彩构成你更看不懂，有激动的小伙伴就要说了：“能不能说点我看得懂的？”\n好嘞！\n平面构成就是画面上的元素通过什么组织方式构成了这个平面作品。重点在构成，又有聪明的小伙伴要说了：“我知道这些，说点我不知道的”\n好嘞！\n画面都是由点线面构成的，\n那么问题来了，点线面是什么面？\n这是一个 “.” 这是一条线 “——“ 这是一个面 “▪️” 同理，\n这是一个点：▪️\n这是一条线： ▪️▪️▪️▪️▪️▪️▪️▪️▪️▪️\n这是一个面：\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n​\t▪️▪️▪️▪️▪️\n一般说到这里，按照同行的规矩，就应该写这个：\n设计大帅班，不要9999，不要 8888，只要998！只要998 …\u0026hellip;\n哈哈，你知道的，我比较叛逆（瞎讲）\n在设计中，第一件事就是锻炼抽象能力，近似、重复、对比、渐变……，这些都是方法，设计就是将复杂形状的内容抽象简单成形状的点线面，然后使用这些方法进行表达。如何表达，就是经验了，锻炼这种能力只能多看、多练。\n以文字内容为例，当你疑惑文字内容太少想知道怎样能让画面变得丰富的时候，你不妨思考以下问题：\n文字在画面中的构图方式是否可以多样化？\n文字是否可以分组？\n文字是否可以添加内容的背景概述？\n是否可以添加为背景肌理？\n文字是否可以在可识别的情况下稍作修改？\n文字是否可以添加图片说明？\n文字一定是表意的吗？\n文字是否可以作为背景？ 文字是否可以成为设计元素？ 以上，都是在引导你处理画面的构成。\n总之有太多的方式可以让你的画面变得丰富，但是多就是好吗？\n这恐怕需要想想设计的目的是什么，为什么设计又叫视觉传达（视觉传达一般归纳为：“谁”、“把什么”、“向谁传达”、“效果、影响如何”四个程序）。\n我们经常看到有一些设计师写的文章，描述设计过程的时候，总是改了很多版以后，终于改出了一个几乎完美的版本，好像给人一种错觉 —— 改得越多越好，实际上不是这样的，改得越多只能说明对需求的过程很糟糕，设计师无法准确把握到需求的要点。\n以前我设计实习的时候，在一家小外包公司，做图总是比别人要慢，十几分钟做一个版本，然后就摸鱼，隔一两个小时去对一下需求，然后改一下，我交稿的时间总是卡在截止时间前不久，这样做的设计不会很差，也基本好不了，但是符合需求，“能跑就行”。设计师可能自己也不太行，但是这是少数，整天做设计的人，审美不会太差，而美的东西总是有吸引力的。\n如果你想改得少，又不想在产品构思阶段下功夫，你就会发现自己没什么可以设计的，然后看到什么新奇就像加到自己的设计上去，最后导致你的设计非常臃肿滥俗，尽管画面很丰富。这是糟糕设计的一种。\n常见的需求 LOGO 设计 LOGO 设计是很难的一个部分，为什么？\nLOGO 设计的不仅仅是一个 LOGO，而是整个项目对外的视觉，是一种调性。很多人能理解整容费用高，但是不能理解 LOGO 费用高，在我看来这是难以理解的，LOGO 和整容有什么区别？\n当你看到一个 LOGO 的时候，你不一定会想起他们的产品，但是一定会想起他们是做什么的，以及他们的调性。\n会 PS/AI 就可以做 LOGO 吗？从形式上来说，是的！作为独立开发者，不要想着找设计师做 LOGO，除非你有产品实力了，否则不要花太多成本做 LOGO。对于产品初期的 LOGO，你只需要想想是文字还是图形，然后确保你的 LOGO 容易被分辨，其他的都不要考虑了。LOGO 设计的价格一般都很高，如果你准备找一个 LOGO 设计，那么请准备好你至少一个月的工资作为 LOGO 设计的费用（实际LOGO 定价不是这样的，但是几千到几万都是正常的）。\n在一个项目的初期，LOGO 没有那么重要。\n一句话来说，LOGO 只是一个标识，这个标识压缩了你的产品理念和愿景。\n有时候这种绑定关系会自然产生，有聪明的小伙伴又要问了：“如何压缩理念和愿景？”这个是设计中的经验部分也是哲学部分，不存在唯一解，很难几百字解释清楚。或者\u0026hellip;\u0026hellip;你认为它好它就好。如果必须有标准，你不妨拿着你设计去问问其他人，“你觉得这个 LOGO 是什么公司用的？”\n实际上这并不准确，大多数公司的 LOGO 都不是这样被创造出来的。他们的创造过程可能在文化上的造诣更高，而不只是形状上的表现。\n有点激动的小伙伴就要问了：“那 LOGO 设计到底怎么做？”\n你希望如何呈现？文字还是图形？绝大多数项目都是图形 LOGO，那么你希望你的品牌是什么内涵？有什么动物或者植物能够代表这种内涵吗？或者喜欢什么？尝试把它画下来，使用 PS/AI 画下来，你也可以使用 Figma 或者即时设计画，随意。只要方便修改就行，唯一的建议是颜色少、无渐变，不仅是可识别性的问题，更是为了避免印刷工艺的限制。\nLOGO 设计，越简单越好。2013年Instagram品牌重塑的标志设计师 Mackey Saturday 表示，人们在设计标志时最常犯的错误之一就是把标志过于复杂。\n版式设计 排版是几乎所有场景都会遇到的！\n亲密性、对比、对齐、重复，看不懂？\n意思是不要劈腿出轨，不要没大没小的、不要乱停乱放、不要随地大小便。\n这里主要讲一下亲密性？\n我认为这是排版中最重要的部分，其他几项都比较容易理解，而亲密性是最容易犯的错误。说白了就是在特定的场景下，有一段给定的内容，其中什么文字和什么文字应该放在一起，比如在一个摄影展览的海报中，只能用以下关键词设计画面：\n“街头摄影大师分享”“马格南” “彩色摄影经典” “Alex Webb” “展览时间2012/12/12-2012/12/13”“国际摄影展” “中国成都站”\n这个海报放在哪里？街头还是商场？摄影展所在场馆门口的易拉宝还是墙上？或者只是在社交应用中传播？呈现场景是设计工作的基础。\n有些手快的小伙伴，转眼就把“马格南”和“街头摄影大师分享”放一起，emm…，他们相关，但是马格南全称是“马格南图片社”，这不重要，因为你应该不会犯这个错误。\n如果你有摄影经验，你应该知道 Alex Webb 是一个人名（好像没摄影经验应该也看得出来，这不重要），Alex Webb 是马格南著名摄影师之一，以彩色摄影著称。\n假设这个海报是面向大众的线上海报，那么主标题是什么？个人经验认为应该是“街头摄影大师分享”，它直接传达了在那个特定的时刻会发生什么。其次，应该也可以理解“Alex Webb” 两个关键字与“街头摄影大师分享”直接关联，所以他们的亲密度是最高的，其次是 “马格南”，从传播的角度考虑，这个名称是一个符号，这个名称压缩了很多信息，但是其他人可能比较难理解。然后是特点标签，例如“中国成都”和“国际摄影展”，它最后是时间地点。至于如何组织，画面，这就是经验问题了，你需要建立你的自信，哪怕是抄，你总要走出这一步。\n这个过程有点像写新闻标题：新闻中的五个要素 ―― 何时、何地、何人、何事、何因或为什么，简称五个“W”。后面再加上一个“H”，即怎样、如何，可理解为结果的意思。\n每项都有可能成为标题，关键是看哪一项更具有传播价值。如果传播的人物为社会所熟悉，在该新闻中特别重要，则应以“人”为先导。以此类推。\nUI/UX 设计 根本问题：你希望用户如何使用你的产品？\n产品好不好，UI/UX 的作用往往没有想象的那么重要，产品营销也不重要，那都是锦上添花的“术”，而产品本身的对用户的价值才是“道”。\n这里只简单讲一下设计中的 UI/UX，至于用户体验的内容暂且搁置。\n多数时候，UI设计多数时候都是经验为先，（审美也是一种经验）。\n至于页面中，应该使用圆形按钮还是方形按钮，输入框还是下划线，这不是很重要，并且它会随着设计的潮流变化而变化。使用你认为容易识别的方式，添加上去即可。或许现在你认为它不够新潮，但是过一段时间以后，它也许就成为了设计的标杆。这并不奇怪。\n最好的 UI/UX 学习就是抄，抄那些知名的产品。而创造就是排列组合。\n海报（宣传）设计 根本问题：你希望其他人如何获取到关键信息？\n你想要传达什么信息，特性？福利？或者其他精彩内容。总之，你有一个点想要传达，这个点就是你想传达的主题，这是整个海报最重要的地方。\n与之相关的是什么？时间？地点？人物？主题？全都有！你只需根据排版的原则进行设计即可。在设计中，设计的载体经常变化，但是设计的内核 —— 排版原则异常稳定的。\n作为初学者，可能会担心，这个黑色的背景行不行？灰色的字在设计中允许吗？彩色字体会更好吗？图形会不会太大了？画面会不会太空了，文字可以分割吗？\n其实这些都不重要，设计中没有任何一条规则告诉你不能做什么，所有的书都会告诉你各种最佳实践的建议。\n有时，规则只有在被打破的时候，你才能发现设计的精巧之处。\n常见的问题 为什么我的设计很空？\n“留白是一种艺术”，你要建立自信（不是，哈哈\n设计空不空不重要，重要的是：你想表达的重点有没有如期展示出来？需要有更多的信息提供吗？如果有表达出来，建议你不要动。有聪明的小伙伴就要说了：“我就是想做好一点”\n行，听你的！\n20世纪最伟大的战地摄影师罗伯特·卡帕说过：你拍得不够好，是因为你离得不够近。\n同样的，你设计不够好，是因为你形不够大。放大一点试试？或者用一些排版的技巧？\n好才做营销 知名战略营销专家小马宋说：“营销的营，首先是经营的营”。所有的增长问题都推诿到营销是不正确的。在做战略营销的时候，往往不是怎么写口号、怎么做包装、怎么打广告的问题，而是解决“客户不喜欢你的产品”的问题。\n不妨回到第一节，思考自己的产品解决了什么样的问题，你的方案优势是什么。\n好产品必然口口相传。\n个人见解 初学设计，你不必追求一鸣惊人，相反，你应该抄，大量地抄。创作的灵感会随着你抄的数量而涌现。\n如果你在创作的时候，觉得自己的配色上不太有感觉或者由于产品定位非常特殊，没有竞品参考，导致没有太多的设计思路，那么你应该更多地去看看 Zcool 或者 Behance，有时候，你做的不好往往是因为你想做好。这看上去是一句废话。确实。\n你做的不好，往往是因为，呈现的极端，一是什么都想要，认为这样可以给用户更好的体验，或者不知道要什么，没内容可写。这不可怕，可怕的是你觉得那些你能想到的东西都很重要，所以把他们都排在一起，并且表现的方式都是类似的，这就导致了问题 —— 你的用户不能定位到准确的信息。\n但是不要忘记，你不是一个设计师，因为设计师不需要看我这篇文章。你是一个独立开发者，是一个项目的负责人，你不应该花很多时间研究设计，好的设计不是需求端（用户）创造的，而是一种自顶向下的设计。\n100多年前，福特公司的创始人亨利·福特先生到处跑去问客户：“您需要一个什么样的更好的交通工具？”几乎所有人的答案都是：“我要一匹更快的马”。很多人听到这个答案，于是立马跑到马场去选马配种，以满足客户的需求。但是福特先生却没有立马往马场跑，而是接着往下问。\n福特：“你为什么需要一匹更快的马？”\n客户：“因为可以跑得更快！”\n福特：“你为什么需要跑得更快？”\n客户：“因为这样我就可以更早的到达目的地。”\n福特：“所以，你要一匹更快的马的真正用意是？”\n客户：“用更短的时间、更快地到达目的地！”\n你的用户往往会很好心地提供一些解决方案，但是那些只是解决问题的方案而不是问题所在。\n除此之外，如果你想成为一个设计师，那么你就不能只读设计。一个问题的解决过程往往不是单一领域的、定向研究的方式，正如温铁军教授所说，“当我们做批判的时候，希望能够跨学科，我们对问题的意识就能建立起来，而不是按照现在这个所谓学科给你的规范，去把他归到某个窄化的那个领域上去”，如果你遇到问题时，认为只有一个解决方案，那么你应该停下来，跳出你现在的问题框架，重新定义这个问题。\n推荐书籍 平面设计 《版式设计从入门到精通》这是一本全面的设计原理书籍，有点厚。\n《版式设计原理》这本书比上一本内容精简很多\n《平面设计原理》这部和上一本类似\n《超越平凡的平面设计：版式设计原理与应用》这一本设计理论和实践的书\n《超越 LOGO 设计：国际顶级平面设计师的成功法则》这是一本LOGO 设计入门的案例参考书籍\nUI/UX/UE 设计 《UX 最佳实践：提高用户体验影响力的艺术》这是一本用户体验的书，侧重于整体目标的实现。\n《以匠心，致设计》 这是关于如何从用户体验的角度思考产品设计的书\n《众妙之门：用户体验设计的秘密》 这是一本关于用户体验优化的小案例研究\n《众妙之门：抓住访客心理的网页设计》这是一本侧重心理学原理的 UI/UX 设计书籍\n《决胜UX：互联网产品用户体验策略》这是一本关于如何通过有效策略，实现产品目标的书。\n《UX 设计之道：以用户体验为中心的 web 设计》这本书比较全面得解析了用户体验设计在整个产品项目的生命周期的应用\n《见微知著：Web 用户体验解构》 这是一本关于网站 UX 设计的实践书籍，但是受限于这本书的出版时间，其案例比较老，所以 UI 看上去会比较过时。\n《用户体验要素：以用户为中心的产品设计》这本书比较全面的解析了产品设计，对于web 产品开发内容不够精专。\n《在你身边，为你设计》由多篇小文章组成，可以有一些灵感，单不够系统\n《破茧成蝶：用户体验设计师的成长之路》这本书主要将用户体验设计工作的门道\n其他类型 《提问》 这是一本关于如何重构问题找到最佳解决方案的书\n《定位》 这是一本风靡全球的营销书\n《营销笔记》这是一本关于营销的书籍，讲了 4P 理论中的产品和定价（渠道和推广在另一本书《卖货真相》）\n如果你学有余力，建议你读一些社会学和经济学，以及交叉学科的通识书籍和研究书籍。\n如果你真读完这些书，你真会发现，做一天和尚撞一天钟；做一天设计发一天疯。\n结语 我虽然是设计科班出身，但自己一般不做设计，除了手痒的时候。平时给团队提供设计/营销策略，可能这也只是我少数几篇设计/营销类文章之一了，内容不免粗糙，感谢阅读！\n欢迎留言，分享你做设计和产品的见解！\n","date":"2025-01-20","tags":["设计","开发"],"title":"作为独立开发者，你真的需要设计师吗？","url":"/post/2025/01/do_you_really_need_a_designer/"},{"content":" https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html ↗ 梦开始的地方 简单的 asm null.s\n.section __TEXT,__text .globl _main .p2align 2 _main: mov w0, #0 ret int main() { return 0; } as null.s -o null.o # 汇编 ld null.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o null # 链接（由于在 macOS 上不能创建静态链接的可执行文件，因此在链接时必须使用 -lSystem 动态链接上系统库。） ./null # 运行 # or clang null.s -o null # or gcc null.s -o null as 是 LLVM 的汇编器, lldb 是 LLVM 的调试器。 GCC 套件是 GNU 操作系统的一个部分，GNU 是开源的、社区驱动的。而 LLVM 项目也是开源的，现在主要是 Apple 在投资运行。因此，既然在 macOS 上，我就主要用的是 LLVM 系的工具。\nhello world hello.s\n.section __TEXT,__text ; 代码段声明 .globl _main ; 声明 main 函数对外可见 .p2align 2 ; 4字节对齐 _main: ; main 函数入口 ; 准备系统调用参数 mov x0, #1 ; stdout 文件描述符 adrp x1, message@PAGE ; 获取消息的页地址 add x1, x1, message@PAGEOFF ; 加上页内偏移 mov x2, #13 ; 消息长度 mov x16, #4 ; write 系统调用号 svc #0x80 ; 触发系统调用 ; 返回值设为 0 mov x0, #0 ; 返回值放入 x0 ret ; 返回 .section __DATA,__data ; 数据段声明 message: .ascii \u0026#34;Hello World!\\n\u0026#34; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 编译\nas hello.s -o hello.o ld hello.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o hello ./hello 参考 Using as ↗ OS X Assembler Reference ↗ [Armv8-A Instruction Set Architecture]( https://developer.arm.com/-/media/Arm ↗ Developer Community/PDF/Learn the Architecture/Armv8-A Instruction Set Architecture.pdf) Arm Architecture Reference Manual for A-profile architecture ↗ ARM Assembly Language ↗ Writing ARM64 Code for Apple Platforms ↗ ","date":"2025-01-18","tags":["编程"],"title":"mac 汇编笔记","url":"/post/2025/01/mac_assembly/"},{"content":"为什么需要闭包？ // 问题1：函数复用 // 没有闭包时，需要传入所有参数 fn add(x: i32, base: i32) -\u0026gt; i32 { x \u0026#43; base } // 有了闭包，可以部分应用 let base = 5; let add_five = |x| x \u0026#43; base; // 问题2：函数式编程需求 vec![1, 2, 3].iter().map(|x| x * 2); // 更简洁 vec![1, 2, 3].iter().map(multiply); // 需要单独定义函数 // 问题3：上下文捕获 // 没有闭包时很难处理 struct Context { value: i32 } let ctx = Context { value: 42 }; let use_context = || println!(\u0026#34;{}\u0026#34;, ctx.value); 闭包是什么？ 闭包是可以捕获其环境的匿名函数 它\u0026quot;封闭\u0026quot;了其定义时的环境，故称\u0026quot;闭包\u0026quot; 闭包 = 函数 + 环境 闭包的优势 // 1. 简洁的语法 let add = |a, b| a \u0026#43; b; // vs fn add(a: i32, b: i32) -\u0026gt; i32 // 2. 灵活的环境捕获 let multiplier = 2; let double = |x| x * multiplier; // 捕获 multiplier // 3. 支持函数式编程 let numbers: Vec\u0026lt;i32\u0026gt; = vec![1, 2, 3, 4, 5]; let even_numbers: Vec\u0026lt;i32\u0026gt; = numbers .into_iter() .filter(|x| x % 2 == 0) .collect(); 理解闭包 我用 Python 和 TypeScript 的概念来解释 Rust 的闭包：\nPython 风格理解： # Python 的 lambda lambda x: x \u0026#43; 1 # Python 的闭包 def outer(a): # 捕获外部变量 a def inner(x): return x \u0026#43; a return inner # 对应的 Rust 代码 |x| x \u0026#43; 1 let a = 1; let closure = |x| x \u0026#43; a; TypeScript 风格理解： // TypeScript 的箭头函数 const add = (x: number) =\u0026gt; x \u0026#43; 1; // 带类型标注的闭包 const multiply: (x: number) =\u0026gt; number = (x) =\u0026gt; x * 2; // 对应的 Rust 代码 let add = |x: i32| x \u0026#43; 1; let multiply: fn(i32) -\u0026gt; i32 = |x| x * 2; Rust 闭包的特殊之处： // 1. Rust 闭包有三种类型 // FnOnce - 获取所有权 let owns = |x| takes_ownership(x); // FnMut - 可变借用 let mut mutates = |x| mutates_value(x); // Fn - 不可变借用 let reads = |x| reads_value(x); // 2. 闭包会自动推断捕获方式 let mut val = 5; let mut closure = || { val \u0026#43;= 1; // 自动推断需要可变借用 println!(\u0026#34;{}\u0026#34;, val); }; 主要区别：\nRust 的闭包更关注内存安全和所有权 Python/TS 的闭包主要关注词法作用域 Rust 的闭包语法更简洁（使用 || 而不是 ()=\u0026gt;） Rust 的闭包有更严格的类型系统和借用规则 人们常说：\u0026ldquo;如果你理解 JavaScript/TypeScript 的箭头函数，就很容易理解 Rust 的闭包语法；如果你理解 Python 的 lambda 和闭包概念，就很容易理解 Rust 闭包的用途。\u0026rdquo;\n如何使用闭包 // 1. 基本语法 let closure = |params| body; // 2. 带类型标注 let closure = |x: i32| -\u0026gt; i32 { x \u0026#43; 1 }; // 3. 作为函数参数 fn apply\u0026lt;F\u0026gt;(f: F, x: i32) where F: Fn(i32) -\u0026gt; i32 { println!(\u0026#34;Result: {}\u0026#34;, f(x)); } // 4. 在迭代器中使用 let v = vec![1, 2, 3]; v.iter().map(|x| x * 2).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); 最佳实践 // 1. 选择合适的特征界定 // Fn - 不可变借用 fn call_closure\u0026lt;F\u0026gt;(closure: F) where F: Fn(i32) -\u0026gt; i32 { closure(1); } // FnMut - 可变借用 fn call_closure_mut\u0026lt;F\u0026gt;(mut closure: F) where F: FnMut(i32) -\u0026gt; i32 { closure(1); } // FnOnce - 获取所有权 fn call_closure_once\u0026lt;F\u0026gt;(closure: F) where F: FnOnce(i32) -\u0026gt; i32 { closure(1); } // 2. 避免过度捕获 let x = 1; let y = 2; // 好的做法 let closure = move |z| x \u0026#43; y \u0026#43; z; // 明确使用 move // 不好的做法 let closure = |z| x \u0026#43; y \u0026#43; z; // 隐式捕获 // 3. 保持闭包简洁 // 好的做法 let is_even = |x| x % 2 == 0; // 不好的做法 - 过于复杂 let complex = |x| { let mut result = x; for i in 0..10 { result \u0026#43;= i; } result % 2 == 0 }; // 4. 适当的错误处理 // 好的做法 let safe_divide = |x, y| { if y == 0 { None } else { Some(x / y) } }; // 5. 文档和类型标注 /// 计算一个数的平方 let square: fn(i32) -\u0026gt; i32 = |x| x * x; 常见用例 // 1. 回调函数 button.on_click(|| println!(\u0026#34;Clicked!\u0026#34;)); // 2. 自定义排序 let mut vec = vec![1, 5, 2]; vec.sort_by(|a, b| b.cmp(a)); // 降序排序 // 3. 惰性计算 let expensive_closure = || { // 复杂计算 compute_something_expensive() }; // 4. 配置和构建模式 let config = Config::new() .with_timeout(|c| c.timeout(Duration::from_secs(5))) .with_retry(|c| c.max_retries(3)); 掌握闭包可以让代码更简洁、更灵活，同时提高代码的可维护性和重用性。但要注意在使用时遵循最佳实践，以确保代码的清晰性和性能。\n","date":"2025-01-15","tags":["编程","rust"],"title":"简述 Rust 中的闭包","url":"/post/2025/01/rust_closure_brief/"},{"content":"引用：你的快递地址和包裹 想象这样一个场景：你在网上买了个漂亮的花瓶，快递公司需要把它送到你家。快递员需要知道两个信息：\n你家的地址（引用） 花瓶本身（值） 为什么我们需要引用？ 让我们看一个具体的问题：\nfn calculate_length(s: String) -\u0026gt; usize { s.len() } let s = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(s); println!(\u0026#34;{}\u0026#34;, s); // 编译错误！s 已经被转移了所有权 这就像你把花瓶（值）直接给了快递员（函数），花瓶就不再属于你了。但很多时候，我们只是想让快递员看看花瓶，而不是把它拿走。\n引用的本质是什么？ 引用就像是地址，它告诉我们值在哪里，但不拥有值本身。就像快递员拿着你家的地址，但房子依然是你的。\nfn calculate_length(s: \u0026amp;String) -\u0026gt; usize { // 借用花瓶 s.len() } let s = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s); // 给出地址 println!(\u0026#34;{}\u0026#34;, s); // 可以使用！因为我们只是借出去看看 引用的规则 1. 不可变引用 就像快递员只能看看你的花瓶，不能重新给它上色：\nfn modify(s: \u0026amp;String) { s.push_str(\u0026#34;world\u0026#34;); // 编译错误！不能修改借用的值 } 2. 可变引用 有时候我们确实需要让快递员修改花瓶（比如补个裂缝）：\nfn modify(s: \u0026amp;mut String) { s.push_str(\u0026#34;world\u0026#34;); // OK！可以修改 } let mut s = String::from(\u0026#34;hello\u0026#34;); modify(\u0026amp;mut s); 3. 引用的限制 就像一个花瓶同一时间：\n要么可以有多个人在看（多个不可变引用） 要么只能有一个人在修改（一个可变引用） 但不能同时发生 let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; // ok let r2 = \u0026amp;s; // ok let r3 = \u0026amp;mut s; // 编译错误！不能同时有可变和不可变引用 println!(\u0026#34;{}, {}\u0026#34;, r1, r2); 实战经验 使用引用的最佳实践： // 好的实践：使用引用避免不必要的所有权转移 fn process(data: \u0026amp;Vec\u0026lt;i32\u0026gt;) { // 处理数据但不需要所有权 } // 不好的实践：不必要的所有权转移 fn process(data: Vec\u0026lt;i32\u0026gt;) { // 获取了所有权但其实不需要 } 生命周期问题： fn danger() -\u0026gt; \u0026amp;String { // 编译错误！ let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s // s 要被销毁了，不能返回它的引用 } 这就像快递员记录了一个即将拆迁的房子的地址 —— 等他送货时，房子已经不在了。\n引用的方法论 所有权原则：\n值同时只能有一个所有者 引用不获取所有权，只是借用 借用规则：\n要么多个不可变引用 要么一个可变引用 引用必须总是有效的 实践指导：\n优先使用不可变引用 仅在必要时使用可变引用 注意引用的生命周期 通过这样的理解，Rust 的引用机制就不再神秘。它就像现实世界中的地址和借用概念，帮助我们安全高效地管理内存。记住：引用就是地址，借用就是临时使用权，这两个概念将帮助你更好地理解和使用 Rust 的引用系统。\n引用实践，看似简单实则暗藏玄机 在我们日常开发中，经常会遇到这样的问题：\n// 场景1：我想传递一个很大的数据结构 struct BigData { data: [u8; 1024 * 1024] // 1MB 数据 } fn process_data(data: BigData) { // 每次调用都要拷贝1MB？ // 处理数据 } // 场景2：多个地方需要读取同一个数据 let data = String::from(\u0026#34;hello\u0026#34;); let data2 = data; // data 的所有权被移动了 println!(\u0026#34;{}\u0026#34;, data); // 编译错误！ 这些问题归结为一个核心矛盾：我们既想高效地共享数据，又要保证内存安全。\n为什么传统方案不够好？ 让我们看看其他语言是怎么处理的：\nC/C++ 的指针方案 void process(Data* data) { data-\u0026gt;field = 100; // 随意修改 delete data; // 随意释放 data-\u0026gt;field = 200; // 使用已释放的内存！ } 问题：\n可能出现悬垂指针 可能重复释放 数据竞争随处可见 Java 的引用方案 void process(Data data) { // 安全但是： // 1. 需要GC，性能开销大 // 2. 没有解决并发修改的问题 } Go 的指针方案 func process(data *Data) { // 安全性好，但是： // 1. 没有生命周期控制 // 2. 并发安全需要额外机制 } Rust 的借用检查器：安全与性能的完美平衡 Rust 通过引用解决了这个问题：\n// 基本语法 let x = 5; let r = \u0026amp;x; // 不可变引用 let rm = \u0026amp;mut x; // 可变引用 // 引用规则 fn process(data: \u0026amp;BigData) { // 借用数据，无需拷贝 println!(\u0026#34;{:?}\u0026#34;, data); // data 会自动归还，无需手动释放 } 为什么这样设计？ 所有权系统保证了资源的正确管理： let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = \u0026amp;s1; // s1 仍然拥有所有权 println!(\u0026#34;{}, {}\u0026#34;, s1, s2); // 都可以使用 // s2 在这里自动失效 drop(s1); // 只有所有者负责清理 借用规则保证了内存安全： let mut data = String::from(\u0026#34;hello\u0026#34;); // 规则1：同一时刻，只能有多个不可变引用或一个可变引用 let r1 = \u0026amp;data; let r2 = \u0026amp;data; // OK：多个不可变引用 let rm = \u0026amp;mut data; // 错误！已经有不可变引用了 // 规则2：引用不能比它引用的数据存活更久 let r; { let x = 5; r = \u0026amp;x; // 错误：x 的生命周期太短 } println!(\u0026#34;{}\u0026#34;, r); 最佳实践 优先使用不可变引用： // 好的做法 fn process(data: \u0026amp;BigData) { // 只读访问 } // 不好的做法 fn process(data: \u0026amp;mut BigData) { // 除非真的需要修改 } 合理使用生命周期标注： // 当需要在结构体中存储引用时 struct Cache\u0026lt;\u0026#39;a\u0026gt; { data: \u0026amp;\u0026#39;a str } 避免复杂的引用关系： // 避免这样的代码 struct Node\u0026lt;\u0026#39;a\u0026gt; { next: Option\u0026lt;\u0026amp;\u0026#39;a mut Node\u0026lt;\u0026#39;a\u0026gt;\u0026gt; } 引用的威力：一些实际例子 高效的字符串处理： fn process_string(s: \u0026amp;str) { // 直接使用字符串切片，无需拷贝 } let string = String::from(\u0026#34;hello\u0026#34;); process_string(\u0026amp;string); // 借用而不是移动 集合的遍历： let vec = vec![1, 2, 3, 4, 5]; for item in \u0026amp;vec { // 借用遍历，无需获取所有权 println!(\u0026#34;{}\u0026#34;, item); } // vec 仍然可用 方法实现： impl MyStruct { fn get_data(\u0026amp;self) -\u0026gt; \u0026amp;str { // self 的引用 \u0026amp;self.data } } 关键思维模型 地址思维： 引用是地址，不是值本身\n借用思维： 临时使用权，不是所有权\n安全思维： 编译器确保所有借用都是安全的\n总结 Rust 的引用系统看似复杂，实则体现了以下核心原则：\n安全性：通过借用检查器在编译期防止常见的内存问题 性能：零成本抽象，运行时无额外开销 人体工程学：符合直觉的所有权和借用规则 掌握引用，你就掌握了 Rust 最核心的特性之一。它不仅能帮你写出更安全的代码，还能帮你获得更好的性能。记住：引用不是为了限制你，而是为了保护你。\n这就像是生活中的借用：你可以借别人的书看，但不能撕掉书页；可以同时借给多人看，但不能在有人看的时候去修改内容。这些规则不是限制，而是让所有人都能安全愉快地共享资源。\n","date":"2025-01-15","tags":["编程","rust"],"title":"Rust 中的引用","url":"/post/2025/01/rust_ref/"},{"content":"从一个常见问题说起 假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：\nlet numbers = vec![1, 2, 3, 4, 5]; // 如何优雅地复用过滤逻辑？ let even_numbers = ??? // 这里怎么写 let multiplied_numbers = ??? // 这里怎么写 闭包的本质 Rust 的闭包本质上是一种特殊的数据结构，它包含：\n函数逻辑 捕获的环境变量 让我们通过反编译来看闭包的真实面目：\n// 表面上的闭包 let multiplier = 2; let closure = |x| x * multiplier; // 编译器实际生成的结构（简化版） struct Closure { multiplier: i32, } impl Closure { fn call(\u0026amp;self, x: i32) -\u0026gt; i32 { x * self.multiplier } } 闭包的三种类型 通过具体案例来理解三种闭包 trait：\n// 1. FnOnce - 获取所有权 let vec = vec![1, 2, 3]; let consume = move || { // 使用 move 语义 // vec在这里被消费 println!(\u0026#34;Consumed: {:?}\u0026#34;, vec); }; consume(); // 只能调用一次 // 2. FnMut - 可变借用 let mut counter = 0; let mut increment = || { counter \u0026#43;= 1; // 修改捕获的变量 println!(\u0026#34;Counter: {}\u0026#34;, counter); }; increment(); // 可以多次调用 // 3. Fn - 不可变借用 let factor = 2; let multiply = |x| x * factor; // 仅读取 factor println!(\u0026#34;Result: {}\u0026#34;, multiply(5)); // factor 仍然可以在这里使用 理解闭包 假设你正在开发一个文件处理系统，需要对不同类型的文件执行不同的操作。你可能会写出这样的代码：\nfn process_files(files: Vec\u0026lt;String\u0026gt;) { for file in files { if file.ends_with(\u0026#34;.txt\u0026#34;) { process_text_file(file); } else if file.ends_with(\u0026#34;.json\u0026#34;) { process_json_file(file); } } } 这段代码虽然能工作，但如果要增加新的文件类型支持，就需要修改这个函数。如何让这个处理逻辑更灵活？这就是闭包可以发挥作用的地方。\n一、闭包的本质 1.1 从函数到闭包 先看一个基础示例：\n// 传统函数 fn add_one(x: i32) -\u0026gt; i32 { x \u0026#43; 1 } // 等价的闭包 let add_one = |x: i32| -\u0026gt; i32 { x \u0026#43; 1 }; 闭包实际上是一个可以捕获其环境的匿名函数。关键在于\u0026quot;捕获环境\u0026quot;这四个字：\nlet multiplier = 10; let multiply = |x| x * multiplier; // 捕获了外部变量multiplier println!(\u0026#34;Result: {}\u0026#34;, multiply(5)); // 输出：50 1.2 深入闭包特性 Rust的闭包有三个关键特征：\n类型推导 // 完整语法 let add_verbose = |x: i32| -\u0026gt; i32 { x \u0026#43; 1 }; // 简化语法（类型推导） let add_simple = |x| x \u0026#43; 1; 环境捕获 #[derive(Debug)] struct Counter { count: i32, } fn main() { let counter = Counter { count: 0 }; // 通过引用捕获 let print_count = || println!(\u0026#34;Count: {}\u0026#34;, counter.count); print_count(); // 可以访问counter } 所有权语义 let mut vector = vec![1, 2, 3]; // 通过可变引用捕获 let mut mutate_vec = || vector.push(4); mutate_vec(); println!(\u0026#34;Vector: {:?}\u0026#34;, vector); // [1, 2, 3, 4] 1.3 深入理解闭包捕获规则 闭包捕获变量遵循几个关键原则：\n最小权限原则： let name = String::from(\u0026#34;Alice\u0026#34;); let printer = || println!(\u0026#34;Name: {}\u0026#34;, name); // 只需不可变借用 let consumer = || name; // 需要所有权，编译器会报错 移动语义： let data = vec![1, 2, 3]; let closure = move || { // data 的所有权移入闭包 println!(\u0026#34;{:?}\u0026#34;, data); }; // 这里不能再使用 data 生命周期约束： let result: Option\u0026lt;Vec\u0026lt;i32\u0026gt;\u0026gt; = None; let mut processor = || { result.as_ref().map(|v| v.len()) }; 二、闭包的实现机制 2.1 Rust 中的闭包特征 Rust使用三个特征来实现闭包功能：\n// 1. FnOnce - 获取所有权并消费 let consume = || vector; consume(); // vector的所有权被转移 // 2. FnMut - 可变借用 let mut counter = 0; let mut add_to_counter = || counter \u0026#43;= 1; add_to_counter(); // counter被可变借用 // 3. Fn - 不可变借用 let value = String::from(\u0026#34;hello\u0026#34;); let print_value = || println!(\u0026#34;{}\u0026#34;, value); print_value(); // value被不可变借用 2.2 内存实现分析 看一个具体例子：\nfn main() { let external = String::from(\u0026#34;external data\u0026#34;); let closure = || { println!(\u0026#34;Using: {}\u0026#34;, external); }; closure(); } 这个闭包在编译时会被转换为类似这样的结构：\n// 编译器生成的等效代码 struct ClosureEnvironment { external: String, } impl Fn() for ClosureEnvironment { fn call(\u0026amp;self) { println!(\u0026#34;Using: {}\u0026#34;, self.external); } } 三、闭包示例 1. 自定义排序： let mut users = vec![ User { name: \u0026#34;Alice\u0026#34;, age: 30 }, User { name: \u0026#34;Bob\u0026#34;, age: 25 }, ]; users.sort_by_key(|u| u.age); // 按年龄排序 2. 惰性求值： struct Cached\u0026lt;T\u0026gt; where T: Fn(u32) -\u0026gt; u32, { calculation: T, value: Option\u0026lt;u32\u0026gt;, } impl\u0026lt;T\u0026gt; Cached\u0026lt;T\u0026gt; where T: Fn(u32) -\u0026gt; u32, { fn new(calculation: T) -\u0026gt; Cached\u0026lt;T\u0026gt; { Cached { calculation, value: None, } } fn value(\u0026amp;mut self, arg: u32) -\u0026gt; u32 { match self.value { Some(v) =\u0026gt; v, None =\u0026gt; { let v = (self.calculation)(arg); self.value = Some(v); v } } } } 3. 错误处理模式： let error_handler = |err| { log::error!(\u0026#34;Operation failed: {}\u0026#34;, err); // 返回默认值 Vec::new() }; let result = operation().unwrap_or_else(error_handler); 四、性能考虑 4.1 大小优化： // 编译器优化前 let large_data = vec![1; 1000]; let closure = move || large_data[0]; // 整个vec被移动 // 优化后 let large_data = vec![1; 1000]; let closure = move || \u0026amp;large_data[0]; // 只捕获引用 4.2 内联优化： // 通常会被内联优化 let multiply = |x| x * 2; let result = multiply(4); // 直接优化为 let result = 4 * 2; 五、常见陷阱 5.1 生命周期问题： fn create_closure() -\u0026gt; impl Fn(i32) -\u0026gt; i32 { let factor = 2; // 错误：factor的生命周期不够长 |x| x * factor } 5.2 可变性冲突： let mut data = vec![1, 2, 3]; let closure = || { // 错误：不能同时有可变和不可变借用 data.push(4); println!(\u0026#34;{:?}\u0026#34;, data); }; 通过这些具体的示例和分析，我们可以看到Rust闭包不仅是一个语法糖，更是一个强大的工具，它能够帮助我们写出更加灵活和高效的代码。理解其内部机制和使用规则，对于编写高质量的Rust程序至关重要。\n你可以从这个分析中看到，闭包的每个特性都有其实际的应用场景和性能影响。这不仅帮助我们理解\u0026quot;是什么\u0026quot;，更重要的是理解\u0026quot;为什么\u0026quot;和\u0026quot;怎么用\u0026quot;。\n六、实战应用 6.1 函数式迭代器 let numbers = vec![1, 2, 3, 4, 5]; // 链式调用示例 let sum: i32 = numbers.iter() .filter(|\u0026amp;x| x % 2 == 0) // 过滤偶数 .map(|\u0026amp;x| x * x) // 平方 .sum(); // 求和 println!(\u0026#34;Sum of squares of even numbers: {}\u0026#34;, sum); 6.2 自定义排序 #[derive(Debug)] struct Person { name: String, age: u32, } fn main() { let mut people = vec![ Person { name: String::from(\u0026#34;Alice\u0026#34;), age: 30 }, Person { name: String::from(\u0026#34;Bob\u0026#34;), age: 25 }, ]; // 使用闭包定义排序规则 people.sort_by_key(|p| p.age); println!(\u0026#34;Sorted by age: {:?}\u0026#34;, people); } 6.3 资源管理 struct Connection { port: u32, } impl Connection { fn new(port: u32) -\u0026gt; Connection { println!(\u0026#34;Opening connection on port {}\u0026#34;, port); Connection { port } } } impl Drop for Connection { fn drop(\u0026amp;mut self) { println!(\u0026#34;Closing connection on port {}\u0026#34;, self.port); } } fn with_connection\u0026lt;F\u0026gt;(port: u32, f: F) where F: FnOnce(\u0026amp;Connection) { let conn = Connection::new(port); f(\u0026amp;conn); // 连接会在这里自动关闭 } fn main() { with_connection(8080, |conn| { println!(\u0026#34;Using connection on port {}\u0026#34;, conn.port); }); } 七、性能和调试技巧 内联优化 #[inline] fn regular_function(x: i32) -\u0026gt; i32 { x \u0026#43; 1 } let closure = |x| x \u0026#43; 1; // 编译器通常会自动内联 大小优化 // 移动捕获而不是引用可能更高效 let value = String::from(\u0026#34;hello\u0026#34;); let closure = move || println!(\u0026#34;{}\u0026#34;, value); 通过这些实例和分析，我们可以看到Rust闭包不仅仅是一个语法特性，更是一套完整的系统设计。它结合了函数式编程的灵活性和Rust的安全性保证，为我们提供了强大的编程工具。\n这种设计告诉我们：语言特性的设计不是随意的，而是要考虑实用性、性能和安全性的平衡。Rust的闭包实现就很好地体现了这一点。\n","date":"2025-01-15","tags":["编程","rust"],"title":"rust 闭包","url":"/post/2025/01/rust_closure/"},{"content":"从一个实际问题开始 假设我们在写一个文件处理程序：\nfn read_config_file(path: \u0026amp;str) -\u0026gt; String { std::fs::read_to_string(path) // 这里会返回什么？ } 这段代码看似简单，但隐藏着两个基本问题：\n文件可能不存在 即使文件存在，读取过程也可能失败 这就是为什么 Rust 引入了 Result 和 Option。\nOption：处理\u0026quot;有\u0026quot;与\u0026quot;没有\u0026quot; Option 的本质 enum Option\u0026lt;T\u0026gt; { Some(T), // 有值 None, // 没有值 } 让我们看一个实际例子：\nfn find_user(id: u32) -\u0026gt; Option\u0026lt;User\u0026gt; { if id == 0 { None // 用户不存在 } else { Some(User { id, ... }) // 用户存在 } } // 使用方式 match find_user(1) { Some(user) =\u0026gt; println!(\u0026#34;Found user: {}\u0026#34;, user.name), None =\u0026gt; println!(\u0026#34;User not found\u0026#34;), } Option 的常用方法 let x: Option\u0026lt;i32\u0026gt; = Some(5); // 方法1：unwrap - 危险操作 let value1 = x.unwrap(); // 如果是 None 会 panic // 方法2：unwrap_or - 提供默认值 let value2 = x.unwrap_or(0); // None 时返回0 // 方法3：map - 变换内部值 let value3 = x.map(|n| n * 2); // Some(5) -\u0026gt; Some(10) // 方法4：and_then - 链式操作 let value4 = x.and_then(|n| if n \u0026gt; 0 { Some(n) } else { None }); Result：处理“成功”与“失败” Result 的本质 enum Result\u0026lt;T, E\u0026gt; { Ok(T), // 成功，包含值 T Err(E), // 错误，包含错误 E } 实际应用示例：\nfn divide(x: i32, y: i32) -\u0026gt; Result\u0026lt;i32, \u0026amp;\u0026#39;static str\u0026gt; { if y == 0 { Err(\u0026#34;division by zero\u0026#34;) } else { Ok(x / y) } } // 使用方式 match divide(10, 2) { Ok(result) =\u0026gt; println!(\u0026#34;Result: {}\u0026#34;, result), Err(e) =\u0026gt; println!(\u0026#34;Error: {}\u0026#34;, e), } Result 的进阶操作 使用 ? 运算符简化错误处理： fn read_config() -\u0026gt; Result\u0026lt;Config, std::io::Error\u0026gt; { let data = std::fs::read_to_string(\u0026#34;config.json\u0026#34;)?; // 自动返回错误，Rust 会自动将错误从当前函数传播到调用者 let config = serde_json::from_str(\u0026amp;data)?; // 链式错误处理，将多个可能失败的操作串联起来，形成一个“链”，任何一个操作失败都会导致整个链中断并返回错误。 Ok(config) } 组合多个 Result： fn complex_operation() -\u0026gt; Result\u0026lt;(), MyError\u0026gt; { let x = step1()?; let y = step2(x)?; step3(y)?; Ok(()) } 实际工程中的最佳实践 自定义错误类型： #[derive(Debug)] enum MyError { IoError(std::io::Error), ParseError(serde_json::Error), ValidationError(String), } impl From\u0026lt;std::io::Error\u0026gt; for MyError { fn from(err: std::io::Error) -\u0026gt; MyError { MyError::IoError(err) } } 结合 Option 和 Result： fn process_data(data: Option\u0026lt;\u0026amp;str\u0026gt;) -\u0026gt; Result\u0026lt;(), MyError\u0026gt; { let text = data.ok_or(MyError::ValidationError(\u0026#34;No data\u0026#34;.into()))?; // 进一步处理... Ok(()) } 错误传播模式： fn operation() -\u0026gt; Result\u0026lt;(), Error\u0026gt; { let mut file = File::open(\u0026#34;test.txt\u0026#34;).map_err(|e| { Error::new(\u0026#34;Failed to open file\u0026#34;, Some(Box::new(e))) })?; let mut content = String::new(); file.read_to_string(\u0026amp;mut content).map_err(|e| { Error::new(\u0026#34;Failed to read file\u0026#34;, Some(Box::new(e))) })?; Ok(()) } 性能考虑 Option 和 Result 都是零开销抽象 编译器可以优化 match 模式匹配 ?运算符不会引入额外开销 常见误区 过度使用 unwrap()： // 不好的做法 let value = some_option.unwrap(); // 如果错误，会 Panic // 好的做法 let value = some_option.ok_or(\u0026#34;meaningful error message\u0026#34;)?; // 如果错误，会使用（默认值） 忽略错误类型： // 不好的做法 type Result\u0026lt;T\u0026gt; = std::result::Result\u0026lt;T, Box\u0026lt;dyn Error\u0026gt;\u0026gt;; // 好的做法 type Result\u0026lt;T\u0026gt; = std::result::Result\u0026lt;T, MyError\u0026gt;; 不恰当的 None 使用： // 不好的做法 fn get_user_name(id: u32) -\u0026gt; Option\u0026lt;String\u0026gt; { if id == 0 { None // 这里应该用 Result 表达错误 } else { Some(\u0026#34;name\u0026#34;.to_string()) } } 通过这样的设计，Rust 强制我们在编译时就处理所有可能的错误情况，使得程序更加健壮。Option 和 Result 不仅是类型，更是一种编程思维的体现。\n深入理解 Rust 的错误处理机制 如上，你可能写过这样的代码：\nlet file = File::open(\u0026#34;config.json\u0026#34;); let content = read_to_string(file); process_config(content); 这段代码看似简单，但隐藏着几个关键问题：\n文件可能不存在 文件内容可能无法读取 内容可能不是有效的配置 这就是为什么 Rust 引入了 Result 和 Option 来处理这些情况。\nResult 的实际使用 示例 fn read_config_file(path: \u0026amp;str) -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let file = match File::open(path) { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; return Err(error), }; let mut content = String::new(); match file.read_to_string(\u0026amp;mut content) { Ok(_) =\u0026gt; Ok(content), Err(error) =\u0026gt; Err(error), } } // 使用方式 match read_config_file(\u0026#34;config.json\u0026#34;) { Ok(content) =\u0026gt; println!(\u0026#34;配置内容: {}\u0026#34;, content), Err(error) =\u0026gt; println!(\u0026#34;读取失败: {}\u0026#34;, error), } Result 的常用方法 // 使用?运算符简化错误传播 fn read_config() -\u0026gt; Result\u0026lt;Config, io::Error\u0026gt; { let content = File::open(\u0026#34;config.json\u0026#34;)?.read_to_string()?; Ok(Config::from_str(\u0026amp;content)?) } // unwrap - 成功则返回值，失败则panic let content = file.read_to_string().unwrap(); // expect - 类似unwrap，但可以自定义panic消息 let content = file.read_to_string().expect(\u0026#34;无法读取配置文件\u0026#34;); // unwrap_or - 提供默认值 let content = file.read_to_string().unwrap_or(String::from(\u0026#34;默认配置\u0026#34;)); // unwrap_or_else - 提供默认值的闭包 let content = file.read_to_string().unwrap_or_else(|_| { println!(\u0026#34;使用默认配置\u0026#34;); String::from(\u0026#34;默认配置\u0026#34;) }); Option 实战 示例 fn find_user(id: u64) -\u0026gt; Option\u0026lt;User\u0026gt; { if id == 0 { return None; } Some(User { id, name: \u0026#34;John\u0026#34;.to_string() }) } // 链式处理 let user_name = find_user(1) .map(|user| user.name) .unwrap_or_else(|| \u0026#34;Unknown\u0026#34;.to_string()); Option 的进阶用法 // 组合多个Option fn get_user_settings(user_id: u64) -\u0026gt; Option\u0026lt;Settings\u0026gt; { let user = find_user(user_id)?; let preferences = user.get_preferences()?; Some(Settings::new(preferences)) } // 处理复杂逻辑 match find_user(1) { Some(user) if user.is_admin =\u0026gt; { println!(\u0026#34;找到管理员用户\u0026#34;); } Some(user) =\u0026gt; { println!(\u0026#34;找到普通用户\u0026#34;); } None =\u0026gt; { println!(\u0026#34;未找到用户\u0026#34;); } } Result 和 Option 的组合使用 实际开发中，我们经常需要同时处理这两种情况：\nfn process_user_data(user_id: u64) -\u0026gt; Result\u0026lt;Option\u0026lt;UserData\u0026gt;, Error\u0026gt; { let user = match find_user(user_id) { Some(user) =\u0026gt; user, None =\u0026gt; return Ok(None), // 用户不存在，但这不是错误 }; match user.process_data() { Ok(data) =\u0026gt; Ok(Some(data)), Err(e) =\u0026gt; Err(e), // 处理数据时出错 } } // 使用?简化版本 fn process_user_data_simple(user_id: u64) -\u0026gt; Result\u0026lt;Option\u0026lt;UserData\u0026gt;, Error\u0026gt; { Ok(Some(find_user(user_id)?.process_data()?)) } 最佳实践 错误处理策略 // 不好的做法：滥用unwrap let data = risky_operation().unwrap(); // 可能panic // 好的做法：proper error handling let data = match risky_operation() { Ok(data) =\u0026gt; data, Err(e) =\u0026gt; { log::error!(\u0026#34;操作失败: {}\u0026#34;, e); return Err(e.into()); } }; 自定义错误类型 #[derive(Debug)] enum AppError { IoError(io::Error), ConfigError(String), UserError { id: u64, message: String }, } impl From\u0026lt;io::Error\u0026gt; for AppError { fn from(error: io::Error) -\u0026gt; Self { AppError::IoError(error) } } 合理使用组合器 // 使用map_err转换错误类型 let config = read_config() .map_err(|e| AppError::ConfigError(e.to_string()))?; // 使用and_then链式处理 let processed_data = find_user(1) .and_then(|user| user.get_data()) .and_then(|data| process_data(data)); 总结启示 Result 和 Option 是 Rust 的核心类型，掌握它们对于写出可靠的 Rust 程序至关重要。 合理使用这些类型可以让代码更加健壮和可维护。 注意区分什么时候使用 Result（表示可能的错误），什么时候使用 Option（表示可能的缺失）。 通过这种方式处理错误和可选值，我们可以在编译时就发现很多潜在的问题，而不是在运行时才遇到意外情况。这正是Rust的设计理念：在编译时发现问题总比在运行时崩溃要好。\n你在实际项目中是如何处理错误和空值的？欢迎分享你的经验。\n","date":"2025-01-15","tags":["编程","rust"],"title":"深入解释 Rust 中的 Result 和 Option 这两个核心类型","url":"/post/2025/01/rust_result_option/"},{"content":"在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：\n使用 web_sys 和 wasm_bindgen 进行浏览器 API 调用： use wasm_bindgen::prelude::*; use web_sys::{console, window}; pub fn move_test(name: \u0026amp;str) { // 控制台打印 console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!(\u0026#34;move test: {}\u0026#34;, name))); // 使用 console.warn console::warn_1(\u0026amp;JsValue::from_str(\u0026#34;This is a warning\u0026#34;)); // 使用 console.error console::error_1(\u0026amp;JsValue::from_str(\u0026#34;This is an error\u0026#34;)); // 浏览器 alert if let Some(window) = window() { window .alert_with_message(\u0026amp;format!(\u0026#34;Hello, {}!\u0026#34;, name)) .expect(\u0026#34;alert failed\u0026#34;); } // 确认对话框 if let Some(window) = window() { if window .confirm_with_message(\u0026#34;Do you want to continue?\u0026#34;) .expect(\u0026#34;confirm failed\u0026#34;) { console::log_1(\u0026amp;JsValue::from_str(\u0026#34;User clicked OK\u0026#34;)); } else { console::log_1(\u0026amp;JsValue::from_str(\u0026#34;User clicked Cancel\u0026#34;)); } } } 在 Cargo.toml 中需要添加必要的依赖： [dependencies] wasm-bindgen = \u0026#34;0.2\u0026#34; web-sys = { version = \u0026#34;0.3\u0026#34;, features = [ \u0026#34;console\u0026#34;, \u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;HtmlElement\u0026#34;, \u0026#34;Node\u0026#34;, \u0026#34;Location\u0026#34; ]} 如果需要格式化打印，可以使用 console::log! 宏： use web_sys::console; // 需要引入宏 #[macro_export] macro_rules! console_log { ($($t:tt)*) =\u0026gt; (console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!($($t)*)))) } pub fn move_test(name: \u0026amp;str) { console_log!(\u0026#34;Testing move with name: {}\u0026#34;, name); } 操作 DOM 示例： use wasm_bindgen::prelude::*; use web_sys::{Document, Element, HtmlElement, window}; pub fn move_test(name: \u0026amp;str) { // 获取 document let window = window().expect(\u0026#34;no global window exists\u0026#34;); let document = window.document().expect(\u0026#34;no document exists\u0026#34;); // 创建新元素 if let Some(div) = document.get_element_by_id(\u0026#34;test-input\u0026#34;) { // 修改输入框的值 if let Some(input) = div.dyn_ref::\u0026lt;HtmlElement\u0026gt;() { input.set_inner_text(\u0026amp;format!(\u0026#34;New value: {}\u0026#34;, name)); } } // 创建新元素 let new_div = document.create_element(\u0026#34;div\u0026#34;).unwrap(); new_div.set_text_content(Some(\u0026amp;format!(\u0026#34;Hello {}\u0026#34;, name))); // 添加到 body if let Some(body) = document.body() { body.append_child(\u0026amp;new_div).unwrap(); } } 处理错误和 Result： pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { // 使用 ? 运算符处理错误 let window = window().ok_or(\u0026#34;no global window exists\u0026#34;)?; let document = window.document().ok_or(\u0026#34;no document exists\u0026#34;)?; // 处理可能的错误 match document.get_element_by_id(\u0026#34;test-input\u0026#34;) { Some(element) =\u0026gt; { console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!(\u0026#34;Found element: {}\u0026#34;, name))); Ok(()) }, None =\u0026gt; Err(JsValue::from_str(\u0026#34;Element not found\u0026#34;)) } } 使用本地存储： use web_sys::Storage; pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { let window = window().ok_or(\u0026#34;no global window exists\u0026#34;)?; // 获取 localStorage if let Some(storage) = window.local_storage()? { // 存储数据 storage.set_item(\u0026#34;user_name\u0026#34;, name)?; // 读取数据 if let Ok(Some(saved_name)) = storage.get_item(\u0026#34;user_name\u0026#34;) { console::log_1(\u0026amp;JsValue::from_str(\u0026amp;format!(\u0026#34;Saved name: {}\u0026#34;, saved_name))); } } Ok(()) } 记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 \u0026ldquo;Storage\u0026rdquo; feature：\nweb-sys = { version = \u0026#34;0.3\u0026#34;, features = [ \u0026#34;console\u0026#34;, \u0026#34;Window\u0026#34;, \u0026#34;Storage\u0026#34;, // ... 其他需要的 features ]} 这些示例展示了在 Rust WASM 中如何与浏览器进行交互的基本方法。你可以根据需要组合使用这些功能。\n以下是 Rust WebAssembly 开发的最佳实践建议：\n错误处理 use wasm_bindgen::prelude::*; use web_sys::console; // 定义自定义错误类型 #[derive(Debug)] pub enum WasmError { JsError(String), CustomError(String) } // 实现错误转换 impl From\u0026lt;WasmError\u0026gt; for JsValue { fn from(error: WasmError) -\u0026gt; Self { JsValue::from_str(\u0026amp;format!(\u0026#34;{:?}\u0026#34;, error)) } } // 使用 Result 处理错误 pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), WasmError\u0026gt; { // 优雅处理错误 if name.is_empty() { return Err(WasmError::CustomError(\u0026#34;Name cannot be empty\u0026#34;.into())); } // 记录日志 console::log_1(\u0026amp;format!(\u0026#34;Processing: {}\u0026#34;, name).into()); Ok(()) } 性能优化 use wasm_bindgen::prelude::*; use std::rc::Rc; use std::cell::RefCell; // 使用 Rc 和 RefCell 来共享数据 struct State { count: i32, data: Vec\u0026lt;String\u0026gt; } #[wasm_bindgen] pub struct App { state: Rc\u0026lt;RefCell\u0026lt;State\u0026gt;\u0026gt; } #[wasm_bindgen] impl App { // 尽量减少 JS/Rust 边界调用 pub fn batch_operation(\u0026amp;self, items: \u0026amp;[JsValue]) -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { let mut state = self.state.borrow_mut(); // 批量处理 for item in items { // 处理逻辑 } Ok(()) } } 模块化设计 // lib.rs mod utils; mod components; mod types; use utils::logging; use components::button; use types::custom_types; // 清晰的模块结构 pub fn initialize() { logging::setup_logging(); button::register_components(); } 日志和调试 #[macro_export] macro_rules! console_log { ($($t:tt)*) =\u0026gt; { web_sys::console::log_1(\u0026amp;format!($($t)*).into()) } } #[macro_export] macro_rules! console_error { ($($t:tt)*) =\u0026gt; { web_sys::console::error_1(\u0026amp;format!($($t)*).into()) } } // 使用 pub fn debug_operation(data: \u0026amp;str) { console_log!(\u0026#34;Starting operation with: {}\u0026#34;, data); // ... 操作代码 console_log!(\u0026#34;Operation completed\u0026#34;); } 内存管理 #[wasm_bindgen] pub struct LargeData { // 使用 Vec\u0026lt;u8\u0026gt; 而不是 String 处理二进制数据 buffer: Vec\u0026lt;u8\u0026gt;, } impl Drop for LargeData { fn drop(\u0026amp;mut self) { // 清理资源 self.buffer.clear(); } } 异步操作处理 use wasm_bindgen_futures::JsFuture; use web_sys::{Request, RequestInit, Response}; // 异步函数处理 pub async fn fetch_data(url: \u0026amp;str) -\u0026gt; Result\u0026lt;JsValue, JsValue\u0026gt; { let mut opts = RequestInit::new(); opts.method(\u0026#34;GET\u0026#34;); let request = Request::new_with_str_and_init(url, \u0026amp;opts)?; let window = web_sys::window().unwrap(); let resp_value = JsFuture::from(window.fetch_with_request(\u0026amp;request)).await?; let resp: Response = resp_value.dyn_into().unwrap(); JsFuture::from(resp.json()?).await } 测试策略 #[cfg(test)] mod tests { use super::*; use wasm_bindgen_test::*; wasm_bindgen_test_configure!(run_in_browser); #[wasm_bindgen_test] fn test_basic_functionality() { // 浏览器环境测试 let result = move_test(\u0026#34;test\u0026#34;); assert!(result.is_ok()); } } 构建优化 # Cargo.toml [package] name = \u0026#34;wasm-project\u0026#34; version = \u0026#34;0.1.0\u0026#34; [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [profile.release] lto = true opt-level = \u0026#39;z\u0026#39; codegen-units = 1 类型安全 use serde::{Serialize, Deserialize}; #[derive(Serialize, Deserialize)] pub struct UserData { name: String, age: u32, } #[wasm_bindgen] impl UserData { // 提供类型安全的接口 pub fn new(name: \u0026amp;str, age: u32) -\u0026gt; Result\u0026lt;UserData, JsValue\u0026gt; { if name.is_empty() { return Err(\u0026#34;Name cannot be empty\u0026#34;.into()); } Ok(UserData { name: name.to_string(), age, }) } } 文档注释 /// Performs a move test operation /// /// # Arguments /// /// * `name` - The name to test with /// /// # Returns /// /// * `Result\u0026lt;(), WasmError\u0026gt;` - Ok if successful, Err with error details if failed /// /// # Examples /// /// ``` /// let result = move_test(\u0026#34;test\u0026#34;); /// assert!(result.is_ok()); /// ``` #[wasm_bindgen] pub fn move_test(name: \u0026amp;str) -\u0026gt; Result\u0026lt;(), WasmError\u0026gt; { // 实现代码 } ","date":"2025-01-15","tags":["编程","wasm"],"title":"Wasm 打印输出和浏览器特性等最佳实践","url":"/post/2025/01/wasm_print/"},{"content":"参考： 中文文档 https://hugo.opendocs.io/getting-started/quick-start/ ↗ 博客：\nhttps://blog.gujiakai.top/2023/03/hugo-theme-development-diary ↗ https://juejin.cn/post/7151253414427492382 ↗ 一个简单的 Hugo 主题 创建一个空的网站模版 hugo new site demo 这会在当前目录创建一个名为 demo 的目录，然后初始化 hugo 的目录结构，\n创建一个空的主题模版 cd demo hugo new theme hugo-zero 得到输出信息：\nCreating theme at /hugo/demo/themes/hugo-zero 一开始的目录结构如下图所示：\nhugo-zero（hugo主题） ├── archetypes（hugo主题文章模板） ├── layouts（hugo主题布局文件） ├── static（hugo主题的静态文件） ├── LICENSE（hugo主题的许可证信息） └── themes.toml（hugo主题的元数据信息） 其中，重点关注layouts文件夹。剩余的文件可以慢慢补充。\nlayouts 文件夹的目录结构如下图所示：\nlayouts ├── _default（默认页面布局文件夹） │ ├── baseof.html（所有页面的基底模板） │ ├── list.html（列表页面的模板文件） │ └── single.html（单页面的模板文件） ├── partials（部分页面布局文件夹） │ ├── head.html（网页头部） │ ├── header.html（网页的主导航栏） │ └── footer.html（网页的页脚信息） ├── 404.html（网站的404错误页面） └── index.html（网站的主页） 在 config.toml 里添加一行： theme = \u0026#34;hugo-zero\u0026#34; 这样就可以加载主题 hugo-zero了，运行看看有没有报错：\nhugo server 如果配置有问题会显示出错误信息，一切正常的话，能看到下面的输出：\n| EN \u0026#43;------------------\u0026#43;----\u0026#43; Pages | 3 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 5 ms Watching for changes in /tmp/demo/{archetypes,content,data,layouts,static,themes} Watching for config changes in /tmp/demo/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl\u0026#43;C to stop 用浏览器访问 http://localhost:1313/ 看到一个空页面，这个时候什么内容都还没有。\nindex.html 是首页，single.html 是文章页面。 baseof.html 所有页面的模版，每个页面都是基于这个页面进行扩展。 css 目录用来放样式文件。 head.html用来定义部分的内容，加载 CSS 样式文件就在这里添加。 footer.html一般用来展示版权信息。 header.html显示在顶部，展示网站名称。\n使用 创建网站 # 创建 demo 网站 hugo new site demo # 进入网站文件夹 cd demo 添加主题 # 初始化 git 仓库 git init # 添加 git 子模块（主题） git submodule add https://github.com/caoyang2002/hugo-zero.git themes/hugo-zero 在 config.toml 里添加一行： theme = \u0026#34;hugo-zero\u0026#34; 创建文章 创建 post_name.md 文章\nhugo new content/posts/post_name.md 生成 post_name.md 文件并添加元信息\n\u0026#43;\u0026#43;\u0026#43; date = \u0026#39;2025-01-03T11:11:07\u0026#43;08:00\u0026#39; draft = true title = \u0026#39;Post_name\u0026#39; \u0026#43;\u0026#43;\u0026#43; 启动 # 不包含草稿内容 hugo server # 包含草稿内容 hugo server -D 访问 http://localhost:1313/\n","date":"2025-01-03","tags":["hugo"],"title":"Hugo 主题创建方法及简单说明","url":"/post/2025/01/create_hugo_theme/"},{"content":"在 Go 项目架构中，有一些重要的设计原则和规则。我来详细说明：\n接口定义规则： // ✅ 正确：接口定义在使用方(调用方)包中 package handler type UserService interface { Create(ctx context.Context, user *User) error } // ❌ 错误：接口定义在实现方包中 package service type UserService interface { Create(ctx context.Context, user *User) error } 依赖方向： // ✅ 正确的依赖方向 handler -\u0026gt; service -\u0026gt; repository -\u0026gt; database // ❌ 错误：不应该出现反向依赖 service -\u0026gt; handler repository -\u0026gt; service 数据模型定义： // ✅ 正确：每层使用自己的数据模型 package handler type CreateUserRequest struct { // API层模型 Username string `json:\u0026#34;username\u0026#34;` } package service type UserDTO struct { // 业务层模型 ID uint64 Username string } package repository type UserDO struct { // 数据层模型 ID uint64 `gorm:\u0026#34;primaryKey\u0026#34;` Username string CreatedAt time.Time } // ❌ 错误：直接在所有层使用相同的模型 type User struct { ID uint64 `json:\u0026#34;id\u0026#34; gorm:\u0026#34;primaryKey\u0026#34;` Username string `json:\u0026#34;username\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` } 错误处理层级： // ✅ 正确：每层对错误进行适当包装 package repository func (r *UserRepo) Create(user *UserDO) error { return fmt.Errorf(\u0026#34;database error: %w\u0026#34;, err) } package service func (s *UserService) Create(user *UserDTO) error { return fmt.Errorf(\u0026#34;business error: %w\u0026#34;, err) } package handler func (h *UserHandler) Create(c *gin.Context) { if err := h.service.Create(user); err != nil { c.JSON(getErrorStatus(err), ErrorResponse{err.Error()}) return } } // ❌ 错误：直接暴露底层错误 if err := db.Create(\u0026amp;user).Error; err != nil { c.JSON(500, err.Error()) } 包的组织： ✅ 正确的包组织： project/ ├── api/ │ └── handler/ # HTTP 处理层 ├── internal/ │ ├── service/ # 业务逻辑层 │ ├── repository/ # 数据访问层 │ └── model/ # 内部数据模型 ├── pkg/ │ └── util/ # 公共工具函数 └── main.go ❌ 错误的包组织： project/ ├── handlers/ ├── services/ ├── models/ └── main.go 依赖注入： // ✅ 正确：通过构造函数注入依赖 func NewUserHandler(service UserService) *UserHandler { return \u0026amp;UserHandler{service: service} } // ❌ 错误：全局变量或直接初始化 var userService = \u0026amp;UserService{} 接口隔离： // ✅ 正确：小接口，职责单一 type UserReader interface { GetUser(id uint64) (*User, error) } type UserWriter interface { CreateUser(user *User) error } // ❌ 错误：大接口，职责过多 type UserService interface { GetUser(id uint64) (*User, error) CreateUser(user *User) error UpdateUser(user *User) error DeleteUser(id uint64) error ListUsers() ([]*User, error) SearchUsers(query string) ([]*User, error) } 配置管理： // ✅ 正确：集中管理配置 package config type Config struct { Server ServerConfig DB DatabaseConfig Redis RedisConfig } // ❌ 错误：分散的配置或硬编码 var serverPort = 8080 var dbConnection = \u0026#34;root:password@tcp(localhost:3306)/db\u0026#34; 上下文传递： // ✅ 正确：统一使用 context 传递请求上下文 func (h *Handler) Create(c *gin.Context) { ctx := c.Request.Context() err := h.service.Create(ctx, req) } // ❌ 错误：不传递上下文或使用不一致的上下文 func (h *Handler) Create(c *gin.Context) { err := h.service.Create(req) } 测试组织： // ✅ 正确：测试文件与源文件对应 package handler func TestUserHandler_Create(t *testing.T) { // 单元测试 } // ❌ 错误：测试代码与源码混合或测试覆盖不全 func TestAll(t *testing.T) { // 混合测试多个功能 } 遵循这些规则可以使代码：\n更容易理解和维护 更好的测试覆盖 更清晰的责任边界 更容易进行重构 更好的扩展性 同时也避免了常见的问题如：\n循环依赖 紧耦合 难以测试 难以维护 代码重复 是的，还有一些重要的设计规则和最佳实践：\n命名规范： // ✅ 正确：清晰的命名约定 type ( // Response 用于外部 API CreateUserResponse struct { UserID uint64 `json:\u0026#34;user_id\u0026#34;` } // DTO 用于服务层 UserDTO struct { ID uint64 } // DO 用于数据库层 UserDO struct { ID uint64 `gorm:\u0026#34;column:id\u0026#34;` } ) // ❌ 错误：命名不清晰或不一致 type ( UserResp struct {} UserData struct {} TUser struct {} ) 领域驱动的包组织： // ✅ 正确：按领域组织代码 project/ ├── user/ │ ├── handler.go │ ├── service.go │ └── repository.go ├── order/ │ ├── handler.go │ ├── service.go │ └── repository.go └── product/ ├── handler.go ├── service.go └── repository.go // ❌ 错误：按技术层级组织 project/ ├── handler/ │ ├── user.go │ ├── order.go │ └── product.go └── service/ ├── user.go ├── order.go └── product.go 错误处理： // ✅ 正确：定义领域错误类型 package errors type ErrorCode int const ( ErrNotFound ErrorCode = iota \u0026#43; 1 ErrInvalidInput ErrUnauthorized ) type Error struct { Code ErrorCode Message string Err error } // ❌ 错误：使用通用错误或字符串 if err != nil { return errors.New(\u0026#34;something went wrong\u0026#34;) } 中间件链管理： // ✅ 正确：中间件配置集中管理 func SetupMiddlewares(r *gin.Engine) { r.Use( middleware.Recovery(), middleware.Logger(), middleware.Trace(), middleware.Auth(), ) } // ❌ 错误：中间件分散配置 r.Use(middleware.Logger()) // ... 其他代码 r.Use(middleware.Auth()) 配置验证： // ✅ 正确：配置验证和默认值 type Config struct { Port int `validate:\u0026#34;required,min=1024,max=65535\u0026#34;` Timeout time.Duration `validate:\u0026#34;required,min=1s\u0026#34;` LogLevel string `validate:\u0026#34;oneof=debug info warn error\u0026#34;` } func (c *Config) Validate() error { return validator.Struct(c) } // ❌ 错误：无验证的配置 type Config struct { Port int Timeout time.Duration LogLevel string } 日志处理： // ✅ 正确：结构化日志，带上下文信息 func (s *service) CreateUser(ctx context.Context, user *User) error { logger := log.WithContext(ctx).With( \u0026#34;user_id\u0026#34;, user.ID, \u0026#34;action\u0026#34;, \u0026#34;create_user\u0026#34;, ) logger.Info(\u0026#34;creating user\u0026#34;) if err := s.repo.Create(user); err != nil { logger.Error(\u0026#34;failed to create user\u0026#34;, \u0026#34;error\u0026#34;, err) return err } return nil } // ❌ 错误：非结构化日志，信息不完整 log.Printf(\u0026#34;error: %v\u0026#34;, err) 事务处理： // ✅ 正确：统一的事务管理 type TxManager interface { WithTx(ctx context.Context, fn func(ctx context.Context) error) error } func (s *service) CreateOrder(ctx context.Context, order *Order) error { return s.txManager.WithTx(ctx, func(ctx context.Context) error { // 在事务中执行操作 if err := s.repo.Create(ctx, order); err != nil { return err } return s.eventRepo.Publish(ctx, \u0026#34;order_created\u0026#34;, order) }) } // ❌ 错误：手动事务管理 tx := db.Begin() if err := tx.Create(order).Error; err != nil { tx.Rollback() return err } tx.Commit() 缓存策略： // ✅ 正确：缓存抽象和策略 type Cache interface { Get(ctx context.Context, key string) (interface{}, error) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error } type UserService struct { repo Repository cache Cache } // ❌ 错误：直接使用缓存实现 func (s *service) GetUser(id string) (*User, error) { key := fmt.Sprintf(\u0026#34;user:%s\u0026#34;, id) if val, err := redis.Get(key).Result(); err == nil { // 处理缓存 } } 并发控制： // ✅ 正确：优雅的并发控制 func ProcessItems(items []Item) error { sem := make(chan struct{}, MaxConcurrent) errs := make(chan error, len(items)) for _, item := range items { sem \u0026lt;- struct{}{} // 获取信号量 go func(item Item) { defer func() { \u0026lt;-sem }() // 释放信号量 if err := processItem(item); err != nil { errs \u0026lt;- err } }(item) } // 等待所有 goroutine 完成 return errors.Join(errs...) } // ❌ 错误：无控制的并发 for _, item := range items { go processItem(item) } 优雅关闭： // ✅ 正确：优雅关闭服务 func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() go func() { sigCh := make(chan os.Signal, 1) signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-sigCh cancel() }() if err := server.Run(ctx); err != nil { log.Fatal(err) } } // ❌ 错误：直接退出 func main() { if err := server.Run(); err != nil { os.Exit(1) } } 这些规则和最佳实践能帮助你：\n提高代码质量和可维护性 减少 bug 和技术债务 提高团队协作效率 使系统更加健壮和可靠 便于扩展和重构 这个接口定义应该放在 handler 包中。原因如下：\n依赖关系:\nHandler 依赖 Service 接口应该由调用方(Handler)定义，而不是实现方(Service)定义 这样符合依赖倒置原则(DIP) 导入循环:\n如果接口定义在 service 包中，会导致包循环引用的问题： handler 包需要导入 service 包来使用数据结构 service 包需要导入 handler 包来实现接口 让我来展示正确的结构：\n这样组织代码的好处是：\n符合依赖倒置原则：\n高层模块(Handler)不依赖于低层模块(Service) 两者都依赖于抽象(接口) 抽象由调用方定义，不依赖于具体实现 避免循环依赖：\nHandler 定义接口和数据结构 Service 实现接口，使用 Handler 中定义的类型 Repository 层不需要知道上层的存在 清晰的依赖方向：\nHandler (定义接口) \u0026lt;- Service (实现接口) \u0026lt;- Repository 更好的测试性：\n可以轻松为 Handler 创建 Service 的 mock 接口和数据结构集中在一处，易于维护 更容易进行修改：\n如果需要修改接口，只需要修改 Handler 包 实现方(Service)会得到编译错误提示，确保实现完整性 是的，还有更多重要的设计规则和最佳实践：\n参数验证： // ✅ 正确：分层的参数验证 // handler 层：验证 API 参数格式 type CreateUserRequest struct { Username string `json:\u0026#34;username\u0026#34; binding:\u0026#34;required,min=3,max=32\u0026#34;` Email string `json:\u0026#34;email\u0026#34; binding:\u0026#34;required,email\u0026#34;` Age int `json:\u0026#34;age\u0026#34; binding:\u0026#34;required,gte=0,lte=150\u0026#34;` } // service 层：验证业务规则 func (s *UserService) Create(ctx context.Context, dto *UserDTO) error { if err := s.validateBusinessRules(ctx, dto); err != nil { return fmt.Errorf(\u0026#34;business validation failed: %w\u0026#34;, err) } // ... } // ❌ 错误：验证逻辑混乱或重复 if username == \u0026#34;\u0026#34; || len(username) \u0026lt; 3 { return errors.New(\u0026#34;invalid username\u0026#34;) } 模块化配置： // ✅ 正确：模块化的配置管理 type Config struct { HTTP HTTPConfig `mapstructure:\u0026#34;http\u0026#34;` Database DatabaseConfig `mapstructure:\u0026#34;database\u0026#34;` Cache CacheConfig `mapstructure:\u0026#34;cache\u0026#34;` } type HTTPConfig struct { Port int `mapstructure:\u0026#34;port\u0026#34; validate:\u0026#34;required\u0026#34;` ReadTimeout time.Duration `mapstructure:\u0026#34;read_timeout\u0026#34; validate:\u0026#34;required\u0026#34;` WriteTimeout time.Duration `mapstructure:\u0026#34;write_timeout\u0026#34; validate:\u0026#34;required\u0026#34;` } // ❌ 错误：平铺的配置结构 type Config struct { HTTPPort int HTTPReadTimeout time.Duration HTTPWriteTimeout time.Duration DBHost string DBPort int DBUser string // ... } 资源管理： // ✅ 正确：统一的资源管理器 type ResourceManager struct { db *gorm.DB redis *redis.Client es *elasticsearch.Client } func NewResourceManager() *ResourceManager { return \u0026amp;ResourceManager{ db: initDB(), redis: initRedis(), es: initElasticsearch(), } } func (rm *ResourceManager) Close() error { var errs []error if err := rm.db.Close(); err != nil { errs = append(errs, fmt.Errorf(\u0026#34;db close error: %w\u0026#34;, err)) } if err := rm.redis.Close(); err != nil { errs = append(errs, fmt.Errorf(\u0026#34;redis close error: %w\u0026#34;, err)) } return errors.Join(errs...) } // ❌ 错误：分散的资源管理 var ( db *gorm.DB redis *redis.Client ) 环境配置： // ✅ 正确：环境感知的配置 type Environment string const ( EnvDevelopment Environment = \u0026#34;development\u0026#34; EnvStaging Environment = \u0026#34;staging\u0026#34; EnvProduction Environment = \u0026#34;production\u0026#34; ) type Config struct { Env Environment `mapstructure:\u0026#34;env\u0026#34; validate:\u0026#34;required,oneof=development staging production\u0026#34;` } func (c *Config) IsDevelopment() bool { return c.Env == EnvDevelopment } func (c *Config) IsProduction() bool { return c.Env == EnvProduction } // ❌ 错误：硬编码的环境判断 if os.Getenv(\u0026#34;ENV\u0026#34;) == \u0026#34;prod\u0026#34; { // ... } 监控指标： // ✅ 正确：结构化的监控指标 const ( MetricRequestTotal = \u0026#34;http_requests_total\u0026#34; MetricRequestDuration = \u0026#34;http_request_duration_seconds\u0026#34; MetricDatabaseQueries = \u0026#34;database_queries_total\u0026#34; ) type Metrics interface { Counter(name string, labels map[string]string) float64 Histogram(name string, value float64, labels map[string]string) Gauge(name string, value float64, labels map[string]string) } // ❌ 错误：临时或非结构化的监控 log.Printf(\u0026#34;request took %v\u0026#34;, time.Since(start)) API 版本控制： // ✅ 正确：显式的 API 版本控制 func SetupRoutes(r *gin.Engine) { v1 := r.Group(\u0026#34;/api/v1\u0026#34;) { users := v1.Group(\u0026#34;/users\u0026#34;) users.POST(\u0026#34;/\u0026#34;, handler.CreateUserV1) } v2 := r.Group(\u0026#34;/api/v2\u0026#34;) { users := v2.Group(\u0026#34;/users\u0026#34;) users.POST(\u0026#34;/\u0026#34;, handler.CreateUserV2) } } // ❌ 错误：隐式或缺少版本控制 r.POST(\u0026#34;/api/users\u0026#34;, handler.CreateUser) 依赖注入容器： // ✅ 正确：使用依赖注入容器 type Container struct { services map[reflect.Type]interface{} mu sync.RWMutex } func (c *Container) Register(service interface{}) { c.mu.Lock() defer c.mu.Unlock() c.services[reflect.TypeOf(service)] = service } func (c *Container) Resolve(t reflect.Type) interface{} { c.mu.RLock() defer c.mu.RUnlock() return c.services[t] } // ❌ 错误：全局变量依赖 var ( userService *UserService orderService *OrderService ) 数据库迁移： // ✅ 正确：版本化的数据库迁移 type Migration struct { Version uint64 Description string UpSQL string DownSQL string } var migrations = []Migration{ { Version: 1, Description: \u0026#34;Create users table\u0026#34;, UpSQL: `CREATE TABLE users (...)`, DownSQL: `DROP TABLE users`, }, // ... } // ❌ 错误：手动或非版本化的迁移 func initDatabase() { db.Exec(\u0026#34;CREATE TABLE IF NOT EXISTS users (...)\u0026#34;) } 文档生成： // ✅ 正确：自动化的文档生成 // @Summary 创建用户 // @Description 创建新用户并返回用户ID // @Tags users // @Accept json // @Produce json // @Param user body CreateUserRequest true \u0026#34;用户信息\u0026#34; // @Success 200 {object} CreateUserResponse // @Router /api/v1/users [post] func (h *UserHandler) Create(c *gin.Context) { // ... } // ❌ 错误：手动维护或缺少文档 func (h *UserHandler) Create(c *gin.Context) { // TODO: add documentation } 测试数据工厂： // ✅ 正确：使用测试数据工厂 type UserFactory struct { faker *faker.Faker } func (f *UserFactory) MakeUser(opts ...UserOption) *User { user := \u0026amp;User{ Username: f.faker.Internet().UserName(), Email: f.faker.Internet().Email(), } for _, opt := range opts { opt(user) } return user } // ❌ 错误：硬编码测试数据 user := \u0026amp;User{ Username: \u0026#34;test_user\u0026#34;, Email: \u0026#34;test@example.com\u0026#34;, } 这些规则和最佳实践能帮助你：\n提高代码的可测试性 增强系统的可观测性 简化部署和运维 提高开发效率 减少潜在问题 建议根据项目的具体需求和团队情况，选择合适的规则来遵循。不必一次性实现所有规则，可以渐进式地改进。\n是的，还有更多高级的设计规则和最佳实践：\n限流器实现： // ✅ 正确：可配置的限流器 type RateLimiter struct { tokens chan struct{} refillInterval time.Duration } func NewRateLimiter(rate int, interval time.Duration) *RateLimiter { rl := \u0026amp;RateLimiter{ tokens: make(chan struct{}, rate), refillInterval: interval, } // 初始填充令牌 for i := 0; i \u0026lt; rate; i\u0026#43;\u0026#43; { rl.tokens \u0026lt;- struct{}{} } // 定期补充令牌 go rl.refill() return rl } // middleware 使用 func RateLimitMiddleware(rl *RateLimiter) gin.HandlerFunc { return func(c *gin.Context) { select { case \u0026lt;-rl.tokens: c.Next() default: c.JSON(429, gin.H{\u0026#34;error\u0026#34;: \u0026#34;too many requests\u0026#34;}) c.Abort() } } } // ❌ 错误：简单计数器限流 var ( count int mu sync.Mutex lastReset time.Time ) 重试策略： // ✅ 正确：可配置的重试策略 type RetryConfig struct { MaxRetries int BaseDelay time.Duration MaxDelay time.Duration Multiplier float64 ShouldRetry func(error) bool } func WithRetry(ctx context.Context, fn func() error, cfg RetryConfig) error { var lastErr error for attempt := 0; attempt \u0026lt; cfg.MaxRetries; attempt\u0026#43;\u0026#43; { if err := fn(); err != nil { if !cfg.ShouldRetry(err) { return err } lastErr = err delay := time.Duration(float64(cfg.BaseDelay) * math.Pow(cfg.Multiplier, float64(attempt))) if delay \u0026gt; cfg.MaxDelay { delay = cfg.MaxDelay } select { case \u0026lt;-ctx.Done(): return ctx.Err() case \u0026lt;-time.After(delay): continue } } return nil } return fmt.Errorf(\u0026#34;max retries exceeded: %w\u0026#34;, lastErr) } // ❌ 错误：硬编码重试逻辑 for i := 0; i \u0026lt; 3; i\u0026#43;\u0026#43; { if err := doSomething(); err == nil { break } time.Sleep(time.Second) } 工作池模式： // ✅ 正确：通用工作池实现 type Pool struct { tasks chan func() workers int wg sync.WaitGroup ctx context.Context cancel context.CancelFunc } func NewPool(workers int) *Pool { ctx, cancel := context.WithCancel(context.Background()) p := \u0026amp;Pool{ tasks: make(chan func()), workers: workers, ctx: ctx, cancel: cancel, } p.start() return p } func (p *Pool) start() { for i := 0; i \u0026lt; p.workers; i\u0026#43;\u0026#43; { p.wg.Add(1) go func() { defer p.wg.Done() for { select { case task, ok := \u0026lt;-p.tasks: if !ok { return } task() case \u0026lt;-p.ctx.Done(): return } } }() } } // ❌ 错误：为每个任务创建 goroutine for _, task := range tasks { go process(task) } 断路器模式： // ✅ 正确：断路器实现 type CircuitBreaker struct { mu sync.RWMutex failureCount int lastFailure time.Time state State threshold int timeout time.Duration } type State int const ( StateClosed State = iota StateHalfOpen StateOpen ) func (cb *CircuitBreaker) Execute(fn func() error) error { if !cb.allowRequest() { return ErrCircuitOpen } err := fn() cb.recordResult(err) return err } // ❌ 错误：无保护的外部调用 response, err := http.Get(url) 优雅降级： // ✅ 正确：降级策略 type Fallback struct { Primary func() (interface{}, error) Secondary func() (interface{}, error) Cache Cache } func (f *Fallback) Execute() (interface{}, error) { // 尝试主要实现 result, err := f.Primary() if err == nil { return result, nil } // 尝试缓存 if cached, err := f.Cache.Get(); err == nil { return cached, nil } // 使用备用实现 return f.Secondary() } // ❌ 错误：无降级处理 result, err := getPrimaryData() if err != nil { return err } 服务健康检查： // ✅ 正确：结构化的健康检查 type HealthChecker struct { checks map[string]HealthCheck } type HealthCheck func() error func (h *HealthChecker) AddCheck(name string, check HealthCheck) { h.checks[name] = check } func (h *HealthChecker) RunChecks() map[string]string { results := make(map[string]string) for name, check := range h.checks { if err := check(); err != nil { results[name] = fmt.Sprintf(\u0026#34;unhealthy: %v\u0026#34;, err) } else { results[name] = \u0026#34;healthy\u0026#34; } } return results } // ❌ 错误：简单的 ping 检查 func healthCheck(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;ok\u0026#34;)) } 应用指标收集： // ✅ 正确：结构化的指标收集 type Metrics struct { counters map[string]*atomic.Int64 histograms map[string]*metrics.Histogram mu sync.RWMutex } func (m *Metrics) RecordLatency(name string, duration time.Duration) { m.mu.RLock() histogram, exists := m.histograms[name] m.mu.RUnlock() if exists { histogram.Observe(duration.Seconds()) } } // ❌ 错误：简单日志记录 log.Printf(\u0026#34;operation took %v\u0026#34;, time.Since(start)) 链路追踪： // ✅ 正确：完整的链路追踪 type Tracer struct { spans map[string]*Span } type Span struct { TraceID string SpanID string ParentID string Operation string StartTime time.Time EndTime time.Time Attributes map[string]string } func (t *Tracer) StartSpan(ctx context.Context, op string) (*Span, context.Context) { parent := SpanFromContext(ctx) span := \u0026amp;Span{ TraceID: generateTraceID(), SpanID: generateSpanID(), Operation: op, StartTime: time.Now(), Attributes: make(map[string]string), } if parent != nil { span.ParentID = parent.SpanID } return span, ContextWithSpan(ctx, span) } // ❌ 错误：仅记录开始和结束 start := time.Now() defer func() { log.Printf(\u0026#34;operation took %v\u0026#34;, time.Since(start)) }() 这些高级模式可以帮助你：\n提高系统的可靠性 增强系统的弹性 改善系统的可观测性 优化性能 更好地处理异常情况 重要提示：\n这些模式应根据实际需求选择使用 不要过度设计 应该渐进式地引入这些模式 需要考虑维护成本 团队的技术能力要匹配 你还需要了解其他方面的内容吗？\n是的，让我继续分享一些高级设计模式和最佳实践：\n缓存策略模式： // ✅ 正确：可插拔的缓存策略 type CacheStrategy interface { Get(ctx context.Context, key string) (interface{}, error) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error Delete(ctx context.Context, key string) error } // 多级缓存策略 type MultiLevelCache struct { l1 CacheStrategy // 本地缓存 l2 CacheStrategy // Redis缓存 } func (m *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) { // 先查本地缓存 if val, err := m.l1.Get(ctx, key); err == nil { return val, nil } // 查Redis缓存 val, err := m.l2.Get(ctx, key) if err != nil { return nil, err } // 回填本地缓存 go m.l1.Set(ctx, key, val, time.Minute) return val, nil } // ❌ 错误：硬编码的缓存逻辑 if val, err := localCache.Get(key); err == nil { return val } return redisCache.Get(key) 数据库读写分离： // ✅ 正确：读写分离封装 type Database struct { master *gorm.DB slaves []*gorm.DB mu sync.RWMutex index uint64 // 用于轮询 } func (db *Database) Master() *gorm.DB { return db.master } func (db *Database) Slave() *gorm.DB { db.mu.RLock() defer db.mu.RUnlock() if len(db.slaves) == 0 { return db.master } // 轮询选择从库 index := atomic.AddUint64(\u0026amp;db.index, 1) return db.slaves[index%uint64(len(db.slaves))] } // 使用示例 func (r *UserRepo) Create(ctx context.Context, user *User) error { return r.db.Master().Create(user).Error } func (r *UserRepo) Find(ctx context.Context, id uint64) (*User, error) { var user User err := r.db.Slave().First(\u0026amp;user, id).Error return \u0026amp;user, err } // ❌ 错误：不区分读写的数据库操作 db.Create(user) db.First(\u0026amp;user) 消息队列封装： // ✅ 正确：抽象的消息队列接口 type MessageQueue interface { Publish(ctx context.Context, topic string, msg interface{}) error Subscribe(ctx context.Context, topic string, handler MessageHandler) error } type MessageHandler func(ctx context.Context, msg []byte) error // Kafka实现 type KafkaQueue struct { producer sarama.SyncProducer consumer sarama.ConsumerGroup } func (k *KafkaQueue) Publish(ctx context.Context, topic string, msg interface{}) error { data, err := json.Marshal(msg) if err != nil { return err } _, _, err = k.producer.SendMessage(\u0026amp;sarama.ProducerMessage{ Topic: topic, Value: sarama.ByteEncoder(data), }) return err } // ❌ 错误：直接使用消息队列客户端 producer.SendMessage(\u0026amp;sarama.ProducerMessage{...}) 分布式锁： // ✅ 正确：分布式锁接口和实现 type DistributedLock interface { Lock(ctx context.Context) error Unlock(ctx context.Context) error } // Redis实现 type RedisLock struct { client *redis.Client key string value string expires time.Duration } func (l *RedisLock) Lock(ctx context.Context) error { ok, err := l.client.SetNX(ctx, l.key, l.value, l.expires).Result() if err != nil { return err } if !ok { return ErrLockAcquireFailed } return nil } func (l *RedisLock) Unlock(ctx context.Context) error { script := ` if redis.call(\u0026#34;get\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;, KEYS[1]) else return 0 end ` return l.client.Eval(ctx, script, []string{l.key}, l.value).Err() } // ❌ 错误：简单的互斥锁 var mu sync.Mutex 业务规则引擎： // ✅ 正确：可配置的规则引擎 type Rule interface { Evaluate(ctx context.Context, facts map[string]interface{}) (bool, error) } type CompositeRule struct { rules []Rule operator string // \u0026#34;and\u0026#34; or \u0026#34;or\u0026#34; } func (c *CompositeRule) Evaluate(ctx context.Context, facts map[string]interface{}) (bool, error) { switch c.operator { case \u0026#34;and\u0026#34;: for _, rule := range c.rules { ok, err := rule.Evaluate(ctx, facts) if err != nil { return false, err } if !ok { return false, nil } } return true, nil case \u0026#34;or\u0026#34;: for _, rule := range c.rules { ok, err := rule.Evaluate(ctx, facts) if err != nil { return false, err } if ok { return true, nil } } return false, nil default: return false, fmt.Errorf(\u0026#34;unknown operator: %s\u0026#34;, c.operator) } } // ❌ 错误：硬编码的业务规则 if user.Age \u0026gt;= 18 \u0026amp;\u0026amp; user.Country == \u0026#34;CN\u0026#34; { // ... } 配置热更新： // ✅ 正确：支持热更新的配置 type DynamicConfig struct { mu sync.RWMutex current atomic.Value watch chan struct{} } func (c *DynamicConfig) Watch() { go func() { for { select { case \u0026lt;-c.watch: // 配置变更通知 if err := c.reload(); err != nil { log.Printf(\u0026#34;reload config error: %v\u0026#34;, err) } } } }() } func (c *DynamicConfig) reload() error { c.mu.Lock() defer c.mu.Unlock() // 加载新配置 newConfig, err := loadConfig() if err != nil { return err } // 原子更新 c.current.Store(newConfig) return nil } // ❌ 错误：静态配置 var config = loadConfig() 权限控制： // ✅ 正确：RBAC权限系统 type Permission string const ( PermissionUserCreate Permission = \u0026#34;user:create\u0026#34; PermissionUserRead Permission = \u0026#34;user:read\u0026#34; PermissionUserUpdate Permission = \u0026#34;user:update\u0026#34; PermissionUserDelete Permission = \u0026#34;user:delete\u0026#34; ) type RBAC struct { roles map[string][]Permission userRoles map[string][]string } func (r *RBAC) Can(userID string, perm Permission) bool { roles := r.userRoles[userID] for _, role := range roles { perms := r.roles[role] for _, p := range perms { if p == perm { return true } } } return false } // 中间件使用 func RequirePermission(perm Permission) gin.HandlerFunc { return func(c *gin.Context) { userID := GetUserID(c) if !rbac.Can(userID, perm) { c.AbortWithStatus(http.StatusForbidden) return } c.Next() } } // ❌ 错误：简单的角色检查 if user.Role != \u0026#34;admin\u0026#34; { return errors.New(\u0026#34;permission denied\u0026#34;) } 这些高级模式和最佳实践可以帮助你：\n实现更复杂的业务需求 提高系统的可扩展性 增强代码的可维护性 提升系统性能 更好地处理分布式场景 关键建议：\n根据实际需求选择合适的模式 避免过度设计 考虑团队的技术水平 注意维护成本 持续优化和改进 需要了解更多其他方面的内容吗？\n是的，让我们继续探讨更多高级设计模式和实践：\n领域事件处理： // ✅ 正确：领域事件处理 type DomainEvent interface { EventName() string OccurredAt() time.Time } type EventHandler interface { Handle(ctx context.Context, event DomainEvent) error } type EventBus struct { handlers map[string][]EventHandler mu sync.RWMutex } // 用户创建事件 type UserCreatedEvent struct { UserID uint64 Username string CreatedAt time.Time } func (e UserCreatedEvent) EventName() string { return \u0026#34;user.created\u0026#34; } // 事件处理器 type EmailNotifier struct { emailService EmailService } func (n *EmailNotifier) Handle(ctx context.Context, event DomainEvent) error { userCreated, ok := event.(*UserCreatedEvent) if !ok { return errors.New(\u0026#34;invalid event type\u0026#34;) } return n.emailService.SendWelcomeEmail(userCreated.UserID) } // 使用示例 func (s *UserService) Create(ctx context.Context, user *User) error { if err := s.repo.Create(ctx, user); err != nil { return err } // 发布领域事件 event := \u0026amp;UserCreatedEvent{ UserID: user.ID, Username: user.Username, CreatedAt: time.Now(), } return s.eventBus.Publish(ctx, event) } // ❌ 错误：直接在服务中处理副作用 func (s *UserService) Create(ctx context.Context, user *User) error { if err := s.repo.Create(ctx, user); err != nil { return err } s.emailService.SendWelcomeEmail(user.ID) // 紧耦合 return nil } 幂等性处理： // ✅ 正确：幂等性控制器 type IdempotencyKey string type IdempotencyControl struct { redis *redis.Client } func (ic *IdempotencyControl) Process( ctx context.Context, key IdempotencyKey, ttl time.Duration, fn func() error, ) error { // 使用 Redis 的 SETNX 实现幂等性检查 ok, err := ic.redis.SetNX(ctx, string(key), \u0026#34;processing\u0026#34;, ttl).Result() if err != nil { return fmt.Errorf(\u0026#34;idempotency check failed: %w\u0026#34;, err) } if !ok { return ErrDuplicateRequest } // 执行业务逻辑 if err := fn(); err != nil { // 业务执行失败，删除幂等键 ic.redis.Del(ctx, string(key)) return err } // 更新状态为已完成 return ic.redis.Set(ctx, string(key), \u0026#34;completed\u0026#34;, ttl).Err() } // 使用示例 func (s *PaymentService) ProcessPayment(ctx context.Context, req *PaymentRequest) error { key := IdempotencyKey(fmt.Sprintf(\u0026#34;payment:%s\u0026#34;, req.OrderID)) return s.idempotency.Process(ctx, key, 24*time.Hour, func() error { return s.processPaymentLogic(ctx, req) }) } // ❌ 错误：无幂等性控制 func (s *PaymentService) ProcessPayment(ctx context.Context, req *PaymentRequest) error { return s.processPaymentLogic(ctx, req) } 异步任务处理： // ✅ 正确：异步任务系统 type Task struct { ID string Type string Payload json.RawMessage Status TaskStatus Result json.RawMessage CreatedAt time.Time UpdatedAt time.Time } type TaskProcessor interface { Process(ctx context.Context, task *Task) error } type TaskQueue struct { processors map[string]TaskProcessor repo TaskRepository } func (q *TaskQueue) Submit(ctx context.Context, taskType string, payload interface{}) (*Task, error) { data, err := json.Marshal(payload) if err != nil { return nil, err } task := \u0026amp;Task{ ID: uuid.New().String(), Type: taskType, Payload: data, Status: TaskStatusPending, CreatedAt: time.Now(), } if err := q.repo.Save(ctx, task); err != nil { return nil, err } // 异步处理任务 go q.process(context.Background(), task) return task, nil } // 使用示例 type EmailTask struct { To string `json:\u0026#34;to\u0026#34;` Subject string `json:\u0026#34;subject\u0026#34;` Body string `json:\u0026#34;body\u0026#34;` } func (s *EmailService) SendAsync(ctx context.Context, to, subject, body string) (*Task, error) { task := \u0026amp;EmailTask{ To: to, Subject: subject, Body: body, } return s.taskQueue.Submit(ctx, \u0026#34;email\u0026#34;, task) } // ❌ 错误：直接在 goroutine 中处理 go sendEmail(to, subject, body) 审计日志： // ✅ 正确：审计日志系统 type AuditLog struct { ID uint64 UserID uint64 Action string Resource string ResourceID string Changes map[string]interface{} IP string UserAgent string CreatedAt time.Time } type AuditLogger struct { repo AuditLogRepository } func (l *AuditLogger) Log(ctx context.Context, event *AuditEvent) error { log := \u0026amp;AuditLog{ UserID: GetUserID(ctx), Action: event.Action, Resource: event.Resource, ResourceID: event.ResourceID, Changes: event.Changes, IP: GetClientIP(ctx), UserAgent: GetUserAgent(ctx), CreatedAt: time.Now(), } return l.repo.Create(ctx, log) } // 中间件使用 func AuditMiddleware(logger *AuditLogger) gin.HandlerFunc { return func(c *gin.Context) { // 记录请求前的状态 // ... c.Next() // 记录请求后的状态变化 event := \u0026amp;AuditEvent{ Action: c.Request.Method, Resource: c.Request.URL.Path, Changes: getChanges(c), } logger.Log(c, event) } } // ❌ 错误：简单的日志记录 log.Printf(\u0026#34;user %d modified resource %s\u0026#34;, userID, resourceID) API 版本控制和兼容性： // ✅ 正确：API 版本控制 type APIVersion string const ( APIVersionV1 APIVersion = \u0026#34;v1\u0026#34; APIVersionV2 APIVersion = \u0026#34;v2\u0026#34; ) // 请求结构体版本控制 type CreateUserRequestV1 struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } type CreateUserRequestV2 struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` PhoneNumber string `json:\u0026#34;phone_number\u0026#34;` // V2新增字段 } // 服务层版本控制 type UserService interface { CreateUserV1(ctx context.Context, req *CreateUserRequestV1) error CreateUserV2(ctx context.Context, req *CreateUserRequestV2) error } // 路由版本控制 func SetupRoutes(r *gin.Engine) { v1 := r.Group(\u0026#34;/api/v1\u0026#34;) { v1.POST(\u0026#34;/users\u0026#34;, handler.CreateUserV1) } v2 := r.Group(\u0026#34;/api/v2\u0026#34;) { v2.POST(\u0026#34;/users\u0026#34;, handler.CreateUserV2) } } // ❌ 错误：不兼容的API变更 type CreateUserRequest struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` // 直接修改已发布的API结构 PhoneNumber string `json:\u0026#34;phone_number\u0026#34;` } 这些设计模式和最佳实践适用于：\n大型复杂系统 微服务架构 高可用要求的系统 需要严格审计的系统 需要良好扩展性的系统 要点提示：\n根据实际需求选择合适的模式 在简单系统中避免过度设计 考虑团队的技术能力和维护成本 保持代码的可测试性 注重文档和注释的维护 需要了解更多其他方面的内容吗？\n这些最佳实践和设计模式来源于多个领域，我来整理一下来源和推荐阅读：\nGo 语言最佳实践来源： 书籍： 1. 《Go Programming Language》 - Alan A. A. Donovan, Brian W. Kernighan - Go 语言权威指南，基础语法和最佳实践 2. 《100 Go Mistakes and How to Avoid Them》 - Teiva Harsanyi - 详细介绍 Go 常见错误和避免方法 3. 《Concurrency in Go》 - Katherine Cox-Buday - Go 并发编程最佳实践 在线资源： 1. Go 官方文档和博客：https://golang.org/doc/ 2. Uber Go 风格指南：https://github.com/uber-go/guide 3. Go Code Review Comments：https://github.com/golang/go/wiki/CodeReviewComments 4. effective_go：https://golang.org/doc/effective_go 架构设计参考： 书籍： 1. 《Clean Architecture》 - Robert C. Martin - 架构设计原则和最佳实践 2. 《Designing Data-Intensive Applications》 - Martin Kleppmann - 分布式系统设计圣经 3. 《Domain-Driven Design》 - Eric Evans - 领域驱动设计 4. 《Building Microservices》 - Sam Newman - 微服务架构设计 在线资源： 1. Microsoft Azure Architecture Center：https://docs.microsoft.com/azure/architecture/ 2. AWS Architecture Center：https://aws.amazon.com/architecture/ 3. System Design Primer：https://github.com/donnemartin/system-design-primer 设计模式： 书籍： 1. 《Design Patterns》 - Gang of Four - 经典设计模式 2. 《Go Design Patterns》 - Mario Castro Contreras - Go 语言设计模式实现 3. 《Cloud Native Go》 - Matthew A. Titmus - 云原生 Go 应用设计模式 在线资源： 1. Go Patterns：https://github.com/tmrts/go-patterns 2. Cloud Native Patterns：https://www.cnpatterns.org/ 数据库和性能优化： 书籍： 1. 《High Performance MySQL》 - Baron Schwartz - MySQL 性能优化指南 2. 《Database Internals》 - Alex Petrov - 数据库内部原理 在线资源： 1. GORM 文档：https://gorm.io/docs/ 2. MySQL 官方文档：https://dev.mysql.com/doc/ 微服务和分布式系统： 书籍： 1. 《Microservices Patterns》 - Chris Richardson - 微服务设计模式 2. 《Site Reliability Engineering》 - Google - Google SRE 实践 在线资源： 1. Go Micro：https://go-micro.dev/ 2. Go Kit：https://gokit.io/ 安全最佳实践： 书籍： 1. 《Web Application Security》 - Andrew Hoffman - Web 应用安全指南 在线资源： 1. OWASP：https://owasp.org/ 2. Go Security Cheat Sheet：https://github.com/OWASP/CheatSheetSeries 测试和质量保证： 书籍： 1. 《Test-Driven Development with Go》 - Adelina Simion - Go TDD 实践 在线资源： 1. Go Testing：https://golang.org/pkg/testing/ 2. GoMock：https://github.com/golang/mock 持续学习资源： 1. Go Weekly：https://golangweekly.com/ 2. Go Time Podcast：https://changelog.com/gotime 3. Go Forum：https://forum.golangbridge.org/ 4. Reddit r/golang：https://www.reddit.com/r/golang/ 实践建议：\n循序渐进：\n从基础开始，逐步掌握高级概念 在实际项目中应用所学知识 社区参与：\n关注 Go 语言社区动态 参与开源项目 分享经验和学习心得 实践为主：\n多写代码，多做项目 复现和实现书中的示例 根据实际需求选择合适的模式 持续更新：\n关注新版本特性 学习新的最佳实践 保持对技术的热情 这些资源和建议可以帮助你：\n系统地学习 Go 开发 提高代码质量 掌握先进的架构设计 解决实际问题 持续进步 你对哪些方面特别感兴趣？我可以给出更具体的学习建议。\nGo 后端开发学习路线图 1. 基础架构 1.1 分层架构 Handler (API) 层\n参数验证 错误处理 响应封装 路由管理 API 文档 (Swagger) Service (业务) 层\n业务逻辑 事务管理 领域模型 数据转换 业务规则验证 Repository (数据) 层\n数据访问 ORM 使用 SQL 优化 缓存管理 数据模型 1.2 依赖管理 依赖注入原则 接口定义位置 依赖方向控制 循环依赖处理 模块化设计 1.3 配置管理 环境配置 配置分离 配置验证 敏感信息保护 热更新支持 2. 性能优化 2.1 并发控制 Goroutine 池 工作池模式 并发限制 竞态条件处理 上下文管理 2.2 数据库优化 连接池管理 读写分离 分库分表 索引优化 慢查询处理 2.3 缓存策略 多级缓存 缓存一致性 缓存穿透 缓存雪崩 缓存更新 3. 可靠性保障 3.1 错误处理 错误类型定义 错误包装 错误传播 错误恢复 错误监控 3.2 重试机制 退避策略 超时控制 熔断器模式 降级策略 限流控制 3.3 事务管理 本地事务 分布式事务 补偿事务 事务隔离级别 死锁处理 4. 安全性保障 4.1 认证授权 JWT 实现 OAuth2 集成 RBAC 权限 会话管理 权限校验 4.2 数据安全 加密解密 敏感数据处理 SQL 注入防护 XSS 防护 CSRF 防护 4.3 访问控制 限流 黑白名单 IP 控制 请求频率控制 资源隔离 5. 可观测性 5.1 日志管理 结构化日志 日志分级 日志轮转 审计日志 日志收集 5.2 监控指标 性能指标 业务指标 系统指标 告警策略 指标可视化 5.3 链路追踪 请求追踪 性能分析 调用链路 异常定位 性能瓶颈 6. 最佳实践 6.1 代码规范 项目结构 命名规范 注释规范 代码格式 最佳实践 6.2 设计模式 创建型模式 结构型模式 行为型模式 DDD 实践 微服务模式 6.3 测试规范 单元测试 集成测试 性能测试 压力测试 测试覆盖率 7. 工程化实践 7.1 CI/CD 自动构建 自动测试 自动部署 版本控制 环境管理 7.2 文档管理 API 文档 架构文档 运维文档 变更记录 使用指南 7.3 质量保障 代码审查 静态分析 性能分析 安全扫描 质量监控 8. 中间件使用 8.1 消息队列 Kafka RabbitMQ Redis Pub/Sub 消息幂等性 顺序保证 8.2 缓存中间件 Redis Memcached 本地缓存 分布式缓存 缓存策略 8.3 搜索引擎 Elasticsearch 全文搜索 数据同步 搜索优化 聚合分析 9. 微服务架构 9.1 服务治理 服务注册 服务发现 负载均衡 配置中心 服务网关 9.2 容器化 Docker Kubernetes 服务编排 资源管理 容器监控 9.3 高可用设计 服务容错 灾难恢复 数据备份 多活部署 自动扩缩容 10. 架构进阶 10.1 领域驱动设计 领域模型 限界上下文 聚合根 领域事件 CQRS 10.2 分布式系统 CAP 理论 一致性算法 分布式锁 分布式事务 分布式缓存 10.3 性能调优 系统调优 网络调优 数据库调优 应用调优 代码调优 让我总结一下在 Go 和 Rust 中常见的接口设计和依赖管理最佳实践：\nGo 语言接口设计原则：\n接口定义位置： // 接口应该由调用方定义，而不是实现方 caller/ -\u0026gt; 定义接口 service/ -\u0026gt; 实现接口 小接口原则： // 好的设计 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // 需要时可以组合 type ReadWriter interface { Reader Writer } 面向抽象编程： // Handler 依赖接口而不是具体实现 type Handler struct { service ServiceInterface // 好 // service *ConcreteService // 不好 } Rust 中的类似原则：\n特征(Trait)定义位置： // 在调用方 crate 中定义特征 mod caller { pub trait ImageService { fn upload(\u0026amp;self, image: Image) -\u0026gt; Result\u0026lt;(), Error\u0026gt;; } } // 在实现方 crate 中实现特征 mod service { use caller::ImageService; struct MyImageService; impl ImageService for MyImageService { fn upload(\u0026amp;self, image: Image) -\u0026gt; Result\u0026lt;(), Error\u0026gt; { // 实现 } } } 特征边界和泛型： // 使用特征边界而不是具体类型 struct Handler\u0026lt;S: ImageService\u0026gt; { service: S, } // 或者使用 impl Trait fn new_handler(service: impl ImageService) -\u0026gt; Handler\u0026lt;impl ImageService\u0026gt; { Handler { service } } 面向特征编程： // 好的设计 pub trait Repository { fn save(\u0026amp;self, data: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;(), Error\u0026gt;; } // 实现可以放在单独的模块 pub struct FileRepository; impl Repository for FileRepository { // 实现 } // 使用 Box\u0026lt;dyn Trait\u0026gt; 实现运行时多态 struct Service { repo: Box\u0026lt;dyn Repository\u0026gt;, } 依赖注入模式： // 使用构建器模式 pub struct ServiceBuilder\u0026lt;R\u0026gt; { repository: R, } impl\u0026lt;R: Repository\u0026gt; ServiceBuilder\u0026lt;R\u0026gt; { pub fn new(repository: R) -\u0026gt; Self { Self { repository } } pub fn build(self) -\u0026gt; Service\u0026lt;R\u0026gt; { Service { repository: self.repository, } } } 错误处理： // 定义域特定错误 #[derive(Debug, thiserror::Error)] pub enum ServiceError { #[error(\u0026#34;database error: {0}\u0026#34;)] Database(#[from] DbError), #[error(\u0026#34;validation error: {0}\u0026#34;)] Validation(String), } // 实现时使用 ? 运算符传播错误 impl ImageService for MyService { fn process(\u0026amp;self, data: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;(), ServiceError\u0026gt; { let validated = validate_data(data)?; self.repository.save(validated)?; Ok(()) } } 模块化和可见性： // 在 lib.rs 中定义公共 API pub mod api { pub trait Service { // 公共接口 } } // 内部实现保持私有 mod internal { use super::api::Service; pub(crate) struct ServiceImpl; impl Service for ServiceImpl { // 实现 } } 共同的设计原则：\n依赖倒置：\n高层模块不应该依赖低层模块 都应该依赖于抽象 单一职责：\n每个接口/特征应该只负责一个功能领域 避免大而全的接口/特征 接口隔离：\n客户端不应该依赖它不需要的接口 使用小而精确的接口/特征 显式依赖：\n通过构造函数/builder注入依赖 避免全局状态和隐式依赖 这些原则能帮助我们创建：\n松耦合的系统 易于测试的代码 可维护的项目结构 清晰的依赖关系 ","date":"2024-12-29","tags":["编程","go"],"title":"Go 最佳实践","url":"/post/2024/12/go/"},{"content":"如何找资源 下载 盘搜 ↗ 盘搜搜 ↗ 大圣盘 ↗ TG机器人 ↗ 阿里搜 ↗ 一、我维护的其他站 Move 学习 move ↗ 二、编程相关内容 各种镜像收录 iframe src=\u0026ldquo; http://www.yishimei.cn/\" ↗ width=\u0026ldquo;100%\u0026rdquo; height=\u0026ldquo;600\u0026rdquo;\u0026gt;\nNPS: http://101.43.125.94:20002/ DS220j-SSH: http://101.43.125.94:20010/ DS220j-DSM: http://101.43.125.94:20011/\nWindows10: http://101.43.125.94:20020/\n","date":"2024-12-29","tags":["资源"],"title":"资源","url":"/post/2024/12/resource/"},{"content":" # 基础优化配置 enableGitInfo = true # 启用 Git 信息,可以显示文章的最后修改时间 hasCJKLanguage = true # 启用中日韩文字支持,能准确统计字数 summaryLength = 140 # 文章摘要长度 # SEO 优化 [params] keywords = [\u0026#34;博客\u0026#34;,\u0026#34;技术\u0026#34;,\u0026#34;编程\u0026#34;] # 网站关键词 description = \u0026#34;个人技术博客\u0026#34; # 网站描述 images = [\u0026#34;site-feature-image.jpg\u0026#34;] # 默认社交媒体分享图片 # 自定义 Open Graph 信息 [params.og] title = \u0026#34;我的博客\u0026#34; type = \u0026#34;website\u0026#34; images = [\u0026#34;og-image.jpg\u0026#34;] # 性能优化 [minify] disableCSS = false # 启用 CSS 压缩 disableHTML = false # 启用 HTML 压缩 disableJS = false # 启用 JS 压缩 disableJSON = false # 启用 JSON 压缩 minifyOutput = true # 压缩 HTML 输出 # 图片处理 [imaging] quality = 75 # JPEG 图片质量 resampleFilter = \u0026#34;Lanczos\u0026#34; # 图片重采样过滤器 anchor = \u0026#34;Smart\u0026#34; # 图片裁剪锚点 # 内容安全策略 [params.csp] childsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] fontsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;, \u0026#34;https://fonts.gstatic.com\u0026#34;, \u0026#34;https://cdn.jsdelivr.net\u0026#34;] formaction = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] framesrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] imgsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;] objectsrc = [\u0026#34;\u0026#39;none\u0026#39;\u0026#34;] stylesrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;, \u0026#34;\u0026#39;unsafe-inline\u0026#39;\u0026#34;] scriptsrc = [\u0026#34;\u0026#39;self\u0026#39;\u0026#34;, \u0026#34;\u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;\u0026#39;unsafe-eval\u0026#39;\u0026#34;] # 文章配置 [permalinks] posts = \u0026#34;/post/:year/:month/:slug/\u0026#34; # 自定义文章 URL 结构 # 自定义输出格式 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] # 支持 JSON API 输出 section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] term = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] # RSS 订阅配置 [params.rss] limit = 20 # RSS 文章数量限制 fullContent = true # RSS 包含完整文章内容 # 站内搜索配置 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;, \u0026#34;SearchIndex\u0026#34;] [outputFormats.SearchIndex] mediaType = \u0026#34;application/json\u0026#34; baseName = \u0026#34;searchindex\u0026#34; isPlainText = true notAlternative = true # 文章目录配置 [markup.tableOfContents] endLevel = 3 # 目录最大深度 ordered = false # 使用无序列表 startLevel = 2 # 目录开始层级 # 代码高亮配置 [markup.highlight] codeFences = true # 启用代码围栏 guessSyntax = true # 自动推测代码语言 lineNoStart = 1 # 起始行号 lineNos = true # 显示行号 lineNumbersInTable = true # 使用表格式行号 tabWidth = 4 # 制表符宽度 style = \u0026#34;monokai\u0026#34; # 代码高亮主题 一些重要的最佳实践建议：\n内容组织 content/ ├── posts/ # 博客文章 │ ├── tech/ # 技术文章 │ └── life/ # 生活随笔 ├── about/ # 关于页面 ├── projects/ # 项目展示 └── notes/ # 学习笔记 图片资源管理 static/ ├── images/ │ ├── posts/ # 文章配图 │ ├── avatars/ # 头像 │ └── icons/ # 图标 └── assets/ # 其他资源 文章 Front Matter 模板 --- title: \u0026#34;文章标题\u0026#34; date: 2024-03-21T15:04:05\u0026#43;08:00 lastmod: 2024-03-21T15:04:05\u0026#43;08:00 draft: false weight: 1 categories: [\u0026#34;分类\u0026#34;] tags: [\u0026#34;标签1\u0026#34;, \u0026#34;标签2\u0026#34;] author: \u0026#34;作者\u0026#34; description: \u0026#34;文章描述\u0026#34; featuredImage: \u0026#34;featured-image.jpg\u0026#34; toc: true # 是否显示目录 autoCollapseToc: true # 自动折叠目录 --- 安全性建议： 开启 HTTPS 配置适当的 CSP(Content Security Policy) 定期更新主题和依赖 使用 robots.txt 控制爬虫访问 实现基本的 DDoS 防护 性能优化： 使用 CDN 加速静态资源 开启图片懒加载 合理设置缓存策略 压缩静态资源 优化关键渲染路径 SEO 优化： 编写清晰的 robots.txt 创建 sitemap.xml 优化 meta 标签 实现结构化数据 使用规范的 URL 结构 确保移动端适配 备份策略： 使用 Git 进行版本控制 定期备份数据库 导出重要配置 多平台备份 以上配置和建议可以帮助你搭建一个更完善的 Hugo 博客站点。根据实际需求，你可以选择性地采用这些配置。记住定期维护和更新，确保站点的安全性和性能。\n","date":"2024-12-22","tags":["hugo"],"title":"hugo 配置","url":"/post/2024/12/about_hugo_config/"},{"content":"再见Hexo——从Hexo迁移至Hugo 16 年的时候，博客使用的虚拟主机需要做迁移，当时所使用的 Typecho 是一个依赖于数据库的 PHP 博客系统，数据导出过程很艰辛。彼时 Gihub Pages 正大火，我也就跟风转投了静态博客系统 Hexo 。七年过去了，博客还在，但折腾 Hexo 的人是越来越少了。如今我也要和 Hexo 说声再见，拥抱 Hugo 的怀抱了。\n为什么改用Hugo 依赖管理问题 在 静态博客的同步和备份方案 ↗ 一文中，我分享了基于 Github 和 iCloud 的同步备份方案，期望在保证数据安全的同时，写作环境可以在我的两台电脑上无缝切换。\n然而实际上，由于 Hexo 依赖于 Node.js ，庞大的 node_modules 并不能直接同步而是需要分别安装和更新，如果忘了运行 npm install -S ，那报错和渲染异常就是家常便饭的事。而 node-sass 这样的库还对 node 版本做了显式要求，导致如果哪台设备改了 nvm 中 node 的版本就会报错。但偏偏又有大量的主题和插件都依赖于 node-sass 。\n而 Hugo 是基于 Golang 的二进制程序，安装和升级都很简单。由于内置功能足够多，插件（模块）不再是必需的了，如果有需要，其也都是通过 go mod 管理，轻量而简洁。虽然大部分主题仍然依赖于 Node.js ，但那只是创建和修改主题时的事情，不会影响到写作流程。\n诚然，这并不能算作 Hexo 本身的问题，但由于底层的技术选型，导致 Hexo 必然和各类主题及插件的耦合较为严重。在三方组件实现和依赖复杂的情况下，整体的复杂度也就必然会成倍地上涨。\n网页生成速度 Hexo 裸安装后的网页生成速度并不算不可接受，和 Hugo 比起来也就几秒到十几秒的差异，没有网上传得那么夸张。但多加了几个像 hexo-all-minifier ↗ 这样生命周期靠后的插件后，生成速度确实会肉眼可见地下降。而 Hugo 的网页生成速度则非常稳定，总是保持在秒级别甚至毫秒级别，因此也可以真正意义上地实现本地实时预览。\nHugo的特性 Hugo 对 org-mode 、pandoc 等提供了原生支持，轻度使用体验也不错（深度使用也会遇到坑）。虽然 Hexo 等也可以通过安装插件和转换器等方式来实现，但这又会回到上面的依赖复杂的问题之中。此外，Hugo 的 shortcode ↗ 功能也非常强大，如果不考虑 md 文件的通用性，那结合 shortcodes 可以轻松实现很多本需要依赖于插件（模块）才能做到的功能。\n快速上手 首先安装 Hugo 并创建站点，以 macOS 系统为例：\n1 2 brew install hugo # For macOS hugo new site sample 这里需要注意的是，如果此前系统中已经安装过旧版本的 Go ，那有可能需要升级后才能使用 homebrew 完成安装。随后选一个喜欢的主题拉取到 /themes 目录，以 even 主题为例：\n1 git clone https://github.com/olOwOlo/hugo-theme-even themes/even 主题通常会带有示例配置文件 config.toml ，将其复制到站点的根目录下覆盖默认配置文件，并完成相应配置后，运行 hugo new post/test.md 新建文章，随后运行 hugo server -D 即可查看站点。对于存量的文章，需要将其复制到主题 /content/ 目录下，其中文章类的需要按主题的设计来放置于具体目录，如 even 主题使用 post 目录，则需要将文章复制到 /content/posts 目录下，重新执行上面的命令就能在站点里看到文章了。\n如果运行命令时报错，则可能是存量文章的 front matter 格式有不符合 Hugo 要求的情况，此时需要按 官方文档 ↗ 进行修改适配。\n写作习惯的变化 整体写作习惯其实和 Hexo 的体验差别不大。不过 Hugo 提供了比 Hexo 更丰富的 front matter 默认配置，同时还支持 org-mode 等玩法，所以写作方式上的可玩性会更高些。\n主题自定义方式的变化 与 Hexo 主题的完全前端实现不同，Hugo 的主题使用了 Go 的模板语言，有点类似于 PHP 和 JSP ，并向主题暴露了一系列的全局变量和函数，所以其实主题和 Hugo 或 Golang 还是有一定的耦合的。\n不过这也使得我们可以通过自定义模板覆盖主题默认模板的方式，来既实现自己的需求，又能最低限度地避免修改主题源代码导致的升级困难。但很多主题没有提供关键位置的钩子模板（也可以说是接口），导致我们经常需要拷贝一部分主题的源代码到自定义模板中，这又对主题的升级造成了一定的影响，可以说是有得必有失了。\n向前兼容 迁移工作的一个核心要求就是尽量避免引入 breaking change 。首先要保证存量页面的链接不发生变化，以避免出现 404 的情况。其次要尽量对此前在 Hexo 中使用的各项功能进行支持。\n永久链接格式兼容 在 Hexo 中，通常有以下三种 URL 永久链接路径格式：\n日期前缀+英文别称或文件名：/2021/07/06/a-better-hexo-theme-even/ 固定前缀+英文别称或文件名：/posts/slidev-tutorial/ 使用了 abbrlink 等插件生成 CRC/Hash 值作为路径：/posts/8ccq01298/ 而 Hugo 默认的永久链接格式为 /{{ 文章目录 }}/{{ 文章文件名 }} ，和上面第二种比较相似但又有所不同。那么我们该如何实现兼容呢？\n首先我们要了解 Hugo 可以在根目录的 config.toml 中对永久链接进行自定义配置，例如：\n1 2 [permalinks] '/' = \u0026quot;/posts/:slug\u0026quot; 因此我们只需要针对不同情况，对该配置进行自定义即可。\n日期前缀+英文别称或文件名：仿照 Hexo 的日期格式，将值配置为 /:year/:month/:day/:title/ 。 固定前缀+英文别称或文件名：将值改为 /posts/:title 即可。 Hugo front matter 中的 slug 变量表示自定义别名，所以如果此前在 Hexo 使用了自定义的变量，只要仿照此前的配置将 title 改为 slug 即可，例如 /posts/:title 。 使用 abbrlink 等插件生成的 CRC/Hash 值作为路径：Hugo 似乎没有 abbrlink 这类插件，不过我们可以仿照 这篇文章 ↗ ，在默认内容模板 archetypes/default.md ，再将其中的 slug 配置为一段具备哈希或 CRC 功能的表达式即可。不过存量文章可能需要通过 front-matter 中的 url 变量进行完整路径的显式声明，不然如果表达式的处理结果和 Hexo 中的不同，那链接可就变了。 上面说明了 permalinks 的值，那 key 该如何配置呢？与 Hexo 不同，Hugo 中永久链接的固定前缀（对应上文的情况 2 和情况 3）是根据目录位置生成的，该位置的选择又与主题有关。有的主题使用的是 /content/post/ 目录，有的主题使用的又是 /content/posts 目录，同时这个路径在很多主题的实现中是写死的。因此如果此前你在 Hexo 中所使用的固定前缀和所选 Hugo 主题的不同（如 /articles/），那就会造成链接发生变化的问题。\n所以我们需要在 permalinks 配置的 key 上做些文章，把主题所用的路径做一层指定映射，保证最终的路径以我们期望的前缀输出。以主题使用 /content/post/ 作为内容目录、原 Hexo 文章的永久链接格式为 /posts/:slug 为例，对 permalinks 进行以下配置即可：\n1 2 [permalinks] post = \u0026quot;/posts/:slug\u0026quot; 另外，对于此前在 Hexo 中配置了 html 后缀等情况，可以开启 Hugo 的 Ugly URLs 来实现兼容，细节可以参考 官方文档 ↗ 。\n归档页面路径链接的兼容 前一节提到了主题对内容目录路径的选择可能是不同的，而这也会影响到归档页面的路径。在 Hugo 的大部分主题中，如果主题使用 /content/post/ 作为内容目录，那归档页面路径则默认为 /post/ 且不支持配置。而我们在 Hexo 中通常会使用 /archives/ 作为归档页面的路径，如何才能保持不变呢？\n虽然绝大部分主题（也可能是所有）都没有此项配置，但我们可以通过自定义一套模板和页面的方式来绕过主题的限制。以 even 主题的模板和 CSS 样式为例，在 /layouts/_default/ 目录下新建 archives.html 模板，随后填充以下内容，用于按年分组遍历所有文章，并在原主题的框架下输出文章标题列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 {{- define \u0026quot;title\u0026quot; }}{{ T \u0026quot;archive\u0026quot; }} - {{ .Site.Title }}{{ end -}} {{- define \u0026quot;content\u0026quot; }} {{ $pageList := (where .Site.RegularPages \u0026quot;Type\u0026quot; \u0026quot;post\u0026quot;) }} \u0026lt;section id=\u0026quot;archive\u0026quot; class=\u0026quot;archive\u0026quot;\u0026gt; {{- if .Site.Params.showArchiveCount }} \u0026lt;div class=\u0026quot;archive-title\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;archive-post-counter\u0026quot;\u0026gt; {{ T \u0026quot;archiveCounter\u0026quot; (len $pageList) }} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} {{ range ($pageList.GroupByDate \u0026quot;2006\u0026quot;) }} \u0026lt;div class=\u0026quot;collection-title\u0026quot;\u0026gt; \u0026lt;h2 class=\u0026quot;archive-year\u0026quot;\u0026gt;{{ .Key }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026quot;archive-list\u0026quot;\u0026gt; {{ range (where .Pages \u0026quot;Type\u0026quot; \u0026quot;post\u0026quot;) }} \u0026lt;div class=\u0026quot;archive-post\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;archive-post-time\u0026quot;\u0026gt; {{ .PublishDate.Format \u0026quot;01-02\u0026quot; }} \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;archive-post-title\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;{{ .RelPermalink }}\u0026quot; class=\u0026quot;archive-post-link\u0026quot;\u0026gt; {{ .Title }} \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; {{ end }} \u0026lt;/section\u0026gt; {{ end }} 随后在 /content/ 目录下新建 archives.md 页面，将 type 指定为刚刚定义的 archives ：\n1 2 3 4 5 6 7 8 --- title: \u0026quot;归档\u0026quot; layout: \u0026quot;archives\u0026quot; url: \u0026quot;/archives/\u0026quot; comment: false hidden: true type: archives --- 这时我们就已经可以通过访问 /archives/ 路径来进入到归档页面了，接下来只要在 config.toml 中再将导航栏中的对应按钮指定为预期链接即可。\n1 2 3 4 5 [[menu.main]] name = \u0026quot;归档\u0026quot; weight = 20 identifier = \u0026quot;archives\u0026quot; url = \u0026quot;/archives/\u0026quot; 上文这种实现的效果和很多主题的归档页面相比，主要区别在于单页面内罗列了所有文章，即缺少分页。由于大部分主题的分页逻辑和其内部的其他模板耦合较为严重，同时 Hugo 的分页相关变量被限制不能用于自定义模板之中，所以如果希望自定义的归档页能支持分类，则可能需要对 Hugo 的原生逻辑进行包装即额外实现一套分页能力才行。这里不做展开讲述。\n友情链接和自我介绍 和 Hexo 一样，Hugo 也没有直接支持友情链接和自我介绍这类常用页面。在实现上我们要么在 /content/ 目录下自定义页面也就是在页面内维护内容，要么如归档页面一般，通过自定义模板的方式来加载 config.toml 中的配置。两种实现都比较简单，我也更倾向于前者，毕竟这些是低频修改页面，是否可配置区别都不大。\n标签和分类的中英文问题 在 Hexo 中，我们通常会在 _config.yml 中配置标签和分类的中英文映射，这样我们在 front matter 中可以使用任意语言标识标签和分类，但生成后两者的 URI 都是英文。然而在 Hugo 中却没有这类简易设置，也许我们可以通过修改主题和永久链接的方式来间接支持，但估计成本较高。所以如果对 URI 有强迫症的读者，还是建议把存量文章的标签和分类改为英文。而如果对此没有特殊需求，那使用中文也可。除了 URL 的分享可读性可能较差外，在 2022 年的今天其实已经不会影响搜索引擎的 SEO 效果了。\n支持Git与VPS部署 不知为何 Hugo 官方没有直接支持使用 Git 搭配 Git Hooks 部署站点，对于我这种把博客部署在 VPS 的用户给出的建议方案是 rsync 。其实 rsync 方案是完全可行且成本不高的，不过本着尽量兼容的原则我还是决定在部署时执行以下 shell 脚本来通过 Git 推送生成的 /public/ 目录至 VPS ，而 VPS 上的 Git 库和 Git Hooks 配置则无需改动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #! /bin/bash rm -rf ./public hugo rm -rf ./.deploy_git mkdir .deploy_git cp -r public/* ./.deploy_git cd .deploy_git git init --initial-branch=master git add -A git commit -m 'Deploy commit.' --quiet git push -u foo@bar-server:/var/blog.git HEAD:master --force cd .. rm -rf ./.deploy_git 兼容Hexo的RSS形式 使用 Hexo 时博客的 RSS 是全文输出，而换到 Hugo 后 RSS 却变为了输出摘要。作为一个重度 RSS 用户，我自然是深知拉取到的文章还要二次跳转到浏览器才能看原文的体验有多差，所以还是要让 RSS 的表现和此前一致才行。\nHugo 的 RSS 是基于默认 RSS 模板生成的，所以我们只要重新定义一个模板并改为全文输出即可。 Hugo 的默认实现 ↗ 中，决定输出内容的是如下这行代码：\n| 1 | \u0026lt;description\u0026gt;{{ .Summary | html }}\u0026lt;/description\u0026gt; | | \u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | | |\n我们只需要在 /layouts/ 目录新建 index.rss.xml 覆盖默认模版并将原实现拷贝至其中，接着把代码中的 {{ .Summary | html }} 替换为代表全文内容的表达式 {{ .Content | html }} 即可：\n| 1 | \u0026lt;description\u0026gt;{{ .Content | html }}\u0026lt;/description\u0026gt; | | \u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | | |\neven主题迁移 由于此前一直在使用 修改过的 Hexo even 主题 ↗ ，为保证前端效果不变，所以主题方面也采用了 Hugo 下的 even 主题，因此会有很多主题层面的额外适配工作。\n自定义导航栏 此前使用 Hexo 下 even 主题时自定义了一个用于引导用户的导航栏，那么如何在 Hugo 的 even 主题中实现兼容呢？\n首先我们在 /layouts/partials/header/ 下新建 top-nav.html 模板，按需填充内容，如增加 Newsletter 、Telegram Channel 等引导：\n1 2 3 4 5 6 7 8 9 10 11 12 13 {{- if .Site.Params.enableTopNav }} \u0026lt;div class=\u0026quot;top-nav\u0026quot;\u0026gt; {{- if .Site.Params.revue.enabled -}} \u0026lt;a href=\u0026quot;{{ .Site.Params.revue.home }}\u0026quot; href=\u0026quot;_blank\u0026quot; class=\u0026quot;top-nav-button\u0026quot;\u0026gt;Newsletter\u0026lt;/a\u0026gt; {{- end -}} {{- if .Site.Params.telegram.enabled -}} \u0026lt;a href=\u0026quot;{{ .Site.Params.telegram.link }}\u0026quot; href=\u0026quot;_blank\u0026quot; class=\u0026quot;top-nav-button\u0026quot;\u0026gt;电报频道\u0026lt;/a\u0026gt; {{- end -}} {{- if .Site.Params.wxOfficialAccount.enabled -}} \u0026lt;a href=\u0026quot;{{ .Site.Params.wxOfficialAccount.url }}\u0026quot; href=\u0026quot;_blank\u0026quot; class=\u0026quot;top-nav-button\u0026quot;\u0026gt;微信公众号\u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; {{- end -}} 随后我们需要找个位置引入该模板。受 even 主题实现的限制，我们需要将该模板放置于 header 块之后才能最低成本地保留原布局。因此我们只有一个选择，那就是将 baseof.html 这个基础模板进行覆盖。拷贝原模板内容至 /layouts/_default/baseof.html 中，并在 header 块之后、main 块之前引入此前定义的 top-nav.html ：\n1 2 3 4 5 6 7 8 9 10 11 12 ... \u0026lt;div class=\u0026quot;container\u0026quot; id=\u0026quot;mobile-panel\u0026quot;\u0026gt; {{ if not .Params.hideHeaderAndFooter -}} \u0026lt;header id=\u0026quot;header\u0026quot; class=\u0026quot;header\u0026quot;\u0026gt; {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;/header\u0026gt; {{- end }} {{- partial \u0026quot;header/top-nav.html\u0026quot; . -}} \u0026lt;main id=\u0026quot;main\u0026quot; class=\u0026quot;main\u0026quot;\u0026gt; ... 最后在 config.toml 中完成相关参数配置即可：\n1 2 3 4 5 6 7 8 9 10 11 [params.wxOfficialAccount] enabled = true url = \u0026quot;\u0026quot; [params.telegram] enabled = true link = \u0026quot;\u0026quot; [params.revue] enabled = true home = \u0026quot;\u0026quot; 支持umami访问统计 博客之前一直按「 使用Nginx将请求转发至Google Analytics实现后端统计 ↗ 」一文的方式来实现请求统计。但这个方式的问题在于，由于不要求加载 JS ，很多非真实流量（主要为 RSS 阅读器的抓取）也会被统计进来。后来看到「 搭建 umami 收集个人网站统计数据 ↗ 」这篇文章，便也用 umami 搭建了一个轻量的统计能力。\neven 主题自然没有对 umami 进行原生支持，我们需要做的是先找到一个包含 head 的模版并在 \u0026lt;head/\u0026gt; 标签中添加以下内容：\n| 1 2 3 | {{- if (in (slice (getenv \u0026quot;HUGO_ENV\u0026quot;) hugo.Environment) \u0026quot;production\u0026quot;) | and .Site.Params.umami.enabled -}} \u0026lt;script async defer data-website-id=\u0026quot;{{ .Site.Params.umami.id }}\u0026quot; src=\u0026quot;{{ .Site.Params.umami.js }}\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; {{- end -}} | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | | |\n然后在配置中完成定义即可：\n1 2 3 4 [params.umami] enabled = true id = \u0026quot;\u0026quot; # umami 统计 id js = \u0026quot;\u0026quot; # umami 的 JS 地址 由于 even 主题没有提供可以直接拓展 \u0026lt;head/\u0026gt; 标签的模板，我的选择是将代码加到此前不得不重写的 baseof.html 中。不得不说，这个实现很丑陋，但成本确实也是最低的。\n此外，为了避免本地启动时 umami 将本地请求也进行了统计并将 Referrer 识别为 localhost ，上文的实现中对环境做了判断，即正式生成站点时才会引入 JS 依赖来上报 umami ，本地运行则不引入。\n自定义文章末尾页脚 此前在 Hexo 的 even 下我也对文章末尾进行了自定义。对于 Hugo 的 even 主题，改造成本最低的方式为重写 /layouts/partials/post/copyright.html 模板。\n首先要和此前展现形式对齐的是「原文链接」。even 主题本身只支持将 Markdown 原文件地址作为文章链接，所以我们需要在该模板中仿照 lionToMarkDown 部分添加以下内容：\n1 2 3 4 5 6 {{ if $.Site.Params.copyrightLink -}} \u0026lt;p class=\u0026quot;copyright-item\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;item-title\u0026quot;\u0026gt;文章链接\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;item-content\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;link-to-markdown\u0026quot; href=\u0026quot;{{ .Permalink }}\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;{{ .Permalink }}\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; {{- end }} 因为暂时没有国际化需要所以文案是固定的中文，如果想更灵活些也可以仿照原实现中的 Markdown link 来做 i18n 。\n随后只要在 copyright.html 的最后引入我们自定义的文末模板即可：\n1 {{- partial \u0026quot;post/post-footer.html\u0026quot; . -}} utterances适配 even 主题本身是支持 utterances 的，但用于生成 issue 的唯一标识参数被主题写死为了 issue-term=\u0026quot;pathname\u0026quot; 即根据 URI 路径生成，并没有暴露配置。而我在使用 Hexo 时该参数的值是 issueTerm=\u0026quot;title\u0026quot; 即根据文章标题生成，不进行适配的话会丢失存量评论。\n所以我们需要在 /layouts/partials/ 目录下新建 comments.html 覆盖主题原实现。顺便地，我们可以把另一个参数 label 也改为可配置的，这样一来，生成的 Github issues 便可以自动加上 utterances 标签方便分类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {{ if and .IsPage (ne .Params.comment false) -}} \u0026lt;!-- utterances --\u0026gt; {{- if .Site.Params.utterances.owner}} \u0026lt;script src=\u0026quot;https://utteranc.es/client.js\u0026quot; repo=\u0026quot;{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}\u0026quot; issue-term=\u0026quot;{{ .Site.Params.utterances.issueTerm }}\u0026quot; label=\u0026quot;{{ .Site.Params.utterances.label }}\u0026quot; theme=\u0026quot;github-light\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026quot;https://github.com/utterance\u0026quot;\u0026gt;comments powered by utterances.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; {{- end }} {{- end }} 随后我们便可以在 config.toml 中对 utterances 按需进行配置：\n1 2 3 4 5 [params.utterances] # https://utteranc.es/ owner = \u0026quot;\u0026quot; # Your GitHub ID repo = \u0026quot;\u0026quot; # The repo to store comments issueTerm = \u0026quot;title\u0026quot; # 新增配置，可按需选择 issue 生成时的唯一标识方式 label = \u0026quot;utterances\u0026quot; # 新增配置，可按需指定 issue label 补齐底部社交图标 主题的社交图标使用的是托管于 iconfont 的私有实现所以直接拓展未支持的新图标较为困难。我在 记hexo-theme-even主题优化 ↗ 一文中提到了相同的问题，文中最终选择了使用 Font Awesome 来解决，对于 Hugo 的 even 主题我们也如法炮制进行处理。\n首先，在 Font Awesome ↗ 官网下载依赖并放置于 /static 目录下。例如我使用的是引入所有图标 JS 的方式，则最终路径为 /static/js/fontawesome.all.min.js 。然后在 config.toml 配置中引入该 JS 文件：\n1 2 [params] customJS = [\u0026quot;fontawesome.all.min.js\u0026quot;] 接着，我们在 /layouts/partials/ 目录下新建 footer.html 覆盖主题原实现并保留原实现的其他代码，只对 social-links 部分进行如下修改：\n| 1 2 3 4 5 6 7 8 9 10 11 12 | \u0026lt;div class=\u0026quot;social-links\u0026quot;\u0026gt; {{- range $name, $config := .Site.Params.social }} {{- if $config.path }} \u0026lt;a href=\u0026quot;{{ $config.path | safeURL }}\u0026quot; class=\u0026quot;iconfont\u0026quot; title=\u0026quot;{{ $name }}\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;{{ $config.icon }}\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; {{- end }} {{- end }} {{ if .Site.LanguagePrefix -}} \u0026lt;a href=\u0026quot;{{ .Site.LanguagePrefix | absURL }}/index.xml\u0026quot; type=\u0026quot;application/rss+xml\u0026quot; class=\u0026quot;iconfont\u0026quot; title=\u0026quot;rss\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fas fa-rss\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; {{- else -}} \u0026lt;a href=\u0026quot;{{ .Site.RSSLink }}\u0026quot; type=\u0026quot;application/rss+xml\u0026quot; class=\u0026quot;iconfont\u0026quot; title=\u0026quot;rss\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fas fa-rss\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/div\u0026gt; | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | | |\n最后在 config.toml 中添加需要的图标配置即可。icon 即图标的完整 class 属性，path 即需要跳转的链接地址。需要注意的是，主题的原逻辑为了实现多语言，将 RSS 图标的逻辑隔离在了通用逻辑之外。这里也保留了原实现，即 RSS 图标是默认出现且不可去除的。如果不需要 RSS 则可以对上面的代码再进行修改，以删除独立的 RSS 逻辑。\n1 2 3 4 5 6 7 [params.social] a-email = { title = \u0026quot;Email\u0026quot;, icon = \u0026quot;fas fa-envelope\u0026quot;, path = \u0026quot;\u0026quot; } b-twitter = { title = \u0026quot;Twitter\u0026quot;, icon = \u0026quot;fab fa-twitter\u0026quot;, path = \u0026quot;\u0026quot; } c-github = { title = \u0026quot;Github\u0026quot;, icon = \u0026quot;fab fa-github\u0026quot;, path = \u0026quot;\u0026quot; } d-weixinOfficialAccount = { title = \u0026quot;微信公众号\u0026quot;, icon = \u0026quot;fab fa-weixin\u0026quot;, path = \u0026quot;\u0026quot; } e-telegram = { title = \u0026quot;Telegram\u0026quot;, icon = \u0026quot;fab fa-telegram\u0026quot;, path = \u0026quot;\u0026quot; } f-search = { title = \u0026quot;Search\u0026quot;, icon = \u0026quot;fas fa-search\u0026quot;, path = \u0026quot;\u0026quot; } 除了 Font Awesome ，最近我还看到了 tabler ICONS ↗ 这个库，直接支持 SVG 同时还是 MIT 协议的开源项目，也值得一试。\n此外，由于我们已经覆盖了 footer 模板，那我们也可以对其他内容也进行自定义，比如将友情链接放置于 footer 等，下文的总字数统计也同样均基于自定义的 footer.html 进行处理。\n支持总字数统计 even 主题自带每篇文章的字数和预计阅读时间统计，但却没有之前我借助 hexo-wordcount ↗ 所实现的全站文章字数统计。检索网络后找到了这么一篇文章 Hugo 总文章数和总字数 ↗ ，照猫画虎在 footer.html 中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 {{ if .Site.Params.countAllWords.enabled }} {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026quot;Kind\u0026quot; \u0026quot;page\u0026quot; )}} {{$scratch.Add \u0026quot;total\u0026quot; .WordCount}} {{ end }} \u0026lt;span style=\u0026quot;display: block;\u0026quot;\u0026gt; {{ .Site.Params.countAllWords.prefix }} {{$scratch.Get \u0026quot;total\u0026quot; }} {{ .Site.Params.countAllWords.suffix }} \u0026lt;/span\u0026gt; {{ end }} 随后在 config.toml 中对相关参数进行配置即可：\n1 2 3 4 [params.countAllWords] enabled = true prefix = \u0026quot;共计\u0026quot; suffix = \u0026quot;字\u0026quot; 除了以上逻辑，还可以通过改变 range 的查询范围来按需限定需要进行总字数统计的页面集合。另外配置中的固定文案比较生硬，可以考虑加入 i18n 相关实现来满足多语言切换的需要。\n总结 天下武功，唯快不破，Hugo 的速度确实让我印象深刻。但对于从 Hexo 迁移而来，同时还对 Hexo 有很多自定义配置的用户来说，迁移过程中的兼容和适配的成本其实是不低的，实际上目前的迁移仍未实现「基于 LeanCloud 的阅读计数」和「推荐阅读」两项功能的兼容。此外，无论是 Hexo 还是 Hugo ，其主题的深度自定义修改都比较麻烦，以后还是要考虑自己实现一套主题（明年一定）。\n文章作者 Eason Yang\n上次更新 2022-08-10\n文章链接 https://easonyang.com/posts/hexo-to-hugo/ ↗ 许可协议 知识共享署名-非商业性使用 4.0 国际许可协议 ↗ 关注本站 Telegram Channel ↗ 获取最新文章推送\n扫码关注微信公众号**「举一得一」**获取最新文章推送\n赞赏支持\nhugo ↗ 把Notion变为个人网站 ↗ 旁路由的原理与配置一文通 ↗ 由 Hugo ↗ 强力驱动 | 主题 - Even ↗ 本站总访问量 72625 次 | 本站总访客数 46411 人\n共计 123042 字 站点地图 ↗ | 友情链接 ↗ © 2012 - 2024Eason Yang\n","date":"2024-12-22","tags":["hugo"],"title":"从 Hexo 迁移至 Hugo","url":"/post/2024/12/my-first-post/"},{"content":"我的博客之前是在云服务器上部署的java服务，现在把博客迁移到了github托管，使用 Hexo ↗ 以及主题 Theme NexT ↗ ， 在源码仓库通过hexo会生成静态html文件，通过github action部署到网站仓库。网站仓库自动部署到 vercel ↗ 作为一个把Hexo、NexT官网的文档看了一个遍的人，我想我可以写一篇文章总结一下。\n名词解释 名词 说明 网址 hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 https://hexo.io/zh-cn/docs/ ↗ Next NexT是Hexo的高品质优雅主题 https://theme-next.js.org/ ↗ vercel Vercel 是一个面向开发人员的平台，它提供了更快地构建和部署 Web 应用程序所需的工具、工作流和基础架构，而无需进行其他配置。Vercel 开箱即用地支持流行的前端框架，其可扩展的安全基础架构遍布全球，可从用户附近的数据中心提供内容，以实现最佳速度。 https://vercel.com/ ↗ github pages github官方的，直接用github仓库生成静态网站。但是速度比较慢，建议使用支持cdn的托管平台，例如vercel https://pages.github.com/ ↗ github actions 亦称为workflows。工作流是将运行一个或多个作业的可配置自动化过程。工作流由签入到存储库的 YAML 文件定义，并在存储库中的事件触发时运行，也可以手动触发或按定义的计划触发。工作流在存储库的 .github/workflows 目录中定义，一个存储库可以有多个工作流，每个工作流可以执行一组不同的任务。例如，您可以有一个工作流来构建和测试拉取请求，另一个工作流在每次创建发布时部署应用程序，还有另一个工作流在每次有人打开新问题时添加标签。 https://docs.github.com/en/actions/using-workflows/about-workflows ↗ 安装并使用hexo 首先安装 nodejs ↗ 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\nnpm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init \u0026lt;folder\u0026gt; cd \u0026lt;folder\u0026gt; npm install 新建完成后，指定文件夹的目录如下：.\n. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml 网站的 配置 ↗ 信息，您可以在此配置大部分的参数。\nsource 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\nthemes 主题 ↗ 文件夹。Hexo 会根据主题来生成静态页面。\n写文章 hexo new \u0026#34;My New Post\u0026#34; hexo new会在source/_posts文件夹中创建一个名为My-New-Post.md的新文件，—和—之间是meta元信息，有标题、创建时间、标签等。在其后使用markdown语法写文章。\n更多信息介绍: Writing ↗ 运行hexo hexo generate hexo server hexo generate会通过源码生成静态Html文件，hexo server会在本地开启服务器，默认url是http://localhost:4000/.\n也可以简写为：\nhexo g hexo s 安装NexT主题 打开终端，切换到 Hexo 站点根目录并安装 NexT 主题\ncd hexo-site npm install hexo-theme-next 启用NexT主题配置文件 NexT官方教程 ↗ 中给出的2个方式都不是太好，有缺陷。官方教程是修改themes/next/_config.yml或者node_modules/hexo-theme-next/_config.yml，这种方式不利于将来升级NexT，最新的最佳实践是创建_config.next.yml文件，和_config.yml同级。这一点可以查看[hexo的官方文档]( Configuration | Hexo ↗ ), 从Hexo 5.0.0版本开始支持。\n创建完_config.next.yml文件后，把_config.yml中theme值改为next即可启用\n# Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next Next主题重要配置 scheme 建议使用Gemini，NexT官方网站就是使用的Gemini\n#scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 开启搜索 安装[搜索插件]( GitHub - next-theme/hexo-generator-searchdb: 🔍 Seach data generator plugin for Hexo. ↗ )\nnpm install hexo-generator-searchdb Hexo config file _config.yml\nsearch: path: search.xml field: post content: true format: html NexT config file _config.next.yml\n# Local search # Dependencies: https://github.com/next-theme/hexo-generator-searchdb local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 开启评论 hexo支持很多评论系统，例如disqus、disqusjs、changyan、livere、gitalk、utterances、isso等，我基本上都测试了一遍。changyan是国产的，有一些特色功能，例如支持评论先审后发；gittalk、utterances等是基于github issues的；giscus是基于github discussions的，支持楼中楼。\n名称 说明 官网 评价 disqus Disqus 是一种美国博客评论托管服务，适用于使用网络平台的网站和在线社区。 https://disqus.com ↗ 官网不开代理打不开 disqusjs 基于Disqus，DisqusJS 提供一个纯前端的、不依赖后端服务器的 Disqus 评论基础模式。 https://disqusjs.skk.moe/ ↗ 同上，不能用 changyan 畅言云评，国内的 https://changyan.kuaizhan.com ↗ 可以用，支持先审后发。但是评论需要登录到畅言云评账号 gitalk 基于github issues https://gitalk.github.io/ ↗ 不推荐，需要的权限太高，配置也太复杂，我搞了一天也没有完全成功。作者也很久不维护了。评论时需要登录github utterances 基于github issues，gitalk的完全替代者。 https://utteranc.es/ ↗ 推荐，可以只给评论的存储仓库开权限，几分钟就成功了，配置简单。评论时需要登录github giscus 基于github discussions，本项目深受 utterances 的启发。 https://giscus.app/zh-CN ↗ 推荐，和utterances很像，没有授权问题，配置简单。基于discussions，支持楼中楼，评论时需要登录github。本博客使用的是giscus评论系统。 valine 基于LeanCloud https://valine.js.org/ ↗ 推荐，无需登录，支持匿名评论 如果要使用giscus，需要先在源代码项目安装[hexo giscus插件]( GitHub - next-theme/hexo-next-giscus: Giscus comment system for NexT ↗ ) :\nnpm install hexo-next-giscus 其次创建一个自己名下用来存储的公开仓库，然后打开 giscus ↗ 填写相关信息，即可自动生成giscus配置。\ngiscus: enable: true repo: #需要修改成自己的公开仓库 repo_id: 需要修改成自己的 category: General category_id: 需要修改成自己的 # Available values: pathname | url | title | og:title mapping: pathname # Available values: 0 | 1 reactions_enabled: 1 # Available values: 0 | 1 emit_metadata: 1 # Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme theme: preferred_color_scheme # Available values: en | zh-CN lang: en # Place the comment box above the comments input_position: top # Load the comments lazily loading: lazy 其他的设置都比较简单，可以自行参考 NexT官方文档 ↗ 。\n开启文章底部分享 _config.next.yml addtoany: enable: true buttons: - facebook - twitter - telegram - wechat - qzone - sina_weibo 开启文章字数计数 详见 hexo+word+counter ↗ 安装\nnpm install hexo-word-counter _config.next.yml配置\n# Post wordcount display settings # Dependencies: https://github.com/next-theme/hexo-word-counter symbols_count_time: separated_meta: true item_text_total: true 标签词云 标签词云的github地址为 hexo-tag-cloud ↗ 安装\nnpm install hexo-tag-cloud _config.next.yml配置\n# hexo-tag-cloud tag_cloud: textFont: Trebuchet MS, Helvetica textColor: \u0026#39;#333\u0026#39; textHeight: 25 outlineColor: \u0026#39;#E2E1D1\u0026#39; maxSpeed: 0.1 处理图片链接 在使用MarkText等软件编辑md文件上传图片时，生成的路径和hexo路径不匹配。可以使用hexo-image-link插件解决。参考： https://github.com/cocowool/hexo-image-link ↗ NexT其他插件 其他还有数学公式支持、基于LeanCloud的网站访客统计等功能，可参考官方教程\nhttps://theme-next.js.org/plugins ↗ https://theme-next.js.org/docs/third-party-services/ ↗ 部署流程 npm install -g hexo-cli 再hexo init之后，会生成一个nodejs项目，hexo new会在source 文件夹中生成新的markdown文件。这个项目有_config.yml、package.json、.gitignore等文件，可以把这个项目称之为“源代码”项目。源代码项目是私有的。\n然后生成的html静态网站，应该搞一个单独的html项目，例如项目名叫chunqiujinjing.github.io。\nhexo new 新文章编辑好之后，就可以把“源代码”项目commit+push到git上面了。最后运行一下hexo g + hexo d可以部署到html项目中。\n其实html项目也可以是私有的，只不过想使用github pages必须命名为chunqiujinjing.github.io并且公有才行。其实就算随便取名字，设置为私有，也可以自己部署到任意地方。\n如果想做到commit+push源代码之后自动部署html项目，可以使用github actions。\ngithub actions 在[hexo的github-pages文档]( GitHub Pages | Hexo ↗ ) 中有一个github actions的示例，但是其中配置的做法并不科学。它把源代码项目和html项目放到了一个仓库中，用不同的分支来区分，然后还部署到了github pages，github pages必须使用公开仓库。这就导致了网站的源代码和html代码都暴露了，你的所有配置将被一览无余：例如leancloud的appkey、giscus的id等等。\n最佳实践是源代码仓库设置为私有，通过hexo deploy（或者由github action自动化）部署到html仓库。html仓库如果使用github pages部署，必须设置为公开，但通过vercel或者其他托管网站部署则可以设置为私有。\n最佳实践 1 修改源代码仓库：\n_config.yml # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: git repo: git@github.com:你的用户名/你的html仓库 branch: main 2 添加github actions\n可以参考 hexo-action ↗ 来设置。\n2.1 设置 Deploy keys 和 Secrets\n2.1.1 运行ssh-keygen -t rsa -C \u0026quot;username@example.com\u0026quot; (替换为你的邮箱) ，会生成一个文件，里面有公钥和私钥。\n2.1.2 在 Github html存储库中：在 Settings \u0026gt; Deploy Keys 添加公钥。\n2.1.3 在 hexo 源代码存储库中：在 Settings \u0026gt; Secrets 菜单中添加私钥。\n2.2 创建github/workflows/deploy.yml 文件，\nname: Deploy on: [push] jobs: build: runs-on: ubuntu-latest name: A job to deploy blog. steps: - name: Checkout uses: actions/checkout@v1 with: submodules: true # Checkout private submodules(themes or something else). # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: ${{ runner.os }}-node-${{ hashFiles(\u0026#39;**/package-lock.json\u0026#39;) }} restore-keys: | ${{ runner.os }}-node- - name: Install Dependencies if: steps.cache.outputs.cache-hit != \u0026#39;true\u0026#39; run: npm ci # Deploy hexo blog website. - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} # user_name: your github username # (or delete this input setting to use bot account) # user_email: your github useremail # (or delete this input setting to use bot account) commit_msg: ${{ github.event.head_commit.message }} # (or delete this input setting to use hexo default settings) # Use the output from the `deploy` step(use for test action) - name: Get the output run: | echo \u0026#34;${{ steps.deploy.outputs.notify }}\u0026#34; 这样设置完之后，在hexo源代码仓库，创建或者修改完文章，只需要git commit、git push，就会自动触发github actions，完成部署代码到html仓库。\n当然也可以不设置github actions，就需要自己手动hexo generate hexo deploy了。\n部署到vercel 打开 vercel官网 ↗ ，注册并登录，关联github账号，新建项目，选择html项目（注意不是源码项目）即可一键部署到vercel。\n绑定域名 vercel分配的域名在大部分地区是被阻断的，可以绑定自己的域名。操作方法可以参考： GitHub - gaboolic/vercel-reverse-proxy ↗ ","date":"2024-12-22","tags":["hexo"],"title":"使用 Hexo+GitHub+Vercel 搭建个人免费博客的最佳实践","url":"/post/2024/12/hexo/"},{"content":" 原文 ↗ #!/bin/bash # 1. 自定义通知消息 # 传参 $1:消息描述 $2:通知标题 $3:通知副标题 function showNoteMessage(){ osascript -e \u0026#34;display notification \\\u0026#34;${1}\\\u0026#34; with title \\\u0026#34;${2}\\\u0026#34; subtitle \\\u0026#34;${3}\\\u0026#34; sound name \\\u0026#34;Funk\\\u0026#34;\u0026#34; } #test case: #showNoteMessage \u0026#34;消息内容\u0026#34; \u0026#34;通知\u0026#34; \u0026#34;通知副标题\u0026#34; # 2. 自定义弹窗(统一通用方法) # 传参$1 弹窗消息内容 # 传参$2 弹窗标题 # 传参$3 按钮标题,多个用英文逗号隔开 # 传参$4 默认选中的按钮标题或者按钮数字下标 # 传参$5 是否为输入框类型 传\u0026#34;0\u0026#34;或者\u0026#34;1\u0026#34; 默认\u0026#34;0\u0026#34; # 传参$6 输入框默认占位内容,传不传无所谓,默认为空字符串 \u0026#34;\u0026#34; # 传参$7 默认图标note/stop/caution 或者自定义文件路径(:格式路径可以通过choose file获取) # tips: 重要! 如果为输入框模式,那么输出结果就是{button returned:button,text returned:text} 否则只有按钮或者false function showCustomAlertMessage(){ if [[ -n \u0026#34;$4\u0026#34; ]]; then if [[ ${4} == *[!0-9]* ]]; then defaultButton=\u0026#34;default button \\\u0026#34;${4}\\\u0026#34;\u0026#34; else defaultButton=\u0026#34;default button ${4}\u0026#34; fi else defaultButton=\u0026#34;\u0026#34; fi #是否为输入框模式 if [[ \u0026#34;$5\u0026#34; = \u0026#34;1\u0026#34; ]]; then IS_InputMode=\u0026#34;default answer \\\u0026#34;${6}\\\u0026#34;\u0026#34; ReturnValue=\u0026#34;get result\u0026#34; else IS_InputMode=\u0026#34;\u0026#34; ReturnValue=\u0026#34;get the button returned of the result\u0026#34; fi if [[ -n \u0026#34;$7\u0026#34; ]]; then case ${7} in note) ICON=\u0026#34;with icon note\u0026#34; ;; stop) ICON=\u0026#34;with icon stop\u0026#34; ;; caution) ICON=\u0026#34;with icon caution\u0026#34; ;; *) ICON=\u0026#34;with icon file \\\u0026#34;${7}\\\u0026#34;\u0026#34; ;; esac else ICON=\u0026#34;with icon file \\\u0026#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\\\u0026#34;\u0026#34; fi osascript \u0026lt;\u0026lt;EOF set buttonStr to \u0026#34;${3}\u0026#34; set oldDelimiters to AppleScript\u0026#39;s text item delimiters set AppleScript\u0026#39;s text item delimiters to \u0026#34;,\u0026#34; set buttonList to every text item of buttonStr set AppleScript\u0026#39;s text item delimiters to oldDelimiters get buttonList set btns to buttonList display dialog \u0026#34;${1}\u0026#34; with title \u0026#34;${2}\u0026#34; buttons btns ${IS_InputMode} ${defaultButton} ${ICON} ${ReturnValue} EOF } # showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮2\u0026#34; \u0026#34;1\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;note\u0026#34; # showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; 2 \u0026#34;0\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;note\u0026#34; #showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮2\u0026#34; \u0026#34;0\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;stop\u0026#34; #showCustomAlertMessage \u0026#34;弹窗消息内容\u0026#34; \u0026#34;弹窗标题\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮2\u0026#34; \u0026#34;0\u0026#34; \u0026#34;占位内容\u0026#34; \u0026#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\u0026#34; # 普通弹窗 一个ok就够了 就是一个确认的那种 function onlyConfirmButton(){ showCustomAlertMessage \u0026#34;$1\u0026#34; \u0026#34;温馨提示\u0026#34; \u0026#34;好的\u0026#34; 1 } #onlyConfirmButton \u0026#34;登录成功!\\n弹窗成功!\u0026#34; # 多按钮弹窗 最多三个按钮 多了会报错 function mostButtons(){ showCustomAlertMessage \u0026#34;$1\u0026#34; \u0026#34;温馨提示\u0026#34; \u0026#34;按钮1,按钮2,按钮3\u0026#34; \u0026#34;按钮3\u0026#34; } #mostButtons \u0026#34;最多只能定义三个按钮哦\u0026#34; # 输入框弹窗 function showInputAlertMessage(){ showCustomAlertMessage \u0026#34;$1\u0026#34; \u0026#34;$2\u0026#34; \u0026#34;取消,确认\u0026#34; 2 \u0026#34;1\u0026#34; \u0026#34;\u0026#34; } showInputAlertMessage \u0026#34;请输入密码\u0026#34; \u0026#34;登录验证\u0026#34; ","date":"2024-11-09","tags":["编程","shell"],"title":"shell mac 教程","url":"/post/2024/11/shell_mac_pop/"},{"content":"参考：\n中州西鹿 ↗ 多图详细教你注册Google（Gmail）新账号，常见问题和注意事项 ↗ 此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法 ↗ 谷歌账号注册的问题 注册 通过google主页或直接访问 Gmail 主页，选择登录，在登录的时候选择“创建账号”，一般选个人用途就可以了。选好了以后点击下一步。耗时3秒\n如果你注册输入手机号提示“此电话号码无法用于进行验证”，那么有这样几种可能的原因：\n你用来访问的网络环境不是很稳定，Google认为有风险。 你用来访问的浏览器是新的，或者是手机浏览器，Google 认为有风险。 你输入的手机号已经被频繁验证 你的 IP 被注册了大量的 Google 账号 （可能）你的 Google 浏览器不是英文的 （可能）是个虚拟平台的号码 多个成功实践证明，只要是国内三大运营商正常使用的手机号，都是可以正常验证、接收验证码的，请不要怀疑这点。\n如果你已经注册成功了，但是要求你做验证，这时不需要使用的注册时使用的手机号，随便使用一个手机号就行，这个手机号最好是新的，并且你的魔法地址和手机号的归属地必须一样。\n[bsmessage type=\u0026ldquo;common\u0026rdquo; color=\u0026ldquo;red\u0026rdquo; title=\u0026ldquo;登录谷歌账号异常提示\u0026rdquo; icon=\u0026ldquo;exclamation\u0026rdquo;]此电话号码已用过太多次，此电话号码无法用于进行验证[/bsmessage]\n前置准备\n接收验证码的平台：https://sms-activate.io/cn/buy2\n“此电话号码已用过太多次” 与 “此电话号码无法用于进行验证” 是如何产生的？ 在注册谷歌时显示此电话号码已用过太多次，表示你之前使用此电话号码注册过谷歌账号。当你再次注册时候，谷歌会启动防止滥用的注册机制。当你更换其它号码后，如果是新的号码。会顺利的注册成功。\n如果依旧提示此电话号码已用过太多次的提示，只能继续尝试新的号码。\n尝试其它号码五次过后，最终会提示此电话号码无法用于进行验证。也就是说即便是真实有效而且没有注册过谷歌的电话号码，也会被提示无法注册，这个问题不出在电话号码上。\n这个时候你需要关闭页面，重新进行账号注册，然后到手机号码验证页面中继续验证。这一步需要注意的是，输入五次号码后，出现此电话号码无法用于进行验证时，再输入多少号码都是这个提示，即便是可以用于验证的号码，这时一定要关闭页面，重新进行注册填写。\n至于一个手机号可以绑定多少个谷歌账号，网上众说纷纭，有说可以绑定5个谷歌账号的，具体可以绑定多少个谷歌账号，自己可以实验一下，2-3个是没问题的。\n如何使用香港号码注册谷歌账号 目前可以使用香港号码进行谷歌账号注册，虽然说国内号码也可以注册谷歌账号，但是不建议使用国内电话号注册谷歌账号，有个人隐私泄露的风险。那么如何使用香港号码注册谷歌账号呢？\n使用 SMS-Activate 国外接码平台，这是一家俄罗斯的接码平台，里面各个国家的号码非常全面。\nSMS-Activate 提供世界上大多数国家的虚拟号码，以便您可以在线接收带有确认代码的短信。 在我们的服务中，还有虚拟号码的长期租赁，转发连接，电话验证等等。使用SMS-Activate的虚拟号码来在线接受短信。可以在 600个多服务注册的一次性号码。短信即刻送到给你\nSMS-Activate官网：https://sms-activate.org\n在SMS-Activate中充值也比较方便，支持比特币充值和国内支付宝充值等等。\n在 SMS-Activate 左侧的接码服务中点击 Google，YouTube，Gmail然后从中选择对应的国家，例如选择香港。\n使用香港号码注册 Google，只需 11.25 卢布。在注册时候，同时购买 5 个号码，接码不成功是可以取消的，号码多，注册成功的机率高一些。\n由于接码的号码每日数量有限，有很多的号码没有办法进行号码验证，在注册时候就会出现此电话号码已用过太多次\n遇到这样的情况，使用 5 个号码依次进行注册，如果无法注册需要先关闭Google账户注册页面，重新填写注册信息后，再更换号码进行验证。\n需要注意的一点，当你打开谷歌注册页面，填写完资料后，到电话验证的步骤，输入号码后，如果直接显示此电话号码无法用于进行验证\n这时候要关闭谷歌浏览器，打开浏览器的无痕模式！打开新的无痕式窗口，在Microsoft Edge浏览器中，无痕模式叫InPrivate 浏览！这个一定要注意。\n关于注册谷歌账号的几点总结 如果你不是大量注册谷歌账号的话，基本上不会触发谷歌账号滥用的限制，或者你之前注册过谷歌账号，但是长期不使用忘记了，你的电话号码已经进入谷歌的号码库，这时再次进行注册也会产生 此电话号码已用过太多次 的错误提示。\n如果在注册过程中，直接报 此电话号码无法用于进行验证 错误，可以关闭浏览器，使用浏览器的无痕模式再继续进行注册，只要报了 此电话号码无法用于进行验证 这个错误，接下来就必须关闭页面，这个错误无法进行下一步注册。\n关于IP地址和银行卡绑定的一点点经验，IP地址无需纷繁更换，同一个IP地址可以注册多个账号，这个不受影响，银行卡在注册谷歌云进行绑定的时候，有时候会造成谷歌云虽然注册成功，但是谷歌云默认关闭状态，不晓得触发了哪些机制，有时候在绑卡过程中还需要验证银行的短信。\n以上就是在注册谷歌账号时遇到问题的解决方法。\n我们检测到您在尝试访问的账号存在异常活动。如要继续，请按以下说明操作。\n请验证您的身份\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1当系统检测到账号异常，这时候也需要提供电话号码验证，同样可以使用接码平台的手机号码进行验证。\n注意：当你使用手机号码验证谷歌账号时，无需使用初始注册的电话号码，只要是可以接收的号码就可以用来验证。\nSMS-Activate官网：https://sms-activate.org\n在SMS-Activate中充值也比较方便，支持比特币充值和国内支付宝充值等等。\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1\n如果遇到 此电话号码已多次用于验证 的提示，重新更换其它号码，一直到可以接收验证码为止。\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1\n如果出现 此电话号码无法用于进行验证 。这种提示的话，需要关闭网页，等几个小时或者几天后，重新登陆进行验证，一般输入电话号码5-6次错误提示 此电话号码已多次用于验证 之后。会提示无法用于进行验证的错误提示。\n此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法-1\n验证码输入之后，验证通过！遇到类似的问题可以使用同样的方法解决。\n","date":"2024-07-17","tags":["运维","技能"],"title":"谷歌账号注册的问题","url":"/post/2024/07/google_account/"},{"content":" 3 * * * * * * * * 4 * * * * * * * * * * * * 非多组输入 #include \u0026lt;stdio.h\u0026gt; //行定位 int main() { int n = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; \u0026#43;\u0026#43;i) { if (i == 0 || i == n - 1) {//首尾行输出一行* for (int j = 0; j \u0026lt; n; \u0026#43;\u0026#43;j) { printf(\u0026#34;* \u0026#34;); } } else { for (int j = 0; j \u0026lt; n; \u0026#43;\u0026#43;j) {//其它行首尾输出* if(j==0 || j == n-1) printf(\u0026#34;* \u0026#34;); else printf(\u0026#34; \u0026#34;); } } printf(\u0026#34;\\n\u0026#34;);//换行 } return 0; } // 3 ---- n // * * * --- 1行每个位置都输出 一共n个 // * * --- 其它行1和n位置输出 一共2个 // * * * --- n行每个位置都输出 一共n个 // 思路： // 使用for 和 if // 判断是不吃首尾行 是则输出一行* 不是则输出首尾* 多组输入 #include \u0026lt;stdio.h\u0026gt; //行和列定位 int main() { int n = 0; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1){//输入的数量为1 for (int i = 0; i \u0026lt; n; \u0026#43;\u0026#43;i) {//控制行 for (int j = 0; j \u0026lt; n; \u0026#43;\u0026#43;j) {//控制列 if(i == 0 || i == n-1 || j == 0 || j == n-1)//第0行，第n-1行，第0列，第n-1列输出 *_,其它位置输出 __ printf(\u0026#34;* \u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } } return 0; } ","date":"2024-06-29","tags":["编程"],"title":"C 语言字符画","url":"/post/2024/06/c_shar/"},{"content":"如何生成 .dll文件 生成dll文件同时会生成lib文件\n在VS开始界面，搜索dll，创建dll动态链接库 创建一个类（右键创建类，会自动包含需要的文件） 以查询目录下的文件为例 创建的文件可以不用管 .cpp文件 输入自己的代码 #include \u0026#34;pch.h\u0026#34; #include \u0026#34;check_repository.h\u0026#34; namespace fs = std::filesystem; int Check::CheckRepository() { std::string folderName = \u0026#34;.Rysigy\u0026#34;; fs::path currentPath = fs::current_path(); fs::path folderPath = currentPath / folderName; if (fs::exists(folderPath) \u0026amp;\u0026amp; fs::is_directory(folderPath)) { std::cout \u0026lt;\u0026lt; \u0026#34;存储库 \u0026#39;.Rysigy\u0026#39; 文件夹存在\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;[错误]\\t存储库 \u0026#39;.Rysigy\u0026#39; 文件夹不存在\\n请在右键菜单中点击 \u0026#39;创建存储库\u0026#39;\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;点击任意按键退出...\u0026#34; \u0026lt;\u0026lt; std::endl; _getch(); return 0; }; .h文件\n#pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;filesystem\u0026gt; #include \u0026lt;conio.h\u0026gt; // 查询当前的目录下是否有.Rysigy class __declspec(dllexport) Check{ public: int CheckRepository();//检查是否有存储库 }; 为了让生成的文件尽量小，可以使用release模式，以及MT运行库MT生成\n","date":"2024-06-29","tags":["编程"],"title":"如何生成 dll 文件","url":"/post/2024/06/dl/"},{"content":"如果你需要删除错误提交到GitHub仓库中的文件，你可以通过以下步骤来创建一个新的提交来撤销之前的更改：\n在本地仓库中删除文件： 首先，在你的本地仓库中删除该文件：\ngit rm --cached \u0026lt;file\u0026gt; 这里 \u0026lt;file\u0026gt; 是你想要从仓库中删除的文件名。--cached 参数意味着仅从Git的跟踪中删除文件，而不删除工作目录中的文件。\n提交这个更改： 然后，提交这个更改到你的本地仓库：\ngit commit -m \u0026#34;Remove mistakenly added file\u0026#34; 推送到远程仓库： 最后，将这个更改推送到GitHub上的远程仓库：\ngit push origin \u0026lt;branch\u0026gt; 其中 \u0026lt;branch\u0026gt; 是你想要推送更改的分支名，比如 main 或 master。\n这样，你就创建了一个新的提交，它撤销了错误提交的文件。这个文件将从GitHub仓库中删除。\n如果你想要完全从仓库的提交历史中删除该文件（而不是仅仅创建一个新的提交来删除它），你可以使用 git filter-branch 或 BFG Repo-Cleaner 等工具来重写历史。但请注意，这些方法会改变仓库的历史，如果你已经推送了原始提交，这可能会给其他协作者带来问题。在这种情况下，最好的做法是联系仓库管理员来帮助解决。\n警告：使用 git filter-branch 或其他历史修改工具应该非常小心，因为它们可能会破坏公共仓库的历史，使得其他人难以与你的仓库同步。在尝试这些高级操作之前，请确保你完全理解它们的后果，并且已经备份了你的仓库。\n","date":"2024-06-19","tags":["编程","git"],"title":"删除错误提交到GitHub仓库中的文件","url":"/post/2024/06/git_delete_file/"},{"content":"软件 https://github.com/tangyoha/telegram_media_downloader/ ↗ 在 elease 里面下载可执行程序 Win https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.3/tdl-v2.2.3-win64.zip ↗ Linux （x86_64) https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-linux-amd64.zip ↗ mac 没有测试 https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-macos.zip ↗ 配置 所有配置都通过 config.yaml 文件传递​​给 Telegram Media Downloader。\n获取您的 API 密钥： 第一步需要您获得有效的 Telegram API 密钥（API id/hash pair）：\n访问 https://my.telegram.org/apps ↗ 并使用您的 Telegram 帐户登录。 填写表格以注册新的 Telegram 应用程序。 完成！ API 密钥由两部分组成：api_id 和api_hash。 获取聊天ID：\n如果你需要下载收藏夹的内容请填me\n1。使用网络电报：\n打开 https://web.telegram.org/?legacy=1#/im ↗ 现在转到聊天/频道，您将看到 URL 类似 https://web.telegram.org/?legacy=1#/im?p=u853521067_2449618633394 这里 853521067 是聊天 ID。 https://web.telegram.org/?legacy=1#/im?p=@somename 这里的 somename 是聊天 ID。 https://web.telegram.org/?legacy=1#/im?p=s1301254321_6925449697188775560 此处取 1301254321 并将 -100 添加到 id =\u0026gt; -1001301254321 的开头。 https://web.telegram.org/?legacy=1#/im?p=c1301254321_6925449697188775560 此处取 1301254321 并将 -100 添加到 id =\u0026gt; -1001301254321 的开头。 2。使用机器人： 1.使用 @username_to_id_bot ↗ 获取chat_id - 几乎所有电报用户：将用户名发送给机器人或将他们的消息转发给机器人 - 任何聊天：发送聊天用户名或复制并发送其加入聊天链接到机器人 - 公共或私人频道：与聊天相同，只需复制并发送给机器人 - 任何电报机器人的 ID\n配置文件 api_hash: your_api_hash api_id: your_api_id bot_token: your_bot_token chat: - chat_id: telegram_chat_id last_read_message_id: 0 download_filter: message_date \u0026gt;= 2022-12-01 00:00:00 and message_date \u0026lt;= 2023-01-17 00:00:00 - chat_id: telegram_chat_id_2 last_read_message_id: 0 # 我们将ids_to_retry移到data.yaml ids_to_retry: [] media_types: - audio - document - photo - video - voice file_formats: audio: - all document: - pdf - epub video: - mp4 save_path: D:\\telegram_media_downloader file_path_prefix: - chat_title - media_datetime disable_syslog: - INFO upload_drive: enable_upload_file: true remote_dir: drive:/telegram before_upload_file_zip: True after_upload_file_delete: True hide_file_name: true file_name_prefix: - message_id - file_name file_name_prefix_split: \u0026#39; - \u0026#39; max_download_task: 5 web_host: 127.0.0.1 web_port: 5000 web_login_secret: 123 api_hash - 你从电报应用程序获得的 api_hash api_id - 您从电报应用程序获得的 api_id bot_token - 你的机器人凭证 chat - 多频道 chat_id - 您要下载媒体的聊天/频道的 ID。你从上述步骤中得到的。 download_filter - 下载过滤器, 查阅 如何使用过滤器 ↗ last_read_message_id -如果这是您第一次阅读频道，请将其设置为“0”，或者如果您已经使用此脚本下载媒体，它将有一些数字，这些数字会在脚本成功执行后自动更新。不要改变它。 chat_id - 您要下载媒体的聊天/频道的 ID。你从上述步骤中得到的。 last_read_message_id - 如果这是您第一次阅读频道，请将其设置为“0”，或者如果您已经使用此脚本下载媒体，它将有一些数字，这些数字会在脚本成功执行后自动更新。不要改变它。 ids_to_retry - 保持原样。下载器脚本使用它来跟踪所有跳过的下载，以便在下次执行脚本时可以下载它。 media_types - 要下载的媒体类型，您可以更新要下载的媒体类型，它可以是一种或任何可用类型。 file_formats - 为支持的媒体类型（“音频”、“文档”和“视频”）下载的文件类型。默认格式为“all”，下载所有文件。 save_path - 你想存储下载文件的根目录 file_path_prefix - 存储文件子文件夹，列表的顺序不定，可以随机组合 chat_title - 聊天频道或者群组标题, 如果找不到标题则为配置文件中的chat_id media_datetime - 资源的发布时间 media_type - 资源类型，类型查阅 media_types disable_syslog - 您可以选择要禁用的日志类型，请参阅 logging._nameToLevel upload_drive - 您可以将文件上传到云盘 enable_upload_file - [必填]启用上传文件，默认为false remote_dir - [必填]你上传的地方 upload_adapter - [必填]上传文件适配器，可以为rclone,aligo。如果为rclone，则支持rclone所有支持上传的服务器，如果为aligo，则支持上传阿里云盘 rclone_path，如果配置upload_adapter为rclone则为必填，rclone的可执行目录，查阅 如何使用rclone ↗ before_upload_file_zip - 上传前压缩文件，默认为false after_upload_file_delete - 上传成功后删除文件，默认为false file_name_prefix - 自定义文件名称,使用和 file_path_prefix 一样 message_id - 消息id file_name - 文件名称（可能为空） caption - 消息的标题（可能为空） file_name_prefix_split - 自定义文件名称分割符号，默认为- max_download_task - 最大任务下载任务个数，默认为5个。 hide_file_name - 是否隐藏web界面文件名称，默认false web_host - web界面地址 web_port - web界面端口 language - 应用语言，默认为英文(EN),可选ZH（中文）,RU,UA web_login_secret - 网页登录密码，如果不配置则访问网页不需要登录 执行 python3 media_downloader.py 所有下载的媒体都将存储在save_path根目录下。 具体位置参考如下：\nfile_path_prefix: - chat_title - media_datetime - media_type 视频下载完整目录为：save_path/chat_title/media_datetime/media_type。 列表的顺序不定，可以随机组合。 如果配置为空，则所有文件保存在save_path下。\n代理 该项目目前支持 socks4、socks5、http 代理。要使用它，请将以下内容添加到config.yaml文件的底部\nproxy: scheme: socks5 hostname: 127.0.0.1 port: 1234 username: 你的用户名（无则删除该行） password: 你的密码（无则删除该行） 如果您的代理不需要授权，您可以省略用户名和密码。然后代理将自动启用。\n","date":"2024-05-29","tags":["运维"],"title":"TG 下载器","url":"/post/2024/05/download_telegram/"},{"content":"作者： 阮一峰 ↗ 日期： 2018年1月21日 ↗ 学习编程其实就是学高级语言，即那些为人类设计的计算机语言。\n但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。\n计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。\n汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。\n一、汇编语言是什么？ 我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。\n这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。 编译器 ↗ 的作用，就是将高级语言写好的程序，翻译成一条条操作码。\n对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。\n汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。\n二、来历 最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。\n为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。\n这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。\n每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。\n三、寄存器 学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。\n先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。\n但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。\n寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。\n四、寄存器的种类 早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。\nEAX EBX ECX EDX EDI ESI EBP ESP 上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。\n我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。\n五、内存模型：Heap 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。\n程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。\n程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。\n这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。\n六、内存模型：Stack 除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。\n请看下面的例子。\nint main() { int a = 2; int b = 3; } 上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。\n如果函数内部调用了其他函数，会发生什么情况？\nint main() { int a = 2; int b = 3; return add_a_and_b(a, b); } 上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。\n等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。\n所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做\u0026quot;入栈\u0026quot;，英文是 push；栈的回收叫做\u0026quot;出栈\u0026quot;，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做\u0026quot;后进先出\u0026quot;的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。\nStack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。\n七、CPU 指令 7.1 一个实例 了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。\nint add_a_and_b(int a, int b) { return a \u0026#43; b; } int main() { return add_a_and_b(2, 3); } gcc 将这个程序转成汇编语言。\n$ gcc -S example.c 上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。\nexample.s经过简化以后，大概是下面的样子。\n_add_a_and_b: push %ebx mov %eax, [%esp\u0026#43;8] mov %ebx, [%esp\u0026#43;12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。\n每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。\npush %ebx 这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。\n下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。\n7.2 push 指令 根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。\n然后，开始执行第一行代码。\npush 3 push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。\n虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。\npush 2 第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。\n7.3 call 指令 第三行的call指令用来调用函数。\ncall _add_a_and_b 上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。\n下面就开始执行_add_a_and_b的代码。\npush %ebx 这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。\n这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。\n7.4 mov 指令 mov指令用于将一个值写入某个寄存器。\nmov %eax, [%esp\u0026#43;8] 这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。\n下一行代码也是干同样的事情。\nmov %ebx, [%esp\u0026#43;12] 上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。\n7.5 add 指令 add指令用于将两个运算子相加，并将结果写入第一个运算子。\nadd %eax, %ebx 上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。\n7.6 pop 指令 pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。\npop %ebx 上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。\n注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。\n7.7 ret 指令 ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。\nret 可以看到，该指令没有运算子。\n随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。\nadd %esp, 8 上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。\nret 最后，main函数运行结束，ret指令退出程序执行。\n原文地址 ↗ ","date":"2024-05-02","tags":["编程","x86"],"title":"x86 教程","url":"/post/2024/05/x86/"},{"content":" 在idea中分号并不是必须加的, 在执行多条语句才必须加, 在控制台使用的时候必须加 数据库相关的操作 查询数据库\tSHOW DATABASES\n创建数据库 CREATE DATABASE 数据库名 CREATE DATABASE mydatabase\n查看数据库信息 SHOW CREATE DATABASE 数据库名 SHOW CREATE DATABASE database\n删除数据库 DROP DATABASE 数据库名 DROP DATABASE mydatabase\n使用数据库 USE 数据库名 USE mydatabase\nDDL语句\t数据定义语言 创建表\nCREATE TABLE 表名( 列名1 类型[长度] [DEFAULT 默认值] [约束条件] 列名2 类型 …… ); CREATE TABLE userinfo( id INT username VARCHAR(32) password VARCHAR(32) nickname VARCHAR(32) age INT(3) ); 查看当前数据库创建的所有表 SHOW TABLES;\n查看表的详细信息 SHOW CREATE TABLE 表名 SHOW CREATE TABLE table;\n查看表结构 DESC 表名 DESC table;\n删除表 DROP TABLE 表名 DROP TABLE table;\n修改表名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE old_table TO new_table;\n修改表结构 ALTER TABLE\n添加列 ALTER TABLE 表名 ADD 列名 类型[长度] ALTER TABLE hero ADD age INT(3)\n在表中插入一个字段 ALTER TABLE 表名 ADD 列名 类型[长度] AFTER 字段名 ALTER TABLE table ADD col VARCHAR(32) AFTER name\n删除表中现有的列 ALTER TABLE 表名 DROP 列名 ALTER TABLE table DROP col\n修改表中现有的列 ALTER TABLE 表名 CHANGE 原字段名 新字段名 新类型 ALTER TABLE table CHANGE old_name new_old VARCHAR(10)\nDML语句（数据操作语言，对表中数据进行操作的语言）（增、删、改操作） PreparedStatement\n插入数据 INSERT INTO 表名[(字段1,字段2...)] VALUES(字段1的值,字段2的值...) INSERT INTO person(name,age) VALUES('张三',22)\n查看表中的所有数据 SELECT * FROM 表名 SELECT * FROM person\n修改表数据 UPDATE 表名 SET 字段名1=心值1[字段2=新值2...][WHERE 过滤条件] UPDATE person SET age=23 WHERE name='李四'\n删除数据 DELETE FROM 表名[WHERE 过滤条件] DELETE FROM person WHERE name='李老四'\nDQL语句\t数据查询语句\tPreparedStatement 使用数据库 USE 数据库名 USE mydb\n查询数据库 SHOW DATABASE\n创建数据库 CREATE DATABASE 数据库名 SHOW DATABASE mydb\n查询表的部分所有字段 SELECT 字段名1[字段名2，字段名3，... 或 *] FROM 表名 SELECT * FROM user\n查看emp表的特定的字段 SELECT name,job FROM emp\nWHERE字句（添加过滤条件，查询满足条件的） SELECT name,job,sal FROM emp WHERE sal\u0026gt;1000; 连接多个条件 AND、OR 值在列表中 IN(列表)\tIN(emp) 区间 BETWWEEN 2000 AND 3000\t去重 SELECT DISTINCT SELECT DISTINCT job FROM emp\n多列去重 - 去除指定列中有重复的行 SELECT DISTINCT job,dept_id FROM emp\n模糊查询 - LIKE （两个通配符：_表示一个字符，和%表示任意个字符） WHERE name LIKE '%name%'\n总结:\n%X%:字符串中包含\u0026rsquo;X' %X:字符串以X结尾 X%:字符串以X开头 _X%:字符串第二个字符是X %X_:倒数第二个字符是X X%Y:字符串以X开头Y结尾 X_Y:字符串只有三个字，第一个是X，第三个是Y 根据指定的字段排序查询结果集 （该子句只能放在查询语句的最后一个子句上），默认升序，DESC降序 ORDER BY 字段\tORDER BY sal DESC\n多字段查询 ORDER BY 字段1,字段2,... ORDER BY sal,dept_id DESC\n分页查询 LIMIT 跳过的记录数（（页数-1）* 每页的记录数），，每页显示的记录数\t查询的字段可以使用表达式\tSELECT SELECT name,sal,sal*12 FROM emp; 查询时可使用函数的结果作为字段 SELECT CONCAT(name,'的职位是',job) FROM emp;\n数据库相关的操作 查询数据库： SHOW DATABASES;\n创建数据库： CREATE DATABASE 数据库名; CREATE DATABASE mydb;\n数据库创建时可以指定字符集： CREATE DATABASE 数据库名字 CHARSET=UTF8/GBK (字符集); CREATE DATABASE db1 CHARSET=UTF8;\n创建数据库db1(字符集用gbk) db2(字符集UTF8); CREATE DATABASE db1 CHARSET=UTF8; CREATE DATABASE db2 CHARSET=GBK;\n查看数据库信息 SHOW CREATE DATABASE 数据库名; SHOW CREATE DATABASE db1;\n删除数据库 DROP DATABASE 数据库名 DROP DATABASE db2;\n使用数据库 USE 数据库名字 USE mydb;\n表相关的操作 （列：字段，是一组数据中各属性信息） （行：记录，一条记录保存一组数据）\nDDL语句 （数据定义语言：用来操作数据库对象的）（数据库对象：表、视图、索引都属于数据库对象）\n创建表\nCREATE TABLE 表名( 列名1 类型[(长度)] [DEFAULT 默认值] [约束条件], 列名2 类型... )[CHARSET=UTF8/GBK] CREATE TABLE userinfo( id INT, username VARCHAR(32), password VARCHAR(32), nickname VARCHAR(32), age INT(3) ); 数字的长度表示位数，VACHAR的长度表示最多占用的字节数\n插入数据 INSERT INTO 表名[(字段1,字段2...)] VALUES (字段1的值,字段2的值...)\nINSERT INTO person(name,age) VALUES ('张三',22); INSERT INTO person(age,name) VALUES (27,'赵六'); # 对应即可\n未指定的列插入都是列的默认值，当创建表时没有为列声明特定的默认值时，列的默认值为null\nINSERT INTO person(name) VALUES ('李四');\n字段名可以忽略不写，此时为全列插入，即：VALUES需要指定每一列的值，且顺序、个数、类型必须与表相同\nINSERT INTO person VALUES ('王五',24);\n查看person表中的所有数据\nSELECT * FROM person;\n修改表数据操作: UPDATE语句\nUPDATE 表名 STE 字段名1=新值1[字段2=新值2...][WHERE 过滤条件]\nUPDATE person SET age=23 WHERE name='李四';\nWHERE 中常用的条件: =,\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;不等于（!= 不是所有数据库都支持）\nUPDATE person SET age=25 WHERE age\u0026gt;50;\nUPDATE person SET age=age+1 ;\nUPDATE person SET name='李老四',age=55 WHERE age=24;\n通常修改语句要添加WHERE子句，用于添加过滤条件来定位要修改的记录，不添加WHERE子句则是全表所有记录都修改\nUPDATE person SET age=55;\n删除数据 DELETE FROM 表名 [WHERE 过滤条件]\n注意！！！不添加WHERE条件则是全发表删除！！！\nDELETE FROM person WHERE name='李老四';\nUPDATE person SET age=20 WHERE name='张三'; DELETE FROM person WHERE age\u0026gt;25; #删除年龄大于25岁的人\nCREATE DATABASE day1db CHARSET=UTF8; USE day1db; CREATE TABLE t_hero( name VARCHAR(32) )CHARSET UTF8; RENAME TABLE t_hero TO hero; ALTER TABLE hero ADD money INT(10); ALTER TABLE hero ADD id INT FIRST; ALTER TABLE hero ADD age INT(3) AFTER name; INSERT INTO hero(name,age,money) VALUES (\u0026#39;李白\u0026#39;,22,6888); INSERT INTO hero(name,age,money) VALUES (\u0026#39;赵云\u0026#39;,30,13888); INSERT INTO hero(name,age,money) VALUES (\u0026#39;刘备\u0026#39;,25,6888); SELECT name FROM hero WHERE money=6888; SELECT * FROM hero; UPDATE hero SET age=52 WHERE name=\u0026#39;刘备\u0026#39;; UPDATE hero SET money=5000 WHERE age\u0026lt;50; DELETE FROM hero WHERE money=5000; DROP TABLE hero; DROP DATABASE day1db; USE empdb; SELECT * FROM emp; USE mydb; 数据类型 数字类型 整数: INT(m)和BIGINT(m) m表示的是长度 例如:m=5,存数字18,实际存储00018 浮点数:DOUBLE(m,n) m表示整体数字长度,n表示小数位 例如:DOUBLE(5,3) 99.999 （实际插入数据时，当精度超过可保存范围时，会四舍五入） 字符类型 CHAR(n):定长字符串，每条记录实际占用的字节空间是定长的，不足的部分补充空字符来满足长度要求 优点:查询速度快 缺点:浪费磁盘空间 VARCHAR(n):变长字符串，最多存n指定的字节数对应的字符，实际保存时，用多少占多少 （推荐） 优点:节省磁盘空间 缺点:查询速度慢 TEXT(n):可变长字符串，最大65535 日期时间类型\nDATE:保存年月日 TIME:保存十分秒 DATETIME:保存年月日时分秒 TIMESTAMP:时间戳，记录UTC时间，从1970-01-01 00:00:00到表示的时间之间经过的毫秒 DROP TABLE userinfo; CREATE TABLE userinfo( id INT, name VARCHAR(30), birth DATETIME, salary DOUBLE(7,2) )CHARSET UTF8; set names UTF8; INSERT INTO userinfo VALUES (1,\u0026#39;张三\u0026#39;,\u0026#39;1992-08-02 11:22:05\u0026#39;,5000.59); INSERT INTO userinfo VALUES (2,\u0026#39;李四\u0026#39;,\u0026#39;1999-05-16\u0026#39;,6500.23); INSERT INTO userinfo VALUES (3,\u0026#39;王五\u0026#39;,\u0026#39;06:12:45\u0026#39;,9700.342); DELETE FROM userinfo; SELECT * FROM userinfo; DELETE FROM userinfo WHERE name=\u0026#39;王五\u0026#39;; 约束:约束是为表中某个字段添加特定的限制条件，只有符合条件的记录才可以保存 主键约束:该字段非空且唯一，用该字段的值唯一表示一条记录 非空约束:该字段的值不允许为空 外键约束:实际开发中几乎不用\nCREATE TABLE student( id INT AUTO_INCREMENT PRIMARY KEY ,# AUTO_INCREMENT 自增 name VARCHAR(30) NOT NULL , age INT(3), gender CHAR(1) ); DESC student; SELECT * FROM student; INSERT INTO student VALUES (NULL,NULL,55,\u0026#39;m\u0026#39;); INSERT INTO student VALUES (NULL,\u0026#39;刘桑\u0026#39;,55,\u0026#39;m\u0026#39;); INSERT INTO student(name,age,gender) VALUES (\u0026#39;克晶\u0026#39;,18,\u0026#39;f\u0026#39;); 不允许\nINSERT INTO student(age,gender) VALUES (18,\u0026#39;f\u0026#39;); INSERT INTO student(name,age,gender) VALUES (\u0026#39;传奇\u0026#39;,22,NULL); INSERT INTO student(name,age) VALUES (\u0026#39;国斌\u0026#39;,33); DELETE FROM student WHERE id=3; CREATE TABLE teacher( id INT PRIMARY KEY , name VARCHAR(30) NOT NULL, age INT(3), gender CHAR(1) ); INSERT INTO teacher VALUES (1,\u0026#39;张三\u0026#39;,22,\u0026#39;F\u0026#39;); INSERT INTO teacher VALUES (1,\u0026#39;李四\u0026#39;,23,\u0026#39;M\u0026#39;);# 不可重复 INSERT INTO teacher VALUES (NULL,\u0026#39;李四\u0026#39;,23,\u0026#39;M\u0026#39;); SELECT * FROM teacher; NULL 要作为条件，要使用IS NULL 或 IS NOT NULL SELECT * FROM student WHERE gender IS NULL; SELECT * FROM student WHERE gender IS NOT NULL; DQL语句 数据查询语句 基本语法: SELECT 字段名1[字段名2，字段名2，...或 * ] FROM 表名\nUSE empdb;\n查看emp表的所有字段\nSELECT * FROM emp; 查看特定的字段 SELECT name,job,hiredate FROM emp;\nWHERE子句，用来添加过滤条件，此时可以仅将满足条件的记录查询出来 比较运算符:=,\u0026lt;,\u0026gt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;\n查看工资大于1000的员工的名字，职位，工资\nSELECT name,job,sal FROM emp WHERE sal\u0026gt;1000; SELECT name,job,sal FROM emp WHERE job\u0026lt;\u0026gt;\u0026#39;人事\u0026#39;; SELECT name,job,sal,dept_id FROM emp WHERE dept_id=2; 使用AND和OR来连接多个条件 SELECT name,sal,job,dept_id FROM emp WHERE dept_id=2 AND sal\u0026gt;1000; SELECT name,sal,job,dept_id FROM emp WHERE job=\u0026#39;人事\u0026#39; OR job=\u0026#39;销售\u0026#39;; SELECT name,sal,job FROM emp WHERE job=\u0026#39;人事\u0026#39; OR sal\u0026gt;1000 AND job=\u0026#39;销售\u0026#39;; SELECT name,sal,job FROM emp WHERE (job=\u0026#39;人事\u0026#39; OR job=\u0026#39;销售\u0026#39;) AND sal\u0026gt;1000; # and优先级大于or,可以通过（）提高优先级 IN(列表) 值在列表中（等于列表中的其中之一） SELECT name,sal,job,dept_id FROM emp WHERE job IN (\u0026#39;人事\u0026#39;,\u0026#39;销售\u0026#39;); SELECT name,sal,job,dept_id FROM emp WHERE job NOT IN (\u0026#39;人事\u0026#39;,\u0026#39;销售\u0026#39;); 区间 SELECT name,sal,job FROM emp WHERE sal BETWEEN 2000 AND 3000; 去重 SELECT DISTINCT job FROM emp; 多列去重时，就是去除指定这些列的值的组合有重复的行\nSELECT DISTINCT job,dept_id FROM emp; SELECT * FROM emp WHERE dept_id=2 AND sal\u0026gt;1000; SELECT name,job,sal,dept_id FROM emp WHERE dept_id=3 OR sal=5000; SELECT name,job,sal,dept_id FROM emp WHERE sal BETWEEN 1000 AND 2000; SELECT name,sal,job,dept_id FROM emp WHERE sal NOT IN (2000,5000); SELECT DISTINCT job FROM emp WHERE dept_id=1; 模糊查询: LIKE LIKE 中两个通配符:_和% %:表示任意的一个字符(0-多个) _:表示一个字符 SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;孙%\u0026#39;; SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;%悟%\u0026#39;; SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;__精\u0026#39;; SELECT name,sal,job FROM emp WHERE name LIKE \u0026#39;_骨%\u0026#39;; 总结:\n%X%:字符串中包含\u0026rsquo;X' %X:字符串以X结尾 X%:字符串以X开头 _X%:字符串第二个字符是X %X:倒数第二个字符是X X%Y:字符串以X开头Y结尾 X_Y:字符串只有三个字，第一个是X，第三个是Y SELECT name FROM emp WHERE name LIKE \u0026#39;猪%\u0026#39;; SELECT * FROM emp WHERE name LIKE \u0026#39;%僧%\u0026#39;; SELECT name FROM emp WHERE name LIKE \u0026#39;%精\u0026#39;; SELECT * FROM emp WHERE job LIKE \u0026#39;%销售%\u0026#39; AND sal\u0026gt;1500; SELECT name,job FROM emp WHERE job LIKE \u0026#39;_售%\u0026#39;; SELECT * FROM emp WHERE dept_id IN (1,2) AND job LIKE \u0026#39;市%\u0026#39;; ORDER BY 子句，根据指定的字段排序查询结果集，该子句只能放在查询语句的最后一个子句上 默认升序 DESC降序\nSELECT name,sal FROM emp ORDER BY sal; SELECT name,hiredate FROM emp ORDER BY hiredate; SELECT name,sal FROM emp ORDER BY sal DESC; 按照多字段排序，在前的优先，可以单独设置升序和降序\nSELECT name,dept_id,sal FROM emp ORDER BY dept_id,sal DESC; SELECT * FROM emp WHERE manager IS NOT NULL ORDER BY hiredate; SELECT * FROM emp WHERE dept_id=1 AND name LIKE \u0026#39;%八%\u0026#39;; SELECT * FROM emp WHERE dept_id IN (2,3) AND sal\u0026lt;5000; SELECT name,sal,job FROM emp WHERE job IN (\u0026#39;人事\u0026#39;,\u0026#39;程序员\u0026#39;) AND sal\u0026gt;2500; SELECT name,job,sal FROM emp WHERE job NOT IN (\u0026#39;CEO\u0026#39;) AND sal\u0026gt;2000 ORDER BY sal DESC ; 分页查询 将满足查询条件的数据分段分批查询出来。这可以减少不必要的系统开销。\nLIMITE 跳过的记录数，显示的记录数\nLIMITE (页数-1)*美页显示的记录数，每页显示的记录数\nSELECT name,sal FROM emp ORDER BY sal LIMIT 3,3; 查询的字段可以使用表达式 SELECT name,sal,sal*12 FROM emp;\n查询时也可以使用函数的结果作为字段 SELECT CONCAT(name,'的职位是',job) FROM emp;\nSELECT CONCAT(name,'的奖金是',comm) FROM emp;\n数字与NULL运算，结果就是NULL\nSELECT sal,comm,sal+comm FROM emp;\nNVL函数 用来替换NULL值\nNVL(arg1,arg2) 当arg1不为NULL时，则函数返回arg1的值，如果arg1为NULL在返回arg2的值\nSELECT name,sal,NVL(comm,0) FROM emp;\n别名（字段和表） 为字段定义别名:\n1.隐藏实际表字段名\n2.为计算表达式或函数的结果值作为字段时定义可读性更好的字段名\nSELECT name ename,sal salary FROM emp; SELECT name,sal*12 salary FROM emp;\n支持的语法 字段名 别名\nSELECT name,sal*12 salary FROM emp;\n字段名 as 别名 SELECT name,sal*12 as salary FROM emp;\n字段名 as \u0026lsquo;别名\u0026rsquo; SELECT name,sal*12 as 'salary' FROM emp;\n字段名 as \u0026ldquo;别名\u0026rdquo; SELECT name,sal*12 as \u0026quot;salary\u0026quot; FROM emp;\nSELECT * FROM emp WHERE dept_id=3 AND sal\u0026gt;1500; SELECT * FROM emp WHERE dept_id=2 OR manager IS NULL; SELECT name,sal FROM emp WHERE manager IS NOT NULL ORDER BY sal; SELECT name,hiredate FROM emp WHERE dept_id IN (2,3) ORDER BY hiredate DESC ; SELECT name FROM emp WHERE name LIKE \u0026#39;%僧%\u0026#39; OR name LIKE \u0026#39;%精%\u0026#39;; SELECT DISTINCT job FROM emp WHERE sal\u0026gt;2000; SELECT sal FROM emp ORDER BY sal LIMIT 6,2; 聚合函数（多行函数）: 用来将多条记录统计为一条记录 (忽略NULL值)\nMIN():求最小值\nMAX():求最大值\nCOUNT():统计记录数\nAVG():求平均值\nSUM():求和\nSELECT MIN(sal) 最低工资,MAX(sal) 最高工资,AVG(sal) 平均工资,SUM(sal) 工资总和 FROM emp; SELECT AVG(sal) FROM emp WHERE job=\u0026#39;销售\u0026#39;; SELECT MAX(sal) FROM emp WHERE job=\u0026#39;程序员\u0026#39;; SELECT COUNT(*) FROM emp WHERE name LIKE \u0026#39;%精%\u0026#39;; SELECT SUM(sal) FROM emp WHERE job LIKE \u0026#39;%销售%\u0026#39;; SELECT MAX(sal) 最高工资, MIN(sal) 最低工资 FROM emp WHERE dept_id=2; GROUP BY子句，分组 GROUP BY 也是为统计服务的，所以是搭配在聚合函数上使用的\nSELECT子句中不在聚合函数中的其他字段必须出现GROUP BY子句中\nSELECT AVG(sal),dept_id FROM emp GROUP BY dept_id; SELECT MAX(sal),job FROM emp GROUP BY job; SELECT MAX(sal),dept_id FROM emp GROUP BY dept_id; #查询最高工资 SELECT COUNT(*) FROM emp WHERE sal\u0026gt;2000 GROUP BY dept_id; SELECT MIN(sal),job FROM emp GROUP BY job; SELECT COUNT(*),dept_id FROM emp WHERE dept_id IN (1,2) GROUP BY dept_id; SELECT AVG(sal) avg,dept_id FROM emp GROUP BY dept_id ORDER BY avg DESC LIMIT 0,1; 聚合函数不能写在WHERE子句中\nSELECT AVG(sal) avg,dept_id FROM emp WHERE AVG(sal)\u0026gt;2000 ORDER BY dept_id; HAVING子句 HAVING子句是跟在GROUP BY子句之后，对分组统计出的结果再进行过滤的\nSELECT AVG(sal),dept_id FROM emp GROUP BY dept_id HAVING AVG(sal)\u0026gt;2000; SELECT AVG(sal),dept_id FROM emp GROUP BY dept_id HAVING MIN(sal)\u0026gt;1000; SELECT SUM(sal) sal,dept_id FROM emp WHERE manager IS NOT NULL GROUP BY dept_id HAVING SUM(sal)\u0026gt;5400; 嵌套在其他SQl语句中的查询语句被称作“子查询” SELECT name,sal FROM emp HAVING sal\u0026gt; (SELECT AVG(sal) FROM emp); SELECT * FROM emp HAVING sal\u0026gt; (SELECT AVG(sal) FROM emp WHERE dept_id=2); SELECT * FROM emp HAVING sal\u0026lt;(SELECT sal FROM emp WHERE name=\u0026#39;沙僧\u0026#39;); SELECT * FROM emp HAVING job=(SELECT job FROM emp WHERE name=\u0026#39;孙悟空\u0026#39;); SELECT * FROM emp HAVING dept_id=(SELECT dept_id FROM emp WHERE sal=(SELECT MIN(sal) FROM emp)); SELECT * FROM emp WHERE sal\u0026gt;ALL(SELECT sal FROM emp WHERE dept_id IN (2,3)); SELECT * FROM emp WHERE sal\u0026gt;ANY(SELECT sal FROM emp WHERE dept_id IN (2,3)); 子查询分类（按查询结果集分类）: 单行单列查询（结果集只有一个值） 多行单列子查询（结果集有多个值） 多行多列子查询（结果集是一个表）\n单行单列查询通常在过滤条件中使用 单行单列可以配合\u0026gt;,\u0026gt;=,=,\u0026lt;,\u0026lt;=使用 多行单列可以配合ANY,ALL,IN使用 例如:\nALL(子查询) \u0026lt;ALL(子查询) ANY(子查询) \u0026lt;ANY(子查询)： IN(子查询)：等于子查询结果集中的任意一个值\n多行多列子查询（结果通常是一个表），通常就当做一个表，可以跟在FROM子句中，或者跟在DDl语句中，可以基于一个查询结果集创建表。\nCREATE TABLE emp_dept1 AS SELECT * FROM emp WHERE dept_id=1; SELECT * FROM emp_dept1; 如果创建表基于的子查询某个字段是一个表达式或函数时，要给该字段取别名，那么创建出来的表该字段会以别名作为字段名 CREATE TABLE emp_dept_sal AS SELECT MAX(sal) max_sal,MIN(sal) min_sal,AVG(sal) avg_sal, SUM(sal) sum_sal,dept_id FROM emp GROUP BY dept_id; SELECT * FROM emp_dept_sal; DROP TABLE emp_annual_salary; CREATE TABLE emp_annual_salary AS SELECT name aneme,sal salary,sal\u0026#43;12 a_salary,dept_id FROM emp; SELECT * FROM emp_annual_salary; SELECT aneme,a_salary FROM emp_annual_salary WHERE aneme LIKE \u0026#39;%精%\u0026#39;; SELECT * FROM dept; 关联查询 查询结果集中的数据来自多张表，而表中的数据之间的对应关系就是关联关系\n两张表就可以产生关联关系了，关联关系分为三类: 1:一对一 A表中的1条记录只唯一对应B表中的1条记录 2:一对多 A表中的1条记录可以对应B表中的多条记录 3:多对多 A表与B表双向都是一对多时，就是多对多关系。\n关联查询就是基于多张表联合查询数据而形成一个结果集的过程，在关联查询中一个至关重要的点就是关联条件 原则:N张表关联查询至少要有N-1个连接条件。 缺失连接条件会产生笛卡尔积，该查询结果集的记录数是关联表中所有记录数乘积的结果，它通常是一个无意义的结果集，要 尽量避免产生\n关联查询语法:\nSELECT 字段\nFROM 表A，表B[，表C，表D\u0026hellip;]\nWHERE 过滤条件\nAND 连接条件\n注意:连接条件必须与过滤条件同时成立!!\nSELECT * FROM emp,dept; 当表中的字段名相同时，我们可以通过给表取别名用\u0026#34;别名.字段名\u0026#34; SELECT e.name,e.sal,e.dept_id,d.name,d.loc FROM emp e,dept d WHERE e.dept_id=d.id; SELECT e.name,e.sal,e.job,d.name,d.loc FROM emp e,dept d WHERE e.dept_id=d.id AND d.loc=\u0026#39;天庭\u0026#39;; SELECT e.name,d.loc FROM emp e,dept d WHERE e.dept_id=d.id AND e.name LIKE \u0026#39;%飞%\u0026#39;; SELECT e.name,MAX(e.sal) max_sal,d.loc FROM emp e ,dept d WHERE e.dept_id=d.id AND d.loc=\u0026#39;天庭\u0026#39; GROUP BY d.loc; SELECT AVG(e.sal),d.loc FROM emp e ,dept d WHERE e.dept_id=d.id GROUP BY d.loc; SELECT sal,name FROM emp WHERE sal\u0026gt;3000; 内连接JOIN子句\nSELECT 字段\nFROM A表 a\nJOIN B表\nON a.xx=b.xx(连接条件)\nJOIN C表 c\nON c.xxx=b.xxx或c.xxx=a.xxx;\nJOIN\u0026hellip;ON\u0026hellip;\nSELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e JOIN dept d on e.dept_id=d.id; 在内连接中，过滤条件还是写在WHERE子句中 SELECT e.*,d.loc FROM emp e JOIN dept d ON e.dept_id = d.id WHERE e.sal\u0026gt;1300; 在关联查询中不满足连接条件的记录会被排除在外 SELECT * FROM emp; INSERT INTO emp(name,dept_id) VALUES (\u0026#39;灭霸\u0026#39;,5); SELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e JOIN dept d ON e.dept_id = d.id 如果需要在结果集中列出不满足连接条件的记录时我们需要使用外连接 外连接: 左外连接: 以LEFT JOIN左侧表为主表，其中的记录都要展示，不满足连接条件时来自左侧记录的字段值全部为NULL 右外连接: 以RIGHT JOIN右侧表为主表，其中的记录都要展示，不满足连接条件时来自左侧记录的字段值全部为NULL\nSELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e LEFT JOIN dept d #此为主表，展示所有，不满足的为NULL ON e.dept_id = d.id; SELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM dept d RIGHT JOIN emp e ON d.id = e.dept_id 全连接效果，结果集包含满足连接条件的左连接和有连接的所有数据\nSELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e LEFT JOIN dept d #此为主表，展示所有，不满足的为NULL ON e.dept_id = d.id; UNION SELECT e.name,e.job,e.manager,e.sal,d.name,d.loc FROM emp e RIGHT JOIN dept d ON d.id = e.dept_id; SELECT e.*,d.* FROM emp e JOIN dept d on d.id = e.dept_id WHERE sal\u0026gt;(SELECT AVG(sal) FROM emp WHERE e.dept_id); 查看比本部门平均工资高的员工工资 1.查看每个部门的平均工资\navg_sal SELECT AVG(sal) avg_sal,dept_id FROM emp GROUP BY dept_id; 2.将子查询结果当做表进行关联\nSELECT e.name,e.sal,e.dept_id,a.avg_sal FROM emp e,(SELECT AVG(sal) avg_sal,dept_id FROM emp GROUP BY dept_id) a WHERE e.dept_id=a.dept_id AND e.sal\u0026gt;a.avg_sal; SELECT * FROM dept d,emp e WHERE d.id=e.dept_id; 1.查看每个地区的平均工资\nSELECT AVG(e.sal) avg_sal,d.loc FROM emp e JOIN dept d ON d.id = e.dept_id GROUP BY d.loc; SELECT e.name,e.sal,e.dept_id,a.avg_sal,d.loc,d.id FROM emp e, (SELECT AVG(e.sal) avg_sal,d.loc FROM emp e JOIN dept d ON d.id = e.dept_id GROUP BY d.loc) a,dept d WHERE a.loc=d.loc AND d.id=e.dept_id AND e.sal\u0026gt;a.avg_sal; 1.查看每个员工的工资及其所在的地区\nSELECT e.sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id; 2.每个地区平均工资（按照loc字段分组）\nSELECT AVG(e.sal) avg_sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id GROUP BY d.loc; 3.关联三张表查询:员工表-部门表-（第二步子查询的结果作为表）\nSELECT e.name,e.sal,a.avg_sal,d.loc FROM emp e,dept d,(SELECT AVG(e.sal) avg_sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id GROUP BY d.loc) a WHERE e.dept_id=d.id AND d.loc=a.loc AND e.sal\u0026gt;a.avg_sal; 内连接写法\nSELECT e.name,e.sal,a.avg_sal,d.loc FROM emp e JOIN dept d ON e.dept_id=d.id JOIN (SELECT AVG(e.sal) avg_sal,d.loc FROM emp e,dept d WHERE e.dept_id=d.id GROUP BY d.loc) a ON d.loc=a.loc WHERE e.sal\u0026gt;a.avg_sal; 查看每个地区的最高工资是谁\n查看最高工资\nSELECT MAX(sal) FROM emp SELECT MAX(sal),loc,e.name FROM emp e JOIN dept d ON e.dept_id = d.id # 将部门关联起来 GROUP BY loc; # 按地区分组 内连接 自连接的设计是为了保存同样的一组数字卡的数据，之间又存在上下级关系时（树状结构数据）\n查看每个员工和他的领导是谁\nSELECT e.name,m.name FROM emp e,emp m WHERE e.manager=m.id SELECT e.name,m.name FROM emp e JOIN emp m ON e.manager=m.id; 查看刘备的手下\nSELECT * FROM emp; SELECT e.name name,m.name manager FROM emp e JOIN emp m ON e.manager=m.id WHERE m.name=\u0026#39;刘备\u0026#39;; 查看孙悟空的领导\nSELECT e.name name,m.name manager,m.sal FROM emp e JOIN emp m ON e.manager=m.id WHERE e.name=\u0026#39;孙悟空\u0026#39;; SELECT name,sal FROM emp WHERE sal\u0026gt;(SELECT m.sal FROM emp e JOIN emp m ON e.manager=m.id WHERE e.name=\u0026#39;孙悟空\u0026#39;); CREATE TABLE userinfo( id INT primary key auto_increment, username VARCHAR(30) NOT NULL , password VARCHAR(30), age INT(3), salary DOUBLE(7,2) ); DROP TABLE userinfo; DESC userinfo; CREATE TABLE Student( id INT primary key auto_increment, name VARCHAR(32), age INT(3), class_id INT(3) ); CREATE TABLE Class( id INT primary key auto_increment, name VARCHAR(32) ); DESC Student; DESC class; DROP TABLE student; DROP TABLE class; SELECT * FROM class; 练习\n查询工资大于等于3000的员工姓名和工资 SELECT name,sal FROM emp WHERE sal\u0026gt;=3000;\n查询1号部门的员工姓名和工作 SELECT name,job FROM emp WHERE dept_id=1;\n查询不是程序员的员工姓名和工作(两种写法) SELECT name,job FROM emp WHERE NOT IN \u0026lsquo;程序员\u0026rsquo; ;\nSELECT name,job FROM emp WHERE job\u0026lt;\u0026gt;\u0026lsquo;程序员\u0026rsquo;\n查询奖金等于300的员工姓名,工资和工作 SELECT name,sal,job FROM emp WHERE comm=300;\n查询1号部门工资大于2000的员工信息 SELECT * FROM emp WHERE sal\u0026gt;2000 AND dept_id=1\n查询3号部门或工资等于5000的员工信息 SELECT * FROM emp WHERE dept_id=3 OR sal=5000\n查询出CEO和项目经理的名字 SELECT name FROM emp WHERE job=\u0026lsquo;CEO\u0026rsquo; OR job=\u0026lsquo;项目经理\u0026rsquo;\n查询工资为3000,1500和5000的员工信息 SELECT * FROM emp WHERE sal IN (3000,1500,5000)\n查询工资不等于3000,1500和5000的员工信息 SELECT * FROM emp WHERE sal NOT IN (3000,1500,5000)\n查询工资在1000到2000之间的员工信息 SELECT * FROM emp WHERE sal\u0026gt;1000 AND sal\u0026lt;2000\n查询工资在1000到2000以外的员工信息 SELECT * FROM emp WHERE sal\u0026lt;1000 OR sal\u0026gt;2000\n查询有领导的员工姓名和领导id SELECT name,manager FROM emp WHERE manager IS NOT NULL\n查询没有领导的员工姓名和领导id SELECT name ,manager FROM emp WHERE manager IS NULL\n查询员工表中出现了哪几种不同的工作 SELECT job FROM emp GROUP BY job\n查询员工表中出现了那几个部门的id SELECT dept_id FROM emp GROUP BY dept_id\n查询姓孙的员工姓名 SELECT name FROM emp WHERE name LIKE \u0026lsquo;孙%\u0026rsquo;\n查询名字最后一个字是精的员工信息 SELECT * FROM emp WHERE name LIKE \u0026lsquo;%精\u0026rsquo;\n查询工作中包含销售的员工信息 \bSELECT * FROM emp WHERE job LIKE \u0026lsquo;%销售%\u0026rsquo;\n查询工作中第二个字是售的员工信息 SELECT * FROM emp WHERE job LIKE \u0026lsquo;_售%\u0026rsquo;\n查询名字中包含僧的员工并且工资高于2000的员工信息 SELECT * FROM emp WHERE name LIKE \u0026lsquo;%僧%\u0026rsquo; AND sal\u0026gt;2000\n查询1号和2号部门中工作以市开头的员工信息 SELECT * FROM emp WHERE name LIKE \u0026lsquo;市%\u0026rsquo; AND dept_id IN (1,2)\n查询所有员工的姓名和工资 按照工资升序排序 SELECT name,sal FROM emp ORDER BY sal;\n查询所有员工的姓名和工资 按照工资降序排序 SELECT name,sal FROM emp ORDER BY sal DESC;\n查询所有员工姓名 工资和部门id 按照部门id降序排序,如果部门id一致则按照工资升序排序 SELECT name,sal,dept_id FROM emp ORDER BY dept_id DESC,sal;\n查询员工表中3号部门工资高于1500的员工信息 SELECT * FROM emp WHERE dept_id=3 AND sal\u0026gt;1500\n查询2号部门员工或者没有领导的员工信息 SELECt * FROM emp WHERE dept_id=2 OR manager IS NULL;\n查询有领导的员工姓名,工资按照工资降序排序 SELECT name,sal FROM emp WHERE manager IS NOT NULL ORDER BY sal DESC\n查询2号和3号部门的员工姓名和入职日期hiredate 按照入职日期降序排序 SELECT name,hiredate FROM emp WHERE dept_id IN (2,3) ORDER BY hiredate DESC\n查询名字中包含僧和包含精的员工姓名 SELECT name FROM emp WHERE name LIKE \u0026lsquo;%僧%\u0026lsquo;AND name LIKE\u0026rsquo;%精%\u0026rsquo;\n查询工资高于2000的工作有哪几种? SELECT job FROM emp WHERE sal\u0026gt;2000 GROUP BY job\n查询工资最高的前三个员工 SELECT *,MAX(sal) max_sal FROM emp ORDER BY sal LIMIT 0,3\n查询员工表按照id排序, 第2页的5条数据 SELECT * FROM emp ORDER BY id LIMIT 1,5\n查询员工表按照id排序, 第3页的4条数据 SELECt * FROM emp OEDER BY id LIMIT 2,4\n查询3号部门工资最低的员工姓名和工资 SELECT name,MIN(sal) FROM emp\n查询工作不是人事的员工中工资降序第二页的3条数据 SELECT * FROM emp WHERE job\u0026lt;\u0026gt;\u0026lsquo;人事\u0026rsquo; ORDER BY sal LIMIT 1,3\n查询没有领导的员工和3号部门的员工,工资降序取前三条 SELECT * FROM emp WHERE manager IS NULL AND dept_id=3 ORDER BY sal DESC LIMIT 0,3\n查询2号部门的最高工资 SELECT MAX(sla) FROM emp WHERE dept_id=2\n查询有领导的员工中工资在1000到2000之间的人数\n查询3号部门的工资总和\n查询程序员和销售的总人数\n查询1号部门有领导的员工的平均工资\n查询1号部门的最低工资和最高工资\n查询和销售相关的工作人数\n查询工资不是1500和3000的员工人数\n查询1号部门出现了哪几种工作\n查询名字包含精的员工数量\n查询和销售相关的工作一个月工资总和\n查询2号部门的最高工资和最低工资起别名\n查询每个部门的平均工资\n查询每种工作的平均工资\n查询每个部门的最高工资\n查询每种工作的最低工资\n查询每个部门工资高于2000的人数\n查询每个部门有领导的员工人数\n查询1号部门每种工作的最低工资\n查询平均工资最高的部门id和平均工资\n查询每个部门的平均工资,要求平均工资大于2000\n查询每种工作的人数,只查询人数大于1的\n查询每个部门的工资总和,只查询有领导的员工, 并且要求工资总和大于5400.\n查询每个部门的平均工资, 只查询工资在1000到3000之间的,并且过滤掉平均工资低于2000的\n/* SQLyog Ultimate v12.09 (64 bit) MySQL - 5.5.68-MariaDB : Database - newdb3\n*/\n/*!40101 SET NAMES utf8 */;\n/!40101 SET SQL_MODE=\u0026rsquo;\u0026rsquo;/;\n/!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 /; /!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 /; /!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=\u0026lsquo;NO_AUTO_VALUE_ON_ZERO\u0026rsquo; /; /!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 /; CREATE DATABASE /!32312 IF NOT EXISTS/empdb /*!40100 DEFAULT CHARACTER SET utf8 */;\nUSE empdb;\n/*Table structure for table dept */\nDROP TABLE IF EXISTS dept;\nCREATE TABLE dept ( id int(4) NOT NULL AUTO_INCREMENT, name varchar(14) NOT NULL, loc varchar(13) DEFAULT NULL, PRIMARY KEY (id), UNIQUE KEY DNAME (name) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n/*Data for the table dept */\ninsert into dept(id,name,loc) values (1,\u0026lsquo;神仙\u0026rsquo;,\u0026lsquo;天庭\u0026rsquo;),(2,\u0026lsquo;妖怪\u0026rsquo;,\u0026lsquo;盘丝洞\u0026rsquo;),(3,\u0026lsquo;普通人\u0026rsquo;,\u0026lsquo;北京\u0026rsquo;),(4,\u0026lsquo;赛亚人\u0026rsquo;,\u0026lsquo;外星球\u0026rsquo;);\n/*Table structure for table emp */\nDROP TABLE IF EXISTS emp;\nCREATE TABLE emp ( id int(4) NOT NULL AUTO_INCREMENT, name varchar(10) NOT NULL, job varchar(9) DEFAULT NULL, manager int(4) DEFAULT NULL, hiredate date DEFAULT NULL, sal double(7,2) DEFAULT NULL, comm double(7,2) DEFAULT NULL, dept_id int(4) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;\n/*Data for the table emp */\ninsert into emp(id,name,job,manager,hiredate,sal,comm,dept_id) values (1,\u0026lsquo;孙悟空\u0026rsquo;,\u0026lsquo;销售\u0026rsquo;,4,\u0026lsquo;1980-12-17\u0026rsquo;,800.00,NULL,1),(2,\u0026lsquo;猪八戒\u0026rsquo;,\u0026lsquo;销售\u0026rsquo;,4,\u0026lsquo;1981-02-20\u0026rsquo;,1600.00,300.00,1),(3,\u0026lsquo;沙僧\u0026rsquo;,\u0026lsquo;销售\u0026rsquo;,4,\u0026lsquo;1981-02-22\u0026rsquo;,1250.00,500.00,1),(4,\u0026lsquo;唐僧\u0026rsquo;,\u0026lsquo;销售经理\u0026rsquo;,8,\u0026lsquo;1981-04-02\u0026rsquo;,2975.00,NULL,1),(5,\u0026lsquo;刘备\u0026rsquo;,\u0026lsquo;项目经理\u0026rsquo;,NULL,\u0026lsquo;1981-09-28\u0026rsquo;,1250.00,1400.00,3),(6,\u0026lsquo;关羽\u0026rsquo;,\u0026lsquo;程序员\u0026rsquo;,5,\u0026lsquo;1981-05-01\u0026rsquo;,2850.00,NULL,3),(7,\u0026lsquo;张飞\u0026rsquo;,\u0026lsquo;程序员\u0026rsquo;,5,\u0026lsquo;1981-06-09\u0026rsquo;,2450.00,NULL,3),(8,\u0026lsquo;观音\u0026rsquo;,\u0026lsquo;CEO\u0026rsquo;,NULL,\u0026lsquo;1981-11-17\u0026rsquo;,5000.00,NULL,1),(9,\u0026lsquo;白骨精\u0026rsquo;,\u0026lsquo;人事\u0026rsquo;,8,\u0026lsquo;1981-09-08\u0026rsquo;,1500.00,0.00,2),(10,\u0026lsquo;蜘蛛精\u0026rsquo;,\u0026lsquo;人事\u0026rsquo;,8,\u0026lsquo;1981-12-03\u0026rsquo;,950.00,NULL,2),(11,\u0026lsquo;黑熊怪\u0026rsquo;,\u0026lsquo;市场\u0026rsquo;,8,\u0026lsquo;1981-12-03\u0026rsquo;,3000.00,NULL,2);\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE /; /!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS /; /!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS /; /!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; set names UTF8;\n","date":"2024-04-29","tags":["编程","sql"],"title":"SQL 教程","url":"/post/2024/04/sql/"},{"content":" 以下是我回忆的, 所以没有截图教程\n报税网址 四川省电子税务局 这个主要是企业报税用的\nhttps://etax.sichuan.chinatax.gov.cn/loginb/ ↗ 自然人电子税务局 这个主要是给法人报税用的\nhttps://etax.chinatax.gov.cn ↗ 关于注销 税务申报方面需要仔细一点, 然后就是一些文件里面的项, 我啥也不懂, 就没有改, 发现需要再缴 500, 不知道是什么, 就缴了,\n去注销企业的时候遇到的一些问题:\n我使用的是 \u0026ldquo;简易注销\u0026rdquo;, 这个比较方便, 是一站式的, 办理完后需要等待 20 天的公示期,公示期结束后继续办理注销流程\n登录 \u0026ldquo;四川省电子税务局\u0026rdquo; 在右上角的输入框中输入 \u0026ldquo;清税\u0026rdquo;, 选择 \u0026ldquo;清税申报\u0026rdquo;, 如果进不去提示等级低类似的字样,去窗口办理一下身份认证就行, 重新登录一下\n这时候系统会检查你是否符合条件, 不符合条件的项目会显示出来, 按照应有的内容提交上去就行,\n然后就是把文件打印出来, 到人工窗口办理注销就行, 这个流程还是比较简单的\n等注销的短信发到手机上之后就可以去注销社保和银行账户这些了\n","date":"2024-04-29","tags":["办公"],"title":"报税记账","url":"/post/2024/04/compent/"},{"content":" 我使用的是 Mac，所以以下都是 Mac 的说明\n一、前端（ts、react） 前端配置：TypeScript、React 依赖项：axios、codemirror、react-codemirror2\n1. 初始化模板 任意选一个就行\n1.1 交互式 npm init vite 可能需要先安装 npm install vite --save-dev\ncaoyang@cccy del % npm init vite # 使用 上下键 选择 ✔ Project name: … playground # playground 是项目名称，它会创建一个该名称的文件夹作为项目根目录 ✔ Select a framework: › React # 使用 React 库 ✔ Select a variant: › TypeScript # 使用 TS 语言开发 Scaffolding project in /Users/caoyang/Documents/Aptos/del/playground... Done. Now run: # 需要先运行以下代码 cd playground npm install npm run dev 1.2 一键创建 npm init vite playground -- --template react-ts 或者\nnpx create-vite playground --template react-ts 或者\nnpm init @vitejs/app playground -- --template react-ts {bs-accord style=line title=解析} npm init vite : 是一个 npm 初始化命令，它使用了 Vite 工具， my-react-ts-app : 是您希望创建的项目的名称。 -- : 是用来分隔 npm 命令行选项和参数的， --template react-ts : 是向 Vite 提供的选项，它告诉 Vite 使用 React TypeScript 模板来生成项目。 {/bs-accord}\n2. 安装并运行模板 # 需要先运行以下代码 cd playground npm install npm run dev caoyang@cccy playground % npm install added 218 packages, and audited 219 packages in 59s 41 packages are looking for funding run `npm fund` for details found 0 vulnerabilities 在 vscode 中打开，并编辑\n3. 删除不需要的文件 建议删除，否则可能出现非预期的情况\npublic / vite.svg src / App.css src / index.css 删除 App.tsx 和 main.tsx 中的导入 4. 创建 playground.tsx 组件 安装依赖项\nnpm install axios codemirror react-codemirror2 # 或者 npm install axios codemirror react-codemirror2 --legacy-peer-deps # 或者 npm install axios@1.6.8 codemirror@5.65.16 react@18.2.0 react-codemirror2@7.3.0 react-dom@18.2.0 import React, { useState } from \u0026#39;react\u0026#39;; import { Controlled as CodeMirror } from \u0026#39;react-codemirror2\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import \u0026#39;codemirror/lib/codemirror.css\u0026#39;; import \u0026#39;codemirror/theme/material.css\u0026#39;; import \u0026#39;./move.js\u0026#39;; // 导入 move.js 文件 const Playground: React.FC = () =\u0026gt; { const [code, setCode] = useState(\u0026#39;\u0026#39;); const [output, setOutput] = useState(\u0026#39;\u0026#39;); const handleCodeChange = (editor: any, data: any, value: string) =\u0026gt; { setCode(value); }; const executeCode = async () =\u0026gt; { try { // 发送 Move 代码到后端服务 const response = await axios.post(\u0026#39;http://127.0.0.1:8081/run_move\u0026#39;, code); setOutput(response.data); } catch (error) { console.error(\u0026#39;执行 Move 代码时出错:\u0026#39;, error); } }; return ( \u0026lt;div\u0026gt; \u0026lt;CodeMirror value={code} options={{ mode: \u0026#39;move\u0026#39;, // 使用 move 模式 theme: \u0026#39;material\u0026#39;, lineNumbers: true, }} onBeforeChange={(editor, data, value) =\u0026gt; { setCode(value); }} onChange={handleCodeChange} /\u0026gt; \u0026lt;button onClick={executeCode}\u0026gt;执行\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;执行结果:\u0026lt;/h3\u0026gt; \u0026lt;pre\u0026gt;{output}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Playground; 5. 修改main.tsx import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; import App from \u0026#39;./App.tsx\u0026#39; ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)!).render( // \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt;, ) 6. 修改App.tsx import { useState } from \u0026#39;react\u0026#39; import Playground from \u0026#39;./playground\u0026#39; function App() { const [count, setCount] = useState(0) return ( \u0026lt;\u0026gt; \u0026lt;Playground /\u0026gt; \u0026lt;/\u0026gt; ) } export default App 7. 创建语法高亮 move.js 这部分没有完全适配，只是一个 rust 模板。\nimport CodeMirror from \u0026#39;codemirror\u0026#39;; CodeMirror.defineMode(\u0026#34;move\u0026#34;, function (config, parserConfig) { var indentUnit = config.indentUnit, statementIndentUnit = parserConfig.statementIndentUnit || indentUnit, dontAlignCalls = parserConfig.dontAlignCalls, keywords = parserConfig.keywords || {}, builtin = parserConfig.builtin || {}, blockKeywords = parserConfig.blockKeywords || {}, atoms = parserConfig.atoms || {}, hooks = parserConfig.hooks || {}, multiLineStrings = parserConfig.multiLineStrings; var isOperatorChar = /[\u0026#43;\\-*\u0026amp;%=\u0026lt;\u0026gt;!?|\\/]/; var curPunc; function tokenBase(stream, state) { var ch = stream.next(); if (hooks[ch]) { var result = hooks[ch](stream, state); if (result !== false) return result; } if (ch == \u0026#39;\u0026#34;\u0026#39; || ch == \u0026#34;\u0026#39;\u0026#34;) { state.tokenize = tokenString(ch); return state.tokenize(stream, state); } if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) { curPunc = ch; return null; } if (/\\d/.test(ch)) { stream.eatWhile(/[\\w\\.]/); return \u0026#34;number\u0026#34;; } if (ch == \u0026#34;/\u0026#34;) { if (stream.eat(\u0026#34;*\u0026#34;)) { state.tokenize = tokenComment; return tokenComment(stream, state); } if (stream.eat(\u0026#34;/\u0026#34;)) { stream.skipToEnd(); return \u0026#34;comment\u0026#34;; } } if (isOperatorChar.test(ch)) { stream.eatWhile(isOperatorChar); return \u0026#34;operator\u0026#34;; } stream.eatWhile(/[\\w\\$_]/); var cur = stream.current(); if (keywords.propertyIsEnumerable(cur)) { if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \u0026#34;newstatement\u0026#34;; return \u0026#34;keyword\u0026#34;; } if (builtin.propertyIsEnumerable(cur)) { if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \u0026#34;newstatement\u0026#34;; return \u0026#34;builtin\u0026#34;; } if (atoms.propertyIsEnumerable(cur)) return \u0026#34;atom\u0026#34;; return \u0026#34;variable\u0026#34;; } function tokenString(quote) { return function (stream, state) { var escaped = false, next, end = false; while ((next = stream.next()) != null) { if (next == quote \u0026amp;\u0026amp; !escaped) { end = true; break; } escaped = !escaped \u0026amp;\u0026amp; next == \u0026#34;\\\\\u0026#34;; } if (end || !(escaped || multiLineStrings)) state.tokenize = null; return \u0026#34;string\u0026#34;; }; } function tokenComment(stream, state) { var maybeEnd = false, ch; while (ch = stream.next()) { if (ch == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; maybeEnd) { state.tokenize = null; break; } maybeEnd = (ch == \u0026#34;*\u0026#34;); } return \u0026#34;comment\u0026#34;; } function Context(indented, column, type, align, prev) { this.indented = indented; this.column = column; this.type = type; this.align = align; this.prev = prev; } function pushContext(state, col, type) { var indent = state.indented; if (state.context \u0026amp;\u0026amp; state.context.type == \u0026#34;statement\u0026#34;) indent = state.context.indented; return state.context = new Context(indent, col, type, null, state.context); } function popContext(state) { var t = state.context.type; if (t == \u0026#34;)\u0026#34; || t == \u0026#34;]\u0026#34; || t == \u0026#34;}\u0026#34;) state.indented = state.context.indented; return state.context = state.context.prev; } // Interface return { startState: function (basecolumn) { return { tokenize: null, context: new Context((basecolumn || 0) - indentUnit, 0, \u0026#34;top\u0026#34;, false), indented: 0, startOfLine: true }; }, token: function (stream, state) { var ctx = state.context; if (stream.sol()) { if (ctx.align == null) ctx.align = false; state.indented = stream.indentation(); state.startOfLine = true; } if (stream.eatSpace()) return null; curPunc = null; var style = (state.tokenize || tokenBase)(stream, state); if (style == \u0026#34;comment\u0026#34; || style == \u0026#34;meta\u0026#34;) return style; if (ctx.align == null) ctx.align = true; if ((curPunc == \u0026#34;;\u0026#34; || curPunc == \u0026#34;:\u0026#34; || curPunc == \u0026#34;,\u0026#34;) \u0026amp;\u0026amp; ctx.type == \u0026#34;statement\u0026#34;) popContext(state); else if (curPunc == \u0026#34;{\u0026#34;) pushContext(state, stream.column(), \u0026#34;}\u0026#34;); else if (curPunc == \u0026#34;[\u0026#34;) pushContext(state, stream.column(), \u0026#34;]\u0026#34;); else if (curPunc == \u0026#34;(\u0026#34;) pushContext(state, stream.column(), \u0026#34;)\u0026#34;); else if (curPunc == \u0026#34;}\u0026#34;) { while (ctx.type == \u0026#34;statement\u0026#34;) ctx = popContext(state); if (ctx.type == \u0026#34;}\u0026#34;) ctx = popContext(state); while (ctx.type == \u0026#34;statement\u0026#34;) ctx = popContext(state); } else if (curPunc == ctx.type) popContext(state); else if (((ctx.type == \u0026#34;}\u0026#34; || ctx.type == \u0026#34;top\u0026#34;) \u0026amp;\u0026amp; curPunc != \u0026#39;;\u0026#39;) || (ctx.type == \u0026#34;statement\u0026#34; \u0026amp;\u0026amp; curPunc == \u0026#34;newstatement\u0026#34;)) pushContext(state, stream.column(), \u0026#34;statement\u0026#34;); state.startOfLine = false; return style; }, indent: function (state, textAfter) { if (state.tokenize != tokenBase \u0026amp;\u0026amp; state.tokenize != null) return CodeMirror.Pass; var ctx = state.context, firstChar = textAfter \u0026amp;\u0026amp; textAfter.charAt(0); if (ctx.type == \u0026#34;statement\u0026#34; \u0026amp;\u0026amp; firstChar == \u0026#34;}\u0026#34;) ctx = ctx.prev; var closing = firstChar == ctx.type; if (ctx.type == \u0026#34;statement\u0026#34;) return ctx.indented \u0026#43; (firstChar == \u0026#34;{\u0026#34; ? 0 : statementIndentUnit); else if (ctx.align \u0026amp;\u0026amp; (!dontAlignCalls || ctx.type != \u0026#34;)\u0026#34;)) return ctx.column \u0026#43; (closing ? 0 : 1); else if (ctx.type == \u0026#34;)\u0026#34; \u0026amp;\u0026amp; !closing) return ctx.indented \u0026#43; statementIndentUnit; else return ctx.indented \u0026#43; (closing ? 0 : indentUnit); }, electricChars: \u0026#34;{}\u0026#34;, blockCommentStart: \u0026#34;/*\u0026#34;, blockCommentEnd: \u0026#34;*/\u0026#34;, lineComment: \u0026#34;//\u0026#34;, fold: \u0026#34;brace\u0026#34; }; }); (function () { function words(str) { var obj = {}, words = str.split(\u0026#34; \u0026#34;); for (var i = 0; i \u0026lt; words.length; \u0026#43;\u0026#43;i) obj[words[i]] = true; return obj; } var rustKeywords = \u0026#34;abstract async await become box break const continue crate do dyn else enum extern false fn for if impl in let loop macro match mod move mut pub ref return self Self static struct super trait true type union unsafe use where while yield\u0026#34;; function rustHook(stream, state) { if (!state.startOfLine) return false; for (; ;) { if (stream.skipTo(\u0026#34;\\\\\u0026#34;)) { stream.next(); if (stream.eol()) { state.tokenize = rustHook; break; } } else { stream.skipToEnd(); state.tokenize = null; break; } } return \u0026#34;meta\u0026#34;; } // Rust-style strings where \u0026#34;\u0026#34; escapes a quote. function tokenAtString(stream, state) { var next; while ((next = stream.next()) != null) { if (next == \u0026#39;\u0026#34;\u0026#39; \u0026amp;\u0026amp; !stream.eat(\u0026#39;\u0026#34;\u0026#39;)) { state.tokenize = null; break; } } return \u0026#34;string\u0026#34;; } function mimes(ms, mode) { for (var i = 0; i \u0026lt; ms.length; \u0026#43;\u0026#43;i) CodeMirror.defineMIME(ms[i], mode); } mimes([\u0026#34;text/x-rustsrc\u0026#34;, \u0026#34;text/x-rust\u0026#34;], { name: \u0026#34;rust\u0026#34;, keywords: words(rustKeywords), blockKeywords: words(\u0026#34;enum struct\u0026#34;), atoms: words(\u0026#34;true false None Some\u0026#34;), hooks: { \u0026#34;#\u0026#34;: rustHook } }); }()); 8. 测试运行 npm run dev 访问页面\nVITE v5.2.8 ready in 177 ms ➜ Local: http://localhost:5173/ # 访问这个地址可以打开 ➜ Network: use --host to expose ➜ press h \u0026#43; enter to show help 如果无法运行 报错：\n[vite] Internal server error: Missing \u0026#34;./lib/codemirror.css\u0026#34; specifier in \u0026#34;codemirror\u0026#34; package 检查 paclage.json 中的 \u0026quot;codemirror\u0026quot;: \u0026quot;^5.65.16\u0026quot; 版本是否正确\n这时候点击 执行 会出错，因为还没写服务端\n二、服务端（rust） 1. 安装 Rust（安装 Rust 时会默认安装 Cargo） curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 按照提示操作，选择默认选项安装即可。\n2. Rust 环境 安装完成后，根据终端中的提示，运行以下命令将 Rust 工具链添加到您的 shell 环境中：\nsource $HOME/.cargo/env 3. 验证安装 在终端中运行以下命令来验证 Rust 和 Cargo 是否成功安装：\nrustc --version # 或者 rustc -V cargo --version # 或者 cargo -V 查看帮助\nrustc --help cargo --help cargo run --help cargo build --help 4. 创建 Rust 项目 在您选择的目录中，打开终端。\n创建一个新的 Rust 项目\ncargo new rust_move_server # rust_move_server 是项目的名称，它会创建一个该名称的文件夹作为项目根目录 {bs-accord style=line title=文件解析} Cargo.toml 是 Rust 项目的配置文件，类似于其他语言中的 package.json 或者 requirements.txt。它用来指定项目的元数据、依赖项以及构建配置等信息。您可以在 Cargo.toml 中指定项目的名称、版本号、作者信息等，同时也可以列出项目的依赖项和构建脚本。\nsrc 目录是 Rust 项目的源代码目录，其中包含了您编写的 Rust 源代码文件。通常情况下，Rust 项目的主要源代码文件会放在 src 目录下。您可以在 src 目录中创建 Rust 源代码文件（通常以 .rs 扩展名结尾），并在这些文件中编写 Rust 代码来实现项目的功能。\n初始的 src 目录内包含一个 main.rs 文件\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } {/bs-accord}\n5. 进入项目目录 cd rust_move_server 进入您新创建的项目目录。\n6. 构建项目 您新创建的项目目录内\ncargo build Cargo 将会自动下载和构建项目的依赖项，并生成可执行文件。\n7. 运行项目 构建完成后，您可以在项目目录中找到生成的可执行文件。\n执行项目\n./target/debug/your_project_name {bs-accord style=line title=构建同时运行}\ncargo run 用于构建并运行 Rust 项目的可执行文件。它实际上是 cargo build 和执行生成的可执行文件的组合操作。\n具体来说，cargo run 命令会执行以下操作：\n构建项目：如果项目尚未构建，cargo run 会首先执行与 cargo build 相同的操作，即编译 Rust 项目的源代码并生成可执行文件。如果项目已经构建过，它会跳过这一步，除非代码或依赖项发生了变化。\n运行可执行文件：一旦项目构建完成，cargo run 会自动在项目的 target/debug 目录中查找生成的可执行文件，并将其运行起来。如果项目是库项目而不是可执行文件项目，则 cargo run 不会执行任何操作，因为库项目没有可执行文件。\n传递参数：cargo run 命令可以接受额外的参数，并将它们传递给生成的可执行文件。这些参数可以在执行可执行文件时使用，例如指定程序的运行配置或传递运行时参数。 {/bs-accord}\n8. 写入 Rust 服务端代码 8.1 配置依赖项 Cargo.toml [package] name = \u0026#34;test_server\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] actix-web = \u0026#34;4.0\u0026#34; actix-cors = { version = \u0026#34;0.6.0-beta.10\u0026#34; } 8.2 写入Rust 代码 use actix_web::{web, App, HttpResponse, HttpServer, Responder}; use std::process::{Command, Stdio}; use std::fs; use std::path::Path; use std::str; use actix_cors::Cors; async fn compile_and_run_move(move_code: web::Bytes) -\u0026gt; impl Responder { println!(\u0026#34;Received Move code: {:?}\u0026#34;, move_code); // 创建临时文件目录 let tmp_dir = \u0026#34;/tmp\u0026#34;; if !Path::new(tmp_dir).exists() { fs::create_dir(tmp_dir).expect(\u0026#34;Failed to create temporary directory\u0026#34;); } // 将接收到的 Move 代码写入临时文件 let tmp_file = \u0026#34;/Users/caoyang/Documents/Aptos/ts_playground/move_code/sources/test.move\u0026#34;; fs::write(tmp_file, move_code).expect(\u0026#34;写入文件：Failed to write Move code to file\u0026#34;); // 编译 Move 代码 let compile_output = Command::new(\u0026#34;aptos\u0026#34;) .arg(\u0026#34;move\u0026#34;) .arg(\u0026#34;test\u0026#34;) .arg(\u0026#34;--package-dir\u0026#34;) .arg(\u0026#34;/Users/caoyang/Documents/Aptos/ts_playground/move_code\u0026#34;) .output() .expect(\u0026#34;Failed to execute aptos move test command\u0026#34;); if !compile_output.status.success() { let stderr = str::from_utf8(\u0026amp;compile_output.stderr).unwrap_or(\u0026#34;Error reading stderr\u0026#34;); return HttpResponse::InternalServerError().body(format!(\u0026#34;Move compilation failed: {}\u0026#34;, stderr)); } // 将运行结果作为响应返回给客户端 HttpResponse::Ok().body(String::from_utf8_lossy(\u0026amp;compile_output.stdout).to_string()) } #[actix_web::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { // 启动服务器 HttpServer::new(|| { App::new() // 添加CORS中间件 .wrap( Cors::permissive() // \u0026lt;- 使用 Cors::permissive() 替换 Cors::new() .allowed_origin(\u0026#34;http://localhost:5173\u0026#34;) ) // 定义路由 .route(\u0026#34;/run_move\u0026#34;, web::post().to(compile_and_run_move)) }) .bind(\u0026#34;127.0.0.1:8081\u0026#34;)? .run() .await } 9. 发送 post 请求进行测试 curl -X POST -d \u0026#39;module 0x12::test{ use std::debug::print; use std::string::utf8; #[test] fun test_server(){ print(\u0026amp;utf8(b\u0026#34;server is running\u0026#34;)); } }\u0026#39; http://127.0.0.1:8081/run_move Rust 部分完成 三、move 临时代码 这个目录主要是用于存储前端的代码，然后执行这段代码，将结果返回给前端\n先创建目录 mkdir move_code_tmp cd move_code_tmp 1. 初始化 Move 项目 aptos move init --name move_code 这个命令会在当前目录下初始化一个 move 项目，不会新创建项目， 根据提示输入内容，或者直接回车 创建的 Move.toml 包含了程序的配置信息\n返回结果\ncaoyang@cccy move_code_tmp % aptos move init --name move_code { \u0026#34;Result\u0026#34;: \u0026#34;Success\u0026#34; } 2. 初始化 aptos 账户 aptos init --network testnet 这个命令会在 .aptos 目录下创建一个 config.yaml 文件，这个文件包含了账户的所有信息\n返回结果\ncaoyang@cccy move_code_tmp % aptos init --network testnet Configuring for profile default Configuring for network Testnet Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)] No key given, generating key... Account 0x3846fb4052a41807816c58611911e913526e2370cd97a160025cc7dc670efeff doesn\u0026#39;t exist, creating it and funding it with 100000000 Octas Account 0x3846fb4052a41807816c58611911e913526e2370cd97a160025cc7dc670efeff funded successfully --- Aptos CLI is now set up for account 0x3846fb4052a41807816c58611911e913526e2370cd97a160025cc7dc670efeff as profile default! Run `aptos --help` for more information about commands { \u0026#34;Result\u0026#34;: \u0026#34;Success\u0026#34; } 3. 创建临时 Move 代码文件 temp.move 用于临时存储前端发送的 Move 代码，并执行代码\n3.1 输入一段 Move 代码 module 0x42::test{ use std::debug::print; use std::string::utf8; #[test] fun test_my(){ print(\u0026amp;utf8(b\u0026#34;server is running\u0026#34;)); } } 3.2 测试运行 aptos move test 返回的结果\ncaoyang@cccy move_code_tmp % aptos move test INCLUDING DEPENDENCY AptosFramework INCLUDING DEPENDENCY AptosStdlib INCLUDING DEPENDENCY MoveStdlib BUILDING move_code warning: unused alias ┌─ /Users/caoyang/Documents/Aptos/del/move_code_tmp/sources/temp.move:2:21 │ 2 │ use std::debug::print; │ ^^^^^ Unused \u0026#39;use\u0026#39; of alias \u0026#39;print\u0026#39;. Consider removing it # 这是正常的，因为未使用 warning: unused alias ┌─ /Users/caoyang/Documents/Aptos/del/move_code_tmp/sources/temp.move:3:21 │ 3 │ use std::string::utf8; │ ^^^^ Unused \u0026#39;use\u0026#39; of alias \u0026#39;utf8\u0026#39;. Consider removing it # 这是正常的，因为未使用 Running Move unit tests [debug] \u0026#34;server is running\u0026#34; # 输出了源码中预期的结果 [ PASS ] 0x42::test::test_my Test result: OK. Total tests: 1; passed: 1; failed: 0 { \u0026#34;Result\u0026#34;: \u0026#34;Success\u0026#34; } Move 部分完成 四、测试 输入以下代码后，点击 执行，等待一段时间后，可以看到执行结果区域有输出\nmodule 0x12::test{ use std::debug::print; use std::string::utf8; #[test] fun test_server(){ print(\u0026amp;utf8(b\u0026#34;server is running\u0026#34;)); } } 五、目录结构 tree -I \u0026#39;node_modules|build|target\u0026#39; ./ caoyang@cccy ts_playground % tree -I \u0026#39;node_modules|build|target\u0026#39; ./ ./ ├── move_code # move 程序代码 │ ├── Move.toml # 可以更换为国内源 │ ├── scripts │ ├── sources │ │ └── temp.move # move 临时代码 │ └── tests ├── playground │ ├── README.md │ ├── codemirror.d.ts │ ├── index.html │ ├── package-lock.json │ ├── package.json │ ├── public │ │ └── vite.svg # 这个可以删掉 │ ├── src │ │ ├── App.tsx # 取消严格模式，防止渲染两个输入框 │ │ ├── assets │ │ │ └── react.svg # 这个可以删掉 │ │ ├── main.tsx │ │ ├── move.js # 高亮语法 │ │ ├── playground.tsx # 文本编辑器 │ │ └── vite-env.d.ts │ ├── tsconfig.json │ ├── tsconfig.node.json │ └── vite.config.ts └── rust_move_server # rust 服务端，用于接受 post 请求，并返回 move 的执行结果 └── test_server ├── Cargo.lock ├── Cargo.toml # 需要配置依赖项 └── src └── main.rs # 服务端代码 附录 playground package.json { \u0026#34;name\u0026#34;: \u0026#34;playground\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;tsc \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;axios\u0026#34;: \u0026#34;^1.6.8\u0026#34;, \u0026#34;codemirror\u0026#34;: \u0026#34;^5.65.16\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^18.2.0\u0026#34;, \u0026#34;react-codemirror2\u0026#34;: \u0026#34;^7.3.0\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^18.2.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/codemirror\u0026#34;: \u0026#34;^5.60.15\u0026#34;, \u0026#34;@types/react\u0026#34;: \u0026#34;^18.2.66\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^18.2.22\u0026#34;, \u0026#34;@typescript-eslint/eslint-plugin\u0026#34;: \u0026#34;^7.2.0\u0026#34;, \u0026#34;@typescript-eslint/parser\u0026#34;: \u0026#34;^7.2.0\u0026#34;, \u0026#34;@vitejs/plugin-react\u0026#34;: \u0026#34;^4.2.1\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^8.57.0\u0026#34;, \u0026#34;eslint-plugin-react-hooks\u0026#34;: \u0026#34;^4.6.0\u0026#34;, \u0026#34;eslint-plugin-react-refresh\u0026#34;: \u0026#34;^0.4.6\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.2.2\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^5.2.0\u0026#34; } } rust Cargo.toml [package] name = \u0026#34;rust_move_server\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] actix-web = \u0026#34;4.0\u0026#34; actix-cors = { version = \u0026#34;0.6.0-beta.10\u0026#34; } move Move.toml [package] name = \u0026#34;move_code\u0026#34; version = \u0026#34;1.0.0\u0026#34; authors = [] [addresses] [dev-addresses] [dependencies.AptosFramework] git = \u0026#34;https://github.com/aptos-labs/aptos-core.git\u0026#34; rev = \u0026#34;mainnet\u0026#34; subdir = \u0026#34;aptos-move/framework/aptos-framework\u0026#34; [dev-dependencies] ","date":"2024-04-29","tags":["move"],"title":"创建一个远程编译环境","url":"/post/2024/04/a_code_env/"},{"content":"\n样机 https://bannermockup.com/ ↗ https://mockupplanet.com/ ↗ https://www.anthonyboyd.graphics/ ↗ https://www.pixeden.com/ ↗ https://www.ls.graphics ↗ 条件 登录 grapicpear\n插画 https://dotown.maeda-design-room.net/ ↗ https://www.opendoodles.com ↗ 设计师必备 50 款免费可商用图库网站：照片、插画、纹理一网打尽\n免费素材图像素材工具推荐 Angel Wang・2022-10-13 大家好，本周我为大家准备了超全面的免费可商用高清图库，可能是全网最全的总结，推荐的图库类型有：照片图库、博物馆艺术品图库、图片生成器、纹理图库、插画图库、图标库，总有一种你用得到！\n注：由于免费商用图库网站经营不易，会遇到被收购转成收费素材等情况，所以为了更稳妥一些，在商用前，建议大家先到原网站仔细检查清楚版权限制，避免不必要的纷争哦！\n01 照片图库 1、unsplash\n网址：https://unsplash.com/ 非常经典的免费可商用图库，不仅量多，还支持中文搜索。\n且这个图库有很多宝藏用户，比如你搜索「museum」或者「library」，就能找到不少博物馆和图书馆上传的各种艺术作品。\n当然，你也可以用这种方法搜索看看有没有各领域垂直用户，就能把你需要的图片类型一网打尽！\n2、gratisography\n网址：https://gratisography.com/ 这个图库的图片风格相对比较轻松、搞怪，有故事感。\n3、magdeleine\n网址：https://magdeleine.co/license/cc0/ 此图库并非全部图片都可商用，首页右侧的 「LICENSE」下有专门的CC0分类，是无限制使用，另一个分类需要注明出处，网站还能在搜索结果中可通过颜色进行二次筛选。\n4、foodiesfeed\n网址：https://www.foodiesfeed.com/ 这是专属于食物的免费图库，共有 1700 多张食物图片，每一张都色彩鲜艳，让人食欲大增！\n5、designerspics\n网址：http://www.designerspics.com/ designerspics 是设计师 Jeshu 所拍摄的照片合集网站，供所有人免费商用，在搜索框的下拉菜单中，有不少可选分类。\n6、freejpg\n网址：https://en.freejpg.com.ar/ freejpg 的图片风格非常「北欧风」，可以使用关键词+色彩组合搜索图片。\n7、stocksnap\n网址：https://stocksnap.io/ 分类十分齐全的高清图库网站，是多为摄影师联合建立的。\n8、freephotos\n网址：https://freephotos.cc/zh 不仅是一个高清图库，还提供简单的线上编辑功能。\n首页每天都会有一张精选图片推荐\n9、天空图片素材汇总\n网址：https://www.priga.jp/ 日本的图库网站，顾名思义收录了各式天空图，是很好的合成素材！\n10、pixabay\n网址：https://pixabay.com/zh/ 图库内含图片/插画/矢量/视频/音乐素材，素材量大，支持中文搜索。\n搜索框可选择搜索类型\n11、streetwill\n网址：http://streetwill.co/ streetwill 是一个旅游图片收录图库，多为各地街头巷尾景色。\n12、pexels\n网址：https://www.pexels.com/zh-cn/ 依旧是支持中文搜索，分类十分全面的图库，网站会总结一段时间内的热门搜索词供用户参考，图片提供者是全世界各地的摄影师们。\n13、splitshire\n网址：https://www.splitshire.com/ 很有质感的图库，每张照片都有一种大片既视感。\n02 博物馆艺术品资源库 除了常规的图库外，很多人不知道的是，不少博物馆官方也会设立免费可商用图库，各类名画、艺术品高清大图都能在各大博物馆图库中找到。\n1、芝加哥艺术馆\n网址：https://www.artic.edu/collection 芝加哥艺术馆开放了五万多张高清原图作品，只要点击首页左边的筛选器，勾选Public domain，就可以筛选出可免费商用的艺术作品。\n有神奈川冲浪、巴黎街、莫奈的睡莲、梵高自画像等等等等我们很熟悉的作品，点开喜欢的作品，不仅有详细的介绍，在右下角点击下载键，就可以直接拥有它的高清无码大图。\n2、美国大都会博物馆\n网址：https://www.metmuseum.org/art/the-collection 大都会博物馆是美国最大的艺术博物馆，和中国北京的故宫、英国伦敦的大英博物馆、法国巴黎的卢浮宫、俄罗斯圣彼得堡的艾尔米塔什博物馆并称为世界五大博物馆，这就足以见得它的藏品有多么丰富了！\n打开大都会博物馆的网站首页，点击搜索框按回车，点选搜索框下方的 Open Access，即可跳转到免费可商用素材页面，还能通过材质类别、地理位置、年代等等进行检索，值得一提的是免费可商用的图超过 3 万 7 千副。\n点开喜欢的作品，就可以浏览到详细信息，左下角可以听到在线讲解，而在作品的右下角，点击下载键，就可以查看到高清大图，右键保存就好了。\n3、史密斯协会\n网址：https://www.si.edu/openaccess 史密斯学会网站里收藏了包括非洲艺术博物馆、美国历史博物馆等19个博物馆，一共有300万个数字藏品可以免费下载和商用。\n首页向下滑，就可以看到所有的数字藏品，点开一张作品，会有明确的CC0标识，左下角直接点击下载键就能够拥有作品。\n史密斯学会的数字藏品最特别的是，它还拥有3D模型，还能在线查看！\n4、台北故宫\n网址：https://theme.npm.edu.tw/opendata/ 它是中华文化史上三大博物馆之一，收藏和保存了很多国宝，包括著名的翠玉白菜和毛公鼎，打开官网，首页就很直接了当地说网站「文物图像下载」和「精选图像下载」区共超过7万张图像，都是可以免费商用的。\n点开「精选图像下载」，一万六千多件有名气的各类文物，随便点开一张，不仅能看到详细的文字说明，还可以一键下载72分辨率的图片。\n首页点击「文物查询下载」，然后可以进一步选择器物资料还是书画资料，就能更精细地检索朝代、类别等。\n另外值得一提的是，台北故宫博物馆与时俱进，还上线了动森专区，里面都是在游戏里画出来的知名文物，比如翠玉白菜、肉形石、百骏图、宋仁宗朝服、中式纹样等。\n5、巴黎博物馆\n网址：https://www.parismuseescollections.paris.fr/fr 之前，巴黎博物馆协会网站也宣布对外开放10万张的馆藏作品的可供免费下载商用，这些作品是来自协会管理的14间巴黎博物馆，比如巴尔扎克博物馆、维克多雨果故居等等。\n在首页向下滑，就会看到一个CC0区域，一共有 34 万多张，点击查看更多作品，就可以看到所有的CC0画作。\n点进去后可以直接搜索或者通过博物馆、作者、画面元素、作品时间、甚至是颜色来筛选寻找图片，不过页面是法语，善用浏览器翻译。\n6、荷兰国立博物馆\n网址：https://www.rijksmuseum.nl/nl/rijksstudio 它是荷兰规模最大的博物馆，藏有史前至近现代的各种展品，馆内最为知名的收藏就是十七世纪荷兰画家伦勃朗的作品。\n向下翻，除了官方分类，还有很多网友自己收集的灵感版，比如花卉合集、肖像画合集等等。\n7、沃尔特斯艺术博物馆\n网址：https://art.thewalters.org/browse/medium/ 美国的沃尔特斯艺术馆的三万六千多件藏品都开放了免费商用，除了可以看到不少非常经典的日本版画，还有木乃伊、彩绘玻璃、各式珠宝首饰等等藏品。\n点开作品后左下角就可以看到版权标识，右边就是下载键。\n8、纽约公共图书馆\n网址：https://digitalcollections.nypl.org/ 纽约公共图书馆一共收藏了超过90万件数字藏品，首页向下就可以看到专门的公共领域作品。\n一共有18万张多，包括了很多早年间的城市海报、专辑封面、百老汇资料等等，还有不少近代设计师的创意手稿。\n03 图片生成器、AI 工具 除了保存有限图片的图库外，不少 AI 工具或者各类图片生成器也能作为图库使用，而且内容可以说取之不尽用之不竭！\n但需要注意的是，由于 AI 工具是抓取网络数据生成图片，虽说不少工具声明遵守 CC0 协议，但直接使用还是有风险，毕竟风格抄袭难以定义，建议还是作为参考使用，作为新玩意儿，大家还是可以尝尝鲜。\n1、Midjourney\n网址：https://www.midjourney.com/home/ 这是一个输入关键词就能生成图片的网站，理论来说无版权限制，生成的图谁都能用，生成的图简直照片、建模级别的精细。\n官网有个案例库，是用户生成的各种图，总得来说有点像是一个所有用户共创的 AI 图库。\n生成速度也非常快，几分钟就能生成一组图片，操作起来也很简单。\n2、disco diffusion\n网址：https://colab.research.google.com/github/alembics/disco-diffusion/blob/main/DiscoDiffusion.ipynb 和 Midjourney 一样，是个输入关键词就能生成图片的网站，但生成图更多是原画场景。\n相比 Midjourney 操作起来比较繁琐，大家可参考 b 站视频一步步操作。\n3、Waifu Diffusion\n网址：https://colab.research.google.com/drive/1_8wPN7dJO746QXsFnB09Uq2VGgSRFuYE#scrollTo=1HaCauSq546O 可以说是二次元版的 disco diffusion ，你能用它生成你的二次元角色！生成效果堪比画师手绘！\n操作方法参考下方视频，快来试试生成你的二次元「老婆」！\n4、artbreeder\n网址：https://www.artbreeder.com/ 严格来说，这是一个「捏脸」的在线网站，你可以按自己的喜好捏人脸，然后生成人物肖像画。\n使用起来十分简单，打开网站注册账号后，在首页随便点选一个你喜欢的画风，就能直接开捏。\n除了人物肖像外，网站内还挺捏动物、捏场景等服务，但相对来说技术还没那么成熟。\n调整参数的页面也很好上手，就和游戏里捏脸是差不多的。\n5、fffuel\n网址：https://fffuel.co/ 超级实用的生成器素材大礼包，内含34款功能各异的生成器工具，emoji、像素图案、手绘涂鸦、流体渐变…通通都有，简直不能再全了！\n只要点击主页相应生成器即可跳转页面。\n6、coolbackgrounds\n网址：https://coolbackgrounds.io/ 网站可随机生成 5 种类别的背景，自定义程度极高，交互还非常丝滑，值得一试，适合作为网页背景！\n7、pppalette v2\n网址：https://fffuel.co/pppalette/ 非常全面的配色生成器，选择一个主色就能一键生成几十种不同配色，还能根据混合模式选择相应配色。\n8、meshgradient\n网址：https://meshgradient.in/ meshgradient 是一个一键生成网格渐变背景工具，还支持自定义输出尺寸，渐变样式还特别多，能为你介绍不少制作渐变背景的时间！\n04 纹理图库 无论是作为 PPT 背景，还是作为设计素材，纹理都是不可或缺的，下面这几款纹理图库，你肯定能在工作中用到。\n1、百桨素材网\n网址：https://www.hituyu.com/ 一个很实用的国产纹理图库，优点是本地化做得非常好，分类特别多。\n很多中式特色的纹理都收录在其中。\n2、everypixel\n网址：https://www.everypixel.com/patterns everypixel 包含了数千种纹理图案，有可爱的卡通插画，也有极具现代感的几何拼贴。\n选择一个图案后，图库内会再推荐几个相似的风格供你选择，还可以点击进入编辑页面，在线调整元素在画面中的大小和密度、配色，图库内还有预设的色卡可以选择。\n3、heropatterns\n网址：https://heropatterns.com/ 图库的UI很简洁，主页有两个拾色器，分别是调整纹理和背景的颜色，还有一个滑块是调整纹理的透明度，设置之后，图库中所有的纹理都会保持这种设置，方便统一视觉筛选素材。\n当我们单独选择纹理后 也能对它进行单独的配色调整。\n4、transparenttextures\n网址：https://www.transparenttextures.com/ 此图库的特点是可以下载透明的纹理，进入网站后，左侧可以选择预览颜色和饱和度，不过这个颜色只做预览。\n我们选择纹理下载后，还是会下到一个四方连续的透明纹理素材，下载的格式基本上是PNG，但每个素材都可以在网页左侧复制到CSS代码。\n5、visiwig\n网址：https://www.visiwig.com/patterns 此纹理图库的自定义程度极高，只需要点击一个喜爱的风格示例进去，我们就可以调整纹样的大小、密度、颜色等等诸多选项。\n05 插画图库 1、Pixeltrue\n网址：https://www.pixeltrue.com/free-illustrations 该图库有 400+ 免费插图，风格多样，可以打包下载，也能单独下载，最主要的是还有动画素材。\n2、getillustrations\n网址：https://www.getillustrations.com/illustration-packs 图库内有收费也有免费的素材包下载，虽然是免费的但质量一点也不差！\n3、weareskribbl\n网址：https://weareskribbl.com/ 图库内含多种黑白手绘风格插画，而且每周都会更新。\n4、Open Peeps\n网址：https://www.openpeeps.com/ 这个图库插图风格更偏日系手绘涂鸦风，网站预设了很多人物造型，可直接下载单个 png 或者 svg 格式图片使用。\n你还可以把这些素材都下载下来，然后自由组合搭配。\n5、Open Doodles\n网址：https://www.opendoodles.com/ 同样是手绘风插画图库，设计师的个人风格很强烈，画风很有特色。\n6、Fresh Folk\n网址：https://fresh-folk.com/ 图库内置多样人物素材，还附带各种场景，画风相对偏写实一些。\n和 open peeps 一样可下载下来随意组合。\n7、retro Vectors\n网址：https://retrovectors.com/category/free-vectors 图库内含多种美式复古风插画，就像是旧海报上的插图一样，很有年代感，非常独特。\n8、icon8插画库\n网址：https://icons8.com/illustrations 图库内插画素材风格多样，商务、童趣、休闲，统统都有，涵盖多种日常使用场景。\n甚至还有 3D 的插图。\n9、任天堂像素画库\n网址：https://dotown.maeda-design-room.net/ 这个插画图库是由任天堂的前设计师前田高志发布，内含700+任天堂元素的像素画，从人物到动植物、街景到建筑，统统都有！\n10、Openillux\n网址：https://openillux.com/ 如果上面的插画图库你还觉得不够，那么这个插画图库合集网站一定能满足你的需求，它相当于插画图库检索页，收集了市面上大部分的免费可商用插画网站。\n06 图标库 1、icooon\n网址：https://icooon-mono.com 图库内含 6000+ 免费图标，包括了生活中方方面面的主题，如医疗、动物、建筑物、音乐、文具等等，是个很「生活化」的图标库。\n2、iconduck\n网址：https://iconduck.com 图标库内有19组风格多样的 icon 素材，数量丰富，即下即用，可以说非常方便！\n3、日本旅游图标库\n网址：https://experience-japan.info/en/ 顾名思义，整个图库的图标是和日本文化相关的，有日式建筑、传统、自然景观、食物等相关的图标。\n每个图标点进去还有文化背景解释，特别有意思。\n4、healthcons\n网址：https://healthicons.org 医疗主题图标库，囊括了各类医疗用品图标，现如今可以说非常实用了。\n5、Fluent Emoji\n网址：https://github.com/microsoft/fluentui-emoji 来自微软的开源图标库，这套表情包数量多达1500+，每个 emoji 都包含2D、3D、单色等四个版本，轻拟物的风格看起来质感满满\n以上，就是今天超级丰富的干货分享，存了这么多图库网站，必须要有一个图片、文件管理软件来整理下载到电脑中的素材，Eagle 绝对是你的首选！\n利用它的网页插件，你能在浏览图片时直接拖拽快捷保存。\n快速批量存图也不在话下！\n网页有存图限制也能利用快捷键一键统统存下来！\n海量文件储存在电脑中，Eagle 能自动按照色彩、文件格式为你的素材分类，妥善帮你保管你的图库，让你的文件管理更加高效、透明！\n马上复制链接至官网即可下载试用哟！\n网址：https://cn.eagle.cool/\n如果上面的神器你还觉得不够，不妨收藏 Eagle 官方推出的资源社区，我们会定时跟进各类设计干货！\n网址：https://community-cn.eagle.cool/\n","date":"2024-04-29","tags":["设计"],"title":"设计资料：样机","url":"/post/2024/04/design/"},{"content":"一、什么是SimHash SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。\n对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。 比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。\n二、局部性敏感哈希 说到hash可能我们第一个想到的是md5这种信息摘要算法，可能两篇文本只有一个标点符号的差距，但是两篇文本A和B的md5值差异就非常大，感兴趣的可以试验一下看看。\n有时候我们希望的是原本相同的文章做了微小改动之后的哈希值也是相似的，这种哈希算法称为局部敏感哈希LSH(Locality Sensitive Hashing)，这样我们就能从哈希值来推断相似的文章。\n局部敏感哈希算法使得在原来空间相似的样本集合，进行相关运算映射到特定范围空间时仍然是相似的，这样还不够，还需要保证原来不相似的哈希之后仍然极大概率不相似，这种双向保证才让LSH的应用成为可能。\n三、simhash的基本过程 SimHash算法主要有五个过程：分词、Hash、加权、合并、降维。\n1.分词（可以用一些分词工具来实现） 使用分词手段将文本分割成关键词的特征向量，分词方法有很多，我用了jieba分词来实现，你可以先去除停用词，当然也可以不去除，根据自己的需求选择，假设分割后的特征实词如下：\n12306 服务器 故障 车次 加载失败 购买 候补订单 支付 官方 消费者 建议 卸载 重装 切换网络 耐心 等 目前的词只是进行了分割，但是词与词含有的信息量是不一样的，比如12306 服务器 故障 这三个词就比 支付 卸载 重装更能表达文本的主旨含义，这也就是所谓信息熵的概念。 为此我们还需要设定特征词的权重，方法有很多，简单一点的可以使用TF-IDF来实现。\n2.Hash 前面我们使用分词方法和权重分配将文本就分割成若干个带权重的实词，比如权重使用1-5的数字表示，1最低5最高，这样我们就把原文本处理成如下的样式：\n12306(5) 服务器(4) 故障(4) 车次(4) 加载失败(3) 购买(2) 候补订单(4) 支付(2) 官方(2) 消费者(3) 建议(1) 卸载(3) 重装(3) 切换网络(2) 耐心(1) 等待(1) 然后，通过hash函数对每一个词向量进行映射，产生一个n位二进制串，一般常用的位数为32、64、128。\n3.加权 前面的计算我们已经得到了每个词向量的Hash串和该词向量对应的权重，这一步我们计算权重向量W=hash*weight。 具体的计算过程如下：hash二进制串中为1的，w = 1 * weight，二进制串中为0的，w = weight * -1. 举个例子，12306的带权重哈希值为 [5 -5 -5 5 5 5 -5 -5]，服务器的带权重哈希值为 [-4 4 4 4 -4 4 -4 4]\n4.合并 对于一个文本，我们计算出了文本分词之后每一个特征词的权重向量，在合并这个阶段，我们把文本所有词向量的权重向量相累加，得到一个新的权重向量，假定最终结果为 [18 9 -6 -9 22 -35 12 -5]\n5.降维 对于前面合并后得到的文本的权重向量，大于0的位置1，小于等于0的位置0，就可以得到该文本的SimHash值，以上面提到的 [18 9 -6 -9 22 -35 12 -5] 为例，我们得到 [1 1 0 0 1 0 1 0] 这个bit串，也就是论文中提及的该文本的指纹。 到此为止，我们已经计算出了一个文本的SimHash值。那么，如何判断两个文本是否相似呢？我们要用到海明距离。\n四、相似度判断 对于两个文本的SimHash的相似度判断，我们使用海明距离来计算。 什么是海明距离呢？ 简单的说，海明距离可以理解为，两个二进制串之间相同位置不同的个数。\n举个例子，[1，1，1，0，0，0]和[1，1，1，1，1，1]的海明距离就是3。\n在处理大规模数据的时候，我们一般使用64位的SimHash，正好可以被一个long型存储。这种时候，海明距离在3以内就可以认为两个文本是相似的。 五、大规模数据下的海明距离计算 我们在存储时将64bit simhash值均分为4份每份16bit长，然后使用每一份作为key，value是每一份simhash值对应的二进制向量： 当新来一个文本生成哈希值S\u0026rsquo;之后，按照相同的规则生成abcd四部分，之后逐个进行哈希对比，这个时间复杂度是O(1)： 如果abcd四个作为key都不存在，那么可以认为S\u0026rsquo;没有相似的文本； 如果abcd四个key中有命中，那么就开始遍历对应key的value，查看是否满足\u0026lt;=3的海明距离确定相似性；（一般64位编码的simhash值对应的海明距离阈值设为3） 如果上一个命中的key未找到相似文本，则继续遍历剩下的key，重复相同的过程，直至所有的key全部遍历完或者命中相似文本，则结束。 六、参考文献： https://blog.csdn.net/Daverain/article/details/80919418 ↗ https://cloud.tencent.com/developer/article/1189493 ↗ 文章二 本文要解决的是这样一个问题：\n有一段文本线索：\n“延安西路921号，进门左边第三棵树，有一个一百三十年前的\u0026hellip;\u0026hellip;”\n我想从一个亿级数据库里，把包含这段线索的相似文本都捞出来，找到它背后更多的故事。 这是一个相似匹配的问题（文本相似匹配基础→ 词频与余弦相似度）。但是，亿级数据库，用传统的相似度计算方法太慢了，我们需要一个文本查询方法，可以快速的把一段文本的相似文本查出来。\n在实际的文本处理工作中，不解决海量查询这一基本问题，耗时等待是非常可怕的。比如我们时常要对海量相似文本进行去重、或者对海量相似文本的聚类等。\n具体场景为：在搜索引擎中查询一段文本，10分钟后才能返回？对微博上某种近一周的文本进行聚类，要等1个月？（说到聚类，效果好一点的聚类方法如DBSCAN，时间复杂度很高，耗时是非常让人绝望的，这个后续还会介绍）。\n你会发现，很多时候，如果不先解决掉大规模相似文本的问题，后面很多高大上的分析、模型都做不了，这也是为什么我文本分析这个系列中，我先介绍“大规模文本处理”，而没有先介绍word2vec、LSTM等方法的原因。\n在前面的文章里（→哈希函数），我们介绍过一种叫哈希函数的东西，他可以把文本转换成一段哈希指纹。从而对文本进行量化降维。但是，我们希望转换之后，相似的文本还能保持相似，比如 “最美数说君”，hash之后是 12345，“最帅数说君”，hash之后是12346，还能保持差不多的相似。这个是最难的，满足这种特性的hash函数，叫做局部敏感性哈希（LSH）。\n本文要介绍的SimHash，就是其中的一种，谷歌就是用它来对海量文本进行去重。\n一、SimHash原理\n1、Simhash的使用\nSimahash方法最早由Moses Charikar在《similarity estimation techniques from rounding algorithms》一文中提出。SimHash是将一段文本hash成一串二进制的指纹（如0010110），然后配用海明距离进行两两文本的比较。海明距离，说白了就是看两段二进制指纹有多少不一样，具体可以看这里→ 常用距离/相似度 一览。流程如下图所示：\n一般来说，如果海明距离小于3，则认为这两个文本是相似文本。那么SimHash是如何计算的呢？\n2、Simhash 的计算 我们以 “Python is sexy” 为例，展示以下 一段文本的SimHash过程：\n先给一个总的流程图：\n（1）分词、给定权重 首先是分词，且给定每一个词的权重。\n这里我们采用四字母为单位来切词（我们把大小写归一化、空格去掉），权重统一为1：\n[Pyth：1, ytho：1, thon：1, honi：1, onis：1, niss：1, isse：1, ssex：1, sexy：1] （2）传统hash 把每一个词用传统方法hash成数字（即 hashcode），这里位数根据存储成本和数据集大小来选取，一般多选64位：\nPyth： 0010001010010001101111101000111010100011110110111010100010110011 ytho： 0001110111100111000110010001111000001001001111000110110100011000 ...... （3）加权 每一个分词的 hashcode 中，对应位上如果为1，则该位加上权重w，这里权重为1，即+1,；对应位上如果不为1，则该位减去权重w，这里即-1。\nPyth： -1 -1 2 -1 -1 -1 2 -1 2 -1 -1 2 -1 -1 -1 2 2 -1 2 2 2 2 2 -1 2 -1 -1 -1 2 2 2 -1 2 -1 2 -1 -1 -1 2 2 2 2 -1 2 2 -1 2 2 2 -1 2 -1 2 -1 -1 -1 2 -1 2 2 -1 -1 2 2 ytho： -1 -1 -1 2 2 2 -1 2 2 2 2 -1 -1 2 2 2 -1 -1 -1 2 2 -1 -1 2 -1 -1 -1 2 2 2 2 -1 -1 -1 -1 -1 2 -1 -1 2 -1 -1 2 2 2 2 -1 -1 -1 2 2 -1 2 2 -1 2 -1 -1 -1 2 2 -1 -1 -1 ...... （4）合并 现在每个分词都有64位的二进制表示，我们将每一位进行纵向累加，也就是将每个分词的第1位累加，得到总的第1位，每个分词的第2位累加，得到总的第2位，同理第3位、第4位\u0026hellip;\u0026hellip;第64位。最终得到了一个总的64位的二进制表示：\nPython is sexy： -5, -5, -1, 1, 3, -3, -1, -3, -5, -1, -1, 3, 1, -3, 1, -1, 3, -1, -3, 1, 1, -3, 3, -3, -1, 5, -1, 1, -3, 1, -7, 3, 5, -1, 3, -1, 1, 1, -3, -3, 1, -1, -1, -1, -1, 1, -1, 7, 3, 3, -3, -1, 3, 5, 1, 5, -1, -1, 3, 1, 5, 3, 1, -3 （5）0/1处理 对于64位的每一位，如果大于0，则赋值为1，否则为0：\nPython is sexy 的最终 simhash 二进制指纹：\n0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0 以上，就是一段文本的Simhash过程。它的好处是相似的两段文本，Simhash 之后的值仍然能保持相似，而且经过了降维，储存空间也大大减少，计算效率会提高很多。一般来说，两端simhash的海明距离如果在3以内，就认为是相似文本。\n你可能会问，为什么？为什么这种 Hash 方法可以让相似的文本仍然相似？Simhash的发明人 Charikar 的论文中并没有给出具体的证明，但由于 Simhash 是由随机超平面hash算法演变而来的，有人根据这个给出了证明，大家可以搜搜看。\n二、加速查询：抽屉原理 虽然 Simhash 可以减少单次计算的耗时，海量文本来说，匹配的计算量还是很大的。如果数据库里有几百亿数据，那就意味着要匹配几百亿次。因此，我们需要一种方法来减少匹配。\n对于两段文本，我们分别映射成64位hash指纹之后，再每个文本分为四份，每个部分16位。对于这两段文本，如果海明距离在3以内，则它们对应的4个部分，至少有一个部分是一样的。\n因为，海明距离小于3，意味着，最多有3个位点有区别，而3个差异位点分布在四个部分，至少有一个部分是没有相同的。\n这就好比把3个球放到4个抽屉里面，一定有一个抽屉是空的，所以叫“抽屉原理”。\n基于此，可以把一段64位指纹分成 K-V格式（Key-Value），K就是其中四个部分中的一个部分，V就是剩下3个部分。我们在匹配的时候，只要精确匹配K，K相同了，再去匹配V，这样可以大大减少计算量。\n但问题是，我怎么知道差异位点分布在哪一部分？\n所以，一段文本的Simhash指纹，我们需要复制成四次存储，以text1为例，simhash 成64位之后，我们分成四个部分，A1-A2-A3-A4。我们把这段存储四份，以使得每一部分都做一次K，剩下其他三个为V：\n① K: A1, V: A2-A3-A4 ② K: A2, V: A1-A3-A4 ③ K: A3, V: A1-A2-A4 ④ K: A4, V: A1-A2-A3 这样就可以保证不会有遗漏。\n那么，用这一套方法，最终能减少多少查询呢？给大家算一笔账：\n假设数据库中有 2^30 条数据，也就是差不多10亿条数据：\n如果不用抽屉原理，那么就得与10亿条数据一一查询，即10亿次。 使用了抽屉原理，即与16位的K先查询。 想象一下由0/1组成的16位数字，可能有多少？最多2^16种K（每一位有0/1两种可能，一共有16位，排列组合一下）； 2^30数据，一共2^16种K，那么每个K-V返回的最大数量也就2^(30-16)=16384个候选结果，4个K的话，总的结果也就16384*4=65536，约66W。 这样一来，原来需要比较10亿次，现在只需要比较66万即可。\n项目：去Github搜一下就有，可以找来看看，还是比较容易懂的。\n","date":"2024-04-29","tags":["编程","算法"],"title":"什么是 SimHash","url":"/post/2024/04/simhash/"},{"content":"\n原文一 ↗ 原文二 ↗ 视频 ↗ 一、什么是 JWT JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n二、设计目标 不需要服务器端存储状态，安全地传递非敏感信息\n三、 JSON Web Token 的结构是什么样的 JSON Web Token由三部分组成，例如dafdsafdwfefeqwad.oijhdaffweqtgfdhfdws.dhshfsghhhhhwfsdke\n简化：xxxxx.yyyyy.zzzzz\n可以看到它们之间用圆点(.)连接。\n而这三部分分别是：\nHeader 头部 Payload 载荷 Signature 签名 1. Header 由两部分组成：\ntoken的类型（“JWT”） 签名算法名称（比如：HMAC SHA256或者RSA等等） 例如：\n{ \u0026#39;alg\u0026#39;: \u0026#34;HS256\u0026#34;, \u0026#39;typ\u0026#39;: \u0026#34;JWT\u0026#34; } 然后，用 Base64 对这个 JSON 编码就得到JWT的第一部分\n2. Payload 标准声明：就是该开放标准预先定义的一些字段\n公共声明：是自定义的声明，用于特定应用程序中共享信息\n私有声明：用于在同意双方之间共享信息，通常不会被 JWT 规范定义，而是由应用程序自行定义和使用\n它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。\nRegistered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。 Public claims : 可以随意定义。 Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子： { \u0026#34;sub\u0026#34;: \u0026#39;1234567890\u0026#39;, \u0026#34;name\u0026#34;: \u0026#39;john\u0026#39;, \u0026#34;admin\u0026#34;:true } 对payload进行Base64编码就得到JWT的第二部分\n注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。\n3. Signature 为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。\n例如：\nHMACSHA256(secret, base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload))\nsecret 保存在服务端，用来进行 JWT 的签发和验证，所以在任何时候都不应该泄漏\nJWT 的签发生成也在服务端\nHMACSHA256 是一种对称加密算法\n对称加密算法：用一个密钥加密解密的算法\n非对称加密算法：SSH key（用公钥加密的密文智能用私钥解密，用私钥签发的签名只能用公钥来验证）\n签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。\n看一张官网的图就明白了：\nJWT 是如何工作的 在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。\n无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema。\nheader应该看起来是这样的：\nAuthorization: Bearer\n服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。\n如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。\n三、场景 下列场景中使用JSON Web Token是很有用的：\nAuthorization (认证、授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。\nInformation Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。\n基于Token的身份认证\n基于服务器的身份认证\n1. 基于 Token 的身份认证 在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的：\nHTTP 协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证\n传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。\n这种基于服务器的身份认证方式存在一些问题：\nSessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。 Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。 CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。 CSRF : 用户很容易受到CSRF攻击。 5.2. JWT与Session的差异 相同点是，它们都是存储用户信息；然而，Session是在服务器端的，而JWT是在客户端的。\nSession方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。\n而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。\nSession的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。\n基于Token的身份认证是如何工作的 基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息。\n没有会话信息意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置。\n虽然这一实现可能会有所不同，但其主要流程如下：\n-用户携带用户名和密码请求访问 -服务器校验用户凭据 -应用提供一个token给客户端 -客户端存储token，并且在随后的每一次请求中都带着它 -服务器校验token并返回数据\n注意：\n-每一次请求都需要token -Token应该放在请求header中 -我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *\n5.4. 用Token的好处 - 无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。 - 安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!\n还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。\n5.5. JWT与OAuth的区别 -OAuth2是一种授权框架 ，JWT是一种认证协议 -无论使用哪种方式切记用HTTPS来保证数据的安全性 -OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。\n2. 基于服务器的身份认证 注意：\n服务器不能真正退出登录 用户信息修改后不能及时同步 Token 泄漏后没有有效的手段将 Token 置为无效 用户通过用户名和密码登录后，系统签发一个 JWT 给客户端，这个 Token 保存了一些用户的基本信息，以及权限相关的信息，后续用户请求的时候带上这个 Token ，服务器就知道当前访问的用户是谁、有哪些权限，而不用查询数据库去3获取用户的基本信息以及权限。\n3. 密码重置和电子邮件验证 服务器会生成包含用户信息的 JWT，并组成一个链接发到用户的邮箱，用户点击该链接后就可以重置密码或完成电子邮件验证（不是必须用 JWT）\n4. 单点登录 #\nJWS （Json Web Signature） 只对内容做签名，确保其不被篡改，但是其内容本身并没有被加密。（最常见的实现 JWT 实现方式）\n它的头部和载荷都是没有加密的，所以它的目的并不是想隐藏数据，而是防止数据被篡改，这点是通过第三方签名来实现的\nJWE（Json Web Encryption） 会对内容本身加密，相对更安全，但是成本也会更高。\n对比sesion 对比 Token jwt就是个生成token（用户令牌）的一个规范。session id 也是一种用户令牌。 就是这个令牌里面带的用户信息，表名是哪个用户的令牌。 jwt里存的用户id，也可以存redis里。也可以不存。传统的session id 是在服务器存储服务中。 过期时间可以各种设计，可以在服务端存储，也可以带到jwt里。如果是带到jwt传里的，那某个用户的jwt串只能同时有一个生效，还是只要在没过过期时间内的都有效，这个要怎么控制。 有各种设计，本质上jwt就是个把用户id安全的传给客户端，客户端安全的传给服务端。\n每个用户一个sha256哈希的密码，某个用户密码被破了，就改掉这个密码。 jwt和传统session(包括说的token)，唯一区别就是 服务端保存不保存这个token。然后是，jwt带的身份标识到了服务端后，需要获取权限。session的那个id 也可以存到redis里。redis key就是session的id，value就是鉴权信息。jwt的话，想要增加速度，鉴权信息得查出来后 也可以把鉴权的信息存储到redis里，那么问题来了，到底会不会节省服务器的内存？ 估计只会省掉存储身份id这个空间。 jwt还有个好处，就是服务器，redis炸了，session id的话就会丢失，jwt的话 还在。\n","date":"2024-04-12","tags":["编程"],"title":"JWT 解析","url":"/post/2024/04/jwt/"},{"content":" github ↗ 官方文档 ↗ 其实所有的配置都不推荐修改，但是如果改了一个配置一定要理解为什么改，以及会影响到什么，请务必打开服务器的端口（防火墙）。\n以下不一定能用，因为我搞了许久才发现是我没打开服务器防火墙，而导致无法访问。 简单说：服务器的配置建议改一下，主要是你服务器可能把8080端口占用了，其余的所有都可以不用改。又不是不能用。\n服务器 nps 需要公网服务器，我服务器的是腾讯云，用的 docker 管理\n1. 如果没下载 Docker 下载docker，使用包管理器下载，yum install -y docker\n2. 创建nps的配置文件夹， 可以自定义，我创建的命令是 mkdir /opt/nps/conf\n3. 拉取docker image docker pull ffdfgdfg/nps，可以使用docker images查看是否拉取成功\n4. 在nps的github下载配置文件 GitHub 下载地址 https://github.com/ehang-io/nps/blob/master/conf/nps.conf ↗ 也可以在 gitee 下载 https://gitee.com/mirrors/nps/tree/master/conf ↗ 把配置文件放在之前创建的 /opt/nps/conf\n5. 修改配置文件（也可以不改，见8） 具体文件内容在文末，修改nps.conf中的端口号，在nps.conf中将https_just_proxy设置为true，并且打开https_proxy_port端口，然后nps将直接转发https请求到内网服务器上，由内网服务器进行https处理\n6. 运行 docker run -d -p 20000-20010:20000-20010 -v /opt/nps/conf:/conf --name=nps ffdfgdfg/nps 解释：-d:后台运行容器，并返回容器ID；-p: 指定端口映射，格式为：主机(宿主)端口:容器端口; 20000-20010:20000-20010: 主机(宿主)端口:(docker)容器端口; -v:绑定一个卷; /opt/nps/conf:/conf: (宿主)目录: docker目录 -name=nps: 为容器指定一个名称； ffdfgdfg/nps:镜像，【应该是这个意思】\n如果报错，查看镜像是否存在 docker iamge; 查看运行状态 docker ps -a 删除容器 docker rm 容器名或id 停止运行docker stop 容器名或id\n使用默认配置 docker run --net=host --name nps_server -d ffdfgdfg/nps ，解释 --net=\u0026quot;bridge\u0026quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n通过公网ip访问：你的公网ip:你设置的端口 比如：8.8.8.8:20003, 默认端口20003\n后续发现停止运行了, 可以使用 docker start nps 启动 nps 服务\n面板上的客户端就是实体设备，客户端通过这里设置的秘钥访问nps 面板上的隧道就是设备上的端口，只要你客户端配置好了，隧道就自动在线了。隧道的就是客户端 id + 客户端端口 + 服务器映射端口（给公网访问）\n客户端 npc 1. 拉取docker image docker pull ffdfgdfg/npc\n2. 配置文件见文末 不推荐修改配置\n3. 未修改配置文件启动 在服务端打开面板 客户端 -\u0026gt; 新增（可以不用配置，改改备注就行）-\u0026gt; 新增； 点击新增条目左边的加号，获取客户端命令。类似于：./npc -server=8.8.8.8:20002 -vkey=fds4322we232w -type=tcp；./nps可以不用复制，命令其余部分复制下来，用于配置客户端docker 运行 docker run -d --name npc --net=host ffdfgdfg/npc -server=ip地址:20002 -vkey=z8uhasdfsfdshx -type=tcp 6. 配置文件启动 没用过，不瞎解释。\n主要是修改启动server_addr 改为你自己的地址 docker run -d -p 18080-18090:8080-8090 -v /root/npc/conf:/conf --name=npc ffdfgdfg/npc 配置文件 nps.conf appname = nps runmode = dev http_proxy_ip=0.0.0.0 http_proxy_port=20000 # http访问 https_proxy_port=20001 # https访问 https_just_proxy=true # 仅https代理 https_default_cert_file=conf/server.pem https_default_key_file=conf/server.key bridge_type=tcp bridge_port=20002 # bridge_ip=0.0.0.0 public_vkey=123 log_level=7 web_host=a.o.com web_username=admin #用户名 web_password=123 # 密码 web_port = 20003 # 记住这个端口，这是管理面板的端口 web_ip=0.0.0.0 web_base_url= web_open_ssl=false web_cert_file=conf/server.pem web_key_file=conf/server.key auth_crypt_key =1234567887654321 allow_user_login=false allow_user_register=false allow_user_change_username=false allow_flow_limit=false allow_rate_limit=false allow_tunnel_num_limit=false allow_local_proxy=false allow_connection_num_limit=false allow_multi_ip=false system_info_display=false http_cache=false http_cache_length=100 http_add_origin_header=false 配置文件（/etc/nps/conf/nps.conf）的含义：\n名称\t含义 web_port\tweb管理端口 web_password\tweb界面管理密码 web_username\tweb界面管理账号 web_base_url\tweb管理主路径,用于将web管理置于代理子路径后面 bridge_port\t服务端客户端通信端口 https_proxy_port\t域名代理https代理监听端口 http_proxy_port\t域名代理http代理监听端口 auth_key\tweb api密钥 bridge_type\t客户端与服务端连接方式kcp或tcp public_vkey\t客户端以配置文件模式启动时的密钥，设置为空表示关闭客户端配置文件连接模式 ip_limit\t是否限制ip访问，true或false或忽略 flow_store_interval\t服务端流量数据持久化间隔，单位分钟，忽略表示不持久化 log_level\t日志输出级别 auth_crypt_key\t获取服务端authKey时的aes加密密钥，16位 p2p_ip\t服务端Ip，使用p2p模式必填 p2p_port\tp2p模式开启的udp端口 pprof_ip\tdebug pprof 服务端ip pprof_port\tdebug pprof 端口 disconnect_timeout\t客户端连接超时，单位 5s，默认值 60，即 300s = 5mins 默认配置\nappname = nps #Boot mode(dev|pro) runmode = dev #HTTP(S) proxy port, no startup if empty http_proxy_ip=0.0.0.0 http_proxy_port=80 https_proxy_port=443 https_just_proxy=true #default https certificate setting https_default_cert_file=conf/server.pem https_default_key_file=conf/server.key ##bridge bridge_type=tcp bridge_port=8024 bridge_ip=0.0.0.0 # Public password, which clients can use to connect to the server # After the connection, the server will be able to open relevant ports and parse related domain names according to its own configuration file. public_vkey=123 #Traffic data persistence interval(minute) #Ignorance means no persistence #flow_store_interval=1 # log level LevelEmergency-\u0026gt;0 LevelAlert-\u0026gt;1 LevelCritical-\u0026gt;2 LevelError-\u0026gt;3 LevelWarning-\u0026gt;4 LevelNotice-\u0026gt;5 LevelInformational-\u0026gt;6 LevelDebug-\u0026gt;7 log_level=7 #log_path=nps.log #Whether to restrict IP access, true or false or ignore #ip_limit=true #p2p #p2p_ip=127.0.0.1 #p2p_port=6000 #web web_host=a.o.com web_username=admin web_password=123 web_port = 8080 web_ip=0.0.0.0 web_base_url= web_open_ssl=false web_cert_file=conf/server.pem web_key_file=conf/server.key # if web under proxy use sub path. like http://host/nps need this. #web_base_url=/nps #Web API unauthenticated IP address(the len of auth_crypt_key must be 16) #Remove comments if needed #auth_key=test auth_crypt_key =1234567812345678 #allow_ports=9001-9009,10001,11000-12000 #Web management multi-user login allow_user_login=false allow_user_register=false allow_user_change_username=false #extension allow_flow_limit=false allow_rate_limit=false allow_tunnel_num_limit=false allow_local_proxy=false allow_connection_num_limit=false allow_multi_ip=false system_info_display=false #cache http_cache=false http_cache_length=100 #get origin ip http_add_origin_header=false #pprof debug options #pprof_ip=0.0.0.0 #pprof_port=9999 #client disconnect timeout disconnect_timeout=60 npc.conf [common] server_addr=1.1.1.1:8024 conn_type=tcp vkey=123 username=111 password=222 compress=true crypt=true rate_limit=10000 flow_limit=100 remark=test max_conn=10 #pprof_addr=0.0.0.0:9999 项\t含义 server_addr\t服务端ip/域名:port conn_type\t与服务端通信模式(tcp或kcp) vkey\t服务端配置文件中的密钥(非web) username\tsocks5或http(s)密码保护用户名(可忽略) password\tsocks5或http(s)密码保护密码(可忽略) compress\t是否压缩传输(true或false或忽略) crypt\t是否加密传输(true或false或忽略) rate_limit\t速度限制，可忽略 flow_limit\t流量限制，可忽略 remark\t客户端备注，可忽略 max_conn\t最大连接数，可忽略 pprof_addr\tdebug pprof ip:port 通过域名访问\n[common] server_addr=域名:20002 conn_type=https vkey=123 auto_reconnection=true max_conn=1000 flow_limit=1000 rate_limit=1000 basic_username=11 basic_password=3 web_username=user web_password=1234 crypt=true compress=true #pprof_addr=0.0.0.0:9999 disconnect_timeout=60 [health_check_test1] health_check_timeout=1 health_check_max_failed=3 health_check_interval=1 health_http_url=/ health_check_type=http health_check_target=127.0.0.1:8083,127.0.0.1:8082 [health_check_test2] health_check_timeout=1 health_check_max_failed=3 health_check_interval=1 health_check_type=tcp health_check_target=127.0.0.1:8083,127.0.0.1:8082 [web] host=域名 target_addr=127.0.0.1:8080 说明\n[common] server_addr=1.1.1.1:8024 vkey=123 [web1] host=a.proxy.com target_addr=127.0.0.1:8080,127.0.0.1:8082 host_change=www.proxy.com header_set_proxy=nps ","date":"2024-03-29","tags":["运维"],"title":"搭建 NPS","url":"/post/2024/03/docker_pns/"},{"content":" 查看原文 ↗ 一、获取原厂固件的 ssh 登录权限 有些厂商的路由器会提供原厂固件的 ssh 登录权限，有些则需要通过原厂固件漏洞等方式来获取路由器后台登录权限，比如：小米路由器就需要先通过 OpenWRTInvasion 破解路由登录权限。\n小米路由器4A千兆版是利用 2.28.62 版本固件的一个 Shell 命令注入的漏洞，所以要想刷机成功就必须得降级到这个版本（2.28.62 之后的新版本应该是将这个漏洞修复了，我再次通过 OpenWRTInvasion 没获取到 ssh 登录权，所有刷的时候尽量在 2.28.62 这个固件版本下刷机）。\n克隆破解程序到电脑 并 执行破解 git clone https://github.com/acecilia/OpenWRTInvasion.git # 克隆 cd OpenWRTInvasion/ # 进入目录 pip install -r requirements.txt # 下载配置 python remote_command_execution_vulnerability.py # 执行脚本 二、在命令行登陆路由器后台 telnet 连接 （也可以使用 ssh ） 按 win + R 打开运行窗口。 输入 OptionalFeatures 打开 windows功能 窗口（也可以在设置里面搜索 windows功能 ） 下滑找到 Telnet Client 勾选后点击确定。 telnet 192.168.31.1 密码是 root 显示 \u0026ldquo;are u ok\u0026rdquo; 表示登陆成功\n使用 ssh 连接（也可以使用 telnet ） ssh root@192.168.31.1 密码是 root\n显示 \u0026ldquo;are u ok\u0026rdquo; 表示登陆成功\n刷入 Breed 对于路由器这类的嵌入式设备刷机有很大的可能会变砖。为了防止我们的路由器有变砖的风险，一般会在刷入第三方路由器固件之前先刷入 Breed。Breed 是国内个人 hackpascal 开发的闭源 Bootloader，也被称为“不死鸟”。 因为有些官方升级固件自带 bootloader，如果从官方固件升级，会导致现有 bootloader 被覆盖。而当 Breed 更新固件时，它会自动删除固件附带的引导加载程序，因此可以防止 Breed 被覆盖。 Breed 拥有以下特性： 实时刷机进度，进度条能准确反映刷机进度 Web 页面快速响应 最大固件备份速度，依 Flash 而定，一般能达到 1MB/s 免按复位键进入 Web 刷机模式 Telnet 功能，免 TTL 进入 Breed 命令控制台 复位键定义测试功能 固件启动失败自动进入 Web 刷机模式 可自定义位置和大小的环境变量块 由于是闭源，无法进行二次开发，所有支持的设备均由 hackpascal 一人完成。在 2020-10-09 后已经停止版本更新，但官网目前 然开放所有的 Breed 下载。 一句话概括就是：Breed 是操作系统，第三方路由器固件是应用软件，软件频繁更换和安装不会影响操作系统。\n备份分区数据 cat /proc/mtd dd if=/dev/mtd0 of=/tmp/all.bin dd if=/dev/mtd1 of=/tmp/Bootloader.bin dd if=/dev/mtd3 of=/tmp/eeprom.bin 下载 Breed： Breed 下载地址：https://breed.hackpascal.net/ 在 文件资源管理器 中输入 ftp://192.168.31.1 打开路由器的文件系统\n刷入 Breed：\ncd /tmp mtd -r write breed-mt7621-pbr-m1.bin Bootloader 刷入第三方路由器固件 OpenWRT下载地址：https://downloads.openwrt.org/releases/21.02.3/targets/ramips/mt7621/\n找到对应型号：openwrt-21.02.3-ramips-mt7621-xiaomi_mi-router-4a-gigabit-squashfs-sysupgrade.bin。\ncd /tmp mtd -e OS1 -r write openwrt-21.02.3-ramips-mt7621-xiaomi_mi-router-4a-gigabit-squashfs-sysupgrade.bin OS1 通过 Breed Web 恢复控制台刷入第三方路由器固件 当我们刷入 Breed 后就相当于是给路由器装了个操作系统，可以在上面随意刷入第三方路由器固件，一般情况下不会出现变砖的风险。\nOpenWrt 一般情况都安装 OpenWRT 或者是魔改后的 OpenWRT，小米路由器本身也是魔改的 OpenWRT。 OpenWRT官网下载地址：https://downloads.openwrt.org/releases/21.02.3/targets/ramips/mt7621/ 默认账户：root OpenWRT魔改下载地址：https://download.csdn.net/download/yilovexing/87600550 默认账户：root 默认密码：coolxiaomi\nPadavan 据说小米路由器使用老毛子固件更稳定，我也没有具体去考证，也不知道是不是真的。反正我是比较喜欢用 Padavan，无论是界面还是稳定性都不错（还有个使用老毛子的原因是 2022-07-24 Breed 进行了重大更新，OpenWrt 不再支持直接用底包刷固件了。）！\nPadavan官网源码：https://bitbucket.org/padavan/rt-n56u/src/master/ Padavan下载地址：https://opt.cn2qq.com/padavan/ 默认账户：admin 默认密码：admin\n","date":"2024-03-24","tags":["硬件"],"title":"小米 4a 路由器刷机","url":"/post/2024/03/xiaomi_4a/"},{"content":" 原文 ↗ 介绍一下配置：\nwifi 全程不用连网 win系统电脑刷机，需要下载一个刷机包 windows 有 python 程序，查看方法：在命令提示符窗口输入 python --version，会输出版本号 Breed也被称为“不死鸟”，顾名思义刷入Breed后即使后续为路由器刷固件失败，也不至于让路由器变砖，并且对于以后更换固件非常友好，强烈建议刷Breed。\n首先下载刷机所需要用到的工具 链接：https://pan.baidu.com/s/1kGnIe2T8Ul1XvWobdyxDbQ 提取码：iaxp\n提示：小米路由器后管理地址，一般为192.168.31.1\n打开小米路由器的 Telnet 和 FTP 打开下载工具包中的 R3GV2 patches 文件夹 运行文件夹中的 0.start_main.bat 批处理文件，此文件实际上是运行了一个 python 脚本，向路由器上传了一个开启 Telnet 和 FTP 的文件。 用 MobaXterm 连接小米路由器 （也可以在终端连接，我在小米4a路由器的刷机过程中就是用的终端）\n打开下载的工具包中的 MobaXterm_Personal_21.1.exe 程序， 依次点击 Sessions -\u0026gt; New session -\u0026gt; Telnet ， 在 Remote host 中输入192.168.31.1 Username 中输入 root 最后点击 OK，回到主界面后会发现生成了一个新的session 双击运行新的 session（这一步可能会提示无法连接，从头开始按照以上步骤多试几次就行了），如果需要输入密码，尝试输入 root 或者 password 或者你的 wifi 密码。 界面显示 “are u ok”，表示连接成功。\n备份文件 在 MobaXterm 命令行中分别输入以下命令 dd if=/dev/mtd0 of=/tmp/all.bin 将整个磁盘分区命名为all.bin备份到tmp路径\ndd if=/dev/mtd1 of=/tmp/bootloader.bin 将Bootloader分区命名为bootloader.bin备份到tmp路径\ndd if=/dev/mtd2 of=/tmp/eeprom.bin 将Eeprom分区命名为eeprom.bin备份到tmp路径\n备份完成后打开 文件资源管理器，在地址栏输入 ftp://192.168.31.1，打开 tmp 文件夹，并将刚刚备份的 3个bin文件 复制到 自己的电脑 中(注意：务必检查eeprom.bin文文件大小，通常为64kb，若文件只有几百字节则须重新备份) 刷入Breed 打开工具包中的 Breed 文件夹复制 breed.bin 文件，然后上传到 tmp 目录内\n回到 MobaXterm 中输入 mtd write /tmp/breed.bin Bootloader 刷入Breed。\n刷入完成后将小米路由器4C断电，按住复位键的同时通电，可以看到电源灯与网络灯闪烁几下后即可松开复位键，此时就进入了Breed模式。\n在浏览器输入 192.168.1.1 进入 Breed 页面。\n刷入OpenWrt {bs-font color=\u0026quot;#080000\u0026quot;}注意：一定要先刷入eeprom.bin再刷入OpenWrt固件{/bs-font}\n在 Breed Web 恢复控制台中依次刷入备份好的 eeprom.bin 与 OpenWrt固件 即可 OpenWrt固件在工具包文件夹OpenWrt固件中\n其他 刷好OpenWrt后输入 192.168.5.1 进入路由器管理界面，默认密码为 password\n","date":"2024-03-23","tags":["硬件"],"title":"小米 4c 路由器刷机","url":"/post/2024/03/xiaomi_4c_router/"},{"content":"{bs-font color=\u0026quot;#FF0000\u0026quot;}刷机有风险，如果能用，请不要为了不一样而刷机，又不是不能用！{/bs-font}\n现在你的路由器和小米已经没有任何关系了，恭喜你上了贼船！\n基本介绍： OpenWrt 是一个开源的路由系统，开放、自由的特性让这个路由系统深受欢迎！ 几乎所有的商业路由器品牌都是封闭的，可以操作的空间非常小，往往需要为一些小的功能，而增加几十几百甚至上千的费用。 OpenWrt很好地解决了这个问题。\n我该怎么选择？ 商业品牌的路由器：稳定 OpenWrt路由系统：软件丰富\n一、登陆管理后台 用网线连接电脑的网口和 Wi-Fi 的 LAN口打开浏览器地址烂 （一般是在窗口顶部） 输入：192.168.5.1 打不开地址：确定网口没有连错，比如拔掉 WAN口 的网线 （有的品牌叫 Internet 或者 宽带 ），确保 LAN 口是连接的电脑 在上面一栏的 用户名 或者叫 username 输入 root 在下面一栏的 密码 或者叫 password 输入 password 按 回车键 或者点击 登陆 按钮 二、配置宽带 登陆 路由器后台管理 页面 把路由器的 WAN 口连接到宿舍的网口 打开路由器后台的 网络 -\u0026gt; 接口， 找到 WAN 选择 修改 -\u0026gt; 基本设置 协议选择 PPPoE 用户名：输入你自己的用户名，注意检查空格 密码：输入你自己的密码，注意检查空格 如果登陆成功会出现 pppoe-wan的字样显示 IPv4:xxx.xxx.xxx.xxx 登陆失败？ 第一步：检查账户名或者密码是否正确 ，此时可以登陆，那么无需进行第二步。 第二步：禁用 IPv6：在 WAN -\u0026gt; 修改 -\u0026gt; 高级设置 -\u0026gt; 获取IPv6地址（或者是英文的，总之就是第一个下拉菜单选项），选择 禁用（或者英文的禁用） 11.连接成功\n三、设置无线密码 在 网络 -\u0026gt; 无线：有的有两个有的有一个，这取决于你的 wifi 硬件。 点击 修改 在新页面的下方 接口配置 部分，选择 基本设置 -\u0026gt; ESSID：修改为你想要的网络名称（其余的建议不要动，除非你懂） 在选择 接口配置 -\u0026gt; 无线安全 加密：加密方式，一般是 WPA3 或者 WPA2 算法：选择 自动 就行。 密码：设置你的 wifi 密码。 SSID：是你的无线网络名称，在修改页面对应的是 ESSID。 加密：是你的无线网络加密方式，如果有加密方式就必须要设置密码\nSSID = Service Set IDentifier BSSID = Basic Service Set IDentifier ESSID = Extended Service Set IDentifier\n其他功能说明（不重要） {bs-font color=\u0026quot;#000000\u0026quot;}如果看不懂就不用看，只改自己看得懂的，否则可能出问题！{/bs-font} 以下内容有一些可能没有，这是开发者为了路由器性能做的权衡，没有那些功能会更流畅稳定。\n概览：路由器的基本信息。 路由表：连接路由器的所有设备。 系统日志：日志，对用户来说不重要。 内核日志：日志，对用户来说不重要。 系统进程：请勿更改，可能导致系统不稳定。 实时信息：路由器的状态，可以检查到路由器是不是性能差、网络差等问题 实时监控：实时信息的升级版。 负载均衡：没用过，不知道。 Web管理：设置如何访问到后台管理页面。【不要轻易改】 系统：系统的基本设置，可以改主题和语言。 管理权：设置后台管理页的登陆密码 TTYD终端：访问路由器的Linux系统 软件包：安装和卸载软件。 启动项：脚本，可以实现一些自动化的操作 计划任务：简单版的启动项 挂载点：不要轻易改动，除非你理解Linux 备份/升级：路由器的备份和升级 重启：重启路由器 ShadowSocksR：师夷长技以制夷。 DDNS.to内网穿透：让你的设备可以在外面被访问。 动态DNS：域名解析，可以把一个域名指向 IP地址 KMS服务器：激活 Windows 系统和 office 系统的。 UPnP：端口转发 UU游戏加速器：游戏加速器，我不玩游戏，不了解。 网络唤醒：没用过 目前就这些吧，其他的我几乎没有用，我认为也不是一个普通用户会接触的，就不介绍了。\n","date":"2024-03-22","tags":["硬件"],"title":"小米路由器","url":"/post/2024/03/xiaomi_router/"},{"content":" 原作者 ↗ 个人配置 ↗ 下载 git clone https://github.com/caoyang2002/quartz-obsidian-webside.git cd quartz-obsidian-webside npm i npx quartz build --serve 配置 布局 某些 emitters 可能还会输出HTML文件。为了方便定制，这些 emitters 允许您完全重新排列页面的布局。 默认页面布局可以在 quartz.layout.ts 中找到。\n每个页面由多个不同的部分组成，这些部分包含 QuartzComponents。以下代码片段列出了您可以向其中添加组件的所有有效部分：\nquartz/cfg.ts\nexport interface FullPageLayout { head: QuartzComponent // 单个组件 header: QuartzComponent[] // 水平布局 beforeBody: QuartzComponent[] // 垂直布局 pageBody: QuartzComponent // 单个组件 left: QuartzComponent[] // 桌面上垂直布局，在移动设备上水平布局 right: QuartzComponent[] // 桌面上垂直布局，在移动设备上水平布局 footer: QuartzComponent // 单个组件 } 这些对应于页面的以下部分：\n注意 还有两个未在上图中显示的附加布局字段。\nhead 是一个单独的组件，用于在HTML中呈现\u0026lt;head\u0026gt;标签。这在页面上不会可见，只负责文档的元数据，如标签标题、脚本和样式。 header 是一组以水平方式布局的组件，出现在beforeBody部分之前。这使您可以复制旧的Quartz 3标题栏，其中包含标题、搜索栏和暗模式切换。默认情况下，Quartz 4不在标题中放置任何组件。\nQuartz 组件，就像插件一样，可以接受额外的属性作为配置选项。如果您熟悉React术语，可以将它们视为Higher-order Components。\n查看所有可用组件以及其配置选项的列表。如果您有兴趣进一步定制Quartz的行为，请查看创建组件的指南。\n样式 大多数有意义的样式更改，如颜色方案和字体，都可以通过常规配置选项简单完成。但是，如果您想进行更复杂的样式更改，可以通过编写自己的样式来实现。与Quartz 3一样，Quartz 4也使用Sass进行样式设计。\n您可以在 quartz/styles/base.scss 中查看基本样式表，并在 quartz/styles/custom.scss 中编写自己的样式。\n注意 某些组件可能还提供自己的样式！例如，quartz/components/Darkmode.tsx从quartz/components/styles/darkmode.scss 导入样式。如果您想为特定组件定制样式，请仔细检查组件定义，以查看其样式是如何定义的。\n创建自己的Quartz组件 原文 ↗ 警告 本指南假设您具有编写JavaScript的经验并熟悉TypeScript。\n通常在网络上，我们使用HTML编写布局代码，看起来像下面这样：\n\u0026lt;article\u0026gt; \u0026lt;h1\u0026gt;文章标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;一些内容\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; 这段HTML表示一篇文章，具有领先的标题“文章标题”和一个包含文本“一些内容”的段落。这与CSS结合在一起来为页面添加样式，使用JavaScript添加交互。\n但是，HTML不允许您创建可重用的模板。如果您想创建一个新页面，您需要复制并粘贴上述代码片段，并自行编辑标题和内容。如果我们的网站上有很多内容共享相似的布局，那么这并不理想。创建React的聪明人也有类似的抱怨，并发明了组件的概念——返回JSX的JavaScript函数——来解决代码重复的问题。\n实际上，组件允许您编写一个JavaScript函数，该函数接受一些数据并生成HTML作为输出。虽然Quartz不使用React，但它使用相同的组件概念，以便您可以轻松地在Quartz网站中表达布局模板。\n示例组件 构造函数 组件文件是以 .tsx 文件编写的，位于 quartz/components 文件夹中。这些文件被重新导出到 quartz/components/index.ts 中，以便您可以更轻松地在布局和其他组件中使用它们。\n每个组件文件应该有一个默认导出，满足 QuartzComponentConstructor 函数签名。它是一个接受一个可选参数 opts 并返回一个 Quartz 组件的函数。参数 opts 的类型由您作为组件创建者决定的 Options 接口定义。\n在您的组件中，您可以使用配置选项中的值来更改组件内的渲染行为。例如，下面代码片段中的组件如果 favouriteNumber 选项小于 0，则不会呈现。\ninterface Options { favouriteNumber: number } const defaultOptions: Options = { favouriteNumber: 42, } export default ((userOpts?: Options) =\u0026gt; { const opts = { ...userOpts, ...defaultOpts } function YourComponent(props: QuartzComponentProps) { if (opts.favouriteNumber \u0026lt; 0) { return null } return \u0026lt;p\u0026gt;我的最喜欢的数字是 {opts.favouriteNumber}\u0026lt;/p\u0026gt; } return YourComponent }) 满足 QuartzComponentConstructor 属性 Quartz 组件本身（上面高亮的第 11-17 行）看起来像一个React组件。它接受属性（有时称为 props）并返回JSX。\n所有Quartz组件接受相同的一组属性：\n// 简化以便演示 export type QuartzComponentProps = { fileData: QuartzPluginData cfg: GlobalConfiguration tree: Node\u0026lt;QuartzPluginData\u0026gt; allFiles: QuartzPluginData[] displayClass?: \u0026#34;mobile-only\u0026#34; | \u0026#34;desktop-only\u0026#34; } fileData : 可能已添加到当前页面的任何元数据插件。 fileData.slug : 当前页面的 slug。 fileData.frontmatter : 解析的任何 frontmatter。 cfg : quartz.config.ts 中的配置字段。 tree : 处理和转换文件后的结果HTML AST。如果您想使用 hast-util-to-jsx-runtime 渲染内容，这将非常有用（您可以在 quartz/components/pages/Content.tsx 中找到此示例）。 allFiles : 已解析的所有文件的元数据。用于执行页面列表或确定整体站点结构非常有用。 displayClass : 指示用户如何在移动设备或桌面环境中渲染它的首选项的实用类。如果要在移动设备或桌面环境中有条件地隐藏组件，则很有帮助。 样式 Quartz 组件还可以在实际函数组件上定义 .css 属性，Quartz 将对其进行捕获。这预期是一个 CSS 字符串，可以是内联的也可以是从 .scss 文件导入的。\n请注意，内联样式必须是纯粹的普通 CSS：\nexport default (() =\u0026gt; { function YourComponent() { return \u0026lt;p class=\u0026#34;red-text\u0026#34;\u0026gt;示例组件\u0026lt;/p\u0026gt; } YourComponent.css = ` p.red-text { color: red; } ` return YourComponent }) 满足 QuartzComponentConstructor 但是，导入的样式可以来自 SCSS 文件：\n// 假设您的样式表位于 quartz/components/styles/YourComponent.scss import styles from \u0026#34;./styles /YourComponent.scss\u0026#34; export default (() =\u0026gt; { function YourComponent() { return \u0026lt;p\u0026gt;示例组件\u0026lt;/p\u0026gt; } YourComponent.css = styles return YourComponent }) 满足 QuartzComponentConstructor 警告 Quartz 不使用 CSS 模块，因此在此处声明的任何样式都是全局的。如果您只希望它应用于您的组件，请确保使用特定的类名和选择器。\n脚本和交互性\n那么交互性呢？假设您想添加一个点击处理程序，例如。与组件上的 .css 属性一样，您还可以声明 .beforeDOMLoaded 和 .afterDOMLoaded 属性，这些属性是包含脚本的字符串。\nexport default (() =\u0026gt; { function YourComponent() { return \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击我\u0026lt;/button\u0026gt; } YourComponent.beforeDOM = ` console.log(\u0026#34;hello from before the page loads!\u0026#34;) ` YourComponent.afterDOM = ` document.getElementById(\u0026#39;btn\u0026#39;).onclick = () =\u0026gt; { alert(\u0026#39;button clicked!\u0026#39;) } ` return YourComponent }) 满足 QuartzComponentConstructor 提示 对于那些来自React的人来说，Quartz 组件与React组件不同，因为它只使用JSX进行模板化和布局。像 useEffect、useState 等钩子不会被渲染，其他接受函数的属性如 onClick 处理程序也不起作用。相反，使用一个普通的 JS 脚本，直接修改 DOM 元素。\n正如名称所暗示的那样，.beforeDOMLoaded 脚本在页面加载完成之前执行，因此它不能访问页面上的任何元素。这主要用于预取任何关键数据。\n.afterDOMLoaded 脚本在页面完全加载后执行。这是设置任何在站点访问期间应该持续存在的东西的好地方（例如，从本地存储中获取的内容）。\n如果需要创建一个依赖于页面特定元素的 afterDOMLoaded 脚本，在导航到新页面时可能会更改，您可以监听 “nav” 事件。每当页面加载时都会触发该事件（如果启用了 SPA 路由，则可能会在导航时发生）。\ndocument.addEventListener(\u0026#34;nav\u0026#34;, () =\u0026gt; { // 在这里执行页面特定的逻辑 // 例如，附加事件监听器 const toggleSwitch = document.querySelector(\u0026#34;#switch\u0026#34;) as HTMLInputElement toggleSwitch.addEventListener(\u0026#34;change\u0026#34;, switchTheme) window.addCleanup(() =\u0026gt; toggleSwitch.removeEventListener(\u0026#34;change\u0026#34;, switchTheme)) }) 最佳实践是通过 window.addCleanup 跟踪任何事件处理程序，以防止内存泄漏。这将在页面导航时调用。\n导入代码 当然，将代码作为字符串文字写入组件通常既不实际（也不受欢迎！）。\nQuartz 支持通过 .inline.ts 文件导入组件代码。\n// @ts-ignore: typescript doesn\u0026#39;t know about our inline bundling system // 所以我们需要消除错误 import script from \u0026#34;./scripts/graph.inline\u0026#34; export default (() =\u0026gt; { function YourComponent() { return \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击我\u0026lt;/button\u0026gt; } YourComponent.afterDOM = script return YourComponent }) 满足 QuartzComponentConstructor // 在这里导入的任何内容都将被浏览器捆绑 import * as d3 from \u0026#34;d3\u0026#34; document.getElementById(\u0026#34;btn\u0026#34;).onclick = () =\u0026gt; { alert(\u0026#34;按钮被点击了！\u0026#34;) } 此外，就像上面示例中所显示的一样，您可以在 .inline.ts 文件中导入包。这将由 Quartz 捆绑并包含在实际脚本中。\n使用组件\n创建自定义组件后，重新导出它在 quartz/components/index.ts ：\nimport ArticleTitle from \u0026#34;./ArticleTitle\u0026#34; import Content from \u0026#34;./pages/Content\u0026#34; import Darkmode from \u0026#34;./Darkmode\u0026#34; import YourComponent from \u0026#34;./YourComponent\u0026#34; export { ArticleTitle, Content, Darkmode, YourComponent } 然后，您可以像在 quartz.layout.ts 中使用任何其他组件一样使用它。有关详细信息，请参见布局部分。\n由于Quartz组件只是返回 React 组件的函数，因此您可以在其他 Quartz 组件中进行组合使用。\nimport YourComponent from \u0026#34;./YourComponent\u0026#34; export default (() =\u0026gt; { function AnotherComponent(props: QuartzComponentProps) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;它是嵌套的！\u0026lt;/p\u0026gt; \u0026lt;YourComponent {...props} /\u0026gt; \u0026lt;/div\u0026gt; ) } return AnotherComponent }) 满足 QuartzComponentConstructor 提示 在 quartz/components 中查找更多Quartz组件示例，作为您自己组件的参考！\n制作自己的插件 原文 ↗ 警告 本文档的这一部分将假定您具有 TypeScript 的工作知识，并包含描述 Quartz 插件应该具有的接口的代码片段。\nQuartz 的插件是一系列针对内容的转换。下面是处理流水线的图示：\n所有插件都被定义为一个函数，该函数接受一个参数用于选项类型 OptionType = object | undefined，并返回一个与其所属类型相对应的对象。\ntype OptionType = object | undefined type QuartzPlugin\u0026lt;Options extends OptionType = undefined\u0026gt; = (opts?: Options) =\u0026gt; QuartzPluginInstance type QuartzPluginInstance = | QuartzTransformerPluginInstance | QuartzFilterPluginInstance | QuartzEmitterPluginInstance 接下来的几节将详细介绍每种插件类型可以实现的方法。在我们进行之前，让我们澄清一些更模糊的类型：\nBuildCtx 在 quartz/ctx.ts 中定义。它由以下组成：\nargv : 传递给 Quartz 构建命令的命令行参数 cfg : 完整的 Quartz 配置 allSlugs : 所有有效内容 slug 的列表（有关 ServerSlug 的更多信息，请参阅路径部分） StaticResources 在 quartz/resources.tsx 中定义。它由以下组成：\ncss: 应加载的样式表的 URL 列表 js: 应加载的脚本列表。脚本用 JSResource 类型描述，该类型也在 quartz/resources.tsx 中定义。它允许您定义加载时间（在 DOM 加载前或后），是否应为模块以及脚本的源 URL 或内联内容。\n转换器 转换器对内容进行映射，接受一个 Markdown 文件，并输出修改后的内容或向文件本身添加元数据。\nexport type QuartzTransformerPluginInstance = { name: string textTransform?: (ctx: BuildCtx, src: string | Buffer) =\u0026gt; string | Buffer markdownPlugins?: (ctx: BuildCtx) =\u0026gt; PluggableList htmlPlugins?: (ctx: BuildCtx) =\u0026gt; PluggableList externalResources?: (ctx: BuildCtx) =\u0026gt; Partial\u0026lt;StaticResources\u0026gt; } 所有转换器插件必须至少定义一个 name 字段以注册插件，并且一些可选函数，使您能够连接到转换单个 Markdown 文件的各个部分。\ntextTransform 在将文件解析为 Markdown AST 之前执行文本到文本的转换。 markdownPlugins 定义一个 remark 插件列表。remark 是一个工具，以结构化方式将 Markdown 转换为 Markdown的工具。 htmlPlugins 定义一个 rehype 插件列表。与 remark 类似，rehype 是一个工具，以结构化方式将 HTML 转换为 HTML。 externalResources 定义插件可能需要在客户端加载的任何外部资源。 通常对于 remark 和 rehype，您可以找到现有的插件可供使用。如果您想创建自己的 remark 或 rehype 插件，请查看使用 unified（底层 AST 解析器和转换器库）的插件的指南。\n从 remark 和 rehype 生态系统借鉴的转换器插件的一个很好的例子是 Latex 插件：\nquartz/plugins/transformers/latex.ts import remarkMath from \u0026#34;remark-math\u0026#34; import rehypeKatex from \u0026#34;rehype-katex\u0026#34; import rehypeMathjax from \u0026#34;rehype-mathjax/svg\u0026#34; import { QuartzTransformerPlugin } from \u0026#34;../types\u0026#34; interface Options { renderEngine: \u0026#34;katex\u0026#34; | \u0026#34;mathjax\u0026#34; } export const Latex: QuartzTransformerPlugin\u0026lt;Options\u0026gt; = (opts?: Options) =\u0026gt; { const engine = opts?.renderEngine ?? \u0026#34;katex\u0026#34; return { name: \u0026#34;Latex\u0026#34;, markdownPlugins() { return [remarkMath] }, htmlPlugins() { if (engine === \u0026#34;katex\u0026#34;) { // 如果您需要将选项传递给插件，您可以使用 [插件，选项] 的元组 return [[rehypeKatex, { output: \u0026#34;html\u0026#34; }]] } else { return [rehypeMathjax] } }, externalResources() { if (engine === \u0026#34;katex\u0026#34;) { return { css: [ // 基础 CSS \u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css\u0026#34;, ], js: [ { // 修复复制行为：https://github.com/KaTeX/KaTeX/blob/main/contrib/copy-tex/README.md src: \u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js\u0026#34;, loadTime: \u0026#34;afterDOMReady\u0026#34;, contentType: \u0026#34;external\u0026#34;, }, ], } } else { return {} } }, } } 转换器 插件还经常做的一件事是解析文件并为该文件添加额外数据：\nexport const AddWordCount: QuartzTransformerPlugin = () =\u0026gt; { return { name: \u0026#34;AddWordCount\u0026#34;, markdownPlugins() { return [ () =\u0026gt; { return (tree, file) =\u0026gt; { // tree 是一个 `mdast` 根元素 // file 是一个 `vfile` const text = file.value const words = text.split(\u0026#34; \u0026#34;).length file.data.wordcount = words } }, ] }, } } // 告诉 TypeScript 关于我们正在添加的自定义数据字段 // 其他插件也将意识到这个数据字段 declare module \u0026#34;vfile\u0026#34; { interface DataMap { wordcount: number } } 最后，您还可以使用 unist-util-visit 包中的 visit 函数或 mdast-util-find-and-replace 包中的 findAndReplace 函数对 Markdown 或 HTML AST 进行转换。\nexport const TextTransforms: QuartzTransformerPlugin = () =\u0026gt; { return { name: \u0026#34;TextTransforms\u0026#34;, markdownPlugins() { return [() =\u0026gt; { return (tree, file) =\u0026gt; { // 使用斜体版本替换 _text_ findAndReplace(tree, /_(.\u0026#43;)_/, (_value: string, ...capture: string[]) =\u0026gt; { // inner 是正则表达式括号内的文本 const [inner] = capture // 返回一个 mdast 节点 // https://github.com/syntax-tree/mdast return { type: \u0026#34;emphasis\u0026#34;, children: [{ type: \u0026#39;text\u0026#39;, value: inner }] } }) // 删除所有链接（替换为仅链接内容） // 通过 mdast 节点上的 \u0026#39;type\u0026#39; 字段进行匹配 // 例如在这个例子中的 https://github.com/syntax-tree/mdast#link visit(tree, \u0026#34;link\u0026#34;, (link: Link) =\u0026gt; { return { type: \u0026#34;paragraph\u0026#34; children: [{ type: \u0026#39;text\u0026#39;, value: link.title }] } }) } }] } } } 所有转换器插件都可以在 quartz/plugins/transformers 下找到。如果您决定编写自己的转换器插件，请不要忘记在 quartz/plugins/transformers/index.ts 下重新导出它。\n最后一句话：转换器插件相当复杂，所以如果您一开始不理解也不必担心。查看内置的转换器，了解它们如何在内容上操作，以更好地了解如何实现您想要做的事情。\n过滤器 过滤器用于过滤内容，接受所有转换器处理的输出，并确定实际要保留的文件以及要丢弃的文件。\nexport type QuartzFilterPlugin\u0026lt;Options extends OptionType = undefined\u0026gt; = ( opts?: Options, ) =\u0026gt; QuartzFilterPluginInstance export type QuartzFilterPluginInstance = { name: string shouldPublish(ctx: BuildCtx, content: ProcessedContent): boolean } 过滤器插件必须定义一个 name 字段和一个 shouldPublish 函数，该函数接受所有转换器处理的内容，并根据是否应将其传递给发射器插件返回 true 或 false。\n例如，这是用于移除草稿的内置插件：\nquartz/plugins/filters/draft.ts import { QuartzFilterPlugin } from \u0026#34;../types\u0026#34; export const RemoveDrafts: QuartzFilterPlugin\u0026lt;{}\u0026gt; = () =\u0026gt; ({ name: \u0026#34;RemoveDrafts\u0026#34;, shouldPublish(_ctx, [_tree, vfile]) { // 使用从转换器解析的 frontmatter const draftFlag: boolean = vfile.data?.frontmatter?.draft ?? false return !draftFlag }, }) 发射器 发射器用于在内容的所有转换和过滤输出上进行缩减，并创建输出文件。\nexport type QuartzEmitterPlugin\u0026lt;Options extends OptionType = undefined\u0026gt; = ( opts?: Options, ) =\u0026gt; QuartzEmitterPluginInstance export type QuartzEmitterPluginInstance = { name: string emit(ctx: BuildCtx, content: ProcessedContent[], resources: StaticResources): Promise\u0026lt;FilePath[]\u0026gt; getQuartzComponents(ctx: BuildCtx): QuartzComponent[] } 发射器插件必须定义一个 name 字段、一个 emit 函数和一个 getQuartzComponents 函数。emit 负责查看所有解析和过滤的内容，然后适当创建文件并返回插件创建的文件路径列表。\n创建新文件可以通过常规的 Node fs 模块（例如 fs.cp 或 fs.writeFile）或者通过 quartz/plugins/emitters/helpers.ts 中的 write 函数进行，如果您正在创建包含文本的文件。write 具有以下签名：\nexport type WriteOptions = (data: { // 构建上下文 ctx: BuildCtx // 要发出的文件的名称（不包括文件扩展名） slug: ServerSlug // 文件扩展名 ext: `.${string}` | \u0026#34;\u0026#34; // 要添加的文件内容 content: string }) =\u0026gt; Promise\u0026lt;FilePath\u0026gt; 这是对向适当的输出文件夹写入并确保中间目录存在的简单包装。如果选择使用本机 Node fs API，请确保发出到 argv.output 文件夹。\n如果您正在创建需要渲染组件的发射器插件，还有三件事需要注意：\n您的组件应该使用 getQuartzComponents 声明一个 QuartzComponents 列表，用于构造页面。有关更多信息，请参阅创建组件页面。 您可以使用 quartz/components/renderPage.tsx 中定义的 renderPage 函数将 Quartz 组件呈现为 HTML。 如果需要将 HTML AST 渲染为 JSX，可以使用 quartz/util/jsx.ts 中的 htmlToJsx 函数。您可以在 quartz/components/pages/Content.tsx 中找到一个示例。\n例如，以下是一个简化版本的内容页面插件，它呈现每个页面：\nquartz/plugins/emitters/contentPage.tsx export const ContentPage: QuartzEmitterPlugin = () =\u0026gt; { // 构造布局 const layout: FullPageLayout = { ...sharedPageComponents, ...defaultContentPageLayout, pageBody: Content(), } const { head, header, beforeBody, pageBody, left, right, footer } = layout return { name: \u0026#34;ContentPage\u0026#34;, getQuartzComponents() { return [head, ...header, ...beforeBody, pageBody, ...left, ...right, footer] }, async emit(ctx, content, resources, emit): Promise\u0026lt;FilePath[]\u0026gt; { const cfg = ctx.cfg.configuration const fps: FilePath[] = [] const allFiles = content.map((c) =\u0026gt; c[1].data) for (const [tree, file] of content) { const slug = canonicalizeServer(file.data.slug!) const externalResources = pageResources(slug, resources) const componentData: QuartzComponentProps = { fileData: file.data, externalResources, cfg, children: [], tree, allFiles, } const content = renderPage(cfg, slug, componentData, opts, externalResources) const fp = await emit({ content, slug: file.data.slug!, ext: \u0026#34;.html\u0026#34;, }) fps.push(fp) } return fps }, } } 请注意，它以 FullPageLayout 作为选项。它由共享布局和页面布局组合而成，这两个布局都是通过 quartz.layout.ts 文件提供的。\n提示 在 Quartz 中查看 quartz/plugins 下更多插件的示例，作为您自己插件的参考！\n国际化 原文 ↗ 国际化允许用户将Quartz界面中的文本翻译成各种支持的语言，而无需进行大量的代码更改。这可以通过 quartz.config.ts 中的 locale 配置字段进行更改。\nlocale 字段通常遵循一定的格式：{language}-{REGION}\n{language} 通常是一个由两个小写字母组成的语言代码。 {REGION} 通常是一个由两个大写字母组成的地区代码。 有兴趣贡献吗？ 我们欢迎翻译的 Pull Request！要贡献翻译，请执行以下操作：\n在 quartz/i18n/locales 文件夹中，复制 en-US.ts 文件。 将其重命名为 {language}-{REGION}.ts，使其与上述格式的语言环境匹配。 填写翻译！ 在 quartz/i18n/index.ts 中的 TRANSLATIONS 下添加条目。\n设置你的 GitHub 仓库 原文 ↗ 首先，确保你已经在本地克隆并设置了 Quartz。\n然后，在 GitHub.com 上创建一个新的仓库。不要初始化新仓库，也不要添加 README、许可证或 gitignore 文件。\n在 GitHub.com 仓库的“快速设置”页面顶部，单击剪贴板图标以复制远程仓库的 URL。\n在你选择的终端中，导航到你的 Quartz 文件夹的根目录。然后，运行以下命令，将 REMOTE-URL 替换为你刚刚从上一步复制的 URL。\n列出所有被跟踪的仓库\ngit remote -v 如果 origin 不匹配你自己的仓库，将你的仓库设置为 origin\ngit remote set-url origin REMOTE-URL 如果你没有将上游设置为远程仓库，添加它以便更新工作\ngit remote add upstream https://github.com/jackyzha0/quartz.git 然后，你可以同步内容以将其上传到你的仓库。这是一个辅助命令，将会将你的内容初始推送到你的仓库。\nnpx quartz sync --no-pull 致命错误：--[no-]autostash 选项只能在 --rebase 时有效。\n你可能使用的是过时版本的 git。更新 git 应该会解决这个问题。\n在以后的更新中，每当你想要 将更新推送到你的仓库 时，你只需要运行 npx quartz sync。\n标志和选项 要获取完整的帮助选项，你可以运行 npx quartz sync --help。\n大多数情况下，它们都有合理的默认值，但如果你有自定义设置，你可以覆盖它们：\n-d 或 --directory ：内容文件夹。通常只是 content。 -v 或 --verbose ：打印额外的日志信息 --commit 或 --no-commit ：是否为你的更改进行 git 提交 --push 或 --no-push：是否将更新推送到你的 Quartz GitHub fork --pull 或 --no-pull ：是否在推送之前尝试拉取来自你的 GitHub fork 的任何更新（即来自其他设备的更新）\n编写内容 原文 ↗ 你的 Quartz 中的所有内容都应该放在 /content 文件夹中。Quartz 的主页内容位于 content/index.md。如果你已经设置了 Quartz，那么这个文件夹应该已经被初始化了。这个文件夹中的任何 Markdown 文件都将由 Quartz 处理。\n推荐你使用 Obsidian 来编辑和维护你的 Quartz。它带有一个漂亮的编辑器和图形界面，可以预览、编辑和链接你的本地文件和附件。\n一切都设置好了吗？让我们本地构建和预览你的 Quartz！\n语法 由于 Quartz 使用 Markdown 文件作为编写内容的主要方式，因此它完全支持 Markdown 语法。默认情况下，Quartz 还附带了一些语法扩展，如 Github Flavored Markdown（脚注、删除线、表格、任务列表）和 Obsidian Flavored Markdown（标注、Wiki 链接）。\n以下是 GitHub Flavored Markdown 的全部功能和语法：\n任务列表（Task Lists）：使用 - [ ] 和 - [x] 语法创建待办事项列表，可以勾选或取消勾选每个项目。\n表格（Tables）：使用管道符 | 和连字符 - 创建简单的表格，包括行和列。\n删除线（Strikethrough）：使用双波浪线 ~~ 表示删除的文本。\n自动链接（Autolinks）：GitHub Flavored Markdown 会自动将 URL 和电子邮件地址转换为链接。\n标记语法（Disallowed Raw HTML）：GitHub Flavored Markdown 不允许使用原始 HTML 标记，以确保安全性。\n脚注（Footnotes）：使用 [^] 语法创建文本注释，通常在页面底部显示。\nObsidian Flavored Markdown（OFM）提供了以下功能和语法：\n呼唤（Callouts）：允许在文本中添加特殊样式的注释，以突出显示关键信息或提醒。\n内部链接（Wikilinks）：可以使用双括号 [[ 和 ]] 来创建内部链接，链接到其他笔记或文件。\n时间戳链接（Timestamp Links）：可以使用 [[YYYY-MM-DD]] 的格式创建时间戳链接，链接到特定日期的笔记。\n标签链接（Tag Links）：可以使用 #[tag] 的格式创建标签链接，链接到具有相同标签的笔记。\n这些特性使得 Obsidian 用户可以更方便地创建交互式笔记，并在笔记之间建立丰富的关联。\n此外，Quartz 还允许你在笔记中指定额外的元数据，称为 frontmatter。\ncontent/note.md\n--- title: 示例标题 draft: false tags: - 示例标签 --- 你的其余内容在这里。你可以在这里使用 Markdown :) 一些常见的 frontmatter 字段，Quartz 本身支持：\ntitle: 页面标题。如果没有提供，Quartz 将使用文件名作为标题。 description: 页面描述，用于链接预览。 aliases: 此笔记的其他名称。这是一个字符串列表。 tags: 此笔记的标签。 draft: 是否发布页面。这是在 Quartz 中创建私密页面的一种方式。 date: 表示笔记发布日期的字符串。通常使用 YYYY-MM-DD 格式。 同步你的内容\n当你对 Quartz 满意时，你可以将更改保存到 GitHub。首先确保你已经设置了 GitHub 仓库，然后运行 npx quartz sync。\n自定义\n标题、标签、别名和 cssclasses 的 frontmatter 解析是 Frontmatter 插件的功能，日期由 CreatedModifiedDate 插件处理，描述由 Description 插件处理。查看插件页面以获取自定义选项。\n配置 原文 ↗ Quartz旨在非常可配置，即使您不懂编程也可以进行大多数配置。您应该需要的大多数配置只需编辑quartz.config.ts或更改quartz.layout.ts即可。\n提示 如果您使用像VSCode这样具有TypeScript语言支持的文本编辑器来编辑Quartz配置，当您在配置中出现错误时，它会提醒您，帮助您避免配置错误！\nQuartz的配置可以分为两个主要部分：\nquartz.config.ts\nconst config: QuartzConfig = { configuration: { ... }, plugins: { ... }, } 通用配置 这部分配置涉及可能影响整个站点的任何内容。以下是您可以配置的所有内容的列表：\npageTitle：站点标题。这也用于生成站点的RSS Feed时。 enableSPA：是否在站点上启用SPA路由。 enablePopovers：是否在站点上启用浮窗预览。 analytics：站点分析使用什么。值可以是 null：不使用分析； { provider: 'google', tagId: '\u0026lt;your-google-tag\u0026gt;' } ：使用Google Analytics； { provider: 'plausible' }（托管）或{ provider: 'plausible', host: '\u0026lt;your-plausible-host\u0026gt;' }（自托管）：使用Plausible； { provider: 'umami', host: '\u0026lt;your-umami-host\u0026gt;', websiteId: '\u0026lt;your-umami-website-id\u0026gt;' } ：使用Umami； { provider: 'goatcounter', websiteId: 'my-goatcounter-id' }（托管）或{ provider: 'goatcounter', websiteId: 'my-goatcounter-id', host: 'my-goatcounter-domain.com', scriptSrc: 'https://my-url.to/counter.js' }（自托管）：使用GoatCounter。 locale ：用于国际化和日期格式化。 baseUrl ：这用于需要绝对URL的站点地图和 RSS feeds，以了解站点的规范‘home’位于何处。这通常是站点的部署URL（例如，对于此站点，quartz.jzhao.xyz）。不包括协议（即https://）或任何前导或尾随斜杠。 如果您在 GitHub 页面上没有自定义域名的情况下托管，则此还应包括子路径。例如，如果我的存储库是 jackyzha0/quartz，则GitHub页面将部署到 https://jackyzha0.github.io/quartz，并且 baseUrl 将是 jackyzha0.github.io/quartz。 请注意，Quartz 4将尽可能避免使用此功能，并且在任何情况下都可以使用相对URL以确保您的站点正常工作。 ignorePatterns ：Quartz应忽略并在查找内容文件夹中查找文件时不应搜索的一组glob模式。有关更多详细信息，请参见私有页面。 defaultDateType ：默认要在页面和页面列表上显示的日期是使用created、modified 还是 published。 theme ：配置站点外观。 cdnCaching ：如果为true（默认值），则使用Google CDN缓存字体。这通常会更快。如果要使Quartz下载字体以便自包含，请禁用（false）它。 typography ：要使用的字体。Google字体中的任何字体都可以在这里使用。 header ：标题使用的字体 code ：内联和块引用的字体。 body ：所有内容的字体 colors ：控制站点的主题。 light ：页面背景 lightgray ：边框 gray ：图链接，更重的边框 darkgray ：正文文本 dark ：标题文本和图标 secondary ：链接颜色，当前图节点 tertiary ：悬停状态和已访问的图节点 highlight ：内部链接背景，突出显示的文本，代码行 插件\n您可以将Quartz插件视为内容上的一系列转换。\nquartz.config.ts\nplugins: { transformers: [...], filters: [...], emitters: [...], } 变换器（transformers）对内容进行映射（例如，解析frontmatter、生成描述） 过滤器（filters）过滤内容（例如，过滤掉草稿） 发射器（emitters）在内容上减少（例如，创建RSS Feed或列出所有具有特定标签的文件的页面） 您可以通过在transformers、filters和emitters字段中添加、删除和重新排序插件来自定义Quartz的行为。\n注意 每个节点都按顺序由每个变换器修改。某些转换器是位置敏感的，因此您可能需要特别注意它们是在哪些其他插件之前还是之后。\n您应该小心将插件添加到与其插件类型相对应的正确条目中。例如，要添加ExplicitPublish插件（一个过滤器），您将添加以下行：\nquartz.config.ts\nfilters: [ ... Plugin.ExplicitPublish(), ... ], 要删除插件，应从 quartz.config.ts 中删除它的所有出现。\n要进一步自定义插件，一些插件还可能具有自己的配置设置，您可以传递给它们。如果您没有传递配置，则插件将使用其默认设置。\n例如，Latex 插件允许您传递一个字段，指定 renderEngine 以在 Katex 和 MathJax 之间进行选择。\nquartz.config.ts\ntransformers: [ Plugin.FrontMatter(), // 使用默认选项 Plugin.Latex({ renderEngine: \u0026#34;katex\u0026#34; }), // 设置一些自定义选项 ] 某些插件默认包含在 quartz.config.ts 中，但还有更多可用。\n您可以在此处查看所有插件及其配置选项的列表。\n如果您想制作自己的插件，请参阅制作自定义插件指南。\n语法高亮 原文 ↗ 插件/变换器 此插件用于在Quartz中的代码块中添加语法高亮。有关更多信息，请参见语法高亮。\n注意 有关如何添加、删除或配置插件的信息，请参阅配置页面。\n此插件接受以下配置选项：\ntheme：Shikiji 捆绑的主题之一的单独 ID。一个用于浅色模式，一个用于深色模式。默认为 theme: { light: \u0026quot;github-light\u0026quot;, dark: \u0026quot;github-dark\u0026quot; }。 keepBackground：如果设置为 true，则将使用 Shikiji 主题的背景。如果为 false（默认值），则将改用 Quartz 主题颜色作为背景。 此外，您还可以在 quartz/styles/syntax.scss 文件中进一步覆盖颜色。\nAPI\n类别：变换器 函数名称：Plugin.SyntaxHighlighting()。 来源：quartz/plugins/transformers/syntax.ts\nSPA 路由 原文 ↗ 单页面应用程序风格的渲染。这可以防止出现未经样式化的内容闪烁，并提高了 Quartz 的流畅度。\n在底层，这是通过劫持页面导航来完成的，而不是直接通过 GET 请求获取 HTML ，然后使用 micromorph 进行差异化和选择性地替换页面的部分。这使我们能够在不完全刷新页面的情况下更改页面的内容，减少浏览器需要加载的内容量。\n配置 禁用SPA路由：将 quartz.config.ts 中配置的 enableSPA 字段设置为 false。\n","date":"2024-02-29","tags":["编程","quartz"],"title":"Quartz 教程","url":"/post/2024/02/quartz/"},{"content":"C语言系列 《C漏洞与缺陷》 《C语言深度解剖》 《C和指针》 《明解C语言》 C++系列 《高质量的C/C++编程》 《程序员的自我修养》 java系列 《java编程思想》 计算机系列 深入理解计算机系统 数据结构 《大话数据结构》 内存 《地址的故事》 编程 《程序员编程故事》 算法 《剑指offer》 ","date":"2023-11-29","tags":["书"],"title":"C 语言推荐书籍","url":"/post/2023/11/c_book/"},{"content":"技术领导力 《C语言程序设计（第二版）》 《深入理解计算机系统》 《UNIX环境高级编程》 《UNIX网络编程》 《Windows核心编程》 《TCP/IP详解》 每个程序员都应该要读的书 《Code Complete (2nd edition) 》《代码大全》 《The Pragmatic Programmer》 《程序员修炼之道》 《Structure and interpretation of Computer Programs》 《The C Programming Language》 《Introduction to Algorithms 》 《Design Patterns》 《Refactoring: Improving the Design of Exsting Code》 《The Mythical Man Month》 《The Art of Computer Programming》 《Compilers: Principles, Techniques and Tool》 \u0026hellip;\u0026hellip; 推荐 《代码大全》 《程序员修炼之道》 《计算机的构造和解释》 《算法导论》 《设计模式》 《重构》 《人月神话》 《代码整洁之道》 《Effective C++》/《More Effective C++》 《Unix编程艺术》《Unix高级环境编程》 经典文章 《What every computer science major should know》 《LinkedIn\u0026rsquo;s Tips for Highly Effective Code Review》 《A Large-Scale Study of Programming Language and Code Quality in Github》 《Optimizing Software in C++ - Agner Fog》 ","date":"2023-11-29","tags":["经验"],"title":"左耳朵耗子：技术领导力","url":"/post/2023/11/houle/"},{"content":" OpenWRT下载地址 ↗ 下载 制作启动盘 将PE系统写入到U盘，window：rufus，macOS：balenaEtcher 将OpenWRT镜像、rufus（在PE系统上写盘会需要）拷贝到写完的U盘里（也可以用另一个U盘）\n进入BIOS 将U盘插入至路由器，根据硬件选择启动顺序为U盘，笔者的路由器是F12\n删除设备的磁盘分区 进入PE系统之后，打开rufus（按Ctrl-Alt-F开启内部磁盘的识别），选择OpenWRT镜像并将其写入到内置的磁盘\n写入镜像 (IMG写盘工具) 打开IMG写盘工具, 选择设备的物理盘, 选择OpenWrt镜像\n重启 写入完成之后，就可以拔掉U盘，重启后进入OpenWRT了\n其他信息 ip: 一般是: 192.168.5.1, 可以自己改 账号密码: 账号是 root, 密码不填, 直接登录即可\n","date":"2023-10-29","tags":["运维","openwrt"],"title":"OpenWRT 教程","url":"/post/2023/10/openwrt/"},{"content":"25~35岁是每个人最宝贵的时间，应该用在刀刃上\n本质上来说，程序员就是个手艺人，有手艺的人就能做出别人做不出来的东西，而付费就是一件很自然的事了。\n提升方法 要去经历大多数人经历不到的， 要把时间花在那些比较难的地方。 要写文章就写没有人写过的，或者是别人写过，但是自己能写得更好的。 更重要的是， 技术和知识是完全可以变现的。 如何变现 一、积累 千里之行，积于跬步。任何一件事都是通过小成功达到的，所以你得确保自己有一个一个的小成功，具体来说，你得让你身边的人 有求于你，或是向别人推荐你，这就需要你能够掌握大多数人不能掌握的技术，需要你更多地去学习，并要更多的别人没有的经验和经历。\n二、关注有价值的东西 不仅要看到市场，还要看到技术的趋势，能够分辨什么是主流的技术，什么是过渡的技术。以具备先发优势。\n关注市场：看清市场，看到各个公司都在做什么，他们的难题是什么，中国不缺人，缺的是能够解决技术难题的人。 关注技术：看清技术趋势，你需要将一些老技术吃透，并推测出他未来的走向。 所以在学习技术的过程中一定要多问自己两个问题：\n这个技术解决了什么问题？为什么别的同类技术做不到？ 为什么是这样解决的？有没有更好的方式？ 另外还有一种简单的判断方法：\n如果一个新的技术顺应技术发展趋势，那么这个新的技术出现时，后面一定会有大学的商业公司支持，这类公司支持越多，就说明你越需要关注\n三、找到能体现价值的地方 在一家高速发展的公司中，技术人员的价值可以达到最大，这并不是之大型的成熟公司或许新兴的创业公司，前者是因为稳定性大于创新性，而后者是因为业务还没有跑顺，不需要高精尖的技术。\n四、动手能力很重要 在解决任何一个具体问题的时候，有没有动手能力就成为了关键。只有实践了解细节，你才能提出更好或是更靠谱、可以落地的解决方案，二不是一下笼统和模糊的东西。\n五、关注技术付费点 一是能帮别人挣钱，二是能帮别人“省钱”。也就是说，能够帮别人更流畅地挣钱，或是帮别人提供效率，能够节省更多的成本。而且这个技术或是解决方案最好还是别人做不到的。\n六、提升自己的能力和经历 付费的前提是信任只有提升自己的能力和经历后，别人才会对你有一定的信任，才会觉得你靠谱，才会给你机会。\n七、找到有价值的信息源 在信息社会，如果你比别人有更好的信息源，就意味着你可以比别人成长得更快。对于技术人员来说，几乎所有的技术都来自西方时世界，所以你应该走到信息的源头去。 如果你的信息来自朋友圈、微博、知乎、百度、或是今日头条，那么我觉得你完蛋了。因为这些渠道有就价值的信息不多，有营养的可能只有1%，而为了这1%，你需要读完99%的信息，太不划算了。\n那么如何用好信息源呢？用好Google就是一个关键，比如你在Google搜索引擎里输XXX best practice或是Best programming resource你就会找到很多。而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。\n八、输出观点和价值观 只有输出先进的价值观，才会获得真正的影响力，但是你要能输出观点和价值观并不是一件容易的事，这需要你长期的经历和积累，这本质上一个厚积薄发的过程。\n九、朋友圈很重要 你在什么样的朋友圈，就会有什么样的朋友。优质的朋友圈基本都有这样的特性：\n这些人都比较有想法，有观点，经验也比较丰富 这些人涉猎的面都比较广 这些人都有或多或少的成功 这些人都是喜欢折腾喜欢搞事情的人 这些人都对现状有些不满，并想做一些改变 这些人都有一定的影响力 最后有一个冠关键问题：物以类聚，人以群分，你如何才能进入这样的朋友圈呢？ 会挣钱的人一定是会投资的人，我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱宝贵，因为钱不用它还在那里，但是时间你不用你就浪费掉了。 你把时间投资在什么地方，就意味着你未来会走什么样的路。\n所以利用好你的时间，投到一些有意义的地方吧！\n","date":"2023-09-29","tags":["经验"],"title":"左耳朵耗子：程序员","url":"/post/2023/09/coder/"},{"content":" 原文链接 ↗ 查看 CPU 架构 uname -m：该命令会输出当前系统的CPU架构，如x86_64、i386、armv7l等。 arch：该命令可以查看Linux系统的CPU架构。 cat /proc/version：该命令可以查看系统内核的版本信息。 cat /proc/cpuinfo：该命令可以查看CPU信息，如每个物理CPU中core的个数、逻辑CPU的个数、CPU型号等。 脚本目录 ↗ X86_64 架构安装 切换到root账号 sudo -i 下载脚本 wget http://ipkg.nslu2-linux.org/optware-ng/bootstrap/buildroot-x86_64-bootstrap.sh 添加可执行权限 chmod \u0026#43;x buildroot-x86_64-bootstrap.sh 执行脚本 ./buildroot-x86_64-bootstrap.sh 升级ipkg /opt/bin/ipkg update 安装gcc /opt/bin/ipkg install gcc ARM 架构安装 切换到root账号 sudo -i 安装脚本 切换到临时目录，下载一个脚本 buildroot-armeabihf-bootstrap.sh，并添加可执行权限\ncd /volume1/@tmp wget http://ipkg.nslu2-linux.org/optware-ng/bootstrap/buildroot-armeabihf-bootstrap.sh . chmod \u0026#43;x buildroot-armeabihf-bootstrap.sh 执行脚本 ./buildroot-armeabihf-bootstrap.sh 升级ipkg /opt/bin/ipkg update 安装gcc /opt/bin/ipkg install gcc 可选 设置别名\nalias ipkg=/opt/bin/ipkg ","date":"2023-08-29","tags":["编程","群晖"],"title":"群晖开发","url":"/post/2023/08/synology/"},{"content":"浮点数的存储 IEEE745 国际标准：\n任意一个二进制的浮点数可以表示为下面的形式：\nV = (-1)^s^ * M * 2^E^ (-1)^s^表示符号位，当S=0的时候V为正数，当S=1的时候V为负数 M表示有效数字，大于等于1，小于2; 1\u0026lt;= M \u0026lt;2 2^E^：E表示指数位 科学计数法：123.45 = 1.2345 * 10^2^\n举例：\nV = 5.0 f\n二进制：101.0\n科学计数法：1.01 * 2^2^\niEEE：(-1)^0^ * 1.01 * 2^2^\nS = 0; M = 1.01; E = 2\nV = 9.5f\n二进制：1001.1 小数点后面的权重从左往右为2^-1^ ，2^-2^ ， 2^-3^ \u0026hellip;\u0026hellip;表示1/2^1^， 1/2^-2^，1/2^-3^ \u0026hellip;\u0026hellip;即为0.5，0.25， 0.125\u0026hellip;\u0026hellip; 科学计数法：1.0011 * 2^3^ IEEE：(-1)^0^ * 1.0011*2^3^ S = 0; M = 1.0011; E = 3 精度丢失：\nV = 9.6f 二进制：1001.100\u0026hellip;\u0026hellip;(难以精确) float - 4byte - 32bit double - 8byte - 64bit 浮点数在内存中无法精确保存 对与浮点数，最高位的1位是符号位S，接着8位是指数E，剩下23位位有效数字M M：可以写成1.xxxxxx，在计算机内部保存时，默认M的第一位总是1，因此可以被舍去，只保留后面的xxxxx 部分，比如保存1.01时，舍去前面的1，保留后面的01，等到读取的时候再把第一位加上去，这样做的目的是节省一位有效数字，以单精点浮点数为例原本23位有效数字，在舍去一位后可以保存24位 E：为一个无符号整数，如果E为8位，它的取值范围是0-255；如果是11位，它的取值范围是0-2047。但是科学计数法是可以出现负数的（0.5 = 0.1 * 2^-1^ ），因此规定，存入时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E这个中间数是1023，存储值 = E(真实值) + 127(float) / 1023(double) (中间值) 比如：2^10^ 的E时10，所以保存成32位浮点数时，必须保存位10+127=137，即10001001 #include\u0026lt;stdio.h\u0026gt; int main(){ float f = 5.5; //5.5 //101.1 //1.011 * 2^2 ----科学计数法 //S=0; M=1.011; E=2 //0 ----符号位 //2 \u0026#43; 127 = 129 ----有效数字 //129 = 1000 0001 ----二进制 //011 ----指数 //指数位为23位，不够补零 //011 0000000000 0000000000 //内存存储：0 10000001 01100000000000000000000 ---二进制 //内存存储：0100 0000 1011 0000 0000 0000 0000 0000 = 0x40 b0 00 00 ---十六进制 return 0; } //输出 40 b0 00 00 取出：\nE的三种情况\nE不全为0或不全为1时，既有0又有1\n指数的E减去127（或1023），得到真实值，再将有效数字M得前面加上第一位的1\n比如0.5(1/2)的二进制形式为0.1，由于规定正数必须为1，即将小数右移一位，则为1.0 * 2^-1^ 其阶码为 -1+127 = 126表示为01111110，而尾数1.0去掉整数部分为0，补齐到23位00000000000000000000000，则二进制表示为:\n0 011111110 00000000000000000000000 E全为0\n浮点数的指数E等于1-127（或1-1023）即为真实值 有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数，这样做是为了表示+-0，以及接近0的很小的数字 E全为1\n这是，如果有效数字M全为1，表示+-无穷大，正负值取决上符号位的S #include\u0026lt;stdio.h\u0026gt; int main(){ int n = 9; // 00000000 00000000 00000000 00001001---整数的原码，反码，补码相同 // float* pFloat = (float*)\u0026amp;n; printf(\u0026#34;n为：%d\\n\u0026#34;,n);//9 printf(\u0026#34;n为：%f\\n\u0026#34;,*pFloat);// 0.000000无限接近于0的数 // 0 0000000 00000000 00000000 00001001--- // E= -126 \\ // M = 0.000000000000000000000000001001 // \u0026#43;0.000000000000000000000000001001 * 2^-126 // *pFloat = 9.0; //1001.0 // 1.001 * 2^3 // S = 0; E = 3; M = 1.001 //0 10000010 00000000000000000000000 --- 内存存储 printf(\u0026#34;num为：%d\u0026#34;, n); //1091567616 // \u0026#43;1091567616 （正数原码补码相同） //01000001000000000000000000000000 printf(\u0026#34;*pFloat为：\u0026#34;,*pFloat);//9.0 } ","date":"2023-07-29","tags":["编程"],"title":"浮点数的存储","url":"/post/2023/07/float_at_mem/"},{"content":"C/C++\n函数栈帧的创建和销毁\n在学习最基础的C语言程序的语法与使用时，但你是否有疑问？\n比如：\n函数的作用域是怎么形成的呢？\n局部变量是如何创建的？\n为什么未初始化的局部变量的值是随机值或是乱码呢？\n函数是如何传参的？\n传参的顺序又是怎么样的呢？\n形参和实参的关系是什么？\n函数的调用是怎么实现的呢？\n函数调用结束后是怎么返回的呢？\n为什么会存在函数递归的最大深度呢？\n到达最大深度所提出的堆栈溢出错误是什么意思呢？\n当你了解了函数的栈帧创建与销毁的时候，这些疑惑将会一一解开！带着这些问题，我们来进入函数栈帧！\n由于篇幅较长，本系列文章共分为上、下两篇。本篇为上篇，将主要介绍：\n有疑问欢迎在公众号后台回复。\n什么是寄存器？ 什么是栈？ 函数栈帧的形成过程 函数变量的形成过程 了解函数栈帧需要涉及到反汇编操作，笔者会根据相关的汇编指令来介绍。\n圆规正转，进入正题！\n什么是寄存器？ 首先需要了解的：什么是寄存器？\n计算机硬件中，具有存储功能的硬件有什么？\n它们分别是 硬盘 \u0026ndash;\u0026gt; 内存 \u0026ndash;\u0026gt; 高速缓存(cache) \u0026ndash;\u0026gt; 寄存器，它们4个中访问速度和存储速度由上至下不断递增；\n同时，它们的大小是从下至上依次递减的。\n到最顶上的寄存器，它的存储空间可能只有4byte位的存储单元大小，但它的访问速度是最快的，因为寄存器一般是集成在CPU上，与内存是不同的独立的存储空间。\n常言道，网速飞快是坐在服务器上打游戏，而读取速度越快就是坐在CPU上读取，寄存器读取快就是这个道理。\n寄存器分类 计算机的寄存器还分多种，在程序中我们常用到：\n一般寄存器:EAX、EBX、ECX、EDX\nax:累积暂存器，bx:基底暂存器，cx:计数暂存器，ed:资料暂存器\n索引暂存器:ESI、EDI\nsi:来源索引暂存器，di:目的索引暂存器\n堆叠、基底暂存器:ESP、EBP\nsp:堆叠指标暂存器，bp:基底指标暂存器；\n这两个寄存器，也是函数栈帧中最重要的两个寄存器\n其中：\nEAX、ECX、EDX、EBX：\n为ax,bx,cx,dx的延伸，各为32位\nESI、EDI、ESP、EBP：\n为si,di,sp,bp的延伸，各32位\nEAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。\n寄存器用途 那么，它们在程序中的用途是怎么样的呢？\n这些32位的寄存器但每一个都有“专长”，有各自的特别之处。\nEAX 是\u0026quot;累加器\u0026quot;(accumulator), 它是很多加法乘法指令的缺省寄存器。\nEBX 是\u0026quot;基地址\u0026quot;(base)寄存器, 在内存寻址时存放基地址。\nECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。\nEDX 则总是被用来放整数除法产生的余数。\nESI/EDI分别叫做\u0026quot;源/目标索引寄存器，因为在很多字符串操作指令中，其中DS:ESI指向源串，而ES:EDI指向的是目标串。\nEBP是\u0026quot;基址指针\u0026quot;， 它最经常被用作高级语言函数调用的\u0026quot;框架指针\u0026quot;。\n在破解软件时,经常可以看见一个标准的函数起始汇编代码:\npush ebp ;保存当前ebpmov ebp,esp ;EBP设为当前堆栈指针sub esp, xxx ;预留xxx字节给函数临时变量\u0026hellip;.这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp/pop ebp/ret 即可.\nESP 专门用作堆栈指针，被形象地称为栈顶指针。\n堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。\n在32位操作平台上，ESP每次会减少4个字节。\n关于寄存器的概念就说到这。实际运用起来是将内容存到寄存器内而使用其地址。真正与形成函数栈帧有密切关系的是：EBP和ESP这两个寄存器地址。\n什么是\u0026quot;栈\u0026quot;？ 在开始讲解前，需要再注意一个关键词：什么是“栈”？\n栈是一类数据存储结构，本篇不会对其实现方法做太多解释，只需要了解它的一个特性：数据依次放入栈内后，取出元素时顺序是最先进入的元素最后出；\n例如在一个木桶内放入一堆书籍，在你需要取出底部的书时，你需要先把上部分内容取出才能取出最底部的内容。而本篇说的栈区，与我们常说的数据结构是两个概念，函数的栈区是在操作系统级别上的，管理内存区，是主要运行在系统内存之上的。\n函数栈帧的概念 在寄存器内，EBP、ESP这2个寄存器中存放的是地址，这两个寄存器的指针是用来维护函数栈帧的。而这两个指针维护的内存空间就是一个函数的栈帧。\n每一次函数调用时，都需要在栈区内创建一个空间，而创建的过程就是由这两个指针去实现的；调用了哪个函数，EBP、ESP两个指针地址就会去维护这个函数的内存空间，这就是函数的栈帧；例如main函数在运行过程的当中，esp和ebp两个指针地址会位于函数的它的栈顶和栈底。\n这么说，你可能会不理解。那就画图吧！\n可以看到的是，esp和ebp两个指针地址会位于函数的它的栈顶和栈底，维护属于main函数的内存空间，而esp和ebp形成的这一块空间就是函数的栈帧。\n那么，再回到前面的话题，变量、作用域、函数调用和返回等操作又是如何实现的呢？我们需要来进一步了解函数压栈的过程、\n函数压栈的过程 本篇将以本段代码进行举例，以此来介绍函数的栈帧、局部变量和函数调用的生成与销毁的过程。\n在开始讲解前，我们需要了解的一点是，因为不同的编译器对于程序汇编封装的方法可能是不同的，而更高阶的编译器对于程序的封装会更加细致，不利于观察，所以本处我会使用VS2013版本演示函数压栈的过程，并且会带着你一块一步步的读程序运行中的汇编指令并讲解每一个步骤会做出什么样的操作，最后会对整个指令进行一个总结。\n本篇中，我将结合C语言X86(32位)代码生成细节的汇编指令文档来讲解本篇的汇编指令，以下是将会常用到的汇编语句。\n同时，因为汇编指令的地址会随着每次程序编译而变化（因为内容都是随机分配的），如果你在本地也在进行调试时，请保持在同一个编译情景下以免出现前后差异。但原理上都是相通的。\n（观察方式：运行程序-\u0026gt;调试-\u0026gt;反汇编，观察变化需要开启内存空间监视器。）\n需要说明的是，C语言标准中不允许main函数被调用，但是在VS2013之前的版本中，运行程序调试时查看调用堆栈时会发现main函数也是被其他函数调用的。\n分别是__tmainCRTStartup和mainCRTStartup函数，其中，mainCRTStartup压在最底部。\n调用逻辑是mainCRTStartup \u0026ndash; \u0026gt; __tmainCRTStartup \u0026ndash;\u0026gt; main 函数\n当我们开始运行程序时，main函数被调用，栈帧区的建立过程应该是这样的。\n栈帧区的建立过程 mainCRTStartup函数运行__tmainCRTStartup函数\n__tmainCRTStartup函数调用main函数\n根据我们刚刚说的，先运行的会被先压入函数栈的最底部，以此摞下去\n由此，我们可以理解此时的内存栈表示为\n我们刚刚说的，当函数在运行过程当中，会用esp栈顶指针和ebp栈底指针形成一块内存空间而形成函数的栈帧。那么，程序具体是怎么做的呢？\n下面，我们通过查看程序的反汇编的指令来研究它的压栈过程。以下是主函数的部分反汇编代码，现在我们来看看它的具体原理是如何走的。\n主函数汇编指令 (部分)\n我们刚刚提到主函数也是被其他函数调用的，当程序进入主函数时，那这个调用主函数的函数是不是已经创建起它的函数栈帧了呢？答案是肯定的。此时原函数__tmainCRTStartup 是被esp和ebp两个栈顶/底指针维护的。\n最初开始时的栈区应该如图所示\n一、构建函数栈帧准备 (一) 接下来我们来看main函数进来的第一句汇编指令\n进来的第一句话就是push ebp，汇编指令中，它的意思是把ebp的值放到栈顶\n那么我们可不可以假设：因为esp维护的是程序的栈顶，此时的esp已经跑到了栈的最顶部，esp的地址会指向ebp的值？如图所示\n该如何论证这个假设呢？\n当你去开启监视器去监控esp就可以发现它的值会变动。\n当前是esp栈顶指针的初始值\npush ebp完成后，esp地址是不是由高到低，所以地址应该是减小吧？\n监视器进入逐过程时就可以证明这个道理：a8 到 a4 减少了4个字节\n那么esp的值会不会是ebp的值呢？打开内存块，搜索新的esp的地址会是ebp的值，答案一目了然！~\n刚刚ebp的值时多少？008ffbf4, 现在搜索esp的地址的值就是008ffbf4，假设成立。\nesp维护的是程序的栈顶，此时的esp已经跑到了栈的最顶部，新的esp的地址会指向ebp的值\n而压入的这个ebp是调用函数的ebp，它的作用是什么？我们到下一章会进行讲解。\n二、构建函数栈帧准备 (二) 现在我们再来看第二句汇编指令：mov 把esp的值给到ebp。\n事实果真如此吗？我们运行调试下一步，监控器反馈如下\n此时它的栈区示意图应该是\n三、构建函数栈帧的范围 再来看第三句会汇编指令：sub esp的地址，减去0E4h。（sub是英文中减少的意思，add同理为加上）\n通常来说，ebp减去的值都是0E4h，而这里的0E4h实际上是一个八进制的数字。当你想查看0E4h是一个什么数字时，你可以将它放入监控区后可以显示其十六进制的值，再查看十进制数字\n走到这里，不就是相当于esp减去了0E4h的值吧？那此时的esp会不会已经发生变化了呢？监视器逐过程查看结果\n此时的esp的值已经变成了0x008ffac0，相当于esp的地址值变小上移不再指向原来的地方，而是指向原地址上方某一块区域内。\n这个时候你有没有发现，新的esp栈顶和ebp栈顶指针在进入main函数后已经形成的一块新的维度空间，并且esp和ebp不再是维护原来的函数空间了呢？没错，这一块新的区域就是为main函数预开辟的函数栈帧区。而sub就是提出为main函数开辟的多少字节空间。\n栈区示意图可以理解成下面这张图\n四、放入三个非易失寄存器\n这里的ebx、esi、edi是我们前面所说的寄存器中基底、来源索引、目标索引暂存器，它们三个在这里统称为非易失寄存器。这是一个C语言中的调用约定，这里将三个寄存器压栈的原因就是实现跨平台使用。在X86平台下的调用约定下这3个寄存器用途在于，调用函数时要求压入这3个寄存器以此用来保存调用前的数据，应在调用期间长期存储。\n它们此处是在入栈操作，别忘了入栈的同时，esp栈顶指针也在不断的变化。\n入栈的过程详情可以如下：\n观察监视器内esp和ebx的值\nebx开始压入栈时，esp会如何变化呢？答案是肯定的，esp的值会递减向上挪动\n打开内存器时，会发现对应esp的地址是ebx的值0x007e5000\n同理继续往里压入esi时，esp的变化如下\n压入edi时，esp的变化如下\n综上，原来的esp栈顶指针的值已经由最初的008ffac0变成现在的008ffab4，地址在不断的减小，栈顶在不断的上移。\n现在的栈区的示意图可以理解为 五、加载栈帧有效空间 到了这里为了方便直观感受与理解，我们会显示汇编符号名。 到了第七句这里的lea语句，它的全名应该是load effective address(**加载有效地址**)；顾名思义，从此处开始，程序会正式加载当前函数的有效栈帧区域。我们来看看它该如何走吧。 lea edi, [ebp-0E4h]，这里的0E4h是不是很眼熟？没错，就是刚刚在预申请main函数的函数栈帧中所预申请的大小。 在这里的意思就是将ebp - 0E4h大小的空间存到edi当中去，而ebp-0E4h这块空间就是刚刚esp做减法转移动作使的空间位置，同时这个edi不就是栈顶指针指的寄存器吗？ 由栈区图，我们可以观察到如下情景。 如何论证呢？翻到刚刚前面的三个非易失寄存器未压入栈时esp的地址 现在，我们打开监视器查看ebp-0E4h和edi的地址，答案显而易见！~ebp-0E4h的地址就是当前esp所指的第3个栈——edi的位置，也是三个非易失寄存器未压入栈时esp的地址。 再接着，mov ecx,39h和mov eax,0CCCCCCCCh意思分别是，把39h次和0CCCCCCCCh分别放在ecx, eax寄存器内。 **这里可能会有点绕，但真正起作用的应该是下一句！** 下一句：rep stos dword ptr es:[edi] ，这里就非常有意思，此处会最终形成函数的栈帧有效空间。来看看指令语句的表述：\n从**edi**内所标记的ebp-0E4h处(**低地址**)开始向高地址重复**拷贝ecx次eax的内容**，直到**栈底指针ebp处**(高地址)。需要注意的是，**dword表达的是double word双字节的意思**，假设一个word是2个字节，**double word就是双字节等同于4字节**。 它们的具体流程是什么样的呢？**从edi所标记的ebp-0E4h处开始，向高地址的部分进行字节拷贝，每一次拷贝4个字节。拷贝的内容就是eax的内容（0CCCCCCCCh），拷贝次数为39h次，到栈底指针ebp处停止**。 根据上面的描述，程序会从ebp-0E4h（内存地址：008ffac0）处开始往高地址进行字节拷贝 直到ebp栈底指针处；当你打开内存图查看此时的内存情况时，就可以论证这一个观点~ 从008ffac0出开始向高地址拷贝\n到008ffba4栈底指针处结束 可能你会有疑问，这个cccccccc是什么意思呢？它们在各个编译器可能都有些许不同，而当我们平时在编写程序时，**变量未定义初始值时，打印输出来的是“烫烫烫”乱码字符，实际上这就是内存中放的0CCCCCCCCh字符**。 综上，栈区的示意图可以如下\n程序运行到这里，程序历经五步，为main函数开辟的函数栈帧正式完成，这一块由esp和ebp共同维护形成的区域就是一个函数的栈帧，形成完成后会往一块空间内填入39h次的0CCCCCCCCh字符，而这里面的内容能做什么？函数如何调用和返回，会在下一章进行讲解 生成函数的局部变量\n由上面的诸多操作下来，一个函数的有效栈帧区已经形成，此时程序才会真正执行它的有效代码。根据之前写的代码要求，程序一进来会创建局部变量，在栈帧区内，局部变量又是如何被创建的呢？\n首先我们来看汇编指令：这个语法是不是很熟悉呢？语句的的意思是：依次的将0Ah、14h、0放入到\nebp - 8、ebp - 14h、ebp - 20h 位置处。\nebp - 8、ebp - 14h、ebp - 20h是以栈底指针为基准向低地址减小的一串地址，在这里就是开辟一块空间分配给0Ah、14h、0 ，而这个0Ah、14h、0 就是计算机的十六进制的10、20、0的表达形式。所\n现在我们来论证刚刚所说的。首先来继续观察ebp栈底指针的值，看它是不是往低地址存放变量；\n逐过程进入语句，答案很明显，从栈底指针008ffba4处往低地址 - 8处，存放的值就是0ah。此时局部变量a = 10已创建\n我们继续看下一步，创建局部变量 b = 20，后面的c同理。\n根据观察在栈帧中局部变量的创建过程，我们可以发现局部变量是在形成一片有效的栈帧空间后，由高地址向低地址存放。如果变量未设置初始值时，程序会划定好一块区域规定为该变量的地址。\n此时的栈区示意图可以如下\n本节小节 本篇我们基于main主函数简单介绍了一个函数的栈帧建立的基本过程；我们了解到，一个函数的栈帧实际上是由esp和ebp两个栈顶和栈底指针共同维护的一片内存空间；当一个函数在开始生成栈帧以后，会首先压入上一个函数的栈底指针ebp地址。在生成栈帧过程中，不断扩大的栈帧、压入新的内容或寄存器都会使得esp栈顶指针向上偏移；在进行确定方位相关操作时，都是以栈底指针ebp的位置作为偏移量向低地址开始偏移的。在压入3个非易失寄存器后，程序会基于ebp栈顶指针向低地址的填充一块区域，而这块区域就是一个函数的作用域。在这块作用域中，程序会根据ebp指针向上（低地址）作为方位，生成对应的变量。 下一篇，我们将会介绍函数的调用与返回过程，以及对我们开篇提出的问题做出一个总结。\nC/C++：函数栈帧的创建与销毁(下) 上一篇中，我们介绍了什么是寄存器、已经一个函数栈帧创建的基本过程和函数变量和作用域是如何生成的。那么本篇我们将继续上一篇内容，继续介绍函数的调用过程以及函数返回值，以及函数栈帧销毁的过程。最后，我们会对整个过程以及相关知识点进行一个总结。\n生成函数的局部变量 由上面的诸多操作下来，一个函数的有效栈帧区已经形成，此时程序才会真正执行它的有效代码。根据之前写的代码要求，程序一进来会创建局部变量，在栈帧区内，局部变量又是如何被创建的呢？\n首先我们来看汇编指令：这个语法是不是很熟悉呢？语句的的意思是：依次的将0Ah、14h、0放入到\nebp - 8、ebp - 14h、ebp - 20h 位置处。\nebp - 8、ebp - 14h、ebp - 20h是以栈底指针为基准向低地址减小的一串地址，在这里就是开辟一块空间分配给0Ah、14h、0 ，而这个0Ah、14h、0 就是计算机的十六进制的10、20、0的表达形式。所\n现在我们来论证刚刚所说的。首先来继续观察ebp栈底指针的值，看它是不是往低地址存放变量；\n逐过程进入语句，答案很明显，从栈底指针008ffba4处往低地址 - 8处，存放的值就是0ah。此时局部变量a = 10已创建\n我们继续看下一步，创建局部变量 b = 20，后面的c同理。\n根据观察在栈帧中局部变量的创建过程，我们可以发现局部变量是在形成一片有效的栈帧空间后，由高地址向低地址存放。如果变量未设置初始值时，程序会划定好一块区域规定为该变量的地址。\n此时的栈区示意图可以如下\n函数调用与传参过程 上面已经完成了局部变量的创建，那程序的调用函数操作时如何进行的呢？接下来我们来看一看！废话不多说，先看汇编指令：\n前面讲解了这么多汇编指令，到这里看到的指令是不是开始按捺不住跳动的DNA了呢（bu）？能不能直接说出它们都做了什么呢？ 第一、第三句的mov，含义是将ebp-14h和ebp-8分别放到eax和ecx当中去，我们翻到上一步，看看 ebp-14h和ebp-8是什么呢？根据栈底指针向低地址偏移观察可以看到，没错，就是我们a和b的值。这里是将a和b分别放入寄存器eax和ecx中去。 第二、第四局中的push，是压入栈的指令。分别将eax和ecx压入栈(别忘了每一次压入栈时，程序的栈顶指针也在变化哦)，而eax和ecx现在里面是什么呢？不就是a和b的值吗？ 此时顶部栈区的示意图应该如下\n通过示例函数中我们可以看到。这4个动作是不是很像在进行传参前的准备呢？答案是确定的。那这样的放入和压入操作真的可以把参数传入函数嘛？调用函数又是如何使用我们的参数的呢？让我们继续往下看！\n第五句，call实际上是一个转移指令，转移到另外一个区域内，同时为了执行转移后完成原区域的下一条指令，call指令会总是会将下一条指令压入栈区中，以此实现转移区内指令完成后返回至原地（简单来 说，原地插个眼后传送去支援，最后还能传送回到线上。做到有去有回）。到这里，我们知道call指令会将原区域内的下一个指令的地址压入栈，所以栈顶应该就是下一条指令（00C21450） 的地址，打开内存和监视器确认果真如此 继续看，call指令的右边的一串标识，实际是call的“传送”位置，这个时候我们按下调试的F11进入到声明处，会看到声明处的指令。这里的jmp，就是跳入add函数当中去（本处只需了解jmp也是个转移操作，会在后续深挖细节） 接下来，我们继续往下走，欢迎来到Add函数的内部！！\n到这里函数的调用和传参操作已经完成了，我们可以总结出来的是： 传参时：程序在传参前会把要传入的参数先放入到寄存器当中，并将寄存器地址压入栈中。再观察他们的顺序 a-\u0026gt;b，是由左往右依次压入栈的（示意图显示b在上，根据栈的先进后出原则证明b是后进的），同时栈顶指针在时刻变化。 调用函数时：在调用函数时，程序会使用call指令进入函数，call指令首先会将调用函数完成后的下一步指令压入栈区中，以此实现调用后返回至原函数继续执行内容的操作，接着就会根据标识进行转移，最后进入到新的函数中。 此时栈区顶部示意图应该如下：\n新函数的栈帧的生成 进入到Add函数内，观察到参数z形成前的所有代码，是不是有一种恍然之间中遇见梦中的那个TA的一般的感觉呢？ 没错，这里是在将Add函数基础元素压入栈区并形成其作用域，最后生成这个函数内的局部变量； 这里唯一需要提醒的一点是，我们前面所提到的esp和ebp是用来维护当前运行函数的指针，而push ebp处，实际上是压入main函数的ebp栈底指针地址，以此实现ebp的转移以及函数运行完成后ebp返回原处。\n下面一部分就是形成有效的Add函数栈帧区了，由此可以得到栈顶区域的示意图（画完才发现有点粉\u0026hellip;\u0026hellip;\n粉色即正义！）\n接下来，我们来观察新函数内是如何使用传入进来的参数的。\n函数形参的使用 在开始学习C语言程序时，我们之前一直知道一个函数传参的理论：形参是实参的一份临时拷贝。现在我们来看看它是怎么执行的！ 话不多说，上汇编指令！\n观察这段汇编指令，ebp+8, ebp+0Ch，顺应十六进制转化就是ebp+8和ebp+12，结合当前ebp所指向的位置翻看栈帧区，这两个位置指向的是哪里呢？\n没错，就是进入函数前就已经早早压入栈的函数形参。形参和实参在栈上是两个独立的个体存在，形参的改变不会影响到原来实参的改变，所以有形参是实参的一份临时拷贝。\n汇编指令处，mov 会把ebp+8(a)的值放入寄存器eax中，add会把ebp+12(b)的值加进寄存器eax当中去，这也是程序实现加法的原理。\n再看下一条，mov 将寄存器eax内的值放入到ebp-8的位置，ebp-8是什么？ebp-8就是z的值！此时它已经从0变成了30。\n到这里我们可以看到，在一个函数内，形参是实参的一份临时拷贝，因为程序是不会主动创建的形参 的，在我们调用这个函数之前程序就已经早早把将会用到的形参压入到栈上的，程序只要往前面去拿就可以拿到想要的形参值。这就是函数的形参使用原理。\n函数返回值与函数返回的实现 栈帧销毁的过程） 我们前面看到，程序会把a+b的值结果赋值给z，再将z返回。按照我们之前所学的，程序会在出作用域内会将局部变量销毁，而z又是在新函数内临时生成的局部变量，那程序又是如何拿到z的返回值的呢？而程序在运行结束后，又是怎么将esp和ebp两个栈顶和栈顶指针回到原位，程序又是如何回到原函数内的下一条指令的呢？\n接下来，我们继续通过汇编指令回答这一个问题。\n前面带着你看了那么多汇编指令，现在5秒钟时间可以回到我第一句汇编指令是什么意思吗？5...4...3...2...1，答案没错，就是把ebp-8的值放入到eax当中去。而ebp-8的值就是刚刚z的位置，那么我们可以得到，函数的返回值，通常会放入到临时存放到寄存器eax当中去（为什么叫通常，因为超出寄存器大小时会借用其他的寄存器，比如esi） 再继续往下看，pop指令是什么意思呢（英文含义是什么）？pop指令出栈的意思，将元素弹出栈区以此释放掉。这里连续的3个pop，想想这是啥？是一个函数顶上的3个非易失寄存器。当函数要返回结束时，这3个寄存器会被弹出去。需要注意一点，弹出栈时esp的位置也在调整（向高地址挪动相加） 弹出栈前esp和ebp的值\n弹出3个寄存器地址完成后。\n程序要结束弹出栈区了，那我的esp和ebp指针是不是也要回到原地了呢？来下一句的mov esp,ebp，就是在调整esp和ebp的位置，将ebp的值给到esp。\n此时，程序pop掉add函数内的ebp，这里的ebp是在进入Add函数时压入的栈的main函数ebp，那它是如何返回的呢？这需要提到pop指令的一个用法，pop指令可以实现用一个寄存器接收出栈的数据，此处的pop实际上就是将Add函数的ebp弹出后，又获取到原来压到栈上的main函数的ebp，做到ebp的跳转，这就是此处的pop ebp的作用。 到下面的ret，就比较有意思了。ret是什么意思呢？ret是将栈顶字单元出栈，其值赋给IP寄存器，实现了一个程序的转移。在汇编语言中，IP寄存器是表示即将执行的下一条指令的段内偏移地址。那现在栈顶元素是什么呢？\n还记得现在栈顶的这个（00C21450）元素是什么嘛？如果不太了解，答案在这！这是在调用函数前，程序预留的call指令的下一条指令的地址。通过ret指令，程序已经回到main函数内部了。 到此，程序栈区示意图可以如下图\n综上所述我们可以了解到：\n函数返回值的操作是，会暂时将返回值放入到寄存器eax当中去；\n当函数运行即将返回时，程序首先会销毁当前函数的局部变量，随后悔将放置在函数栈帧上的3个非易失寄存器以此由上至下弹出栈区；\n紧接着程序会把当前栈底指针的ebp的值，赋值给栈顶指针esp，栈帧区的收缩调整，以此实现销毁一个函数的栈帧；与此同时，程序会读取曾经存储在栈区上原函数的ebp的地址（当前位于栈顶），并将ebp转移至之前记录的地址上，之后再弹出压在栈上原函数ebp的地址元素，实现ebp返回至原函数内。\n最后，程序会进行ret 操作，目的是读取调用函数前压在栈上的下一条指令的地址，以此实现调用函数后返回至原函数还能继续执行指令的操作。\n根据以上步骤，可得当前栈区示意图\n返回后形参的销毁与原函数获取返回值 前面我们提到，形参并非是在新函数栈帧区内创建的，而是临时拷贝一份实参后压在栈上的元素。当函数运行完成后，它的形参又该如何销毁的呢？通过前面的许多步骤和观察上方的函数当前栈帧示意图，现在开动你聪明的大脑思考形参会如何处理时一定会有所思路吧！或许你的思路和答案完全一致，就是弹出栈区。 本处只会讲到两句指令。话不多说，上才（hui）艺（bian）！ 现在大声告诉我！add esp,8是什么意思？ 答案就是，esp向高地址出挪上8个字节，而我们前面说一个32位机器上一个栈帧元素是4个字节，那现在向高地址挪动8个字节，不就是把原来存放在栈帧上的2个形参的空间给销毁了么？一个函数的形参销毁的答案就是如此，不接受任何反驳QWQ！~\n到现在，我们程序也返回了，形参也销毁了，返回值说：“我呢？我呢？”别急，再看下一句，说说看这句话是什么意思呢？ 答案：把eax里面的值放到ebp-20h处。\n而eax刚刚不就是放的是Add函数的返回值么？到ebp-20h处，我们刚刚提到，ebp已经返回到原函数了，而ebp-20h所指向的区域就是我们之前所声明的变量c的内存空间。这样，一个函数的返回值从返回处获取到原函数的方式就是先把返回值放到eax寄存器内，返回至原函数后再从eax里拿到这个返回值。\n根据示例代码剩余的内容无非剩下主函数退出和printf输出。不再做过多赘述。\n函数栈帧创建与销毁过程总结 到这里，一个程序的函数栈帧的形成和销毁的全过程就讲解结束啦~你可能会感觉到云里雾里和蒙圈。那现在来带你一点点的回顾整个过程并做出相应的总结吧。 函数栈帧可以追溯到最顶层的三个非易失寄存器顶上，也可以**将edi所标记的ebp-0E4h处开始向高地址填充内容的区域叫做函数栈帧的有效区域**。当真正有效意义上的栈帧应该是除去三个非易失寄存器的。 函数栈帧创建可以分为3步： 第一步：一个函数在准备调用前会做的第一件事是什么呢？先插眼！程序会首先把当前运行的函数的ebp地址压到内存栈上，以此实现函数运行完成后ebp能返回到调用前的ebp原处。如果是调用普通函数（非main函数），还会压入下一条指令的地址做到调用完后继续执行。同时，因为压入了新的数据，所以esp栈顶指针也会随之上浮挪动，随后ebp栈底指针也会移动到esp栈顶指针处，此时esp和ebp两个指针同处在栈顶区域。\n第二步：程序会发出sub 地址减法指令，指示esp向低地址偏移一片区域。esp偏移到新的区域后与当前ebp栈顶指针形成的一片新的内存空间就是这个函数的栈帧区，这也是函数的作用域。随后程序会压入3个非易失寄存器eax,esi,edi，这3个寄存器是一个调用约定（为了能够在不同平台运行）。\n第三步：程序由ebp栈底指针位置为基准发出lea指令，目的是加载一个函数栈帧的有效空间，通常会向低地址偏移0E4H个空间单位直至前面压入的ebx寄存器之下，并在这个空间内填满字符 0CCCCCCCCh，最终这个加载出来的有效空间就是一个函数真正意义上的栈帧有效空间，而这一片由0CCCCCCCCh字符填满的空间就是这个函数的作用域。现在，一个函数的栈帧才真正意义上是完整的。而这时候程序才开始执行它的有效代码。\n函数栈帧的销毁和返回同样可以分为3步： 第一步：程序会首先会将函数内的局部变量给弹出栈，如果程序有返回值，会把返回值暂时放入寄存器eax当中。随后会将栈顶上的非易失寄存器ebx、esi、edi弹出。\n第二步：程序将当前栈底指针的ebp的值，赋值给栈顶指针esp，将esp下移后的释放的那一片空间就是函数的栈帧区。\n第三步：如果还有下一条指令，程序会读取曾经存储在栈区上原函数的ebp的地址，并将ebp转移至之前记录的地址上，实现ebp返回至原函数内，之后再弹出压在栈上原函数ebp的地址元素。最后，程序读取压在栈上的下一条指令的地址，读取完成后弹出栈区，执行下一条指令。\n无论程序做出什么指令，最需要记住的原则就是：无论取多少偏移量，都是以栈底的ebp指针位置为基准；无论压入什么内容，栈顶的esp指针都要跟着向上偏移。\n我们回到前篇我们提出的几个问题，学习完函数栈帧就已经把这些问题都能一一回答了吧！现在来大声告诉我答案吧！！\n问: 函数的作用域是怎么形成的呢？\n答: 一个函数的栈帧就是一个函数的作用域。\n问: 局部变量是如何创建的？\n答: 程序在发出lea（load effective address)指令后开始绘制这个函数的定义域后，开始以底部的 ebp栈底指针为标准不断向低地址划定区域，并将这块区域赋予十六进制的值，这个过程就是局部变量创建的过程。\n问: 为什么未初始化的局部变量的值是随机值或是乱码呢？\n答: 程序在发出lea（load effective address)指令后开始绘制这个函数的定义域并分配好局部变量，因为该区域的初始字符均为0CCCCCCCCh，所以此时打印出来的值多数情况下都是 0CCCCCCCCh的表达形式。\n问: 函数是如何传参的？传参的顺序又是怎么样的呢？\n答: 程序在传参前会把要传入的参数先放入到寄存器当中，并将寄存器地址压入栈中。再观察他们的顺序 a-\u0026gt;b，所以有函数传参是由左往右依次压入栈的（示意图显示b在上，根据栈的先进后出原则证明b是后进的）.\n问: 形参和实参的关系是什么？\n答: 在调用函数内，任何新产生的局部变量会在调用函数的栈帧区内创建，而使用形参的方法实际上是回到当前函数栈帧创建前压入栈上的形参数据。正因为形参和实参在栈上是两个独立个体的存在，形参的改变不会影响到原来实参，所以才有形参是实参的一份临时拷贝。\n问: 函数的调用是怎么实现的呢？\n答: 在开始调用函数前，程序会把需要用到的函数形参提前压到栈。在调用一个函数时，程序会首先压入下一条指令和当前函数的ebp的地址进入栈区内，以此实现调用完成后程序继续执行与ebp返回原处。随后就开始以栈顶位置为起始并同时压入3个非易失寄存器形成一个完整的函数栈帧区。一个函数调用过程正是如此。\n问: 函数调用结束后是怎么返回的呢？\n答: 当被调用函数的栈帧被销毁后，程序会读取曾经存储在栈区上原函数的ebp的地址，并将ebp转移至之前记录的地址上，实现ebp返回至原函数内，之后再弹出压在栈上原函数ebp的地址元 素。最后，程序读取压在栈上的下一条指令的地址，读取完成后弹出栈区，执行下一条指令。\n问: 为什么会存在函数递归的最大深度呢？到达最大深度所提出的堆栈溢出错误是什么意思呢？\n答: 函数的递归之所以有最大深度，是因为每个函数都存在函数栈帧，在每次调用时都会生成对应的栈空间，并有esp与ebp两个栈顶和栈底指针维护。受到了栈空间的限制，如果递归深度超出栈所能承受的空间，此时就会出现最大深度的堆栈溢出的警告。而不同的函数深度可能会有所不同，毕竟每个函数所需要的栈空间是不一样的。\n函数栈帧的创建与销毁（深入了解c的汇编代码） 基础知识介绍 从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。首先应该明白， 栈是从高地址向低地址延伸 的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址)。 从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。首先应该明白，栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址)。\n1.寄存器的种类与功能 寄存器名称 功能 eax 累加寄存器，相对于其他寄存器，在运算方面比较常用。 ebx 基地址寄存器，在内存寻址时存放基地址。 ecx 计数寄存器，用于循环操作，比如重复的字符存储操作，或者数字统计。 edx 作为EAX的溢出寄存器，总是被用来放整数除法产生的余数。 esp 栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，esp也就越来越小。在32位平台上，esp每次减少4字节。栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。是CPU机制决定的，push、pop指令会自动调整esp的值。 ebp 指栈的栈底指针。基址指针寄存器(extended base pointer)，一般与esp配合使用，可以存取某时刻的esp，这个时刻就是进入一个函数内后，CPU会将esp的值赋给ebp，此时就可以通过ebp对栈进行操作，比如获取函数参数，局部变量等。其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。 2. 常用汇编指令 push指令：他首先减少esp的值，再将源操作数复制到栈地址，在位平台上，esp每次减少4个字节\n\u0026nbsp;\n解释：首先esp的值减少4个字节，再将ebp的值压入栈中；\npop指令：它首先把 esp 指向的栈元素内容复制到一个操作数中，再增加 esp 的值。在32位平台上， esp 每次增加4字节。 解释：首先将 esp 所指地址处的值赋给 edi ，再将 esp 的值减少4字节。 mov指令：用于将一个数据从源地址传送到目标地址，源操作地址的内容不变。 解释：将esp 值赋给ebp，这里并不是将esp所指向的内存空间的值赋给 ebp\nsub指令：减操作指令，从寄存器中减去\u0026lt;shifter_operand\u0026gt;表示的数值，并将结果保存到目标寄存器中。\n解释：esp-0E4h字节的结果保存在esp中。\n下面这张图片的指令一般是一起集中出现，所以我集中解释一下：\n解释：rep指令：重复其上面的指令，ecx的值是重复的次数，每执行一次，ecx 减 1，直到 ecx 减至0。stos指令：将 eax中的值拷贝到es:[edi]指向的地址。dword：双字 就是四个字节。ptr：pointer缩写 即指针[ ]里的数据是一个地址值，这个地址指向一个双字型数据一次拷贝双字（4个字节)的数据到目的地址。es:[edi]：指向目的串解释：合起来的意思就是，将栈上从 ebp-0E4h开始的位置，向高地址方向的内存赋值 0CCCCCCCCh，重复 39h 次，每次赋值双字（四字节的空间）。\ncall指令 ：将程序下一条指令的位置的IP压入堆栈中，并转移到调用的子程序。 解释：将下一条指令的IP（00BF1A30)压入栈中，并移动到调用的子程序。\nadd指令 ：用于将两个运算子相加，并将结果写入第一个运算子。 解释：给 esp 加8，也就是 esp 向高地址方向移动 8字节 ，相当于 pop 操作后的指针变化。 ret指令 ：用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。 解释：执行这条命令之后，就自动返回刚才call指令的下一行。 3. 内存模型 图片来源：CNDN作来源csdn：三•九《函数栈帧的创建和销毁（图解)》 对于初学者，只需要简单理解为：\n演示函数栈帧的创建销毁过程 首先来看下这次演示使用的代码：\n\u0026nbsp;\n#include \u0026lt;stdio.h\u0026gt; int Add(int x, int y) { int z = 0; z = x + y; return z; } int main() { int a = 10; int b = 20; int c = 0;\nc = Add(a, b);\nprintf(\u0026quot;%d\\n\u0026quot;, c); return 0; } 按下F10，在视图中打开调用堆栈窗口，我们发现 main() 函数被调用了。 但是 main() 函数被谁调用了呢？ 当我们接着调试到 return 0; 之后，再按F10，我们发现程序跳转到了调用 main() 函数的函数内 原来 main() 函数是被 __tmainCRTStartup 函数调用的，而 __tmainCRTStartup 又是被 mainCRTStartup 调用的。 分步骤演示函数栈帧的创建和销毁的过程。 为main()函数开辟栈帧 \u0026nbsp;\n在main()函数中创建变量 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解）》\n调用Add()函数前的准备 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解）》\n\u0026nbsp;\n为Add()函数开辟栈帧 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解)》 \u0026nbsp;\n在Add()函数中创建变量并运算 图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解)》 6.Add()栈帧的销毁\n图片来源：CNDN作者：三•九《函数栈帧的创建和销毁（图解)》 返回main()函数栈帧 可以看到这里返回到了第3步(3. 调用Add()函数前的准备)，最后指令 call 的下一条指令。 接下来的一系列mian函数的销毁与ADD函数销毁相似，不做过多赘述。\n\u0026nbsp;\n\u0026nbsp;\n思考问题： 局部变量是怎么创建的？ 为什么局部变量的值是随机值？ 函数是怎么传参的？传参的顺序是怎样的？ 形参和实参是什么关系？ 函数调用是怎么做的？ 函数调用是结束后怎么返回的？ ","date":"2023-07-15","tags":["编程","c","cpp"],"title":"函数栈帧的创建和销毁","url":"/post/2023/07/function_stack/"},{"content":"结构体内存对齐 #include \u0026lt;stdio.h\u0026gt; struct S1{ char c1;//1 int i;//4 char c2;//1 }; struct S2{ char c1;//1 char c2;//1 int i;//4 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S1));//12 printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S2));//8 return 0; } 对齐规则：\n第一个成员在与结构体变量偏移量为0的地址处\n其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处 对齐数 = 编译默认的一个对齐数与该成员大小的较小值。 vs中默认是8\n(即：第二个成员和编译器的默认对齐数比较大小,第三个成员和编译器的默认对齐数比较大小,第四个成员和编译器的默认对齐数比较大小\u0026hellip;..)\n结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍\n如果嵌套了结构体的情况，嵌套结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体对齐数）的整数倍。\n如果编译器没有默认对齐数，那么大小就是成员的自身大小\nS1\nstruct S1{ char c1;//1 int i;//4 char c2;//1 }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 结构体成员 c1 \\ \\ \\ i i i i c2 \\ \\ \\ c1 为char类型，占用1个字节；\ni 为int类型，占用4个字节；\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S1{ char c1;//1 int i;//4 char c2;//1 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S1));//12 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S1,c1));//0 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S1,i));//4 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S1,c2));//8 返回结构体成员在这个类型中的偏移量 return 0; } S2\nstruct S2{ char c1;//1 char c2;//1 int i;//4 }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 结构体成员 c1 c2 \\ \\ i i i i 结构体总大小为最大对齐数（每个成员变量都一个对齐数）的整数倍：最后的i放入后已经是整数倍了，不用偏移\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S2{ char c1;//1 char c2;//1 int i;//4 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S2));//8 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S2,c1));//0 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S2,c2));//1 返回结构体成员在这个类型中的偏移量 printf(\u0026#34;%d\\n\u0026#34;,offsetof(struct S2,i));//4 返回结构体成员在这个类型中的偏移量 return 0; } 嵌套\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S3{ double d;//8 char c;//1 int i;//4 }; struct S4{ char c1;//1 struct S3 s3; double d; }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S3)); printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S4)); return 0; } S3\nstruct S3{ double d;//8 char c;//1 int i;//4 }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结构体成员 d d d d d d d d c \\ \\ \\ i i i i 结构体总大小为最大对齐数（每个成员变量都一个对齐数）的整数倍，当前是16，为最大8的整数倍。\n#include \u0026lt;stdio.h\u0026gt; struct S3{ double d;//8 char c;//1 int i;//4 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S3));//16 return 0; } ​\nS4\nstruct S4{ char c1;//1 struct S3 s3; double d; }; 内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 结构体成员 c1 \\ \\ \\ \\ \\ \\ \\ \\ s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 d d d d d d d d 第一个成员：从0开始，占用1个字节\n第二个成员：嵌套结构体对齐到自己的最大对齐数的整数倍处，此处S3的最大对齐数是8，所以从8为位置处开始\n第三个成员：自己需要占用8个自己，如果当前在所占字节的整数倍处，则从当前开始，如果没有，则跳到整数倍位置处再开始\n结束位置是所有成员最大对齐数的整数倍，这里最大是8，32是8的整数倍，所以是32\n#include \u0026lt;stdio.h\u0026gt; struct S4{ char c1;//1 struct S3 s3; double d; }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S4));//32 return 0; } 为什有内存对齐：\n平台原因：不是所有的硬件平台都能访问任意地址上的任意数据；某些硬件平台只能在某些地址处取得特定类型的数据，否则会抛出硬件异常。 性能原因：数据结构，尤其是栈，应尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要一次访问。 结构体的内存对齐是拿空间换时间的做法\n结构体在设计的时候，要尽量满足对齐：\n让占用空间小的成员集中在一起\n默认对齐数 在vs上默认对齐数是8\n#include \u0026lt;stdio.h\u0026gt; #pragma pack(8)//设置默认对齐数为8，一般是2的n次方（0，1，2，3，4......） #pragma pack()//取消设置的默认对齐数，还原为默认 #pragma pack(1)//还原默认对齐数为1 struct S{ int i;//4个字节 double d;//8个字节 }; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(struct S)); return 0; } 设置默认对齐数为8 \u0026mdash;\u0026gt; 结构体占用16个字节\n内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结构体成员 i i i i \\ \\ \\ \\ d d d d d d d d 设置默认对齐数为1 \u0026mdash;\u0026gt; 结构体占用12个字节\n内存地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结构体成员 i i i i d d d d d d d d 第一个成员：从0开始，占用4个字节，默认对齐数为4，对齐数：4；占用0-3， 第二个成员：从4开始，占用字节数为8，默认对齐数是4，取较小的对齐数：4；占用4-11 总大小是最大对齐数 ：4，12是4的整数倍，所以是12 ","date":"2023-06-29","tags":["编程"],"title":"C 语言结构体","url":"/post/2023/06/c_struct/"},{"content":" 暴力算法 时间复杂度过大\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc/_malloc.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; // 最大公约数 // 最小公倍数 //计算最小公倍数和最大公约数的和 int main(){ int n = 0; int m = 0; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m) == 2){//读取两个数 int min = n \u0026lt; m ? n : m; int max = n \u0026gt; m ? n : m; int i = min;//最大公约数 int j = max;//最小公倍数 while(1){ if(n%i == 0 \u0026amp;\u0026amp; m%i == 0){ break; } i--; } // i就是最大公约数 while(1){ if(j%n == 0 \u0026amp;\u0026amp; j%m == 0){ break; } j\u0026#43;\u0026#43;; } // j就是最大公倍数 printf(\u0026#34;最大公倍数 %d \u0026#43; 最小公约数 %d = %d\\n\u0026#34;,j,i,j\u0026#43;i); } return 0; } 辗转相除法 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数\n``c 24 18 \u0026mdash;- 计算最大公约数 24%18 = 6 \u0026mdash;- 获取余数 18%6 = 0 \u0026mdash;- 较小数字于余数的模为0，这个余数就是最大公约数\n\u0026gt; 最大公倍数就是两个数字的积除以最大公约数 ```c 24 * 18 / 6 最终：\n#include \u0026lt;stdio.h\u0026gt; // 最大公约数 // 最小公倍数 //计算最小公倍数和最大公约数的和 int main(){ long n = 0; long m = 0; while(scanf(\u0026#34;%ld %ld\u0026#34;,\u0026amp;n,\u0026amp;m) == 2){//读取两个数 long i = n; long j = m; long r = 0; while(r=i%j){ i = j; j = r; } //j就是最大公约数 //m * n / j //最小公倍数 printf(\u0026#34;%ld\\n\u0026#34;,m*n/j\u0026#43;j); } return 0; } ","date":"2023-06-29","tags":["编程"],"title":"C 语言数学","url":"/post/2023/06/c_number/"},{"content":" codeif ↗ 文件命名 所有文件\n头文件和原文件成对出现\n全部小写, 可是使用下划线\u0026quot;_\u0026quot;(默认)或连字符\u0026quot;-\u0026quot;, 称完整, 不要有歧义\nsystem_file.c \u0026amp; system_file.h item_name.c item-name.c 类型命名 类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数\n每个单词首字母大写, 不使用下划线\nNumber Timer File Name 变量命名 变量, 函数参数, 数据成员名\n全部小写, 使用下划线连接\u0026quot;_\u0026quot;\n类的成员变量以下划线结尾\nvar\nitme_var\nstruct\nitme_struct\ncalss_\nitme_class_\n普通变量命名: string name; string other_name; int a; int a_other; char b; 类数据成员: class PeopleInfo{ public: string name; string other_name int age; int itme_num; static Pool\u0026lt;Psople\u0026gt;* pool_; } 结构体变量: struct person{ string name; int num_age; static Pool\u0026lt;person\u0026gt;* pool_; } 常量 声明为constexpr 或 const的变量,或在程序运行期间其值始终不变的\n静态变量, 全局变量,\n以\u0026quot;k\u0026quot;开头, 所有首字母大小, 大驼峰命名\n函数命名 函数名\n首字母大写(大驼峰命名), 或使用下划线\nmy_parent() MyParent() 枚举命名 枚举和宏或常量一样\n首字母大写, 大驼峰命名\nName\nOtherName\nenum Name{ lisa, tom = 1, } 宏命名 不建议使用宏\n单词全部大小,使用下划线连接\nNAME_ONE\nMY_NAME\n#define MY_NAME #define ORUND(x)... #define PI_NUMBER 3.14 ","date":"2023-05-29","tags":["编程"],"title":"C++ 命名规范","url":"/post/2023/05/cpp_named/"},{"content":"mermaid可以在主流的markdown工具中使用 下面是几个常用的图示类型\n1.思维导图 空格敏感 mindmap root((思维导图)) 节点一 记录1.1 ::icon(fa fa-book) 节点1.1 记录1.1.1 节点二 记录2.1 记录2.2 节点2.1 记录2.1.1 记录2.1.2 记录2.1.3 节点三 记录3.1 记录3.2 基础\n语法\n形状\n默认\nmindmap I am the default shape []矩形\nmindmap id[I am a square] 圆角矩形\nmindmap id(I am a rounded square) 圆形\nmindmap id((I am a circle)) 爆炸形\nmindmap id))I am a bang(( 云朵形\nmindmap id)I am a cloud( 六边形\nmindmap id{{I am a hexagon}} ::icon()图标\nmindmap Root A ::icon(fa fa-book) B(B) ::icon(fa fa-car) 级别\nmindmap Root A[A] :::urgent large B(B) C markdown字符串\nmindmap id1[\"**Root** with a second line Unicode works too: 🤓\"] id2[\"`The dog in **the** hog... a *very long text* that wraps to a new line`\"] id3[Regular labels still works] 翻动\n翻动\n语法\n语法\n2. 顺序图 sequenceDiagram 张三-\u003e\u003e李四: 我是张三！ 李四--\u003e\u003e张三: 我是李四! 张三-)李四: 好的! 基础\n语法\nactor 名称象形图形 sequenceDiagram actor 张三 actor 李四 张三-\u003e\u003e李四: 你好，李四，我是张三！ 李四-\u003e\u003e张三: 你好，张三！ participant A as A的别名 使用别名\nsequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL: 你好，李四！ L-\u003e\u003eZ: 你好! 使用盒子分组\nbox 组名 box 颜色 组名 participant 马克 participant B as 杰森 可以使用as取别名 end box Group without description ... actors ... end box 指定颜色 box rgb(33,66,99) ... actors ... end box 指定透明 box transparent Aqua ... actors ... end 盒子（分组）\nsequenceDiagram box rgb(255,34,67) 场景组 participant A as 马克 participant B as 杰森 end box orange 后期组 participant C as 泰克 end box white 道具组 participant D as 斯坦 end box lightblue演员组 participant 瓦特 participant E as 托尼 end box transparent 导演组 participant F as 塔克 end A-\u003e\u003eB: 不错 B-\u003e\u003eE: 演员呢 A-\u003e\u003eD: 换道具了 B-\u003e\u003eC: 后期组在吗? A-\u003e\u003eF: 我是马克 F-\u003e\u003eD: 我是塔克 E-\u003e\u003eF: 我是托尼 瓦特-\u003e\u003eF: 这里是演员组 可以使用的箭头\n类型 描述 -\u0026gt; 没有箭头的实线 --\u0026gt; 没有箭头的虚线 -\u0026gt;\u0026gt; 带箭头的实线 --\u0026gt;\u0026gt; 带箭头的虚线 -x 末尾有十字的实线 --x 末端有十字的虚线。 -) 尾端有开箭头的实线（异步） --) 末端有开放箭头的虚线（异步） deactivate保持对象（activate激活对象）\n通常用于表示一个完整的内容，避免分割造成的歧义 sequenceDiagram 张三-\u003e\u003e李四: 我是可以使用的对象 activate 李四 李四--\u003e\u003e张三: Great! deactivate 李四 张三-\u003e\u003e李四: 刚才被停用了 李四--\u003e\u003e张三: Great! activate 李四 李四--\u003e\u003e张三: Great! 快捷方式：在消息箭头上附加+/-后缀 -\u0026gt;\u0026gt;+ --\u0026gt;\u0026gt;- sequenceDiagram 张三-\u003e\u003e+李四: Hello John, how are you? 李四--\u003e\u003e-张三: Great! 堆叠\nsequenceDiagram 张三-\u003e\u003e+李四: Hello John, how are you? 张三-\u003e\u003e+李四: John, can you hear me? 李四--\u003e\u003e-张三: Hi Alice, I can hear you! 李四--\u003e\u003e-张三: I feel great! 注释\nsequenceDiagram participant 李四 Note right of 李四: 这是注释 跨对象注释\nsequenceDiagram 张三-\u003e\u003e李四: 你好，李四 Note over 张三,李四: 这是注释 注释使用换行符\nsequenceDiagram 张三-\u003e\u003e李四: 你好 Note over 张三,李四: 尖括号内使用br斜杠换行 循环\nloop 循环说明 循环内容 end\n```mermaid sequenceDiagram 张三-\u0026gt;李四: 接下来是一个循环 loop 循环的说明 李四--\u0026gt;张三: 循环的内容 end 替换和选择\n可以在序列图中表达替代路径。\nalt 描述信息 \u0026hellip; statements \u0026hellip; else \u0026hellip; statements \u0026hellip; end\n或者\n如果有可选的序列（如果没有其他）\nopt 描述信息 \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram 张三-\u0026gt;\u0026gt;李四: 怎么样 alt 生病了 李四-\u0026gt;\u0026gt;张三: 不太好:( else 健康 李四-\u0026gt;\u0026gt;张三: 很好 end opt 额外的 李四-\u0026gt;\u0026gt;张三: 谢谢关心 end 并行发生\n可以显示并行发生的行为。\npar [Action 1] \u0026hellip; statements \u0026hellip; and [Action 2] \u0026hellip; statements \u0026hellip; and [Action N] \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram par 张三 to 李四 张三-\u0026gt;\u0026gt;李四: 你好 and 张三 to 王五 张三-\u0026gt;\u0026gt;王五: 你好 end 李四--\u0026gt;\u0026gt;张三: 你好，张三 王五--\u0026gt;\u0026gt;张三: 你好，张三 嵌套平行块\nsequenceDiagram par 张三 to 李四 张三-\u003e\u003e李四: Go help John and 张三 to 王五 张三-\u003e\u003e王五: I want this done today par 王五 to 赵六 王五-\u003e\u003e赵六: Can we do this today? and 王五 to 小明 王五-\u003e\u003e小明: Can you help us today? end end 条件触发\n可以显示必须通过有条件处理情况自动发生的操作。 critical [Action that must be performed] \u0026hellip; statements \u0026hellip; option [Circumstance A] \u0026hellip; statements \u0026hellip; option [Circumstance B] \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram critical 拨打电话给李四 张三--\u0026gt;李四: 打电话 option 话费不足 张三--\u0026gt;张三: 通话失败 option 被拒绝 张三--\u0026gt;张三: 再次通话失败 end sequenceDiagram critical 张三打电话给李四 张三--\u003e李四: 成功 end 中断\n可以指示流中序列的停止（通常用于模拟异常）。\nbreak [something happened] \u0026hellip; statements \u0026hellip; end\n```mermaid sequenceDiagram 消费者--\u0026gt;商家: 买一个笔记本 商家--\u0026gt;仓库: 查仓库的库存 break 无库存 商家--\u0026gt;消费者: 提示无库存 end 商家--\u0026gt;财务系统: 财务登记 背景高亮显示\n可以通过提供彩色背景来突出显示流。 颜色是使用rgb和rgba语法定义的。\nrect rgb(0, 255, 0) \u0026hellip; content \u0026hellip; end rect rgba(0, 0, 255, .1) \u0026hellip; content \u0026hellip; end\n```mermaid sequenceDiagram participant Alice as 张三 participant John as 李四 rect rgb(191, 223, 255) note right of Alice: 张三给李四打电话 Alice-\u0026gt;\u0026gt;\u0026#43;John: 你好，李四！ rect rgb(200, 150, 255) Alice-\u0026gt;\u0026gt;\u0026#43;John: 李四，你能听到我说话吗？ John--\u0026gt;\u0026gt;-Alice: 我可以听到 end John--\u0026gt;\u0026gt;-Alice: 很清晰 end Alice -\u0026gt;\u0026gt;\u0026#43; John: 今晚有空看比赛吗？ John --\u0026gt;\u0026gt;- Alice: 可以的！ %%注释内容，换行结束注释\nsequenceDiagram A-\u0026raquo;J: Hello J, how are you? %% this is a comment J\u0026ndash;\u0026raquo;A: Great!\n- 转义字符 ```mermaid sequenceDiagram A-\u0026gt;\u0026gt;B: I #9829; you! B-\u0026gt;\u0026gt;A: I #9829; you #infin; times more! 翻动分\n赛\n翻动\n语法\n扽色\n冬粉\n使用end时，建议用[] 或 {} 或 ()括起来 3. 流程图flowchart 使用graph也可以\n基础：\n节点：箭头（连接线）指向的图形 内容：节点上的文字 对空格不敏感 ---三个减号表示线，最后一个减号改为\u0026gt;可带箭头，增加-可增加长度 ```mermaid graph LR 思维导图--\u0026gt; 第一部分 第一部分--\u0026gt;1.1小节 第一部分--\u0026gt;1.2小节 思维导图--\u0026gt; 第二部分 第二部分--\u0026gt;2.2小节 思维导图--\u0026gt; 第三部分 第三部分--\u0026gt; 3.1小节 思维导图--\u0026gt; 若干 ``` graph LR 思维导图--\u003e 第一部分 第一部分--\u003e1.1小节 第一部分--\u003e1.2小节 思维导图--\u003e 第二部分 第二部分--\u003e2.2小节 思维导图--\u003e 第三部分 第三部分--\u003e 3.1小节 思维导图--\u003e 若干 A[Content A]--\u003eB[Content B] B--\u003eC[Content C] B--\u003eD[Content D] 语法：\n排列方式\ngraph LR 从左到右排列，RL相反 graph BT 从上到下排列，TB相反 连接方式\n--\u0026gt; 箭头连接\ngraph LR A --\u003e B --- 无箭头连接\ngraph LR A---B --连接线上带文字--- 或 C---|连接线上带文字|D连接线上带文字\ngraph LR A-- 连接上的文字 ---B C---|连接线上带文字|D --\u0026gt;箭头连接线上带文字--- 或 C---\u0026gt;|箭头连接线上带文字|D箭头连接线上带文字\ngraph LR A--\u003e 连接上的文字 --\u003eB C---\u003e|连接线上带文字|D A-.-\u0026gt;B虚线连接\ngraph LR A-.-\u003eB A-.带文字的虚线连接.-\u0026gt;B带文字的虚线连接\ngraph LR A-.带文字的虚线连接.-\u003eB A==\u0026gt;B粗连接\ngraph LR A==\u003eB A == 带文本的粗连接 ==\u0026gt; B 带文本的粗连接\ngraph LR A == 带文本的粗连接 ==\u003e B - 特殊字符的显示 ```mermaid graph LR A[\u0026quot;这里有个引号#quot;\u0026quot;] --\u0026gt;B[\u0026quot;特殊字符:#9829;\u0026quot;] ``` - 破坏语法的字符`!` ```mermaid graph LR A[\u0026quot;破坏语法的特殊字符 ! \u0026quot;] ``` 节点形状\nA(圆角矩形) “A”和“圆角矩形”可以是任意字符\ngraph RL A(圆角矩形) A[矩形]\ngraph RL A[矩形] A((圆形))\ngraph RL A((圆形)) A\u0026gt;非对称形状]\ngraph RL A\u003e非对称形状] A{菱形}\ngraph RL A{菱形} 文字（别名）\nstart[开始]start将作为节点，显示的字符为开始 子图\nsubgraph 图像块标题1 图像快中的连接 subgraph 图像块标题2 图像快中的连接 ...... end graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end 带样式的连接\n参数 fill：内部填充色 stroke：描边颜色 stroke-width：描边宽度 stroke-dasharray: 虚线描边（虚线块的宽度 虚线空格的宽度） graph LR A(Start)--\u003eB(Stop) style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 style C fill:#f9f,stroke:#993,stroke-width:4px style D fill:#ccf,stroke:#f6f6,stroke-width:6px,stroke-dasharray: 4 2 对 fontawesome ↗ 的基本支持\n图标通过语法\u0026quot;fa:图标名称\u0026quot;来获取\ngraph TD B[\"fa:fa-twitter 和平\"] B--\u003eC[fa:fa-ban 禁止] B--\u003eD(fa:fa-spinner); B--\u003eE(fa:fa-camera-retro 也许?); E--\u003eF(fa:fa-car 汽车) B--\u003eG(fa:fa-file 文件) fds\nfdsfsd\n4. 甘特图 gantt title 一个案例 dateFormat YYYY-MM-DD section 分区 任务一 :a1, 2023-01-01, 30d 其它任务 :after a1, 20d section 其它 任务一中的次要任务 :2023-01-12, 12d 次要任务 :24d 甘特图将把每个计划的任务记录为一个从左向右延伸的连续条。x轴表示时间，y记录不同的任务和完成它们的顺序。\n重要的是要记住，当特定于任务的日期、日期或日期集合被“排除”时，甘特图将通过向右延长相等的天数来适应这些变化，而不是在任务内部创建空隙。但是，如果排除的日期在设置为连续开始的两个任务之间，则排除的日期将以图形方式跳过并留空，以下任务将在排除日期结束后开始。\n甘特图可用于跟踪项目完成所需的时间，但它也可以用于以图形方式表示“非工作日”，只需进行一些调整。\n语法\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section A section Completed task :done, des1, 2023-01-06,2023-01-08 Active task :active, des2, 2023-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2023-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d Functionality added :milestone, 2023-01-25, 0d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 由多个空间分割的依赖项\ngantt apple :a, 2023-07-20, 1w banana :crit, b, 2023-07-23, 1d cherry :active, c, after b a, 1d title标题\ntitle是一个可选字符串，显示在甘特图表的顶部，以描述整个图表。 section章节声明\n将图标分为多个部分 milestone重要事件\n代表时间上的单个瞬间\n里程碑的确切位置由里程碑的初始日期和任务的“持续时间”决定：初始日期+持续时间/2。\ngantt dateFormat HH:mm axisFormat %H:%M Initial milestone : milestone, m1, 17:49, 2m Task A : 10m Task B : 5m Final milestone : milestone, m2, 18:08, 4m 日期\ndateFormat定义甘特元素的日期输入格式。这些日期如何在渲染的图表输出中表示，由axisFormat定义。\n日期格式dateFormat YYYY-MM-DD\n输入的信息 示例： 描述 YYYY 2014 年 4位数年 YY 14 2位数年 Q 1..4 一年的四分之一。将月份设置为季度的第一个月。 M MM 1..12 月号 MMM MMMM 一月..十二月 区域设置中的月份名称由dayjs.locale() D DD 1..31 月日 Do 第1..31 带有序数的月日 DDD DDDD 1..365 一年中的一天 X 1410715640.579 Unix时间戳 x 1410715640579 Unix ms时间戳 H HH 0..23 24小时时间 h hh 1..12 12 hour time used with a A. a A 下午上午 帖子或ante meridiem m mm 0..59 备忘录 s ss 0..59 秒 S 0..9 十分之一秒 SS 0..99 数百秒 SSS 0..999 千分之一秒 Z ZZ +12:00 从UTC偏移为+-HH:mm、+-HHmm或Z 轴上的日期格式\n默认输出日期格式是YYYY-MM-DD。您可以定义自定义axisFormat，例如2020年第一季度的2020-Q1。\naxisFormat %Y-%m-%d\n格式 定义 %a 缩写的工作日名称 %A 完整的工作日名称 %b 缩写的月名 %B 完整月份名称 %c 日期和时间，如“%a %b %e %H:%M:%S %Y” %d 每月零填充日作为十进制数[01,31] %e 每月用空格填充的十进制数[1,31]；相当于%_d %H 小时（24小时时钟）作为十进制数[00,23] %I 小时（12小时时钟）作为小数[01,12] %j 一年中的一天作为十进制数[001,366] %m 月份作为十进制数[01,12] %M 分钟作为十进制数[00,59] %升 毫秒作为十进制数[000,999] %p 上午或下午 %S 第二个十进制数[00,61] %U 一年中的周数（周日作为一周的第一天）作为十进制数[00,53] %w 工作日作为十进制数[0（周日），6] %W 一年中的周数（周一作为一周的第一天）作为十进制数[00,53] %x 日期，如“%m/%d/%Y” %X 时间，如“%H:%M:%S” %y 没有世纪的年份作为十进制数[00,99] %Y 以世纪为十进制数的年份 %Z 时区偏移，例如“-0700” %% 字面上的“%”字符 轴刻度\n默认输出刻度是自动的。您可以自定义您的tickInterval，如1day或1week tickInterval 1day 模式：/^([1-9][0-9]*)(minute|hour|day|week|month)$/; 紧凑模式输出\n--- displayMode: compact --- gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2023-01-01, 30d Another task :a2, 2023-01-20, 25d Another one :a3, 2023-02-10, 20d ·%%注释\nfds\nfds\n5. 饼图 pie title 字符统计 \"中文\" : 386 \"英文\" : 85 \"标点符号\" : 15 饼图（或圆图）是一种圆形统计图形，分为切片以说明数字比例。在饼图中，每个切片的弧长（以及其中心角度和面积）与它所代表的数量成正比。\n语法\npie关键字\nshowData在图例文本之后呈现实际数据值。这是可选的\n后面跟着title关键字及其在字符串中的值，以给饼图一个标题。这是可选的\n其次是数据集。饼图将按照与标签相同的顺序顺时针排序。\nlabel在\u0026quot; \u0026quot;引号中的饼图中的一部分。\n其次是:冒号作为分隔符\n后跟positive numeric value（最多支持小数点后两位）\n%%{init: {\"pie\": {\"textPosition\": 0.5}, \"themeVariables\": {\"pieOuterStrokeWidth\": \"5px\"}} }%% pie showData title 软件技能 \"PS\" : 42.96 \"Word\" : 50.05 \"Exl\" : 10.01 \"Ppt\" : 5 参数 描述 默认值 textPosition 馅饼片标签的轴向位置，从中心0.0到圆圈外缘的1.0。 0.75 ","date":"2023-03-19","tags":["编程"],"title":"mermaid 教程","url":"/post/2023/03/marmaid/"},{"content":" http://patorjk.com/software/taag ↗ http://www.network-science.de/ascii/ ↗ http://www.degraeve.com/img2txt.php ↗ http://life.chacuo.net/convertfont2char ↗ ","date":"2022-07-29","tags":["编程"],"title":"字符图片","url":"/post/2022/07/chart_image/"}]