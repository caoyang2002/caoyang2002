<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>性能优化 on 短松江月</title><link>https://simons.qzz.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><description>Recent content in 性能优化 on 短松江月</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Fri, 30 Jan 2026 01:57:46 +0800</lastBuildDate><atom:link href="https://simons.qzz.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>哈夫曼编码：数据压缩的经典算法</title><link>https://simons.qzz.io/post/2025/01/huffman_coding_a_classic_algorithm_for_data_compression/</link><pubDate>Sun, 26 Jan 2025 11:08:57 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/huffman_coding_a_classic_algorithm_for_data_compression/</guid><description>&lt;h1 id="哈夫曼编码数据压缩的经典算法"&gt;哈夫曼编码：数据压缩的经典算法&lt;/h1&gt;
&lt;p&gt;今天遇到一个有趣的问题：一个100MB的日志文件，需要实时传输，但带宽只有 10MB。很多人二话不说就上 gzip，但你真的理解压缩算法的原理吗？&lt;/p&gt;
&lt;h2 id="什么是哈夫曼编码"&gt;什么是哈夫曼编码？&lt;/h2&gt;
&lt;p&gt;本质上，哈夫曼编码是一种变长编码方案。它的核心思想是：出现频率高的字符用短编码，频率低的用长编码。&lt;/p&gt;









&lt;div class="code-playground" data-language="python"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-python"&gt;# 一个简单的例子
text = &amp;#34;AAAAABBBCC&amp;#34; # 原始数据
# 普通编码：每个字符占8位
# A: 01000001 (8位) × 5 = 40位
# B: 01000010 (8位) × 3 = 24位
# C: 01000011 (8位) × 2 = 16位
# 总共：80位

# 哈夫曼编码
# A: 0 (1位) × 5 = 5位
# B: 10 (2位) × 3 = 6位
# C: 11 (2位) × 2 = 4位
# 总共：15位&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;h2 id="为什么需要哈夫曼编码"&gt;为什么需要哈夫曼编码？&lt;/h2&gt;
&lt;p&gt;看看其他编码方案的问题：&lt;/p&gt;</description></item><item><title>Node.js 的方法</title><link>https://simons.qzz.io/post/2025/01/node.js_methods/</link><pubDate>Sun, 26 Jan 2025 11:03:43 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/node.js_methods/</guid><description>&lt;h1 id="nodejs-的方法"&gt;Node.js 的方法&lt;/h1&gt;
&lt;p&gt;不知道你是否思考过，为什么 Node.js 选择了 JavaScript 作为语言？为什么它能在后端站稳脚跟？今天我们就来扒一扒 Node.js 的底层原理和设计思想。&lt;/p&gt;
&lt;h2 id="什么是-nodejs"&gt;什么是 Node.js?&lt;/h2&gt;
&lt;p&gt;本质上，Node.js 就是一个基于 Chrome V8 引擎的 JavaScript 运行时。但这样说太简单了，让我们来看看它的架构：&lt;/p&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// Node.js 的核心就是事件循环
const fs = require(&amp;#39;fs&amp;#39;);

fs.readFile(&amp;#39;test.txt&amp;#39;, (err, data) =&amp;gt; {
 if (err) throw err;
 console.log(data);
});
console.log(&amp;#39;这行先执行&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;这段代码揭示了 Node.js 最核心的特性：非阻塞I/O和事件驱动。&lt;/p&gt;</description></item><item><title>Hugo 不为人知的强大特性</title><link>https://simons.qzz.io/post/2025/01/hugo_lesser_known_powerful_features/</link><pubDate>Sun, 26 Jan 2025 01:44:00 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/hugo_lesser_known_powerful_features/</guid><description>&lt;h1 id="hugo-不为人知的强大特性"&gt;Hugo 不为人知的强大特性&lt;/h1&gt;
&lt;p&gt;Hugo 被称为世界上最快的静态网站生成器，但大多数人只用它来写写博客。这太浪费了，其实它还有很多好玩的地方，我目前的博客主题就是靠的 Hugo，可以说是非常强大了。今天我们来挖掘一下它的进阶特性。&lt;/p&gt;
&lt;h2 id="1-模板继承的黑魔法"&gt;1. 模板继承的黑魔法&lt;/h2&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;{{/* 基础模板: baseof.html */}}
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
 &amp;lt;head&amp;gt;
 {{ block &amp;#34;head&amp;#34; . }}{{ end }}
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
 {{ block &amp;#34;main&amp;#34; . }}{{ end }}
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

{{/* 子模板 */}}
{{ define &amp;#34;main&amp;#34; }}
 &amp;lt;div&amp;gt;这里是实际内容&amp;lt;/div&amp;gt;
{{ end }}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;看到这个&lt;code&gt;.&lt;/code&gt;了吗？这是Hugo的上下文传递，相当于其他语言的&lt;code&gt;this&lt;/code&gt;。很多人不知道，它可以这样玩：&lt;/p&gt;</description></item><item><title>React vs Vue: 框架之争的深层思考</title><link>https://simons.qzz.io/post/2025/01/react_vue_framework_debate/</link><pubDate>Fri, 24 Jan 2025 13:57:50 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/react_vue_framework_debate/</guid><description>&lt;h1 id="react-vs-vue深度技术分析与对比"&gt;React vs Vue：深度技术分析与对比&lt;/h1&gt;
&lt;h2 id="一核心设计哲学差异"&gt;一、核心设计哲学差异&lt;/h2&gt;
&lt;h3 id="11-编程范式"&gt;1.1 编程范式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;：函数式编程优先&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强调不可变性和纯函数&lt;/li&gt;
&lt;li&gt;组件本质是函数（props in, JSX out）&lt;/li&gt;
&lt;li&gt;Hooks强化了函数式概念&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-jsx" data-lang="jsx"&gt;// React函数式组件
const Component = ({ data }) =&amp;gt; {
 const [state, setState] = useState(initialState);
 const derivedValue = useMemo(() =&amp;gt; compute(data), [data]);
 
 return &amp;lt;div&amp;gt;{derivedValue}&amp;lt;/div&amp;gt;;
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Vue&lt;/strong&gt;：响应式编程 + 面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于可变状态的响应式系统&lt;/li&gt;
&lt;li&gt;组合式API提供函数式能力&lt;/li&gt;
&lt;li&gt;传统选项式API符合OOP思维&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-vue" data-lang="vue"&gt;&amp;lt;!-- Vue组合式API --&amp;gt;
&amp;lt;script setup&amp;gt;
import { ref, computed } from &amp;#39;vue&amp;#39;

const data = ref(initialData)
const derivedValue = computed(() =&amp;gt; compute(data.value))
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id="12-架构理念"&gt;1.2 架构理念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;：最小化API，一切靠JavaScript&lt;/p&gt;</description></item><item><title>React 开发痛点与解决方案详解</title><link>https://simons.qzz.io/post/2025/01/react_development_pain_points_and_solutions_detailed/</link><pubDate>Fri, 24 Jan 2025 13:44:21 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/react_development_pain_points_and_solutions_detailed/</guid><description>&lt;h1 id="react-开发痛点与解决方案详解"&gt;React 开发痛点与解决方案详解&lt;/h1&gt;
&lt;h2 id="1-dom-操作的深层困境"&gt;1. DOM 操作的深层困境&lt;/h2&gt;
&lt;h3 id="传统方式的问题"&gt;传统方式的问题&lt;/h3&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// 更新用户信息
$(&amp;#39;#userName&amp;#39;).text(user.name);
$(&amp;#39;#userRole&amp;#39;).text(user.role);
$(&amp;#39;#department&amp;#39;).text(user.department);

// 更新权限信息
function updatePermissions(permissions) {
 $(&amp;#39;#permissionList&amp;#39;).empty();
 permissions.forEach(p =&amp;gt; {
 $(&amp;#39;#permissionList&amp;#39;).append(`&amp;lt;li&amp;gt;${p}&amp;lt;/li&amp;gt;`);
 });
}

// 更新用户状态
function toggleUserStatus(status) {
 if(status === &amp;#39;active&amp;#39;) {
 $(&amp;#39;#userStatus&amp;#39;).addClass(&amp;#39;active&amp;#39;).removeClass(&amp;#39;inactive&amp;#39;);
 } else {
 $(&amp;#39;#userStatus&amp;#39;).addClass(&amp;#39;inactive&amp;#39;).removeClass(&amp;#39;active&amp;#39;);
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;这种操作方式存在严重问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码分散导致的维护噩梦&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 操作散布在各个函数中&lt;/li&gt;
&lt;li&gt;状态变化需要手动同步多处DOM&lt;/li&gt;
&lt;li&gt;代码修改容易遗漏关联更新&lt;/li&gt;
&lt;li&gt;难以追踪数据流向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>rust 闭包</title><link>https://simons.qzz.io/post/2025/01/rust_closure/</link><pubDate>Wed, 15 Jan 2025 11:29:27 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/rust_closure/</guid><description>&lt;h2 id="从一个常见问题说起"&gt;从一个常见问题说起&lt;/h2&gt;
&lt;p&gt;假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：&lt;/p&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;let numbers = vec![1, 2, 3, 4, 5];
// 如何优雅地复用过滤逻辑？
let even_numbers = ??? // 这里怎么写
let multiplied_numbers = ??? // 这里怎么写&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;h2 id="闭包的本质"&gt;闭包的本质&lt;/h2&gt;
&lt;p&gt;Rust 的闭包本质上是一种特殊的数据结构，它包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数逻辑&lt;/li&gt;
&lt;li&gt;捕获的环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们通过反编译来看闭包的真实面目：&lt;/p&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;// 表面上的闭包
let multiplier = 2;
let closure = |x| x * multiplier;

// 编译器实际生成的结构（简化版）
struct Closure {
 multiplier: i32,
}

impl Closure {
 fn call(&amp;amp;self, x: i32) -&amp;gt; i32 {
 x * self.multiplier
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;h2 id="闭包的三种类型"&gt;闭包的三种类型&lt;/h2&gt;
&lt;p&gt;通过具体案例来理解三种闭包 trait：&lt;/p&gt;</description></item><item><title>Wasm 打印输出和浏览器特性等最佳实践</title><link>https://simons.qzz.io/post/2025/01/wasm_print/</link><pubDate>Wed, 15 Jan 2025 00:31:17 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/wasm_print/</guid><description>&lt;p&gt;在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;web_sys&lt;/code&gt; 和 &lt;code&gt;wasm_bindgen&lt;/code&gt; 进行浏览器 API 调用：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use wasm_bindgen::prelude::*;
use web_sys::{console, window};

pub fn move_test(name: &amp;amp;str) {
 // 控制台打印
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;move test: {}&amp;#34;, name)));

 // 使用 console.warn
 console::warn_1(&amp;amp;JsValue::from_str(&amp;#34;This is a warning&amp;#34;));

 // 使用 console.error
 console::error_1(&amp;amp;JsValue::from_str(&amp;#34;This is an error&amp;#34;));

 // 浏览器 alert
 if let Some(window) = window() {
 window
 .alert_with_message(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;, name))
 .expect(&amp;#34;alert failed&amp;#34;);
 }

 // 确认对话框
 if let Some(window) = window() {
 if window
 .confirm_with_message(&amp;#34;Do you want to continue?&amp;#34;)
 .expect(&amp;#34;confirm failed&amp;#34;)
 {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked OK&amp;#34;));
 } else {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked Cancel&amp;#34;));
 }
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="2"&gt;
&lt;li&gt;在 Cargo.toml 中需要添加必要的依赖：&lt;/li&gt;
&lt;/ol&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-toml" data-lang="toml"&gt;[dependencies]
wasm-bindgen = &amp;#34;0.2&amp;#34;
web-sys = { version = &amp;#34;0.3&amp;#34;, features = [
 &amp;#34;console&amp;#34;,
 &amp;#34;Window&amp;#34;,
 &amp;#34;Document&amp;#34;,
 &amp;#34;Element&amp;#34;,
 &amp;#34;HtmlElement&amp;#34;,
 &amp;#34;Node&amp;#34;,
 &amp;#34;Location&amp;#34;
]}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol start="3"&gt;
&lt;li&gt;如果需要格式化打印，可以使用 &lt;code&gt;console::log!&lt;/code&gt; 宏：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use web_sys::console;

// 需要引入宏
#[macro_export]
macro_rules! console_log {
 ($($t:tt)*) =&amp;gt; (console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!($($t)*))))
}

pub fn move_test(name: &amp;amp;str) {
 console_log!(&amp;#34;Testing move with name: {}&amp;#34;, name);
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="4"&gt;
&lt;li&gt;操作 DOM 示例：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, window};

pub fn move_test(name: &amp;amp;str) {
 // 获取 document
 let window = window().expect(&amp;#34;no global window exists&amp;#34;);
 let document = window.document().expect(&amp;#34;no document exists&amp;#34;);

 // 创建新元素
 if let Some(div) = document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 // 修改输入框的值
 if let Some(input) = div.dyn_ref::&amp;lt;HtmlElement&amp;gt;() {
 input.set_inner_text(&amp;amp;format!(&amp;#34;New value: {}&amp;#34;, name));
 }
 }

 // 创建新元素
 let new_div = document.create_element(&amp;#34;div&amp;#34;).unwrap();
 new_div.set_text_content(Some(&amp;amp;format!(&amp;#34;Hello {}&amp;#34;, name)));

 // 添加到 body
 if let Some(body) = document.body() {
 body.append_child(&amp;amp;new_div).unwrap();
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="5"&gt;
&lt;li&gt;处理错误和 Result：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 // 使用 ? 运算符处理错误
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;
 let document = window.document().ok_or(&amp;#34;no document exists&amp;#34;)?;

 // 处理可能的错误
 match document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 Some(element) =&amp;gt; {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Found element: {}&amp;#34;, name)));
 Ok(())
 },
 None =&amp;gt; Err(JsValue::from_str(&amp;#34;Element not found&amp;#34;))
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="6"&gt;
&lt;li&gt;使用本地存储：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use web_sys::Storage;

pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;

 // 获取 localStorage
 if let Some(storage) = window.local_storage()? {
 // 存储数据
 storage.set_item(&amp;#34;user_name&amp;#34;, name)?;

 // 读取数据
 if let Ok(Some(saved_name)) = storage.get_item(&amp;#34;user_name&amp;#34;) {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Saved name: {}&amp;#34;, saved_name)));
 }
 }

 Ok(())
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 &amp;ldquo;Storage&amp;rdquo; feature：&lt;/p&gt;</description></item><item><title>Wasm</title><link>https://simons.qzz.io/post/2025/01/wasm/</link><pubDate>Sun, 05 Jan 2025 12:41:17 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/wasm/</guid><description>&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;cargo build&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id="webassembly-核心技术剖析"&gt;WebAssembly 核心技术剖析&lt;/h1&gt;
&lt;p&gt;让我用一个具体场景开始：你正在用 JavaScript 开发一个视频编码器，却发现即使用上了 Web Worker，处理 4K 视频时依然卡得厉害。为什么？问题出在哪里？&lt;/p&gt;
&lt;h2 id="深入理解-wasm-的本质"&gt;深入理解 WASM 的本质&lt;/h2&gt;
&lt;p&gt;首先，我们需要理解 WASM 的核心 - 它的内存模型和执行模型。&lt;/p&gt;
&lt;h3 id="内存模型解析"&gt;内存模型解析&lt;/h3&gt;
&lt;p&gt;让我们看一段具体代码：&lt;/p&gt;









&lt;div class="code-playground" data-language="cpp"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-cpp"&gt;// C&amp;#43;&amp;#43; 代码
int* buffer = new int[1024]; // 分配4KB内存
buffer[0] = 42;&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;编译成 WASM 后：&lt;/p&gt;</description></item><item><title>Go 最佳实践</title><link>https://simons.qzz.io/post/2024/12/go/</link><pubDate>Sun, 29 Dec 2024 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2024/12/go/</guid><description>&lt;p&gt;在 Go 项目架构中，有一些重要的设计原则和规则。我来详细说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口定义规则：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：接口定义在使用方(调用方)包中
package handler
type UserService interface {
 Create(ctx context.Context, user *User) error
}

// ❌ 错误：接口定义在实现方包中
package service
type UserService interface {
 Create(ctx context.Context, user *User) error
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="2"&gt;
&lt;li&gt;依赖方向：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确的依赖方向
handler -&amp;gt; service -&amp;gt; repository -&amp;gt; database

// ❌ 错误：不应该出现反向依赖
service -&amp;gt; handler
repository -&amp;gt; service&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="3"&gt;
&lt;li&gt;数据模型定义：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：每层使用自己的数据模型
package handler
type CreateUserRequest struct { // API层模型
 Username string `json:&amp;#34;username&amp;#34;`
}

package service
type UserDTO struct { // 业务层模型
 ID uint64
 Username string
}

package repository
type UserDO struct { // 数据层模型
 ID uint64 `gorm:&amp;#34;primaryKey&amp;#34;`
 Username string
 CreatedAt time.Time
}

// ❌ 错误：直接在所有层使用相同的模型
type User struct {
 ID uint64 `json:&amp;#34;id&amp;#34; gorm:&amp;#34;primaryKey&amp;#34;`
 Username string `json:&amp;#34;username&amp;#34;`
 CreatedAt time.Time `json:&amp;#34;created_at&amp;#34;`
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="4"&gt;
&lt;li&gt;错误处理层级：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：每层对错误进行适当包装
package repository
func (r *UserRepo) Create(user *UserDO) error {
 return fmt.Errorf(&amp;#34;database error: %w&amp;#34;, err)
}

package service
func (s *UserService) Create(user *UserDTO) error {
 return fmt.Errorf(&amp;#34;business error: %w&amp;#34;, err)
}

package handler
func (h *UserHandler) Create(c *gin.Context) {
 if err := h.service.Create(user); err != nil {
 c.JSON(getErrorStatus(err), ErrorResponse{err.Error()})
 return
 }
}

// ❌ 错误：直接暴露底层错误
if err := db.Create(&amp;amp;user).Error; err != nil {
 c.JSON(500, err.Error())
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="5"&gt;
&lt;li&gt;包的组织：&lt;/li&gt;
&lt;/ol&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-" data-lang=""&gt;✅ 正确的包组织：
project/
 ├── api/
 │ └── handler/ # HTTP 处理层
 ├── internal/
 │ ├── service/ # 业务逻辑层
 │ ├── repository/ # 数据访问层
 │ └── model/ # 内部数据模型
 ├── pkg/
 │ └── util/ # 公共工具函数
 └── main.go

❌ 错误的包组织：
project/
 ├── handlers/
 ├── services/
 ├── models/
 └── main.go&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol start="6"&gt;
&lt;li&gt;依赖注入：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：通过构造函数注入依赖
func NewUserHandler(service UserService) *UserHandler {
 return &amp;amp;UserHandler{service: service}
}

// ❌ 错误：全局变量或直接初始化
var userService = &amp;amp;UserService{}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="7"&gt;
&lt;li&gt;接口隔离：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：小接口，职责单一
type UserReader interface {
 GetUser(id uint64) (*User, error)
}

type UserWriter interface {
 CreateUser(user *User) error
}

// ❌ 错误：大接口，职责过多
type UserService interface {
 GetUser(id uint64) (*User, error)
 CreateUser(user *User) error
 UpdateUser(user *User) error
 DeleteUser(id uint64) error
 ListUsers() ([]*User, error)
 SearchUsers(query string) ([]*User, error)
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="8"&gt;
&lt;li&gt;配置管理：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：集中管理配置
package config

type Config struct {
 Server ServerConfig
 DB DatabaseConfig
 Redis RedisConfig
}

// ❌ 错误：分散的配置或硬编码
var serverPort = 8080
var dbConnection = &amp;#34;root:password@tcp(localhost:3306)/db&amp;#34;&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="9"&gt;
&lt;li&gt;上下文传递：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：统一使用 context 传递请求上下文
func (h *Handler) Create(c *gin.Context) {
 ctx := c.Request.Context()
 err := h.service.Create(ctx, req)
}

// ❌ 错误：不传递上下文或使用不一致的上下文
func (h *Handler) Create(c *gin.Context) {
 err := h.service.Create(req)
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="10"&gt;
&lt;li&gt;测试组织：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;// ✅ 正确：测试文件与源文件对应
package handler

func TestUserHandler_Create(t *testing.T) {
 // 单元测试
}

// ❌ 错误：测试代码与源码混合或测试覆盖不全
func TestAll(t *testing.T) {
 // 混合测试多个功能
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;遵循这些规则可以使代码：&lt;/p&gt;</description></item><item><title>hugo 配置</title><link>https://simons.qzz.io/post/2024/12/about_hugo_config/</link><pubDate>Sun, 22 Dec 2024 18:12:52 +0800</pubDate><guid>https://simons.qzz.io/post/2024/12/about_hugo_config/</guid><description>&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-toml" data-lang="toml"&gt;# 基础优化配置
enableGitInfo = true # 启用 Git 信息,可以显示文章的最后修改时间
hasCJKLanguage = true # 启用中日韩文字支持,能准确统计字数
summaryLength = 140 # 文章摘要长度

# SEO 优化
[params]
keywords = [&amp;#34;博客&amp;#34;,&amp;#34;技术&amp;#34;,&amp;#34;编程&amp;#34;] # 网站关键词
description = &amp;#34;个人技术博客&amp;#34; # 网站描述
images = [&amp;#34;site-feature-image.jpg&amp;#34;] # 默认社交媒体分享图片
# 自定义 Open Graph 信息
[params.og]
title = &amp;#34;我的博客&amp;#34;
type = &amp;#34;website&amp;#34;
images = [&amp;#34;og-image.jpg&amp;#34;]

# 性能优化
[minify]
 disableCSS = false # 启用 CSS 压缩
 disableHTML = false # 启用 HTML 压缩
 disableJS = false # 启用 JS 压缩
 disableJSON = false # 启用 JSON 压缩
 minifyOutput = true # 压缩 HTML 输出

# 图片处理
[imaging]
 quality = 75 # JPEG 图片质量
 resampleFilter = &amp;#34;Lanczos&amp;#34; # 图片重采样过滤器
 anchor = &amp;#34;Smart&amp;#34; # 图片裁剪锚点

# 内容安全策略
[params.csp]
 childsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 fontsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;, &amp;#34;https://fonts.gstatic.com&amp;#34;, &amp;#34;https://cdn.jsdelivr.net&amp;#34;]
 formaction = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 framesrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 imgsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 objectsrc = [&amp;#34;&amp;#39;none&amp;#39;&amp;#34;]
 stylesrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;, &amp;#34;&amp;#39;unsafe-inline&amp;#39;&amp;#34;]
 scriptsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;, &amp;#34;&amp;#39;unsafe-inline&amp;#39;&amp;#34;, &amp;#34;&amp;#39;unsafe-eval&amp;#39;&amp;#34;]

# 文章配置
[permalinks]
 posts = &amp;#34;/post/:year/:month/:slug/&amp;#34; # 自定义文章 URL 结构

# 自定义输出格式
[outputs]
 home = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;, &amp;#34;JSON&amp;#34;] # 支持 JSON API 输出
 section = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;]
 taxonomy = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;]
 term = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;]

# RSS 订阅配置
[params.rss]
 limit = 20 # RSS 文章数量限制
 fullContent = true # RSS 包含完整文章内容

# 站内搜索配置
[outputs]
 home = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;, &amp;#34;JSON&amp;#34;, &amp;#34;SearchIndex&amp;#34;]
[outputFormats.SearchIndex]
 mediaType = &amp;#34;application/json&amp;#34;
 baseName = &amp;#34;searchindex&amp;#34;
 isPlainText = true
 notAlternative = true

# 文章目录配置
[markup.tableOfContents]
 endLevel = 3 # 目录最大深度
 ordered = false # 使用无序列表
 startLevel = 2 # 目录开始层级

# 代码高亮配置
[markup.highlight]
 codeFences = true # 启用代码围栏
 guessSyntax = true # 自动推测代码语言
 lineNoStart = 1 # 起始行号
 lineNos = true # 显示行号
 lineNumbersInTable = true # 使用表格式行号
 tabWidth = 4 # 制表符宽度
 style = &amp;#34;monokai&amp;#34; # 代码高亮主题&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一些重要的最佳实践建议：&lt;/p&gt;</description></item></channel></rss>