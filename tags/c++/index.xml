<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 短松江月</title><link>https://simons.qzz.io/tags/c++/</link><description>Recent content in C++ on 短松江月</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Thu, 29 Jan 2026 11:32:58 +0800</lastBuildDate><atom:link href="https://simons.qzz.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Wasm</title><link>https://simons.qzz.io/post/2025/01/wasm/</link><pubDate>Sun, 05 Jan 2025 12:41:17 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/wasm/</guid><description>&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;cargo build&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id="webassembly-核心技术剖析"&gt;WebAssembly 核心技术剖析&lt;/h1&gt;
&lt;p&gt;让我用一个具体场景开始：你正在用 JavaScript 开发一个视频编码器，却发现即使用上了 Web Worker，处理 4K 视频时依然卡得厉害。为什么？问题出在哪里？&lt;/p&gt;
&lt;h2 id="深入理解-wasm-的本质"&gt;深入理解 WASM 的本质&lt;/h2&gt;
&lt;p&gt;首先，我们需要理解 WASM 的核心 - 它的内存模型和执行模型。&lt;/p&gt;
&lt;h3 id="内存模型解析"&gt;内存模型解析&lt;/h3&gt;
&lt;p&gt;让我们看一段具体代码：&lt;/p&gt;









&lt;div class="code-playground" data-language="cpp"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-cpp"&gt;// C&amp;#43;&amp;#43; 代码
int* buffer = new int[1024]; // 分配4KB内存
buffer[0] = 42;&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;编译成 WASM 后：&lt;/p&gt;</description></item><item><title>如何生成 dll 文件</title><link>https://simons.qzz.io/post/2024/06/dll/</link><pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2024/06/dll/</guid><description>&lt;h1 id="如何生成-dll文件"&gt;如何生成 .dll文件&lt;/h1&gt;
&lt;p&gt;生成dll文件同时会生成lib文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在VS开始界面，搜索dll，创建dll动态链接库&lt;/li&gt;
&lt;li&gt;创建一个类（右键创建类，会自动包含需要的文件） 以查询目录下的文件为例
创建的文件可以不用管
&lt;code&gt;.cpp&lt;/code&gt;文件 输入自己的代码&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="cpp"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-cpp"&gt;#include &amp;#34;pch.h&amp;#34;
#include &amp;#34;check_repository.h&amp;#34;
namespace fs = std::filesystem;
 int Check::CheckRepository() {
 std::string folderName = &amp;#34;.Rysigy&amp;#34;;
 fs::path currentPath = fs::current_path();
 fs::path folderPath = currentPath / folderName;

 if (fs::exists(folderPath) &amp;amp;&amp;amp; fs::is_directory(folderPath)) {
 std::cout &amp;lt;&amp;lt; &amp;#34;存储库 &amp;#39;.Rysigy&amp;#39; 文件夹存在\n&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 else {
 std::cout &amp;lt;&amp;lt; &amp;#34;[错误]\t存储库 &amp;#39;.Rysigy&amp;#39; 文件夹不存在\n请在右键菜单中点击 &amp;#39;创建存储库&amp;#39;\n&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 std::cout &amp;lt;&amp;lt; &amp;#34;点击任意按键退出...&amp;#34; &amp;lt;&amp;lt; std::endl;
 _getch();
 return 0;
};&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;.h&lt;/code&gt;文件&lt;/p&gt;</description></item><item><title>C 语言推荐书籍</title><link>https://simons.qzz.io/post/2023/11/c_book/</link><pubDate>Wed, 29 Nov 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/11/c_book/</guid><description>&lt;h1 id="c语言系列"&gt;C语言系列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《C漏洞与缺陷》&lt;/li&gt;
&lt;li&gt;《C语言深度解剖》&lt;/li&gt;
&lt;li&gt;《C和指针》&lt;/li&gt;
&lt;li&gt;《明解C语言》&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="c系列"&gt;C++系列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《高质量的C/C++编程》&lt;/li&gt;
&lt;li&gt;《程序员的自我修养》&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="java系列"&gt;java系列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《java编程思想》&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="计算机系列"&gt;计算机系列&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;深入理解计算机系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="数据结构"&gt;数据结构&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《大话数据结构》&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="内存"&gt;内存&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《地址的故事》&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="编程"&gt;编程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《程序员编程故事》&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="算法"&gt;算法&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;《剑指offer》&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>函数栈帧的创建和销毁</title><link>https://simons.qzz.io/post/2023/07/function_stack/</link><pubDate>Sat, 15 Jul 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/07/function_stack/</guid><description>&lt;p&gt;&lt;code&gt;C/C++&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数栈帧的创建和销毁&lt;/p&gt;
&lt;p&gt;在学习最基础的C语言程序的语法与使用时，但你是否有疑问？&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数的作用域是怎么形成的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部变量是如何创建的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么未初始化的局部变量的值是随机值或是乱码呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数是如何传参的？&lt;/p&gt;
&lt;p&gt;传参的顺序又是怎么样的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形参和实参的关系是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的调用是怎么实现的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数调用结束后是怎么返回的呢？&lt;/p&gt;</description></item><item><title>C++ 命名规范</title><link>https://simons.qzz.io/post/2023/05/cpp_named/</link><pubDate>Mon, 29 May 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/05/cpp_named/</guid><description>&lt;p&gt;
&lt;a href="https://codeif.xinke.org.cn"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 codeif
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;h1 id="文件命名"&gt;文件命名&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;所有文件&lt;/p&gt;
&lt;p&gt;头文件和原文件成对出现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;全部小写, 可是使用下划线&amp;quot;_&amp;quot;(默认)或连字符&amp;quot;-&amp;quot;, 称完整, 不要有歧义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_file.c &amp;amp; system_file.h&lt;/li&gt;
&lt;li&gt;item_name.c&lt;/li&gt;
&lt;li&gt;item-name.c&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="类型命名"&gt;类型命名&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;每个单词首字母大写, 不使用下划线&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;Timer&lt;/li&gt;
&lt;li&gt;File&lt;/li&gt;
&lt;li&gt;Name&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="变量命名"&gt;变量命名&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;变量, 函数参数, 数据成员名&lt;/p&gt;</description></item></channel></rss>