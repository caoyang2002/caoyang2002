<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on 短松江月</title><link>https://simons.qzz.io/tags/rust/</link><description>Recent content in Rust on 短松江月</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Thu, 29 Jan 2026 11:32:58 +0800</lastBuildDate><atom:link href="https://simons.qzz.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 函数式编程</title><link>https://simons.qzz.io/post/2025/01/rust_programming/</link><pubDate>Wed, 15 Jan 2025 11:48:53 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/rust_programming/</guid><description>&lt;p&gt;让我用这种方式来讲解 Rust 的函数式编程概念：&lt;/p&gt;
&lt;h1 id="引入问题"&gt;引入问题&lt;/h1&gt;
&lt;p&gt;想象这样一个场景：你需要处理一个电商系统的订单数据。要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;过滤出金额大于 100 的订单&lt;/li&gt;
&lt;li&gt;计算这些订单的总金额&lt;/li&gt;
&lt;li&gt;给每个订单加上 10% 的折扣&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;传统的命令式编程可能是这样：&lt;/p&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;let mut total = 0;
for order in orders {
 if order.amount &amp;gt; 100 {
 total &amp;#43;= order.amount * 0.9;
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;这段代码有什么问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性不高：逻辑分散在循环中&lt;/li&gt;
&lt;li&gt;难以修改：如果要改变处理逻辑，需要修改循环内部&lt;/li&gt;
&lt;li&gt;难以复用：这段逻辑很难在其他地方重用&lt;/li&gt;
&lt;li&gt;易出错：可变状态(total)增加了出错风险&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="问题模型"&gt;问题模型&lt;/h1&gt;
&lt;p&gt;我们需要一种方式能够：&lt;/p&gt;</description></item><item><title>Rust 生命周期</title><link>https://simons.qzz.io/post/2025/01/rust_cyc/</link><pubDate>Wed, 15 Jan 2025 11:41:27 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/rust_cyc/</guid><description>&lt;p&gt;让我系统地分析 Rust 的生命周期：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;问题场景：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;// 考虑这个场景：我们需要返回一个引用
fn longest(x: &amp;amp;str, y: &amp;amp;str) -&amp;gt; &amp;amp;str {
 if x.len() &amp;gt; y.len() {
 x
 } else {
 y
 }
}
// 编译错误：missing lifetime specifier&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="2"&gt;
&lt;li&gt;这个特性是什么：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;生命周期是 Rust 的类型系统中用于确保引用有效性的一种机制&lt;/li&gt;
&lt;li&gt;它通过标注来告诉编译器多个引用之间的生命周期关系&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;导致这个特性出现的问题：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;// 问题1：悬垂引用
let r;
{
 let x = 5;
 r = &amp;amp;x; // x 在这里就会被销毁
}
println!(&amp;#34;{}&amp;#34;, r); // r 引用了已经无效的内存

// 问题2：引用的有效期不明确
struct Person&amp;lt;&amp;#39;a&amp;gt; {
 name: &amp;amp;&amp;#39;a str // 没有生命周期标注时，不知道这个引用能活多久
}

// 问题3：函数返回引用时的所有权问题
fn return_ref(data: &amp;amp;str) -&amp;gt; &amp;amp;str { // 返回引用时需要明确它的有效期
 data
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="4"&gt;
&lt;li&gt;解决方案分析：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;// 方案1：完全避免使用引用，使用所有权
struct Person {
 name: String // 而不是 &amp;amp;str
}
// 优点：安全
// 缺点：性能开销，不够灵活

// 方案2：生命周期标注
struct Person&amp;lt;&amp;#39;a&amp;gt; {
 name: &amp;amp;&amp;#39;a str
}
// 优点：既安全又灵活
// 缺点：语法复杂度增加

// 方案3：使用智能指针
struct Person {
 name: Rc&amp;lt;String&amp;gt;
}
// 优点：灵活性高
// 缺点：运行时开销&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="5"&gt;
&lt;li&gt;最佳解决方案 - 生命周期标注：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;// 1. 函数中的生命周期标注
fn longest&amp;lt;&amp;#39;a&amp;gt;(x: &amp;amp;&amp;#39;a str, y: &amp;amp;&amp;#39;a str) -&amp;gt; &amp;amp;&amp;#39;a str {
 if x.len() &amp;gt; y.len() {
 x
 } else {
 y
 }
}

// 2. 结构体中的生命周期标注
struct Book&amp;lt;&amp;#39;a&amp;gt; {
 title: &amp;amp;&amp;#39;a str,
 author: &amp;amp;&amp;#39;a str,
}

// 3. impl 块中的生命周期标注
impl&amp;lt;&amp;#39;a&amp;gt; Book&amp;lt;&amp;#39;a&amp;gt; {
 fn get_title(&amp;amp;self) -&amp;gt; &amp;amp;str {
 self.title
 }
}

// 4. 多个生命周期参数
fn complex&amp;lt;&amp;#39;a, &amp;#39;b&amp;gt;(x: &amp;amp;&amp;#39;a str, y: &amp;amp;&amp;#39;b str) -&amp;gt; &amp;amp;&amp;#39;a str {
 x
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="6"&gt;
&lt;li&gt;生命周期最佳实践：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;// 1. 生命周期省略规则
fn first_word(s: &amp;amp;str) -&amp;gt; &amp;amp;str { // 隐含 &amp;lt;&amp;#39;a&amp;gt;
 // ...
}

// 2. 静态生命周期
let static_str: &amp;amp;&amp;#39;static str = &amp;#34;I live forever&amp;#34;;

// 3. 生命周期约束
fn print_type&amp;lt;T: Display &amp;#43; &amp;#39;static&amp;gt;(t: T) {
 println!(&amp;#34;{}&amp;#34;, t);
}

// 4. 正确使用 &amp;#39;static
// 好的做法
const HELLO: &amp;amp;&amp;#39;static str = &amp;#34;Hello, world!&amp;#34;;

// 避免过度使用 &amp;#39;static
// 不好的做法
fn bad_practice(data: &amp;amp;&amp;#39;static str) -&amp;gt; &amp;amp;&amp;#39;static str {
 data
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="7"&gt;
&lt;li&gt;结论总结：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;生命周期是 Rust 独特的解决内存安全的机制&lt;/li&gt;
&lt;li&gt;它在编译时就能发现潜在的内存问题&lt;/li&gt;
&lt;li&gt;主要用途：
&lt;ol&gt;
&lt;li&gt;防止悬垂引用&lt;/li&gt;
&lt;li&gt;确保引用的有效性&lt;/li&gt;
&lt;li&gt;管理数据的生存期&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用建议：
&lt;ol&gt;
&lt;li&gt;优先使用生命周期省略规则&lt;/li&gt;
&lt;li&gt;需要时才显式标注&lt;/li&gt;
&lt;li&gt;谨慎使用 &amp;lsquo;static&lt;/li&gt;
&lt;li&gt;理解借用检查器的错误信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这个特性，Rust 在编译时就能保证内存安全，而不需要运行时垃圾回收，这是它的一个重要优势。虽然生命周期标注增加了一些代码复杂度，但这是为了内存安全付出的必要成本。&lt;/p&gt;</description></item><item><title>深入理解 Rust 所有权机制</title><link>https://simons.qzz.io/post/2025/01/rust_ownership/</link><pubDate>Wed, 15 Jan 2025 11:38:20 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/rust_ownership/</guid><description>&lt;h1 id="从一个常见问题说起"&gt;从一个常见问题说起&lt;/h1&gt;
&lt;p&gt;看这段在其他语言中很普通的代码：&lt;/p&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;fn main() {
 let data = vec![1, 2, 3];
 process_data(data);
 println!(&amp;#34;{:?}&amp;#34;, data); // 编译错误！
}

fn process_data(v: Vec&amp;lt;i32&amp;gt;) {
 println!(&amp;#34;Processing: {:?}&amp;#34;, v);
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;为什么这段代码在Rust中会报错？这就涉及到 Rust 最独特的特性：所有权系统。&lt;/p&gt;
&lt;h2 id="所有权的三条核心规则"&gt;所有权的三条核心规则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;每个值只能有一个所有者&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有者离开作用域，值将被丢弃&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个值同一时刻只能有一个所有者&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们通过代码详细理解这些规则：&lt;/p&gt;
&lt;h3 id="规则1单一所有权"&gt;规则1：单一所有权&lt;/h3&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;let s1 = String::from(&amp;#34;hello&amp;#34;);
let s2 = s1; // 所有权从s1转移到s2
// println!(&amp;#34;{}&amp;#34;, s1); // 编译错误：s1已经失效&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;内存布局变化：&lt;/p&gt;</description></item><item><title>rust 中的属性宏</title><link>https://simons.qzz.io/post/2025/01/rust_macro/</link><pubDate>Wed, 15 Jan 2025 11:16:52 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/rust_macro/</guid><description>&lt;h1 id="deriveclone-debug-serialize-deserialize-eq-partialeq"&gt;&lt;code&gt;#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;这是 Rust 语言中的属性宏(attribute macro)声明，用于自动为数据结构实现一些常用的特性(traits)。让我详细解释每个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;derive&lt;/code&gt; - 这是 Rust 的派生宏，用于自动生成特定 trait 的实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;括号里的每个特性具体作用是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Clone&lt;/code&gt; - 允许类型创建自身的深拷贝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Debug&lt;/code&gt; - 实现格式化调试输出，使用 &lt;code&gt;{:?}&lt;/code&gt; 格式说明符可以打印该类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Serialize&lt;/code&gt; - 来自 serde 库，使类型可以被序列化(比如转换成 JSON)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Deserialize&lt;/code&gt; - 也来自 serde 库，使类型可以被反序列化(比如从 JSON 转换回来)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eq&lt;/code&gt; - 实现完全相等比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PartialEq&lt;/code&gt; - 实现部分相等比较，允许使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种写法可以让我们避免手动实现这些特性，编译器会自动为我们生成实现代码。这在定义数据结构时非常常用，特别是在需要序列化/反序列化数据的场景中。&lt;/p&gt;</description></item><item><title>Wasm 打印输出和浏览器特性等最佳实践</title><link>https://simons.qzz.io/post/2025/01/wasm_print/</link><pubDate>Wed, 15 Jan 2025 00:31:17 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/wasm_print/</guid><description>&lt;p&gt;在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;web_sys&lt;/code&gt; 和 &lt;code&gt;wasm_bindgen&lt;/code&gt; 进行浏览器 API 调用：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use wasm_bindgen::prelude::*;
use web_sys::{console, window};

pub fn move_test(name: &amp;amp;str) {
 // 控制台打印
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;move test: {}&amp;#34;, name)));

 // 使用 console.warn
 console::warn_1(&amp;amp;JsValue::from_str(&amp;#34;This is a warning&amp;#34;));

 // 使用 console.error
 console::error_1(&amp;amp;JsValue::from_str(&amp;#34;This is an error&amp;#34;));

 // 浏览器 alert
 if let Some(window) = window() {
 window
 .alert_with_message(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;, name))
 .expect(&amp;#34;alert failed&amp;#34;);
 }

 // 确认对话框
 if let Some(window) = window() {
 if window
 .confirm_with_message(&amp;#34;Do you want to continue?&amp;#34;)
 .expect(&amp;#34;confirm failed&amp;#34;)
 {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked OK&amp;#34;));
 } else {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked Cancel&amp;#34;));
 }
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="2"&gt;
&lt;li&gt;在 Cargo.toml 中需要添加必要的依赖：&lt;/li&gt;
&lt;/ol&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-toml" data-lang="toml"&gt;[dependencies]
wasm-bindgen = &amp;#34;0.2&amp;#34;
web-sys = { version = &amp;#34;0.3&amp;#34;, features = [
 &amp;#34;console&amp;#34;,
 &amp;#34;Window&amp;#34;,
 &amp;#34;Document&amp;#34;,
 &amp;#34;Element&amp;#34;,
 &amp;#34;HtmlElement&amp;#34;,
 &amp;#34;Node&amp;#34;,
 &amp;#34;Location&amp;#34;
]}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol start="3"&gt;
&lt;li&gt;如果需要格式化打印，可以使用 &lt;code&gt;console::log!&lt;/code&gt; 宏：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use web_sys::console;

// 需要引入宏
#[macro_export]
macro_rules! console_log {
 ($($t:tt)*) =&amp;gt; (console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!($($t)*))))
}

pub fn move_test(name: &amp;amp;str) {
 console_log!(&amp;#34;Testing move with name: {}&amp;#34;, name);
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="4"&gt;
&lt;li&gt;操作 DOM 示例：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, window};

pub fn move_test(name: &amp;amp;str) {
 // 获取 document
 let window = window().expect(&amp;#34;no global window exists&amp;#34;);
 let document = window.document().expect(&amp;#34;no document exists&amp;#34;);

 // 创建新元素
 if let Some(div) = document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 // 修改输入框的值
 if let Some(input) = div.dyn_ref::&amp;lt;HtmlElement&amp;gt;() {
 input.set_inner_text(&amp;amp;format!(&amp;#34;New value: {}&amp;#34;, name));
 }
 }

 // 创建新元素
 let new_div = document.create_element(&amp;#34;div&amp;#34;).unwrap();
 new_div.set_text_content(Some(&amp;amp;format!(&amp;#34;Hello {}&amp;#34;, name)));

 // 添加到 body
 if let Some(body) = document.body() {
 body.append_child(&amp;amp;new_div).unwrap();
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="5"&gt;
&lt;li&gt;处理错误和 Result：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 // 使用 ? 运算符处理错误
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;
 let document = window.document().ok_or(&amp;#34;no document exists&amp;#34;)?;

 // 处理可能的错误
 match document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 Some(element) =&amp;gt; {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Found element: {}&amp;#34;, name)));
 Ok(())
 },
 None =&amp;gt; Err(JsValue::from_str(&amp;#34;Element not found&amp;#34;))
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="6"&gt;
&lt;li&gt;使用本地存储：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use web_sys::Storage;

pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;

 // 获取 localStorage
 if let Some(storage) = window.local_storage()? {
 // 存储数据
 storage.set_item(&amp;#34;user_name&amp;#34;, name)?;

 // 读取数据
 if let Ok(Some(saved_name)) = storage.get_item(&amp;#34;user_name&amp;#34;) {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Saved name: {}&amp;#34;, saved_name)));
 }
 }

 Ok(())
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 &amp;ldquo;Storage&amp;rdquo; feature：&lt;/p&gt;</description></item><item><title>Aptos Wasm 开发笔记</title><link>https://simons.qzz.io/post/2025/01/aptos-wasm/</link><pubDate>Sun, 05 Jan 2025 11:08:24 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/aptos-wasm/</guid><description>&lt;h1 id="起因"&gt;起因&lt;/h1&gt;
&lt;p&gt;最近有一个项目需要使用到 Apots 的 Move 开发环境，但是官方并没有提供 Move-2 的 Wasm，出于对技术的“狂热”，决定自己学一下这个技术的实现。&lt;/p&gt;
&lt;p&gt;对于我来说，可以了解到 Rust 和 Move 的编译原理，这是一个很好的机会，虽然我从来没正式写过 Rust 和 Move。&lt;/p&gt;
&lt;h1 id="开始"&gt;开始&lt;/h1&gt;
&lt;p&gt;我看不懂 &lt;code&gt;aptos-core&lt;/code&gt; 从的功能，但我没有一开始就尝试编译这整个项目，而是在 &lt;code&gt;aptos-core/third_party&lt;/code&gt; 看到了 &lt;code&gt;move&lt;/code&gt; 编译器相关的东西，所以我就从这里开始。&lt;/p&gt;</description></item><item><title>创建一个远程编译环境</title><link>https://simons.qzz.io/post/2024/04/a_code_env/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2024/04/a_code_env/</guid><description>&lt;blockquote&gt;
&lt;p&gt;我使用的是 Mac，所以以下都是 Mac 的说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="一前端tsreact"&gt;一、前端（ts、react）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;前端配置：TypeScript、React
依赖项：axios、codemirror、react-codemirror2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="1-初始化模板"&gt;1. 初始化模板&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;任意选一个就行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="11-交互式"&gt;1.1 交互式&lt;/h3&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;npm init vite&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;可能需要先安装
&lt;code&gt;npm install vite --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-" data-lang=""&gt;caoyang@cccy del % npm init vite
# 使用 上下键 选择
✔ Project name: … playground # playground 是项目名称，它会创建一个该名称的文件夹作为项目根目录
✔ Select a framework: › React # 使用 React 库
✔ Select a variant: › TypeScript # 使用 TS 语言开发

Scaffolding project in /Users/caoyang/Documents/Aptos/del/playground...

Done. Now run:

# 需要先运行以下代码
 cd playground
 npm install
 npm run dev&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id="12-一键创建"&gt;1.2 一键创建&lt;/h3&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;npm init vite playground -- --template react-ts&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;</description></item></channel></rss>