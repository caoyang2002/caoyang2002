<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术 on 短松江月</title><link>https://simons.qzz.io/posts/tech/</link><description>Recent content in 技术 on 短松江月</description><generator>Hugo</generator><language>zh-CN</language><atom:link href="https://simons.qzz.io/posts/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP/IP 协议</title><link>https://simons.qzz.io/post/2026/01/tcp_ip/</link><pubDate>Wed, 28 Jan 2026 12:14:55 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/tcp_ip/</guid><description>&lt;p&gt;
&lt;a href="https://www.cnblogs.com/crazymakercircle/p/14499211.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 原文
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id="tcpip协议详解"&gt;TCP/IP协议详解&lt;/h2&gt;
&lt;p&gt;TCP/IP协议包含了一系列的协议，也叫TCP/IP协议族（TCP/IP Protocol Suite，或TCP/IP&lt;br&gt;
Protocols），简称TCP/IP。TCP/IP协议族提供了点对点的连结机制，并且将传输数据帧的封装、寻址、传输、路由以及接收方式，都予以标准化。&lt;/p&gt;
&lt;h2 id="tcpip协议的分层模型"&gt;TCP/IP协议的分层模型&lt;/h2&gt;
&lt;p&gt;在展开介绍TCP/IP协议之前，首先介绍一下七层ISO模型。国际标准化组织ISO为了使网络应用更为普及，推出了OSI参考模型，即开放式系统互联（Open&lt;br&gt;
System Interconnect）模型，&lt;br&gt;
一般都叫OSI参考模型。OSI参考模型是ISO组织在1985年发布的网络互连模型，其含义就是为所有公司使用一个统一的规范来控制网络，这样所有公司遵循相同的通信规范，网络就能互联互通了。&lt;/p&gt;</description></item><item><title>爬虫、反爬与反反爬</title><link>https://simons.qzz.io/post/2026/01/the_spider/</link><pubDate>Wed, 28 Jan 2026 11:26:57 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/the_spider/</guid><description>&lt;p&gt;
&lt;a href="https://www.cnblogs.com/vivotech/p/16695804.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 查看原文
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;互联网的大数据时代的来临，网络爬虫也成了互联网中一个重要行业，它是一种自动获取网页数据信息的爬虫程序，是网站搜索引擎的重要组成部分。通过爬虫，可以获取自己想要的相关数据信息，让爬虫协助自己的工作，进而降低成本，提高业务成功率和提高业务效率。&lt;/p&gt;
&lt;p&gt;本文一方面从爬虫与反反爬的角度来说明如何高效的对网络上的公开数据进行爬取，另一方面也会介绍反爬虫的技术手段，为防止外部爬虫大批量的采集数据的过程对服务器造成超负载方面提供些许建议。&lt;/p&gt;</description></item><item><title>思通舆情安装和配置</title><link>https://simons.qzz.io/post/2026/01/stonedt_yuqing/</link><pubDate>Tue, 27 Jan 2026 18:51:52 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/stonedt_yuqing/</guid><description>&lt;p&gt;
&lt;a href="https://github.com/stonedtman/stonedt-yuqing"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 Github
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;注意：思通舆情只能安装在 amd64 的设备上。&lt;/p&gt;
&lt;h1 id="docker-安装"&gt;DOcker 安装&lt;/h1&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;docker run -itd --name stonedt_yuqing -p 8085:8085 crpi-8mxxyq37t3w9t2kj.cn-hangzhou.personal.cr.aliyuncs.com/stonedtx/stonedt_yuqing:1.0.10&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果没有提示错误，就是安装成功了&lt;/p&gt;
&lt;p&gt;访问你安装设备的 8085 端口，例如 http://localhost:8085&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户名 &lt;code&gt;13900000000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;密码 &lt;code&gt;stonedt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这时候，你打开页面只能看到一个方案。&lt;/p&gt;
&lt;h1 id="创建一个舆情检测方案"&gt;创建一个舆情检测方案&lt;/h1&gt;
&lt;h2 id="新建方案组"&gt;新建方案组&lt;/h2&gt;
&lt;p&gt;左上角 &lt;code&gt;新建舆情检测&lt;/code&gt; -&amp;gt; &lt;code&gt;新建舆情方案组&lt;/code&gt; -&amp;gt; 输入方案组名称&lt;/p&gt;
&lt;h2 id="新建舆情方案"&gt;新建舆情方案&lt;/h2&gt;
&lt;p&gt;在页面的右上角，点击 &lt;code&gt;新建&lt;/code&gt;, &lt;code&gt;方案名称&lt;/code&gt; 自行设置。然后在 &lt;code&gt;高级创建&lt;/code&gt; 中, 方案主题关键词语法是:&lt;/p&gt;</description></item><item><title>您需要了解的 14 个最重要的元和 HTML 标签</title><link>https://simons.qzz.io/post/2026/01/14_mos_-important_meta_and_html_tags_you_need_to_know_for_seo/</link><pubDate>Mon, 26 Jan 2026 14:19:26 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/14_mos_-important_meta_and_html_tags_you_need_to_know_for_seo/</guid><description>&lt;p&gt;使用有效的 Meta 和 HTML 标签提升您的 SEO。了解如何使用元标记优化您的网站以提高搜索引擎排名。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.searchenginejournal.com/wp-content/uploads/2020/07/important-meta-tags-5f203655f1aa8.jpg" alt="14 Most Important Meta And HTML Tags You Need To Know For SEO"&gt;&lt;/p&gt;
&lt;p&gt;很长一段时间以来，HTML 元标记一直被称为 
&lt;a href="https://www.searchenginejournal.com/seo/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 SEO
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
 最重要的方面之一。你知道吗？这仍然是正确的。&lt;/p&gt;
&lt;p&gt;谷歌的约翰
&lt;a href="https://www.searchenginejournal.com/google-answers-if-meta-description-matters-for-rankings/449119/#:~:text=John%20Mueller%20answered%3A"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 ·穆勒 （John Mueller） 表示
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
，谷歌使用 HTML 元标记来形成 SERP 片段，而不是用于排名。在这段声明中，他还说一个好的搜索片段会让人们访问你的页面。因此，元标记绝对是您必须关心才能获得流量的内容。&lt;/p&gt;</description></item><item><title>Mail 管理</title><link>https://simons.qzz.io/post/2026/01/mail-manager/</link><pubDate>Mon, 26 Jan 2026 14:09:44 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/mail-manager/</guid><description>&lt;p&gt;注意目前管理 outlook 邮箱存在问题。&lt;/p&gt;
&lt;h1 id="下载套件"&gt;下载套件&lt;/h1&gt;
&lt;p&gt;下载 MailPlus 和 MailPlus Server 套件。&lt;/p&gt;
&lt;h1 id="配置-mailplus-server"&gt;配置 MailPlus Server&lt;/h1&gt;
&lt;p&gt;打开 MailPlus Server，如果没有公网 IP，最开始的配置其实无所谓，随便填写都行，毕竟无论如何都发不出邮件。&lt;/p&gt;
&lt;p&gt;然后点击 &lt;code&gt;服务&lt;/code&gt; 选项，在点击顶部的 &lt;code&gt;MailPlus 客户端&lt;/code&gt; 标签，全部勾选即可。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://simons.qzz.io/assets/mailplus_client_pop_settings.png" alt="image"&gt;&lt;/p&gt;
&lt;h1 id="配置-mailplus"&gt;配置 MailPlus&lt;/h1&gt;
&lt;h2 id="打开-设置"&gt;打开 &lt;code&gt;设置&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;点击右上角的用户名，打开 MailPlus 的 &lt;code&gt;设置&lt;/code&gt;，然后找到 &lt;code&gt;POP3 收取&lt;/code&gt;，然后点击 &lt;code&gt;新增&lt;/code&gt;。根据自己的情况添加就可以了。&lt;/p&gt;</description></item><item><title>C10k 问题</title><link>https://simons.qzz.io/post/2026/01/c10k/</link><pubDate>Mon, 26 Jan 2026 13:56:41 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/c10k/</guid><description>&lt;p&gt;
&lt;a href="https://www.kegel.com/c10k.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 查看原文
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;h1 id="前言"&gt;前言&lt;/h1&gt;
&lt;p&gt;《C10K问题》这篇经典文章深入探讨了如何在现代硬件条件下构建能够处理数万并发连接的高性能服务器系统。文章开篇即点明核心观点：随着硬件性能的飞速发展，单个服务器已具备同时服务大量客户端的物理能力，真正的挑战在于软件架构设计和操作系统机制优化。&lt;/p&gt;
&lt;p&gt;作者首先回顾了技术发展背景，指出在二十世纪末期，千兆以太网和高速硬件已经普及，但软件架构却成为制约服务器并发能力的主要瓶颈。接着文章系统性地提出了五种主流的技术方案，每种方案都代表了不同的设计哲学和实现路径。&lt;/p&gt;</description></item><item><title>零复制技术</title><link>https://simons.qzz.io/post/2026/01/zero_copy/</link><pubDate>Mon, 26 Jan 2026 13:45:11 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/zero_copy/</guid><description>&lt;p&gt;
&lt;a href="https://www.cnblogs.com/f-ck-need-u/p/7615914.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 查看原文
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;h1 id="零复制zero-copy技术"&gt;零复制(zero copy)技术&lt;/h1&gt;
&lt;h2 id="11-背景说明网络数据传输的全过程"&gt;1.1 背景说明：网络数据传输的全过程&lt;/h2&gt;
&lt;p&gt;在每一次网络io过程，数据都要经过几个缓存，再发送出去。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://images2017.cnblogs.com/blog/733013/201709/733013-20170930140554637-512964522.png" alt="I/O between OSs" title="I/O between OSs"&gt;&lt;/p&gt;
&lt;p&gt;以右侧为浏览器，左侧为httpd服务器为例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当httpd服务收到浏览器发送的index.html文件的请求时，负责处理请求的httpd子进程/线程总是会先发起系统调用，让内核将index.html从存储设备中加载出来。但是加载到的位置是内核空间的缓冲区kernel buffer，而不是直接给进程/线程的内存区。由于是内存设备和存储设备之间的数据传输，没有CPU的参与，所以这次是DMA操作。&lt;/p&gt;</description></item><item><title>Http 协议</title><link>https://simons.qzz.io/post/2026/01/http_protcal/</link><pubDate>Mon, 26 Jan 2026 13:44:19 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/http_protcal/</guid><description>&lt;h1 id="建议精读http灵魂之问巩固你的-http-知识体系"&gt;（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系&lt;/h1&gt;
&lt;p&gt;上回就已经承诺过大家，一定会出 HTTP 的系列文章，今天终于整理完成了。作为一个 web 开发，HTTP 几乎是天天要打交道的东西，但我发现大部分人对 HTTP 只是浅尝辄止，对更多的细节及原理就了解不深了，在面试的时候感觉非常吃力。这篇文章就是为了帮助大家树立完整的 HTTP 知识体系，并达到一定的深度，从容地应对各种灵魂之问，也同时提升自己作为一个 web 开发的专业素养吧。这是本文的思维导图:&lt;/p&gt;</description></item><item><title>Emacs 基础</title><link>https://simons.qzz.io/post/2026/01/emacs_basic/</link><pubDate>Mon, 26 Jan 2026 13:39:47 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/emacs_basic/</guid><description>&lt;p&gt;本篇介绍 GNU Emacs 的基础知识和操作。本文内容只是让读者初识 Emacs 操作，这些操作需要日积月累的练习才能掌握，本文的后半部分更偏向用于日后查阅；另一方面，很多操作有些繁琐难以记忆，笔者将会在后续介绍一些插件能够极大改善这些问题，因此读者如果遇到晦涩的地方不必过分担心，也不用死记硬背。&lt;/p&gt;
&lt;p&gt;文章的结尾附上了本文出现的快捷键及其命令名，供读者查阅。&lt;/p&gt;</description></item><item><title>Vim 折叠代码块</title><link>https://simons.qzz.io/post/2026/01/vim_code_block/</link><pubDate>Mon, 26 Jan 2026 13:36:45 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/vim_code_block/</guid><description>&lt;p&gt;在查看代码的时候，如果代码十分冗长，尤其是 c/c++ 系列的时候，代码结构比较让人难以理清，主要是各种注释、括号的匹配问题。&lt;/p&gt;
&lt;p&gt;虽然可以用&lt;code&gt;%&lt;/code&gt;来查看匹配的另外一半符号在哪里，但是如果这一对符号之间的代码超过了一页，甚至好几页的话，那么也是比较难以理解的。&lt;/p&gt;
&lt;p&gt;于是可以使用这个vim所提供的折叠功能来简化这些分析。&lt;/p&gt;</description></item><item><title>Vim 命令速查</title><link>https://simons.qzz.io/post/2026/01/vim_refrence/</link><pubDate>Mon, 26 Jan 2026 13:35:50 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/vim_refrence/</guid><description>&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/chloneda/vim-cheatsheet"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 Vim-cheatsheet - GitHub
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
 | 
&lt;a href="https://gitee.com/chloneda/vim-cheatsheet"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 Vim-cheatsheet - Gitee
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://www.vim.org/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 Vim 官网
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
 | 
&lt;a href="https://github.com/vim/vim"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 Vim GitHub
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
 | 
&lt;a href="http://vimcdoc.sourceforge.net/doc/help.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 Vim 中文文档
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="./vimrc"
 
 &gt;
 Vim 跨平台配置文件 vimrc
 
&lt;/a&gt;
 | 
&lt;a href="resources/vim-tools.md"
 
 &gt;
 Vim 体系化工具集
 
&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="一重复的威力"&gt;一、重复的威力&lt;/h1&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;. # 小数点，即重复（Dot）命令，重复执行上一次命令
N{command} # 重复某个命令 N 次，例如：10k，光标上移 10 行&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Tips: 善用宏和正则表达式，同样可以达到减少重复操作的目的。&lt;/p&gt;
&lt;h1 id="二移动"&gt;二、移动&lt;/h1&gt;
&lt;h2 id="1-光标移动"&gt;1. 光标移动&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：普通（Normal）模式下，任意一个动作都可以重复。&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Jupyter 快捷键</title><link>https://simons.qzz.io/post/2026/01/jupyter_key/</link><pubDate>Mon, 26 Jan 2026 13:34:04 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/jupyter_key/</guid><description>&lt;h3 id="jupyter-notebook-的快捷键"&gt;Jupyter Notebook 的快捷键&lt;/h3&gt;
&lt;p&gt;Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。&lt;/p&gt;
&lt;h4 id="命令模式-按键-esc-开启"&gt;命令模式 (按键 Esc 开启)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Enter&lt;/code&gt; : 转入编辑模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Shift-Enter&lt;/code&gt; : 运行本单元，选中下个单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-Enter&lt;/code&gt; : 运行本单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Alt-Enter&lt;/code&gt; : 运行本单元，在其下插入新单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Y&lt;/code&gt; : 单元转入代码状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;M&lt;/code&gt; :单元转入markdown状态&lt;/p&gt;</description></item><item><title>稚晖君的工作流</title><link>https://simons.qzz.io/post/2026/01/zhihuijun_create/</link><pubDate>Mon, 26 Jan 2026 13:32:10 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/zhihuijun_create/</guid><description>&lt;h1 id="一软件篇"&gt;一、软件篇&lt;/h1&gt;
&lt;h2 id="1-创意收集整理"&gt;1. 创意收集整理：&lt;/h2&gt;
&lt;p&gt;1、&lt;code&gt;XMind ZEN&lt;/code&gt; (思维导图，zen版本更为简洁)
2、&lt;code&gt;Typora&lt;/code&gt;(写markdown的编辑器)
3、有道云笔记(推荐)、印象笔记、为知笔记、OneNote&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于markdown：
github：readme.md(md=markdown)
建议从事技术的同行都掌握的一种文本语言
可以在多平台自由遨游，到处分享而无须担心格式&lt;/p&gt;</description></item><item><title>注册一个免费的域名</title><link>https://simons.qzz.io/post/2026/01/register_a_free_domian/</link><pubDate>Mon, 05 Jan 2026 12:28:47 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/register_a_free_domian/</guid><description>&lt;p&gt;大家好，欢迎来到AI解码师的频道。&lt;/p&gt;
&lt;p&gt;之前我们曾发布过一期关于如何利用 DigitalPlat 注册永久免费域名的内容。然而，很可惜，在那个内容上线后不久，us.kg 域名的注册系统就出现了故障，相关的注册服务被迫暂停了一段时间。&lt;/p&gt;
&lt;p&gt;现在，好消息终于来了！经过这段时间的系统升级和维护，DigitalPlat 现已重新开放注册。更令人惊喜的是，本次升级不仅让注册流程变得更加简单便捷，还额外增加了一个免费域名额度的福利。&lt;/p&gt;</description></item><item><title>安装 Gitea</title><link>https://simons.qzz.io/post/2025/12/install_gitea/</link><pubDate>Sun, 28 Dec 2025 21:09:14 +0800</pubDate><guid>https://simons.qzz.io/post/2025/12/install_gitea/</guid><description>&lt;blockquote&gt;
&lt;p&gt;参考：
&lt;a href="https://docs.gitea.com/zh-cn/category/installation"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 官方文档
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gitea 支持多种安装方法，这里只介绍 docker 的安装方法&lt;/p&gt;
&lt;h1 id="方法一使用docker命令行安装推荐"&gt;方法一：使用Docker命令行安装（推荐）&lt;/h1&gt;
&lt;h2 id="1-创建数据目录"&gt;1. 创建数据目录&lt;/h2&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;# 创建必要的目录
sudo mkdir -p /opt/gitea/data
sudo mkdir -p /opt/gitea/config
sudo mkdir -p /opt/gitea/logs

# 设置权限（Gitea默认使用uid=1000, gid=1000的用户）
sudo chown -R 1000:1000 /opt/gitea&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id="2-运行gitea容器"&gt;2. 运行Gitea容器&lt;/h3&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;docker run -d \
 --name=gitea \
 --privileged=true \
 --restart=unless-stopped \
 -p 3000:3000 \
 -p 2222:22 \
 -v /opt/gitea/data:/data \
 -v /opt/gitea/config:/etc/gitea \
 -v /etc/timezone:/etc/timezone:ro \
 -v /etc/localtime:/etc/localtime:ro \
 -e USER_UID=1000 \
 -e USER_GID=1000 \
 gitea/gitea:latest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id="3-验证安装"&gt;3. 验证安装&lt;/h2&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;# 查看容器状态
docker ps -a

# 查看日志
docker logs gitea&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;访问：&lt;code&gt;http://your-server-ip:3000&lt;/code&gt; 进行初始设置。&lt;/p&gt;</description></item><item><title>安装 JupyterLab</title><link>https://simons.qzz.io/post/2025/12/install_jupyter_lab/</link><pubDate>Sun, 28 Dec 2025 21:00:56 +0800</pubDate><guid>https://simons.qzz.io/post/2025/12/install_jupyter_lab/</guid><description>&lt;h1 id="使用-docker"&gt;使用 Docker&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;参考： 
&lt;a href="https://jupyter-docker-stacks.readthedocs.io/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 docker stack
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="conda-安装"&gt;Conda 安装&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: 
&lt;a href="https://lab.jupyter.org.cn"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 jupyter lab
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="安装"&gt;安装&lt;/h1&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;conda install -c conda-forge JupyterLab&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id="启动"&gt;启动&lt;/h2&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;jupyter lab&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</description></item><item><title>如何在Ubuntu系统下搭建ESP32开发环境：从零开始配置与测试</title><link>https://simons.qzz.io/post/2025/04/how_to_build_an_esp32_development_environment_under_ubuntu/</link><pubDate>Sun, 06 Apr 2025 17:09:20 +0800</pubDate><guid>https://simons.qzz.io/post/2025/04/how_to_build_an_esp32_development_environment_under_ubuntu/</guid><description>&lt;h3 id="引言"&gt;引言&lt;/h3&gt;
&lt;p&gt;在物联网（IoT）领域，ESP32因其强大的功能和灵活性而广受欢迎。无论是智能家居、工业自动化还是个人项目，ESP32都能提供可靠的解决方案。然而，要充分利用这一强大的微控制器，首先需要搭建一个稳定的开发环境。本文将详细介绍如何在Ubuntu系统下搭建ESP32开发环境，帮助新手和有一定经验的开发者顺利入门。&lt;/p&gt;</description></item><item><title>mysql</title><link>https://simons.qzz.io/post/2025/03/mysql_creates_user/</link><pubDate>Thu, 06 Mar 2025 08:42:26 +0800</pubDate><guid>https://simons.qzz.io/post/2025/03/mysql_creates_user/</guid><description>&lt;h3 id="1-创建用户"&gt;1. &lt;strong&gt;创建用户&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;CREATE USER&lt;/code&gt; 语句创建新用户。语法如下：&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-sql" data-lang="sql"&gt;CREATE USER &amp;#39;username&amp;#39;@&amp;#39;host&amp;#39; IDENTIFIED BY &amp;#39;password&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;username&lt;/code&gt;&lt;/strong&gt;：新用户的用户名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;host&lt;/code&gt;&lt;/strong&gt;：指定用户可以从哪个主机连接到数据库。常见的值包括：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;localhost&lt;/code&gt;：仅允许从本地主机连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;：允许从任何主机连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;password&lt;/code&gt;&lt;/strong&gt;：用户的密码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="示例"&gt;示例：&lt;/h4&gt;
&lt;p&gt;创建一个名为 &lt;code&gt;testuser&lt;/code&gt; 的用户，密码为 &lt;code&gt;testpass&lt;/code&gt;，允许从任何主机连接：&lt;/p&gt;</description></item><item><title>【转载】如何做一个有质量的技术分享</title><link>https://simons.qzz.io/post/2025/02/how_to_make_a_quality_technology_sharing/</link><pubDate>Wed, 12 Feb 2025 09:28:36 +0800</pubDate><guid>https://simons.qzz.io/post/2025/02/how_to_make_a_quality_technology_sharing/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;转载&lt;/strong&gt;
文章作者：左耳朵耗子
出处：
&lt;a href="https://coolshell.cn/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 酷 壳 – CoolShell
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;

非商用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://coolshell.org/wp-content/uploads/2021/07/knowledge_sharing-300x169.jpeg" alt="img"&gt;&lt;/p&gt;
&lt;p&gt;分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：&lt;/p&gt;
&lt;p&gt;1）分享内容的保鲜期是很长的，&lt;/p&gt;</description></item><item><title>解决在 openwrt 中自动安装 1panel 失败的问题</title><link>https://simons.qzz.io/post/2025/01/openwrt_failed_to_install_1panel/</link><pubDate>Wed, 29 Jan 2025 08:28:43 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/openwrt_failed_to_install_1panel/</guid><description>&lt;p&gt;解决在 openwrt 中自动安装 1panel 失败的问题：&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-error" data-lang="error"&gt;Multiple packages (libgcc1 and libgcc1) providing same name marked HOLD or
PREFER. Using latest.
Multiple packages (libgcc1 and libgcc1) providing same name marked HOLD or PREFER. Using latest.
Installing app-meta-istorepanel (1.0.6-20250116) to root...
Downloading https://istore.istoreos.com/repo/all/meta/app-meta-istorepanel_1.0.6-20250116_all.ipk
Collected errors:
 * pkg_hash_check_unresolved: cannot find dependency zoneinfo-asia for luci-app-istorepanel
 * pkg_hash_fetch_best_installation_candidate: Packages for luci-app-istorepanel found, but incompatible with the architectures configured
 * satisfy_dependencies_for: Cannot satisfy the following dependencies for app-meta-istorepanel:
 * zoneinfo-asia
 * opkg_install_cmd: Cannot install package app-meta-istorepanel.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缺少依赖包 &lt;code&gt;zoneinfo-asia&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;架构不兼容的问题&lt;/li&gt;
&lt;li&gt;存在重复的 &lt;code&gt;libgcc1&lt;/code&gt; 包&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果之前安装过 1panel 那么这个失败原因可能是因为之前安装的包没有被完全清理&lt;/p&gt;</description></item><item><title>哈夫曼编码：数据压缩的经典算法</title><link>https://simons.qzz.io/post/2025/01/huffman_coding_a_classic_algorithm_for_data_compression/</link><pubDate>Sun, 26 Jan 2025 11:08:57 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/huffman_coding_a_classic_algorithm_for_data_compression/</guid><description>&lt;h1 id="哈夫曼编码数据压缩的经典算法"&gt;哈夫曼编码：数据压缩的经典算法&lt;/h1&gt;
&lt;p&gt;今天遇到一个有趣的问题：一个100MB的日志文件，需要实时传输，但带宽只有 10MB。很多人二话不说就上 gzip，但你真的理解压缩算法的原理吗？&lt;/p&gt;
&lt;h2 id="什么是哈夫曼编码"&gt;什么是哈夫曼编码？&lt;/h2&gt;
&lt;p&gt;本质上，哈夫曼编码是一种变长编码方案。它的核心思想是：出现频率高的字符用短编码，频率低的用长编码。&lt;/p&gt;









&lt;div class="code-playground" data-language="python"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-python"&gt;# 一个简单的例子
text = &amp;#34;AAAAABBBCC&amp;#34; # 原始数据
# 普通编码：每个字符占8位
# A: 01000001 (8位) × 5 = 40位
# B: 01000010 (8位) × 3 = 24位
# C: 01000011 (8位) × 2 = 16位
# 总共：80位

# 哈夫曼编码
# A: 0 (1位) × 5 = 5位
# B: 10 (2位) × 3 = 6位
# C: 11 (2位) × 2 = 4位
# 总共：15位&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;h2 id="为什么需要哈夫曼编码"&gt;为什么需要哈夫曼编码？&lt;/h2&gt;
&lt;p&gt;看看其他编码方案的问题：&lt;/p&gt;</description></item><item><title>Node.js 的方法</title><link>https://simons.qzz.io/post/2025/01/node.js_methods/</link><pubDate>Sun, 26 Jan 2025 11:03:43 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/node.js_methods/</guid><description>&lt;h1 id="nodejs-的方法"&gt;Node.js 的方法&lt;/h1&gt;
&lt;p&gt;不知道你是否思考过，为什么 Node.js 选择了 JavaScript 作为语言？为什么它能在后端站稳脚跟？今天我们就来扒一扒 Node.js 的底层原理和设计思想。&lt;/p&gt;
&lt;h2 id="什么是-nodejs"&gt;什么是 Node.js?&lt;/h2&gt;
&lt;p&gt;本质上，Node.js 就是一个基于 Chrome V8 引擎的 JavaScript 运行时。但这样说太简单了，让我们来看看它的架构：&lt;/p&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// Node.js 的核心就是事件循环
const fs = require(&amp;#39;fs&amp;#39;);

fs.readFile(&amp;#39;test.txt&amp;#39;, (err, data) =&amp;gt; {
 if (err) throw err;
 console.log(data);
});
console.log(&amp;#39;这行先执行&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;这段代码揭示了 Node.js 最核心的特性：非阻塞I/O和事件驱动。&lt;/p&gt;</description></item><item><title>Git: 从入门到精通</title><link>https://simons.qzz.io/post/2025/01/git_from_entry_to_mastery/</link><pubDate>Sun, 26 Jan 2025 10:50:22 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/git_from_entry_to_mastery/</guid><description>&lt;h1 id="git-从入门到精通"&gt;Git: 从入门到精通&lt;/h1&gt;
&lt;p&gt;很多人用 Git 只会 &lt;code&gt;add/commit/push&lt;/code&gt; 三板斧，遇到冲突就抓瞎。今天我们从原理到实战，彻底搞懂Git。&lt;/p&gt;
&lt;h2 id="git的本质"&gt;Git的本质&lt;/h2&gt;
&lt;p&gt;Git本质上是个内容寻址的文件系统。它把你的代码转成一棵对象树：&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;# 看看Git的底层对象
echo &amp;#39;test&amp;#39; &amp;gt; test.txt
git add test.txt
git cat-file -p HEAD&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;核心概念就三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index/Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="为什么用git"&gt;为什么用Git？&lt;/h2&gt;
&lt;p&gt;对比一下传统SVN：&lt;/p&gt;</description></item><item><title>GitHub Projects深入剖析：不只是看板，是工程管理的操作系统</title><link>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_projects_its_not_just_kanban_its_the_operating_system_for_project_management/</link><pubDate>Sun, 26 Jan 2025 10:48:35 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_projects_its_not_just_kanban_its_the_operating_system_for_project_management/</guid><description>&lt;h1 id="github-projects深入剖析不只是看板是工程管理的操作系统"&gt;GitHub Projects深入剖析：不只是看板，是工程管理的操作系统&lt;/h1&gt;
&lt;p&gt;先说个真实场景：一个十几人的团队，用GitHub管理代码，但项目进度全靠口头同步。最后结果可想而知: 一团糟。&lt;/p&gt;
&lt;h2 id="本质分析"&gt;本质分析&lt;/h2&gt;
&lt;p&gt;GitHub Projects不是简单的任务管理工具，而是一个完整的工程管理系统。它把Issues、PR、代码、里程碑等所有开发要素关联起来。&lt;/p&gt;</description></item><item><title>GitHub Actions 深入剖析：从原理到实践</title><link>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_actions_from_principle_to_practice/</link><pubDate>Sun, 26 Jan 2025 10:47:26 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_actions_from_principle_to_practice/</guid><description>&lt;h1 id="github-actions-深入剖析从原理到实践"&gt;GitHub Actions 深入剖析：从原理到实践&lt;/h1&gt;
&lt;p&gt;最近收到一个问题：&amp;ldquo;为什么我的 CI/CD 流水线总是莫名其妙失败？&amp;ldquo;这让我想起了 GitHub Actions 的一些有趣特性。今天就来扒一扒它的底层原理。&lt;/p&gt;
&lt;h2 id="github-actions-的本质"&gt;GitHub Actions 的本质&lt;/h2&gt;
&lt;p&gt;本质上，GitHub Actions 就是一个事件驱动的工作流自动化引擎。它监听 GitHub 事件，然后执行预定义的动作。&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;# 这是最基础的工作流
name: CI
on: [push] # 事件触发器
jobs:
 build: # 工作单元
 runs-on: ubuntu-latest # 运行环境
 steps: # 执行步骤
 - uses: actions/checkout@v2
 - run: npm test&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但这只是表象，让我们深入看看它的架构：&lt;/p&gt;</description></item><item><title>Hugo 不为人知的强大特性</title><link>https://simons.qzz.io/post/2025/01/hugo_lesser_known_powerful_features/</link><pubDate>Sun, 26 Jan 2025 01:44:00 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/hugo_lesser_known_powerful_features/</guid><description>&lt;h1 id="hugo-不为人知的强大特性"&gt;Hugo 不为人知的强大特性&lt;/h1&gt;
&lt;p&gt;Hugo 被称为世界上最快的静态网站生成器，但大多数人只用它来写写博客。这太浪费了，其实它还有很多好玩的地方，我目前的博客主题就是靠的 Hugo，可以说是非常强大了。今天我们来挖掘一下它的进阶特性。&lt;/p&gt;
&lt;h2 id="1-模板继承的黑魔法"&gt;1. 模板继承的黑魔法&lt;/h2&gt;









&lt;div class="code-playground" data-language="go"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-go"&gt;{{/* 基础模板: baseof.html */}}
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
 &amp;lt;head&amp;gt;
 {{ block &amp;#34;head&amp;#34; . }}{{ end }}
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
 {{ block &amp;#34;main&amp;#34; . }}{{ end }}
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

{{/* 子模板 */}}
{{ define &amp;#34;main&amp;#34; }}
 &amp;lt;div&amp;gt;这里是实际内容&amp;lt;/div&amp;gt;
{{ end }}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;看到这个&lt;code&gt;.&lt;/code&gt;了吗？这是Hugo的上下文传递，相当于其他语言的&lt;code&gt;this&lt;/code&gt;。很多人不知道，它可以这样玩：&lt;/p&gt;</description></item><item><title>我的项目</title><link>https://simons.qzz.io/post/2025/01/my_projects/</link><pubDate>Sat, 25 Jan 2025 18:50:19 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/my_projects/</guid><description>&lt;h1 id="一关于我"&gt;一、关于我&lt;/h1&gt;
&lt;p&gt;我是一个计算机编程爱好者，有一定的全栈开发经验，熟悉前后端、嵌入式、区块链开发。从 2022 年开始，至今已有十余个项目，大部分都是前端项目。&lt;/p&gt;
&lt;h1 id="二项目介绍"&gt;二、项目介绍&lt;/h1&gt;
&lt;p&gt;下面介绍以下我开发的项目（开发完成、正在开发、终止开发）&lt;/p&gt;
&lt;h2 id="simpleresume"&gt;
&lt;a href="https://github.com/caoyang2002/SimpleResume"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 SimpleResume
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;前端&lt;/code&gt; &lt;code&gt;Vue&lt;/code&gt; &lt;code&gt;TypeScript&lt;/code&gt; &lt;code&gt;实用工具&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href="https://ohohresume.vercel.app/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 简历生成
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;这个工具可以通过填写表单的方式生成简历，而无需记忆 Latex 或者 md 语法。提供少量模板。&lt;/p&gt;</description></item><item><title>React vs Vue: 框架之争的深层思考</title><link>https://simons.qzz.io/post/2025/01/react_vue_framework_debate/</link><pubDate>Fri, 24 Jan 2025 13:57:50 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/react_vue_framework_debate/</guid><description>&lt;h1 id="react-vs-vue深度技术分析与对比"&gt;React vs Vue：深度技术分析与对比&lt;/h1&gt;
&lt;h2 id="一核心设计哲学差异"&gt;一、核心设计哲学差异&lt;/h2&gt;
&lt;h3 id="11-编程范式"&gt;1.1 编程范式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;：函数式编程优先&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强调不可变性和纯函数&lt;/li&gt;
&lt;li&gt;组件本质是函数（props in, JSX out）&lt;/li&gt;
&lt;li&gt;Hooks强化了函数式概念&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-jsx" data-lang="jsx"&gt;// React函数式组件
const Component = ({ data }) =&amp;gt; {
 const [state, setState] = useState(initialState);
 const derivedValue = useMemo(() =&amp;gt; compute(data), [data]);
 
 return &amp;lt;div&amp;gt;{derivedValue}&amp;lt;/div&amp;gt;;
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Vue&lt;/strong&gt;：响应式编程 + 面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于可变状态的响应式系统&lt;/li&gt;
&lt;li&gt;组合式API提供函数式能力&lt;/li&gt;
&lt;li&gt;传统选项式API符合OOP思维&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-vue" data-lang="vue"&gt;&amp;lt;!-- Vue组合式API --&amp;gt;
&amp;lt;script setup&amp;gt;
import { ref, computed } from &amp;#39;vue&amp;#39;

const data = ref(initialData)
const derivedValue = computed(() =&amp;gt; compute(data.value))
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id="12-架构理念"&gt;1.2 架构理念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;：最小化API，一切靠JavaScript&lt;/p&gt;</description></item><item><title>Vue: 一个让前端开发不再痛苦的框架</title><link>https://simons.qzz.io/post/2025/01/vue_painless_frontend_framework/</link><pubDate>Fri, 24 Jan 2025 13:53:44 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/vue_painless_frontend_framework/</guid><description>&lt;h1 id="vue-一个让前端开发不再痛苦的框架"&gt;Vue: 一个让前端开发不再痛苦的框架&lt;/h1&gt;
&lt;h2 id="老板又改需求了"&gt;老板又改需求了?&lt;/h2&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// 改个文本要改三个地方
document.getElementById(&amp;#34;title&amp;#34;).innerText = &amp;#34;新标题&amp;#34;;
document.querySelector(&amp;#34;.header h1&amp;#34;).innerText = &amp;#34;新标题&amp;#34;;
document.getElementsByClassName(&amp;#34;footer&amp;#34;)[0].innerText = &amp;#34;新标题&amp;#34;;&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;这就是没用Vue的下场。数据和视图分离,改一个要改几个地方,还容易改出bug。&lt;/p&gt;
&lt;h2 id="vue是啥"&gt;Vue是啥?&lt;/h2&gt;
&lt;p&gt;简单说: Vue = 数据驱动视图 + 组件化开发&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-vue" data-lang="vue"&gt;&amp;lt;template&amp;gt;
 &amp;lt;div&amp;gt;
 &amp;lt;!-- 数据自动同步到视图 --&amp;gt;
 &amp;lt;h1&amp;gt;{{title}}&amp;lt;/h1&amp;gt;
 &amp;lt;button @click=&amp;#34;changeTitle&amp;#34;&amp;gt;改标题&amp;lt;/button&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
 data() {
 return {
 title: &amp;#34;原标题&amp;#34;
 }
 },
 methods: {
 changeTitle() {
 // 改数据,视图自动更新
 this.title = &amp;#34;新标题&amp;#34;
 }
 }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id="为什么选vue"&gt;为什么选Vue?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上手容易&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>TypeScript: 静态</title><link>https://simons.qzz.io/post/2025/01/typescript_static_types/</link><pubDate>Fri, 24 Jan 2025 13:46:32 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/typescript_static_types/</guid><description>&lt;h1 id="typescript-静态"&gt;TypeScript: 静态&lt;/h1&gt;
&lt;h2 id="你遇到过这些问题吗"&gt;你遇到过这些问题吗?&lt;/h2&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// 调用一个不存在的方法
obj.nonexistMethod()

// 传错参数类型
calculateArea(&amp;#34;5&amp;#34;, &amp;#34;10&amp;#34;)

// 对象属性拼写错误
user.namee = &amp;#34;Bob&amp;#34;&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;玩过JavaScript的同学一定很熟悉这些坑。这就是为什么我们需要 TypeScript。&lt;/p&gt;
&lt;h2 id="typescript是个啥"&gt;TypeScript是个啥?&lt;/h2&gt;
&lt;p&gt;简单说:TypeScript = JavaScript + 类型系统&lt;/p&gt;









&lt;div class="code-playground" data-language="typescript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-typescript"&gt;// 变量类型
let name: string = &amp;#34;老陈&amp;#34;

// 函数类型
function add(x: number, y: number): number {
 return x &amp;#43; y
}

// 接口
interface User {
 id: number
 name: string
 age?: number // 可选属性
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;h2 id="为什么要用typescript"&gt;为什么要用TypeScript?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不用写单元测试了?&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>React 开发痛点与解决方案详解</title><link>https://simons.qzz.io/post/2025/01/react_development_pain_points_and_solutions_detailed/</link><pubDate>Fri, 24 Jan 2025 13:44:21 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/react_development_pain_points_and_solutions_detailed/</guid><description>&lt;h1 id="react-开发痛点与解决方案详解"&gt;React 开发痛点与解决方案详解&lt;/h1&gt;
&lt;h2 id="1-dom-操作的深层困境"&gt;1. DOM 操作的深层困境&lt;/h2&gt;
&lt;h3 id="传统方式的问题"&gt;传统方式的问题&lt;/h3&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// 更新用户信息
$(&amp;#39;#userName&amp;#39;).text(user.name);
$(&amp;#39;#userRole&amp;#39;).text(user.role);
$(&amp;#39;#department&amp;#39;).text(user.department);

// 更新权限信息
function updatePermissions(permissions) {
 $(&amp;#39;#permissionList&amp;#39;).empty();
 permissions.forEach(p =&amp;gt; {
 $(&amp;#39;#permissionList&amp;#39;).append(`&amp;lt;li&amp;gt;${p}&amp;lt;/li&amp;gt;`);
 });
}

// 更新用户状态
function toggleUserStatus(status) {
 if(status === &amp;#39;active&amp;#39;) {
 $(&amp;#39;#userStatus&amp;#39;).addClass(&amp;#39;active&amp;#39;).removeClass(&amp;#39;inactive&amp;#39;);
 } else {
 $(&amp;#39;#userStatus&amp;#39;).addClass(&amp;#39;inactive&amp;#39;).removeClass(&amp;#39;active&amp;#39;);
 }
}&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;这种操作方式存在严重问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码分散导致的维护噩梦&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 操作散布在各个函数中&lt;/li&gt;
&lt;li&gt;状态变化需要手动同步多处DOM&lt;/li&gt;
&lt;li&gt;代码修改容易遗漏关联更新&lt;/li&gt;
&lt;li&gt;难以追踪数据流向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Webpack：前端项目的"搬运工"</title><link>https://simons.qzz.io/post/2025/01/webpack_frontend_project_carrier/</link><pubDate>Fri, 24 Jan 2025 13:41:27 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/webpack_frontend_project_carrier/</guid><description>&lt;h1 id="webpack前端项目的搬运工"&gt;Webpack：前端项目的&amp;quot;搬运工&amp;quot;&lt;/h1&gt;
&lt;h2 id="你遇到过这样的问题吗"&gt;你遇到过这样的问题吗？&lt;/h2&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// 项目目录
src/
 ├── js/
 │ ├── user.js
 │ ├── order.js
 │ └── payment.js
 ├── css/
 │ ├── main.css
 │ └── theme.css
 └── images/
 └── logo.png&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;每次部署都要手动:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并 JS 文件&lt;/li&gt;
&lt;li&gt;压缩 CSS&lt;/li&gt;
&lt;li&gt;处理图片&lt;/li&gt;
&lt;li&gt;更新版本号&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这让我想起小时候帮妈妈打扫房间 - 东西太多，到处都是，不知从何下手。&lt;/p&gt;
&lt;h2 id="为什么会有这些问题"&gt;为什么会有这些问题？&lt;/h2&gt;
&lt;h3 id="前端的特殊性"&gt;前端的特殊性&lt;/h3&gt;
&lt;p&gt;浏览器需要加载:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTML (建筑框架)&lt;/li&gt;
&lt;li&gt;CSS (装修风格)&lt;/li&gt;
&lt;li&gt;JS (家具电器)&lt;/li&gt;
&lt;li&gt;图片等资源 (装饰品)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每多一个文件就多一次 HTTP 请求，网页加载越慢。&lt;/p&gt;</description></item></channel></rss>