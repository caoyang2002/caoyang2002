<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 短松江月</title><link>https://simons.qzz.io/categories/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 短松江月</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Fri, 30 Jan 2026 01:57:46 +0800</lastBuildDate><atom:link href="https://simons.qzz.io/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Emacs 基础</title><link>https://simons.qzz.io/post/2026/01/emacs_basic/</link><pubDate>Mon, 26 Jan 2026 13:39:47 +0800</pubDate><guid>https://simons.qzz.io/post/2026/01/emacs_basic/</guid><description>&lt;p&gt;本篇介绍 GNU Emacs 的基础知识和操作。本文内容只是让读者初识 Emacs 操作，这些操作需要日积月累的练习才能掌握，本文的后半部分更偏向用于日后查阅；另一方面，很多操作有些繁琐难以记忆，笔者将会在后续介绍一些插件能够极大改善这些问题，因此读者如果遇到晦涩的地方不必过分担心，也不用死记硬背。&lt;/p&gt;
&lt;p&gt;文章的结尾附上了本文出现的快捷键及其命令名，供读者查阅。&lt;/p&gt;</description></item><item><title>安装 Gitea</title><link>https://simons.qzz.io/post/2025/12/install_gitea/</link><pubDate>Sun, 28 Dec 2025 21:09:14 +0800</pubDate><guid>https://simons.qzz.io/post/2025/12/install_gitea/</guid><description>&lt;blockquote&gt;
&lt;p&gt;参考：
&lt;a href="https://docs.gitea.com/zh-cn/category/installation"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 官方文档
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gitea 支持多种安装方法，这里只介绍 docker 的安装方法&lt;/p&gt;
&lt;h1 id="方法一使用docker命令行安装推荐"&gt;方法一：使用Docker命令行安装（推荐）&lt;/h1&gt;
&lt;h2 id="1-创建数据目录"&gt;1. 创建数据目录&lt;/h2&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;# 创建必要的目录
sudo mkdir -p /opt/gitea/data
sudo mkdir -p /opt/gitea/config
sudo mkdir -p /opt/gitea/logs

# 设置权限（Gitea默认使用uid=1000, gid=1000的用户）
sudo chown -R 1000:1000 /opt/gitea&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id="2-运行gitea容器"&gt;2. 运行Gitea容器&lt;/h3&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;docker run -d \
 --name=gitea \
 --privileged=true \
 --restart=unless-stopped \
 -p 3000:3000 \
 -p 2222:22 \
 -v /opt/gitea/data:/data \
 -v /opt/gitea/config:/etc/gitea \
 -v /etc/timezone:/etc/timezone:ro \
 -v /etc/localtime:/etc/localtime:ro \
 -e USER_UID=1000 \
 -e USER_GID=1000 \
 gitea/gitea:latest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id="3-验证安装"&gt;3. 验证安装&lt;/h2&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;# 查看容器状态
docker ps -a

# 查看日志
docker logs gitea&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;访问：&lt;code&gt;http://your-server-ip:3000&lt;/code&gt; 进行初始设置。&lt;/p&gt;</description></item><item><title>群晖安装 GO 语言</title><link>https://simons.qzz.io/post/2025/12/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85-go-%E8%AF%AD%E8%A8%80/</link><pubDate>Wed, 24 Dec 2025 11:04:31 +0800</pubDate><guid>https://simons.qzz.io/post/2025/12/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85-go-%E8%AF%AD%E8%A8%80/</guid><description>&lt;p&gt;查看架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arm&lt;/li&gt;
&lt;li&gt;x86_64&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;uname -a&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Linux DS923plus 4.4.302+ #69057 SMP Mon Jul 21 23:26:13 CST 2025 x86_64 GNU/Linux synology_r1000_923+&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的是 x86_64 也就是 amd64&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里简单说一下，&lt;code&gt;x86_64&lt;/code&gt; 和 &lt;code&gt;amd64&lt;/code&gt; 是同义词，指代由 AMD 创立、现由英特尔和 AMD 共同主导的 64 位 PC / 服务器架构。ARM 是另一个竞争架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="安装-go"&gt;安装 go&lt;/h1&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;cd /tmp &amp;amp;&amp;amp; \
wget -q https://go.dev/dl/go1.22.10.linux-amd64.tar.gz &amp;amp;&amp;amp; \
sudo rm -rf /usr/local/go &amp;amp;&amp;amp; \
sudo tar -C /usr/local -xzf go1.22.10.linux-amd64.tar.gz &amp;amp;&amp;amp; \
export PATH=/usr/local/go/bin:$PATH &amp;amp;&amp;amp; \
go version &amp;amp;&amp;amp; \&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id="安装到-jupyter"&gt;安装到 jupyter&lt;/h1&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;go clean -cache -modcache &amp;amp;&amp;amp; \
cd ~/go-module/gophernotes &amp;amp;&amp;amp; \
rm -f ~/go/bin/gophernotes &amp;amp;&amp;amp; \
GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -v -o ~/go/bin/gophernotes &amp;amp;&amp;amp; \
chmod &amp;#43;x ~/go/bin/gophernotes &amp;amp;&amp;amp; \
~/go/bin/gophernotes install &amp;amp;&amp;amp; \
echo &amp;#34;✅ 安装完成！&amp;#34; &amp;amp;&amp;amp; \
jupyter kernelspec list&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</description></item><item><title>GitHub Projects深入剖析：不只是看板，是工程管理的操作系统</title><link>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_projects_its_not_just_kanban_its_the_operating_system_for_project_management/</link><pubDate>Sun, 26 Jan 2025 10:48:35 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_projects_its_not_just_kanban_its_the_operating_system_for_project_management/</guid><description>&lt;h1 id="github-projects深入剖析不只是看板是工程管理的操作系统"&gt;GitHub Projects深入剖析：不只是看板，是工程管理的操作系统&lt;/h1&gt;
&lt;p&gt;先说个真实场景：一个十几人的团队，用GitHub管理代码，但项目进度全靠口头同步。最后结果可想而知: 一团糟。&lt;/p&gt;
&lt;h2 id="本质分析"&gt;本质分析&lt;/h2&gt;
&lt;p&gt;GitHub Projects不是简单的任务管理工具，而是一个完整的工程管理系统。它把Issues、PR、代码、里程碑等所有开发要素关联起来。&lt;/p&gt;</description></item><item><title>GitHub Actions 深入剖析：从原理到实践</title><link>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_actions_from_principle_to_practice/</link><pubDate>Sun, 26 Jan 2025 10:47:26 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/in-depth_analysis_of_github_actions_from_principle_to_practice/</guid><description>&lt;h1 id="github-actions-深入剖析从原理到实践"&gt;GitHub Actions 深入剖析：从原理到实践&lt;/h1&gt;
&lt;p&gt;最近收到一个问题：&amp;ldquo;为什么我的 CI/CD 流水线总是莫名其妙失败？&amp;ldquo;这让我想起了 GitHub Actions 的一些有趣特性。今天就来扒一扒它的底层原理。&lt;/p&gt;
&lt;h2 id="github-actions-的本质"&gt;GitHub Actions 的本质&lt;/h2&gt;
&lt;p&gt;本质上，GitHub Actions 就是一个事件驱动的工作流自动化引擎。它监听 GitHub 事件，然后执行预定义的动作。&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;# 这是最基础的工作流
name: CI
on: [push] # 事件触发器
jobs:
 build: # 工作单元
 runs-on: ubuntu-latest # 运行环境
 steps: # 执行步骤
 - uses: actions/checkout@v2
 - run: npm test&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但这只是表象，让我们深入看看它的架构：&lt;/p&gt;</description></item><item><title>TypeScript: 静态</title><link>https://simons.qzz.io/post/2025/01/typescript_static_types/</link><pubDate>Fri, 24 Jan 2025 13:46:32 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/typescript_static_types/</guid><description>&lt;h1 id="typescript-静态"&gt;TypeScript: 静态&lt;/h1&gt;
&lt;h2 id="你遇到过这些问题吗"&gt;你遇到过这些问题吗?&lt;/h2&gt;









&lt;div class="code-playground" data-language="javascript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-javascript"&gt;// 调用一个不存在的方法
obj.nonexistMethod()

// 传错参数类型
calculateArea(&amp;#34;5&amp;#34;, &amp;#34;10&amp;#34;)

// 对象属性拼写错误
user.namee = &amp;#34;Bob&amp;#34;&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;玩过JavaScript的同学一定很熟悉这些坑。这就是为什么我们需要 TypeScript。&lt;/p&gt;
&lt;h2 id="typescript是个啥"&gt;TypeScript是个啥?&lt;/h2&gt;
&lt;p&gt;简单说:TypeScript = JavaScript + 类型系统&lt;/p&gt;









&lt;div class="code-playground" data-language="typescript"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-typescript"&gt;// 变量类型
let name: string = &amp;#34;老陈&amp;#34;

// 函数类型
function add(x: number, y: number): number {
 return x &amp;#43; y
}

// 接口
interface User {
 id: number
 name: string
 age?: number // 可选属性
}&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;h2 id="为什么要用typescript"&gt;为什么要用TypeScript?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不用写单元测试了?&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>mac 汇编笔记</title><link>https://simons.qzz.io/post/2025/01/mac_assembly/</link><pubDate>Sat, 18 Jan 2025 11:35:14 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/mac_assembly/</guid><description>&lt;p&gt;
&lt;a href="https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;h1 id="梦开始的地方"&gt;梦开始的地方&lt;/h1&gt;
&lt;h1 id="简单的-asm"&gt;简单的 asm&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;null.s&lt;/code&gt;&lt;/p&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-asm" data-lang="asm"&gt;.section __TEXT,__text
.globl _main
.p2align 2
_main:
mov w0, #0
ret&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;











&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-c" data-lang="c"&gt;int main() {
 return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;











&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;as null.s -o null.o # 汇编
ld null.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o null # 链接（由于在 macOS 上不能创建静态链接的可执行文件，因此在链接时必须使用 -lSystem 动态链接上系统库。）
./null # 运行

# or
clang null.s -o null

# or
gcc null.s -o null&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;as&lt;/code&gt; 是 LLVM 的汇编器, &lt;code&gt;lldb&lt;/code&gt; 是 LLVM 的调试器。
&lt;code&gt;GCC&lt;/code&gt; 套件是 GNU 操作系统的一个部分，GNU 是开源的、社区驱动的。而 LLVM 项目也是开源的，现在主要是 Apple 在投资运行。因此，既然在 macOS 上，我就主要用的是 LLVM 系的工具。&lt;/p&gt;</description></item><item><title>Wasm 打印输出和浏览器特性等最佳实践</title><link>https://simons.qzz.io/post/2025/01/wasm_print/</link><pubDate>Wed, 15 Jan 2025 00:31:17 +0800</pubDate><guid>https://simons.qzz.io/post/2025/01/wasm_print/</guid><description>&lt;p&gt;在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;web_sys&lt;/code&gt; 和 &lt;code&gt;wasm_bindgen&lt;/code&gt; 进行浏览器 API 调用：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use wasm_bindgen::prelude::*;
use web_sys::{console, window};

pub fn move_test(name: &amp;amp;str) {
 // 控制台打印
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;move test: {}&amp;#34;, name)));

 // 使用 console.warn
 console::warn_1(&amp;amp;JsValue::from_str(&amp;#34;This is a warning&amp;#34;));

 // 使用 console.error
 console::error_1(&amp;amp;JsValue::from_str(&amp;#34;This is an error&amp;#34;));

 // 浏览器 alert
 if let Some(window) = window() {
 window
 .alert_with_message(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;, name))
 .expect(&amp;#34;alert failed&amp;#34;);
 }

 // 确认对话框
 if let Some(window) = window() {
 if window
 .confirm_with_message(&amp;#34;Do you want to continue?&amp;#34;)
 .expect(&amp;#34;confirm failed&amp;#34;)
 {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked OK&amp;#34;));
 } else {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked Cancel&amp;#34;));
 }
 }
}&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="2"&gt;
&lt;li&gt;在 Cargo.toml 中需要添加必要的依赖：&lt;/li&gt;
&lt;/ol&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-toml" data-lang="toml"&gt;[dependencies]
wasm-bindgen = &amp;#34;0.2&amp;#34;
web-sys = { version = &amp;#34;0.3&amp;#34;, features = [
 &amp;#34;console&amp;#34;,
 &amp;#34;Window&amp;#34;,
 &amp;#34;Document&amp;#34;,
 &amp;#34;Element&amp;#34;,
 &amp;#34;HtmlElement&amp;#34;,
 &amp;#34;Node&amp;#34;,
 &amp;#34;Location&amp;#34;
]}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol start="3"&gt;
&lt;li&gt;如果需要格式化打印，可以使用 &lt;code&gt;console::log!&lt;/code&gt; 宏：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use web_sys::console;

// 需要引入宏
#[macro_export]
macro_rules! console_log {
 ($($t:tt)*) =&amp;gt; (console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!($($t)*))))
}

pub fn move_test(name: &amp;amp;str) {
 console_log!(&amp;#34;Testing move with name: {}&amp;#34;, name);
}&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="4"&gt;
&lt;li&gt;操作 DOM 示例：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, window};

pub fn move_test(name: &amp;amp;str) {
 // 获取 document
 let window = window().expect(&amp;#34;no global window exists&amp;#34;);
 let document = window.document().expect(&amp;#34;no document exists&amp;#34;);

 // 创建新元素
 if let Some(div) = document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 // 修改输入框的值
 if let Some(input) = div.dyn_ref::&amp;lt;HtmlElement&amp;gt;() {
 input.set_inner_text(&amp;amp;format!(&amp;#34;New value: {}&amp;#34;, name));
 }
 }

 // 创建新元素
 let new_div = document.create_element(&amp;#34;div&amp;#34;).unwrap();
 new_div.set_text_content(Some(&amp;amp;format!(&amp;#34;Hello {}&amp;#34;, name)));

 // 添加到 body
 if let Some(body) = document.body() {
 body.append_child(&amp;amp;new_div).unwrap();
 }
}&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="5"&gt;
&lt;li&gt;处理错误和 Result：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 // 使用 ? 运算符处理错误
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;
 let document = window.document().ok_or(&amp;#34;no document exists&amp;#34;)?;

 // 处理可能的错误
 match document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 Some(element) =&amp;gt; {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Found element: {}&amp;#34;, name)));
 Ok(())
 },
 None =&amp;gt; Err(JsValue::from_str(&amp;#34;Element not found&amp;#34;))
 }
}&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;ol start="6"&gt;
&lt;li&gt;使用本地存储：&lt;/li&gt;
&lt;/ol&gt;









&lt;div class="code-playground" data-language="rust"&gt;
 
 &lt;div&gt;
 &lt;pre&gt;
 &lt;code class="language-rust"&gt;use web_sys::Storage;

pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;

 // 获取 localStorage
 if let Some(storage) = window.local_storage()? {
 // 存储数据
 storage.set_item(&amp;#34;user_name&amp;#34;, name)?;

 // 读取数据
 if let Ok(Some(saved_name)) = storage.get_item(&amp;#34;user_name&amp;#34;) {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Saved name: {}&amp;#34;, saved_name)));
 }
 }

 Ok(())
}&lt;/code&gt;
 &lt;/pre&gt;
 &lt;/div&gt;
 

 
&lt;/div&gt;

&lt;p&gt;记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 &amp;ldquo;Storage&amp;rdquo; feature：&lt;/p&gt;</description></item><item><title>C 语言字符画</title><link>https://simons.qzz.io/post/2024/06/c_shar/</link><pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2024/06/c_shar/</guid><description>&lt;blockquote&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-c" data-lang="c"&gt;3
* * *
* *
* * *

4
* * * *
* *
* *
* * * *&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;非多组输入&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-c" data-lang="c"&gt;#include &amp;lt;stdio.h&amp;gt;
//行定位
int main() {
 int n = 0;
 scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);
 for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {
 if (i == 0 || i == n - 1) {//首尾行输出一行*
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {
 printf(&amp;#34;* &amp;#34;);
 }
 } else {
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//其它行首尾输出*
 if(j==0 || j == n-1)
 printf(&amp;#34;* &amp;#34;);
 else
 printf(&amp;#34; &amp;#34;);
 }
 }
 printf(&amp;#34;\n&amp;#34;);//换行
 }

 return 0;
}

// 3 ---- n
// * * * --- 1行每个位置都输出 一共n个
// * * --- 其它行1和n位置输出 一共2个
// * * * --- n行每个位置都输出 一共n个
// 思路：
// 使用for 和 if
// 判断是不吃首尾行 是则输出一行* 不是则输出首尾*&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;多组输入&lt;/li&gt;
&lt;/ul&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-c" data-lang="c"&gt;#include &amp;lt;stdio.h&amp;gt;
//行和列定位
int main() {
 int n = 0;
 while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) == 1){//输入的数量为1
 for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {//控制行
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//控制列
 if(i == 0 || i == n-1 || j == 0 || j == n-1)//第0行，第n-1行，第0列，第n-1列输出 *_,其它位置输出 __
 printf(&amp;#34;* &amp;#34;);
 else
 printf(&amp;#34; &amp;#34;);
 }
 printf(&amp;#34;\n&amp;#34;);
 }
 }
 return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</description></item><item><title>x86 教程</title><link>https://simons.qzz.io/post/2024/05/x86/</link><pubDate>Thu, 02 May 2024 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2024/05/x86/</guid><description>&lt;p&gt;作者： 
&lt;a href="http://www.ruanyifeng.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 阮一峰
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;日期： 
&lt;a href="http://www.ruanyifeng.com/blog/2018/01/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 2018年1月21日
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;学习编程其实就是学高级语言，即那些为人类设计的计算机语言。&lt;/p&gt;
&lt;p&gt;但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/bg2018012204.png" alt="img"&gt;&lt;/p&gt;
&lt;p&gt;计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。&lt;/p&gt;</description></item><item><title>浮点数的存储</title><link>https://simons.qzz.io/post/2023/07/float_at_mem/</link><pubDate>Sat, 29 Jul 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/07/float_at_mem/</guid><description>&lt;h1 id="浮点数的存储"&gt;浮点数的存储&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;IEEE745 国际标准：&lt;/p&gt;
&lt;p&gt;任意一个二进制的浮点数可以表示为下面的形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V = (-1)^s^ * M * 2^E^$&lt;/li&gt;
&lt;li&gt;$(-1)^s^$ 表示符号位，当S=0的时候V为正数，当S=1的时候V为负数&lt;/li&gt;
&lt;li&gt;M表示有效数字，大于等于1，小于2; 1&amp;lt;= M &amp;lt;2&lt;/li&gt;
&lt;li&gt;$2^E^$：E表示指数位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;科学计数法：123.45 = 1.2345 * 10^2^&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;V = 5.0 f&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二进制：101.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;科学计数法：1.01 * 2^2^&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iEEE：(-1)^0^ * 1.01 * 2^2^&lt;/p&gt;</description></item><item><title>函数栈帧的创建和销毁</title><link>https://simons.qzz.io/post/2023/07/function_stack/</link><pubDate>Sat, 15 Jul 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/07/function_stack/</guid><description>&lt;p&gt;&lt;code&gt;C/C++&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数栈帧的创建和销毁&lt;/p&gt;
&lt;p&gt;在学习最基础的C语言程序的语法与使用时，但你是否有疑问？&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数的作用域是怎么形成的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部变量是如何创建的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么未初始化的局部变量的值是随机值或是乱码呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数是如何传参的？&lt;/p&gt;
&lt;p&gt;传参的顺序又是怎么样的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形参和实参的关系是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的调用是怎么实现的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数调用结束后是怎么返回的呢？&lt;/p&gt;</description></item><item><title>C 语言计算最大公约数</title><link>https://simons.qzz.io/post/2023/06/c_number/</link><pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/06/c_number/</guid><description>&lt;ul&gt;
&lt;li&gt;暴力算法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;时间复杂度过大&lt;/p&gt;
&lt;/blockquote&gt;










&lt;div&gt;
 &lt;pre&gt;&lt;code class="language-c" data-lang="c"&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc/_malloc.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
// 最大公约数
// 最小公倍数
//计算最小公倍数和最大公约数的和
int main(){
 int n = 0;
 int m = 0;
 while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m) == 2){//读取两个数
 int min = n &amp;lt; m ? n : m;
 int max = n &amp;gt; m ? n : m;
 int i = min;//最大公约数
 int j = max;//最小公倍数
 while(1){
 if(n%i == 0 &amp;amp;&amp;amp; m%i == 0){
 break;
 }
 i--;
 }
 // i就是最大公约数
 while(1){
 if(j%n == 0 &amp;amp;&amp;amp; j%m == 0){
 break;
 }
 j&amp;#43;&amp;#43;;
 }
 // j就是最大公倍数

 printf(&amp;#34;最大公倍数 %d &amp;#43; 最小公约数 %d = %d\n&amp;#34;,j,i,j&amp;#43;i);
 }
 return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;辗转相除法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;两个数的&lt;em&gt;&lt;strong&gt;最大公约数&lt;/strong&gt;&lt;/em&gt;等于其中较小的数字和二者之间余数的最大公约数&lt;/p&gt;</description></item><item><title>C++ 命名规范</title><link>https://simons.qzz.io/post/2023/05/cpp_named/</link><pubDate>Mon, 29 May 2023 09:31:37 +0800</pubDate><guid>https://simons.qzz.io/post/2023/05/cpp_named/</guid><description>&lt;p&gt;
&lt;a href="https://codeif.xinke.org.cn"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 &gt;
 codeif
 
 &lt;span class="external-icon"&gt;↗&lt;/span&gt;
 
&lt;/a&gt;
&lt;/p&gt;
&lt;h1 id="文件命名"&gt;文件命名&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;所有文件&lt;/p&gt;
&lt;p&gt;头文件和原文件成对出现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;全部小写, 可是使用下划线&amp;quot;_&amp;quot;(默认)或连字符&amp;quot;-&amp;quot;, 称完整, 不要有歧义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_file.c &amp;amp; system_file.h&lt;/li&gt;
&lt;li&gt;item_name.c&lt;/li&gt;
&lt;li&gt;item-name.c&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="类型命名"&gt;类型命名&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;每个单词首字母大写, 不使用下划线&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;Timer&lt;/li&gt;
&lt;li&gt;File&lt;/li&gt;
&lt;li&gt;Name&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="变量命名"&gt;变量命名&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;变量, 函数参数, 数据成员名&lt;/p&gt;</description></item></channel></rss>