<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on caoyang 2002</title><link>https://caoyang2002.xyz/tags/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on caoyang 2002</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 22 Jan 2025 22:41:30 +0800</lastBuildDate><atom:link href="https://caoyang2002.xyz/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>mac 汇编笔记</title><link>https://caoyang2002.xyz/post/2025/01/mac_assembly/</link><pubDate>Sat, 18 Jan 2025 11:35:14 +0800</pubDate><guid>https://caoyang2002.xyz/post/2025/01/mac_assembly/</guid><description>&lt;p>
&lt;a href="https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="梦开始的地方">梦开始的地方&lt;/h1>
&lt;h1 id="简单的-asm">简单的 asm&lt;/h1>
&lt;p>&lt;code>null.s&lt;/code>&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-asm" data-lang="asm">.section __TEXT,__text
.globl _main
.p2align 2
_main:
mov w0, #0
ret&lt;/code>&lt;/pre>
&lt;/div>









&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">int main() {
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div>









&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">as null.s -o null.o # 汇编
ld null.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o null # 链接（由于在 macOS 上不能创建静态链接的可执行文件，因此在链接时必须使用 -lSystem 动态链接上系统库。）
./null # 运行

# or
clang null.s -o null

# or
gcc null.s -o null&lt;/code>&lt;/pre>
&lt;/div>

&lt;blockquote>
&lt;p>&lt;code>as&lt;/code> 是 LLVM 的汇编器, &lt;code>lldb&lt;/code> 是 LLVM 的调试器。
&lt;code>GCC&lt;/code> 套件是 GNU 操作系统的一个部分，GNU 是开源的、社区驱动的。而 LLVM 项目也是开源的，现在主要是 Apple 在投资运行。因此，既然在 macOS 上，我就主要用的是 LLVM 系的工具。&lt;/p></description></item><item><title>简述 Rust 中的闭包</title><link>https://caoyang2002.xyz/post/2025/01/rust_closure_brief/</link><pubDate>Wed, 15 Jan 2025 13:22:26 +0800</pubDate><guid>https://caoyang2002.xyz/post/2025/01/rust_closure_brief/</guid><description>&lt;h1 id="为什么需要闭包">为什么需要闭包？&lt;/h1>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">// 问题1：函数复用
// 没有闭包时，需要传入所有参数
fn add(x: i32, base: i32) -&amp;gt; i32 { x &amp;#43; base }

// 有了闭包，可以部分应用
let base = 5;
let add_five = |x| x &amp;#43; base;

// 问题2：函数式编程需求
vec![1, 2, 3].iter().map(|x| x * 2); // 更简洁
vec![1, 2, 3].iter().map(multiply); // 需要单独定义函数

// 问题3：上下文捕获
// 没有闭包时很难处理
struct Context { value: i32 }
let ctx = Context { value: 42 };
let use_context = || println!(&amp;#34;{}&amp;#34;, ctx.value);&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;h1 id="闭包是什么">闭包是什么？&lt;/h1>
&lt;ul>
&lt;li>闭包是可以捕获其环境的匿名函数&lt;/li>
&lt;li>它&amp;quot;封闭&amp;quot;了其定义时的环境，故称&amp;quot;闭包&amp;quot;&lt;/li>
&lt;li>闭包 = 函数 + 环境&lt;/li>
&lt;/ul>
&lt;h1 id="闭包的优势">闭包的优势&lt;/h1>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">// 1. 简洁的语法
let add = |a, b| a &amp;#43; b; // vs fn add(a: i32, b: i32) -&amp;gt; i32

// 2. 灵活的环境捕获
let multiplier = 2;
let double = |x| x * multiplier; // 捕获 multiplier

// 3. 支持函数式编程
let numbers: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3, 4, 5];
let even_numbers: Vec&amp;lt;i32&amp;gt; = numbers
 .into_iter()
 .filter(|x| x % 2 == 0)
 .collect();&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;h1 id="理解闭包">理解闭包&lt;/h1>
&lt;p>我用 Python 和 TypeScript 的概念来解释 Rust 的闭包：&lt;/p></description></item><item><title>Rust 中的引用</title><link>https://caoyang2002.xyz/post/2025/01/rust_ref/</link><pubDate>Wed, 15 Jan 2025 11:57:02 +0800</pubDate><guid>https://caoyang2002.xyz/post/2025/01/rust_ref/</guid><description>&lt;h1 id="引用你的快递地址和包裹">引用：你的快递地址和包裹&lt;/h1>
&lt;p>想象这样一个场景：你在网上买了个漂亮的花瓶，快递公司需要把它送到你家。快递员需要知道两个信息：&lt;/p>
&lt;ol>
&lt;li>你家的地址（引用）&lt;/li>
&lt;li>花瓶本身（值）&lt;/li>
&lt;/ol>
&lt;h2 id="为什么我们需要引用">为什么我们需要引用？&lt;/h2>
&lt;p>让我们看一个具体的问题：&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">fn calculate_length(s: String) -&amp;gt; usize {
 s.len()
}

let s = String::from(&amp;#34;hello&amp;#34;);
let len = calculate_length(s);
println!(&amp;#34;{}&amp;#34;, s); // 编译错误！s 已经被转移了所有权&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>这就像你把花瓶（值）直接给了快递员（函数），花瓶就不再属于你了。但很多时候，我们只是想让快递员看看花瓶，而不是把它拿走。&lt;/p></description></item><item><title>rust 闭包</title><link>https://caoyang2002.xyz/post/2025/01/rust_closure/</link><pubDate>Wed, 15 Jan 2025 11:29:27 +0800</pubDate><guid>https://caoyang2002.xyz/post/2025/01/rust_closure/</guid><description>&lt;h2 id="从一个常见问题说起">从一个常见问题说起&lt;/h2>
&lt;p>假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">let numbers = vec![1, 2, 3, 4, 5];
// 如何优雅地复用过滤逻辑？
let even_numbers = ??? // 这里怎么写
let multiplied_numbers = ??? // 这里怎么写&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;h2 id="闭包的本质">闭包的本质&lt;/h2>
&lt;p>Rust 的闭包本质上是一种特殊的数据结构，它包含：&lt;/p></description></item><item><title>深入解释 Rust 中的 Result 和 Option 这两个核心类型</title><link>https://caoyang2002.xyz/post/2025/01/rust_result_option/</link><pubDate>Wed, 15 Jan 2025 11:26:02 +0800</pubDate><guid>https://caoyang2002.xyz/post/2025/01/rust_result_option/</guid><description>&lt;h1 id="从一个实际问题开始">从一个实际问题开始&lt;/h1>
&lt;p>假设我们在写一个文件处理程序：&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">fn read_config_file(path: &amp;amp;str) -&amp;gt; String {
 std::fs::read_to_string(path) // 这里会返回什么？
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>这段代码看似简单，但隐藏着两个基本问题：&lt;/p>
&lt;ol>
&lt;li>文件可能不存在&lt;/li>
&lt;li>即使文件存在，读取过程也可能失败&lt;/li>
&lt;/ol>
&lt;p>这就是为什么 Rust 引入了 &lt;code>Result&lt;/code> 和 &lt;code>Option&lt;/code>。&lt;/p></description></item><item><title>Wasm 打印输出和浏览器特性等最佳实践</title><link>https://caoyang2002.xyz/post/2025/01/wasm_print/</link><pubDate>Wed, 15 Jan 2025 00:31:17 +0800</pubDate><guid>https://caoyang2002.xyz/post/2025/01/wasm_print/</guid><description>&lt;p>在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：&lt;/p>
&lt;ol>
&lt;li>使用 &lt;code>web_sys&lt;/code> 和 &lt;code>wasm_bindgen&lt;/code> 进行浏览器 API 调用：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use wasm_bindgen::prelude::*;
use web_sys::{console, window};

pub fn move_test(name: &amp;amp;str) {
 // 控制台打印
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;move test: {}&amp;#34;, name)));

 // 使用 console.warn
 console::warn_1(&amp;amp;JsValue::from_str(&amp;#34;This is a warning&amp;#34;));

 // 使用 console.error
 console::error_1(&amp;amp;JsValue::from_str(&amp;#34;This is an error&amp;#34;));

 // 浏览器 alert
 if let Some(window) = window() {
 window
 .alert_with_message(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;, name))
 .expect(&amp;#34;alert failed&amp;#34;);
 }

 // 确认对话框
 if let Some(window) = window() {
 if window
 .confirm_with_message(&amp;#34;Do you want to continue?&amp;#34;)
 .expect(&amp;#34;confirm failed&amp;#34;)
 {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked OK&amp;#34;));
 } else {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked Cancel&amp;#34;));
 }
 }
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="2">
&lt;li>在 Cargo.toml 中需要添加必要的依赖：&lt;/li>
&lt;/ol>








&lt;div>
 &lt;pre>&lt;code class="language-toml" data-lang="toml">[dependencies]
wasm-bindgen = &amp;#34;0.2&amp;#34;
web-sys = { version = &amp;#34;0.3&amp;#34;, features = [
 &amp;#34;console&amp;#34;,
 &amp;#34;Window&amp;#34;,
 &amp;#34;Document&amp;#34;,
 &amp;#34;Element&amp;#34;,
 &amp;#34;HtmlElement&amp;#34;,
 &amp;#34;Node&amp;#34;,
 &amp;#34;Location&amp;#34;
]}&lt;/code>&lt;/pre>
&lt;/div>

&lt;ol start="3">
&lt;li>如果需要格式化打印，可以使用 &lt;code>console::log!&lt;/code> 宏：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use web_sys::console;

// 需要引入宏
#[macro_export]
macro_rules! console_log {
 ($($t:tt)*) =&amp;gt; (console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!($($t)*))))
}

pub fn move_test(name: &amp;amp;str) {
 console_log!(&amp;#34;Testing move with name: {}&amp;#34;, name);
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="4">
&lt;li>操作 DOM 示例：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, window};

pub fn move_test(name: &amp;amp;str) {
 // 获取 document
 let window = window().expect(&amp;#34;no global window exists&amp;#34;);
 let document = window.document().expect(&amp;#34;no document exists&amp;#34;);

 // 创建新元素
 if let Some(div) = document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 // 修改输入框的值
 if let Some(input) = div.dyn_ref::&amp;lt;HtmlElement&amp;gt;() {
 input.set_inner_text(&amp;amp;format!(&amp;#34;New value: {}&amp;#34;, name));
 }
 }

 // 创建新元素
 let new_div = document.create_element(&amp;#34;div&amp;#34;).unwrap();
 new_div.set_text_content(Some(&amp;amp;format!(&amp;#34;Hello {}&amp;#34;, name)));

 // 添加到 body
 if let Some(body) = document.body() {
 body.append_child(&amp;amp;new_div).unwrap();
 }
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="5">
&lt;li>处理错误和 Result：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 // 使用 ? 运算符处理错误
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;
 let document = window.document().ok_or(&amp;#34;no document exists&amp;#34;)?;

 // 处理可能的错误
 match document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 Some(element) =&amp;gt; {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Found element: {}&amp;#34;, name)));
 Ok(())
 },
 None =&amp;gt; Err(JsValue::from_str(&amp;#34;Element not found&amp;#34;))
 }
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="6">
&lt;li>使用本地存储：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use web_sys::Storage;

pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;

 // 获取 localStorage
 if let Some(storage) = window.local_storage()? {
 // 存储数据
 storage.set_item(&amp;#34;user_name&amp;#34;, name)?;

 // 读取数据
 if let Ok(Some(saved_name)) = storage.get_item(&amp;#34;user_name&amp;#34;) {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Saved name: {}&amp;#34;, saved_name)));
 }
 }

 Ok(())
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 &amp;ldquo;Storage&amp;rdquo; feature：&lt;/p></description></item><item><title>Go 最佳实践</title><link>https://caoyang2002.xyz/post/2024/12/go/</link><pubDate>Sun, 29 Dec 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/12/go/</guid><description>&lt;p>在 Go 项目架构中，有一些重要的设计原则和规则。我来详细说明：&lt;/p>
&lt;ol>
&lt;li>接口定义规则：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：接口定义在使用方(调用方)包中
package handler
type UserService interface {
 Create(ctx context.Context, user *User) error
}

// ❌ 错误：接口定义在实现方包中
package service
type UserService interface {
 Create(ctx context.Context, user *User) error
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="2">
&lt;li>依赖方向：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确的依赖方向
handler -&amp;gt; service -&amp;gt; repository -&amp;gt; database

// ❌ 错误：不应该出现反向依赖
service -&amp;gt; handler
repository -&amp;gt; service&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="3">
&lt;li>数据模型定义：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：每层使用自己的数据模型
package handler
type CreateUserRequest struct { // API层模型
 Username string `json:&amp;#34;username&amp;#34;`
}

package service
type UserDTO struct { // 业务层模型
 ID uint64
 Username string
}

package repository
type UserDO struct { // 数据层模型
 ID uint64 `gorm:&amp;#34;primaryKey&amp;#34;`
 Username string
 CreatedAt time.Time
}

// ❌ 错误：直接在所有层使用相同的模型
type User struct {
 ID uint64 `json:&amp;#34;id&amp;#34; gorm:&amp;#34;primaryKey&amp;#34;`
 Username string `json:&amp;#34;username&amp;#34;`
 CreatedAt time.Time `json:&amp;#34;created_at&amp;#34;`
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="4">
&lt;li>错误处理层级：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：每层对错误进行适当包装
package repository
func (r *UserRepo) Create(user *UserDO) error {
 return fmt.Errorf(&amp;#34;database error: %w&amp;#34;, err)
}

package service
func (s *UserService) Create(user *UserDTO) error {
 return fmt.Errorf(&amp;#34;business error: %w&amp;#34;, err)
}

package handler
func (h *UserHandler) Create(c *gin.Context) {
 if err := h.service.Create(user); err != nil {
 c.JSON(getErrorStatus(err), ErrorResponse{err.Error()})
 return
 }
}

// ❌ 错误：直接暴露底层错误
if err := db.Create(&amp;amp;user).Error; err != nil {
 c.JSON(500, err.Error())
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="5">
&lt;li>包的组织：&lt;/li>
&lt;/ol>








&lt;div>
 &lt;pre>&lt;code class="language-" data-lang="">✅ 正确的包组织：
project/
 ├── api/
 │ └── handler/ # HTTP 处理层
 ├── internal/
 │ ├── service/ # 业务逻辑层
 │ ├── repository/ # 数据访问层
 │ └── model/ # 内部数据模型
 ├── pkg/
 │ └── util/ # 公共工具函数
 └── main.go

❌ 错误的包组织：
project/
 ├── handlers/
 ├── services/
 ├── models/
 └── main.go&lt;/code>&lt;/pre>
&lt;/div>

&lt;ol start="6">
&lt;li>依赖注入：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：通过构造函数注入依赖
func NewUserHandler(service UserService) *UserHandler {
 return &amp;amp;UserHandler{service: service}
}

// ❌ 错误：全局变量或直接初始化
var userService = &amp;amp;UserService{}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="7">
&lt;li>接口隔离：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：小接口，职责单一
type UserReader interface {
 GetUser(id uint64) (*User, error)
}

type UserWriter interface {
 CreateUser(user *User) error
}

// ❌ 错误：大接口，职责过多
type UserService interface {
 GetUser(id uint64) (*User, error)
 CreateUser(user *User) error
 UpdateUser(user *User) error
 DeleteUser(id uint64) error
 ListUsers() ([]*User, error)
 SearchUsers(query string) ([]*User, error)
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="8">
&lt;li>配置管理：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：集中管理配置
package config

type Config struct {
 Server ServerConfig
 DB DatabaseConfig
 Redis RedisConfig
}

// ❌ 错误：分散的配置或硬编码
var serverPort = 8080
var dbConnection = &amp;#34;root:password@tcp(localhost:3306)/db&amp;#34;&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="9">
&lt;li>上下文传递：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：统一使用 context 传递请求上下文
func (h *Handler) Create(c *gin.Context) {
 ctx := c.Request.Context()
 err := h.service.Create(ctx, req)
}

// ❌ 错误：不传递上下文或使用不一致的上下文
func (h *Handler) Create(c *gin.Context) {
 err := h.service.Create(req)
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="10">
&lt;li>测试组织：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：测试文件与源文件对应
package handler

func TestUserHandler_Create(t *testing.T) {
 // 单元测试
}

// ❌ 错误：测试代码与源码混合或测试覆盖不全
func TestAll(t *testing.T) {
 // 混合测试多个功能
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>遵循这些规则可以使代码：&lt;/p></description></item><item><title>shell mac 教程</title><link>https://caoyang2002.xyz/post/2024/11/shell_mac_pop/</link><pubDate>Sat, 09 Nov 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/11/shell_mac_pop/</guid><description>&lt;p>
&lt;a href="https://juejin.cn/post/6921144388802641933"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-as" data-lang="as">#!/bin/bash

# 1. 自定义通知消息
# 传参 $1:消息描述 $2:通知标题 $3:通知副标题
function showNoteMessage(){
 osascript -e &amp;#34;display notification \&amp;#34;${1}\&amp;#34; with title \&amp;#34;${2}\&amp;#34; subtitle \&amp;#34;${3}\&amp;#34; sound name \&amp;#34;Funk\&amp;#34;&amp;#34;
}
#test case:
#showNoteMessage &amp;#34;消息内容&amp;#34; &amp;#34;通知&amp;#34; &amp;#34;通知副标题&amp;#34;

# 2. 自定义弹窗(统一通用方法)
# 传参$1 弹窗消息内容
# 传参$2 弹窗标题
# 传参$3 按钮标题,多个用英文逗号隔开
# 传参$4 默认选中的按钮标题或者按钮数字下标
# 传参$5 是否为输入框类型 传&amp;#34;0&amp;#34;或者&amp;#34;1&amp;#34; 默认&amp;#34;0&amp;#34;
# 传参$6 输入框默认占位内容,传不传无所谓,默认为空字符串 &amp;#34;&amp;#34;
# 传参$7 默认图标note/stop/caution 或者自定义文件路径(:格式路径可以通过choose file获取)
# tips: 重要! 如果为输入框模式,那么输出结果就是{button returned:button,text returned:text} 否则只有按钮或者false
function showCustomAlertMessage(){

if [[ -n &amp;#34;$4&amp;#34; ]]; then

	if [[ ${4} == *[!0-9]* ]]; then
 	defaultButton=&amp;#34;default button \&amp;#34;${4}\&amp;#34;&amp;#34;
 	else
 	defaultButton=&amp;#34;default button ${4}&amp;#34;
	fi
else
	defaultButton=&amp;#34;&amp;#34;
fi

#是否为输入框模式
if [[ &amp;#34;$5&amp;#34; = &amp;#34;1&amp;#34; ]]; then
	IS_InputMode=&amp;#34;default answer \&amp;#34;${6}\&amp;#34;&amp;#34;
	ReturnValue=&amp;#34;get result&amp;#34;
else
	IS_InputMode=&amp;#34;&amp;#34;
	ReturnValue=&amp;#34;get the button returned of the result&amp;#34;
fi

if [[ -n &amp;#34;$7&amp;#34; ]]; then
 case ${7} in
	note)
	ICON=&amp;#34;with icon note&amp;#34;
	;;
	stop)
	ICON=&amp;#34;with icon stop&amp;#34;
	;;
	caution)
	ICON=&amp;#34;with icon caution&amp;#34;
	;;
	*)
	ICON=&amp;#34;with icon file \&amp;#34;${7}\&amp;#34;&amp;#34;
	;;
 esac
else
 ICON=&amp;#34;with icon file \&amp;#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\&amp;#34;&amp;#34;
fi

osascript &amp;lt;&amp;lt;EOF
	set buttonStr to &amp;#34;${3}&amp;#34;
	set oldDelimiters to AppleScript&amp;#39;s text item delimiters
	set AppleScript&amp;#39;s text item delimiters to &amp;#34;,&amp;#34;
	set buttonList to every text item of buttonStr
	set AppleScript&amp;#39;s text item delimiters to oldDelimiters
	get buttonList
	set btns to buttonList
	display dialog &amp;#34;${1}&amp;#34; with title &amp;#34;${2}&amp;#34; buttons btns ${IS_InputMode} ${defaultButton} ${ICON}
	${ReturnValue}
EOF
}

# showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;1&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;note&amp;#34;
# showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; 2 &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;note&amp;#34;
#showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;stop&amp;#34;
#showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns&amp;#34;

# 普通弹窗 一个ok就够了 就是一个确认的那种
function onlyConfirmButton(){
	showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;温馨提示&amp;#34; &amp;#34;好的&amp;#34; 1
}
#onlyConfirmButton &amp;#34;登录成功!\n弹窗成功!&amp;#34;

# 多按钮弹窗 最多三个按钮 多了会报错
function mostButtons(){
	showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;温馨提示&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮3&amp;#34;
}
#mostButtons &amp;#34;最多只能定义三个按钮哦&amp;#34;

# 输入框弹窗
function showInputAlertMessage(){
	showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;$2&amp;#34; &amp;#34;取消,确认&amp;#34; 2 &amp;#34;1&amp;#34; &amp;#34;&amp;#34;
}
showInputAlertMessage &amp;#34;请输入密码&amp;#34; &amp;#34;登录验证&amp;#34;&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>C 语言字符画</title><link>https://caoyang2002.xyz/post/2024/06/c_shar/</link><pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/06/c_shar/</guid><description>&lt;blockquote>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">3
* * *
* *
* * *

4
* * * *
* *
* *
* * * *&lt;/code>&lt;/pre>
&lt;/div>

&lt;/blockquote>
&lt;ul>
&lt;li>非多组输入&lt;/li>
&lt;/ul>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
//行定位
int main() {
 int n = 0;
 scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);
 for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {
 if (i == 0 || i == n - 1) {//首尾行输出一行*
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {
 printf(&amp;#34;* &amp;#34;);
 }
 } else {
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//其它行首尾输出*
 if(j==0 || j == n-1)
 printf(&amp;#34;* &amp;#34;);
 else
 printf(&amp;#34; &amp;#34;);
 }
 }
 printf(&amp;#34;\n&amp;#34;);//换行
 }

 return 0;
}

// 3 ---- n
// * * * --- 1行每个位置都输出 一共n个
// * * --- 其它行1和n位置输出 一共2个
// * * * --- n行每个位置都输出 一共n个
// 思路：
// 使用for 和 if
// 判断是不吃首尾行 是则输出一行* 不是则输出首尾*&lt;/code>&lt;/pre>
&lt;/div>

&lt;hr>
&lt;ul>
&lt;li>多组输入&lt;/li>
&lt;/ul>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
//行和列定位
int main() {
 int n = 0;
 while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) == 1){//输入的数量为1
 for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {//控制行
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//控制列
 if(i == 0 || i == n-1 || j == 0 || j == n-1)//第0行，第n-1行，第0列，第n-1列输出 *_,其它位置输出 __
 printf(&amp;#34;* &amp;#34;);
 else
 printf(&amp;#34; &amp;#34;);
 }
 printf(&amp;#34;\n&amp;#34;);
 }
 }
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>如何生成 dll 文件</title><link>https://caoyang2002.xyz/post/2024/06/dl/</link><pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/06/dl/</guid><description>&lt;h1 id="如何生成-dll文件">如何生成 .dll文件&lt;/h1>
&lt;p>生成dll文件同时会生成lib文件&lt;/p>
&lt;ol>
&lt;li>在VS开始界面，搜索dll，创建dll动态链接库&lt;/li>
&lt;li>创建一个类（右键创建类，会自动包含需要的文件） 以查询目录下的文件为例
创建的文件可以不用管
&lt;code>.cpp&lt;/code>文件 输入自己的代码&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="cpp">
 &lt;div>
 &lt;pre>
 &lt;code class="language-cpp">#include &amp;#34;pch.h&amp;#34;
#include &amp;#34;check_repository.h&amp;#34;
namespace fs = std::filesystem;
 int Check::CheckRepository() {
 std::string folderName = &amp;#34;.Rysigy&amp;#34;;
 fs::path currentPath = fs::current_path();
 fs::path folderPath = currentPath / folderName;

 if (fs::exists(folderPath) &amp;amp;&amp;amp; fs::is_directory(folderPath)) {
 std::cout &amp;lt;&amp;lt; &amp;#34;存储库 &amp;#39;.Rysigy&amp;#39; 文件夹存在\n&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 else {
 std::cout &amp;lt;&amp;lt; &amp;#34;[错误]\t存储库 &amp;#39;.Rysigy&amp;#39; 文件夹不存在\n请在右键菜单中点击 &amp;#39;创建存储库&amp;#39;\n&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 std::cout &amp;lt;&amp;lt; &amp;#34;点击任意按键退出...&amp;#34; &amp;lt;&amp;lt; std::endl;
 _getch();
 return 0;
};&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>&lt;code>.h&lt;/code>文件&lt;/p></description></item><item><title>删除错误提交到GitHub仓库中的文件</title><link>https://caoyang2002.xyz/post/2024/06/git_delete_file/</link><pubDate>Wed, 19 Jun 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/06/git_delete_file/</guid><description>&lt;p>如果你需要删除错误提交到GitHub仓库中的文件，你可以通过以下步骤来创建一个新的提交来撤销之前的更改：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>在本地仓库中删除文件&lt;/strong>：
首先，在你的本地仓库中删除该文件：&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-sh" data-lang="sh">git rm --cached &amp;lt;file&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>这里 &lt;code>&amp;lt;file&amp;gt;&lt;/code> 是你想要从仓库中删除的文件名。&lt;code>--cached&lt;/code> 参数意味着仅从Git的跟踪中删除文件，而不删除工作目录中的文件。&lt;/p></description></item><item><title>x86 教程</title><link>https://caoyang2002.xyz/post/2024/05/x86/</link><pubDate>Thu, 02 May 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/05/x86/</guid><description>&lt;p>作者： 
&lt;a href="http://www.ruanyifeng.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 阮一峰
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>日期： 
&lt;a href="http://www.ruanyifeng.com/blog/2018/01/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 2018年1月21日
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。&lt;/p>
&lt;p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。&lt;/p>
&lt;p>&lt;img src="https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/bg2018012204.png" alt="img">&lt;/p>
&lt;p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。&lt;/p></description></item><item><title>SQL 教程</title><link>https://caoyang2002.xyz/post/2024/04/sql/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/04/sql/</guid><description>&lt;!-- raw HTML omitted -->
&lt;h1 id="数据库相关的操作">数据库相关的操作&lt;/h1>
&lt;p>查询数据库	 &lt;code>SHOW DATABASES&lt;/code>&lt;/p>
&lt;p>创建数据库
&lt;code>CREATE DATABASE 数据库名&lt;/code>
&lt;code>CREATE DATABASE mydatabase&lt;/code>&lt;/p>
&lt;p>查看数据库信息
&lt;code>SHOW CREATE DATABASE 数据库名&lt;/code>
&lt;code>SHOW CREATE DATABASE database&lt;/code>&lt;/p>
&lt;p>删除数据库
&lt;code>DROP DATABASE 数据库名&lt;/code>
&lt;code>DROP DATABASE mydatabase&lt;/code>&lt;/p>
&lt;p>使用数据库
&lt;code>USE 数据库名&lt;/code>
&lt;code>USE mydatabase&lt;/code>&lt;/p>
&lt;h1 id="ddl语句-数据定义语言">DDL语句	 数据定义语言&lt;/h1>
&lt;p>创建表&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-sql" data-lang="sql">CREATE TABLE 表名(
 列名1 类型[长度] [DEFAULT 默认值] [约束条件]
 列名2 类型
 ……
);

CREATE TABLE userinfo(
 id INT
 username VARCHAR(32)
 password VARCHAR(32)
 nickname VARCHAR(32)
 age INT(3)
);&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>查看当前数据库创建的所有表
&lt;code>SHOW TABLES;&lt;/code>&lt;/p></description></item><item><title>什么是 SimHash</title><link>https://caoyang2002.xyz/post/2024/04/simhash/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/04/simhash/</guid><description>&lt;h1 id="一什么是simhash">一、什么是SimHash&lt;/h1>
&lt;p>SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。&lt;/p>
&lt;p>对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。
比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。&lt;/p></description></item><item><title>JWT 解析</title><link>https://caoyang2002.xyz/post/2024/04/jwt/</link><pubDate>Fri, 12 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/04/jwt/</guid><description>&lt;p>&lt;img src="" alt="JWT">&lt;/p>
&lt;p>
&lt;a href="https://zhuanlan.zhihu.com/p/86937325"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文一
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://blog.csdn.net/weixin_39779004/article/details/110801387"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文二
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://b23.tv/3f7Yrct"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 视频
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="一什么是-jwt">一、什么是 JWT&lt;/h1>
&lt;p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。&lt;/p>
&lt;h1 id="二设计目标">二、设计目标&lt;/h1>
&lt;p>不需要服务器端存储状态，安全地传递非敏感信息&lt;/p>
&lt;p>&lt;img src="https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/OIP-C-20240424140338352.jpeg" alt="JWT认证方案讲解-阿里云开发者社区">&lt;/p>
&lt;h1 id="三-json-web-token-的结构是什么样的">三、 JSON Web Token 的结构是什么样的&lt;/h1>
&lt;p>JSON Web Token由三部分组成，例如&lt;code>dafdsafdwfefeqwad.oijhdaffweqtgfdhfdws.dhshfsghhhhhwfsdke&lt;/code>&lt;/p></description></item><item><title>Quartz 教程</title><link>https://caoyang2002.xyz/post/2024/02/quartz/</link><pubDate>Thu, 29 Feb 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2024/02/quartz/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://quartz.jzhao.xyz"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原作者
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="https://www.chyraw.com"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 个人配置
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;/blockquote>
&lt;h1 id="下载">下载&lt;/h1>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">git clone https://github.com/caoyang2002/quartz-obsidian-webside.git
cd quartz-obsidian-webside
npm i
npx quartz build --serve&lt;/code>&lt;/pre>
&lt;/div>

&lt;h1 id="配置">配置&lt;/h1>
&lt;h2 id="布局">布局&lt;/h2>
&lt;p>某些 emitters 可能还会输出HTML文件。为了方便定制，这些 emitters 允许您完全重新排列页面的布局。
默认页面布局可以在 &lt;code>quartz.layout.ts&lt;/code> 中找到。&lt;/p>
&lt;p>每个页面由多个不同的部分组成，这些部分包含 &lt;code>QuartzComponents&lt;/code>。以下代码片段列出了您可以向其中添加组件的所有有效部分：&lt;/p></description></item><item><title>群晖开发</title><link>https://caoyang2002.xyz/post/2023/08/synology/</link><pubDate>Tue, 29 Aug 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/08/synology/</guid><description>&lt;p>
&lt;a href="https://blog.csdn.net/christmans/article/details/129641264"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文链接
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="查看-cpu-架构">查看 CPU 架构&lt;/h1>








&lt;div>
 &lt;pre>&lt;code class="language-shell" data-lang="shell">uname -m：该命令会输出当前系统的CPU架构，如x86_64、i386、armv7l等。
arch：该命令可以查看Linux系统的CPU架构。
cat /proc/version：该命令可以查看系统内核的版本信息。
cat /proc/cpuinfo：该命令可以查看CPU信息，如每个物理CPU中core的个数、逻辑CPU的个数、CPU型号等。&lt;/code>&lt;/pre>
&lt;/div>

&lt;blockquote>
&lt;p>
&lt;a href="http://ipkg.nslu2-linux.org/optware-ng/bootstrap/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 脚本目录
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p></description></item><item><title>浮点数的存储</title><link>https://caoyang2002.xyz/post/2023/07/float_at_mem/</link><pubDate>Sat, 29 Jul 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/07/float_at_mem/</guid><description>&lt;h1 id="浮点数的存储">浮点数的存储&lt;/h1>
&lt;blockquote>
&lt;p>IEEE745 国际标准：&lt;/p>
&lt;p>任意一个二进制的浮点数可以表示为下面的形式：&lt;/p>
&lt;ul>
&lt;li>V = (-1)^s^ * M * 2^E^&lt;/li>
&lt;li>(-1)^s^表示符号位，当S=0的时候V为正数，当S=1的时候V为负数&lt;/li>
&lt;li>M表示有效数字，大于等于1，小于2; 1&amp;lt;= M &amp;lt;2&lt;/li>
&lt;li>2^E^：E表示指数位&lt;/li>
&lt;/ul>
&lt;p>科学计数法：123.45 = 1.2345 * 10^2^&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>举例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>V = 5.0 f&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二进制：101.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>科学计数法：1.01 * 2^2^&lt;/p></description></item><item><title>函数栈帧的创建和销毁</title><link>https://caoyang2002.xyz/post/2023/07/function_stack/</link><pubDate>Sat, 15 Jul 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/07/function_stack/</guid><description>&lt;p>&lt;code>C/C++&lt;/code>&lt;/p>
&lt;p>函数栈帧的创建和销毁&lt;/p>
&lt;p>在学习最基础的C语言程序的语法与使用时，但你是否有疑问？&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>函数的作用域是怎么形成的呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>局部变量是如何创建的？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为什么未初始化的局部变量的值是随机值或是乱码呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数是如何传参的？&lt;/p>
&lt;p>传参的顺序又是怎么样的呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>形参和实参的关系是什么？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数的调用是怎么实现的呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数调用结束后是怎么返回的呢？&lt;/p></description></item><item><title>C 语言结构体</title><link>https://caoyang2002.xyz/post/2023/06/c_struct/</link><pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/06/c_struct/</guid><description>&lt;h1 id="结构体内存对齐">结构体内存对齐&lt;/h1>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
struct S1{
 char c1;//1
 int i;//4
 char c2;//1
};

struct S2{
 char c1;//1
 char c2;//1
 int i;//4
};
int main(){
 printf(&amp;#34;%d\n&amp;#34;,sizeof(struct S1));//12
 printf(&amp;#34;%d\n&amp;#34;,sizeof(struct S2));//8
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>对齐规则：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>第一个成员在与结构体变量偏移量为0的地址处&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处
对齐数 = 编译默认的一个对齐数与该成员大小的&lt;strong>较小值&lt;/strong>。 vs中默认是8&lt;/p>
&lt;p>(即：第二个成员和编译器的默认对齐数比较大小,第三个成员和编译器的默认对齐数比较大小,第四个成员和编译器的默认对齐数比较大小&amp;hellip;..)&lt;/p></description></item><item><title>C 语言数学</title><link>https://caoyang2002.xyz/post/2023/06/c_number/</link><pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/06/c_number/</guid><description>&lt;ul>
&lt;li>暴力算法&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>时间复杂度过大&lt;/p>
&lt;/blockquote>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc/_malloc.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
// 最大公约数
// 最小公倍数
//计算最小公倍数和最大公约数的和
int main(){
 int n = 0;
 int m = 0;
 while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m) == 2){//读取两个数
 int min = n &amp;lt; m ? n : m;
 int max = n &amp;gt; m ? n : m;
 int i = min;//最大公约数
 int j = max;//最小公倍数
 while(1){
 if(n%i == 0 &amp;amp;&amp;amp; m%i == 0){
 break;
 }
 i--;
 }
 // i就是最大公约数
 while(1){
 if(j%n == 0 &amp;amp;&amp;amp; j%m == 0){
 break;
 }
 j&amp;#43;&amp;#43;;
 }
 // j就是最大公倍数

 printf(&amp;#34;最大公倍数 %d &amp;#43; 最小公约数 %d = %d\n&amp;#34;,j,i,j&amp;#43;i);
 }
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div>

&lt;hr>
&lt;ul>
&lt;li>辗转相除法&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>两个数的&lt;em>&lt;strong>最大公约数&lt;/strong>&lt;/em>等于其中较小的数字和二者之间余数的最大公约数&lt;/p></description></item><item><title>C++ 命名规范</title><link>https://caoyang2002.xyz/post/2023/05/cpp_named/</link><pubDate>Mon, 29 May 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/05/cpp_named/</guid><description>&lt;p>
&lt;a href="https://codeif.xinke.org.cn"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 codeif
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="文件命名">文件命名&lt;/h1>
&lt;blockquote>
&lt;p>所有文件&lt;/p>
&lt;p>头文件和原文件成对出现&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>全部小写, 可是使用下划线&amp;quot;_&amp;quot;(默认)或连字符&amp;quot;-&amp;quot;, 称完整, 不要有歧义&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>system_file.c &amp;amp; system_file.h&lt;/li>
&lt;li>item_name.c&lt;/li>
&lt;li>item-name.c&lt;/li>
&lt;/ul>
&lt;h1 id="类型命名">类型命名&lt;/h1>
&lt;blockquote>
&lt;p>类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>每个单词首字母大写, 不使用下划线&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Number&lt;/li>
&lt;li>Timer&lt;/li>
&lt;li>File&lt;/li>
&lt;li>Name&lt;/li>
&lt;/ul>
&lt;h1 id="变量命名">变量命名&lt;/h1>
&lt;blockquote>
&lt;p>变量, 函数参数, 数据成员名&lt;/p></description></item><item><title>mermaid 教程</title><link>https://caoyang2002.xyz/post/2023/03/marmaid/</link><pubDate>Sun, 19 Mar 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2023/03/marmaid/</guid><description>&lt;p>mermaid可以在主流的markdown工具中使用
下面是几个常用的图示类型&lt;/p>
&lt;h4 id="1思维导图">1.思维导图&lt;/h4>
&lt;ul>
&lt;li>空格敏感&lt;/li>
&lt;/ul>







&lt;div class="mermaid">mindmap
 root((思维导图))
 节点一
 记录1.1
 ::icon(fa fa-book)
 节点1.1
 记录1.1.1
 节点二
 记录2.1
 记录2.2
 节点2.1
 记录2.1.1
 			记录2.1.2
 	记录2.1.3
 节点三
 记录3.1
 记录3.2&lt;/div>

&lt;ul>
&lt;li>
&lt;p>基础&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语法&lt;/p>
&lt;ul>
&lt;li>
&lt;p>形状&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认&lt;/p>







&lt;div class="mermaid">mindmap
 I am the default shape&lt;/div>

&lt;/li>
&lt;li>
&lt;p>&lt;code>[]&lt;/code>矩形&lt;/p></description></item><item><title>字符图片</title><link>https://caoyang2002.xyz/post/2022/07/chart_image/</link><pubDate>Fri, 29 Jul 2022 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/post/2022/07/chart_image/</guid><description>&lt;p>&lt;img src="https://www.caoyang2002.top/usr/uploads/2023/10/958002088.jpg" alt="beautiful.jpg">
&lt;img src="https://www.caoyang2002.top/usr/uploads/2023/10/1324992575.jpg" alt="cool.jpg">&lt;/p>
&lt;p>
&lt;a href="http://patorjk.com/software/taag"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://patorjk.com/software/taag
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="http://www.network-science.de/ascii/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://www.network-science.de/ascii/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="http://www.degraeve.com/img2txt.php"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://www.degraeve.com/img2txt.php
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="http://life.chacuo.net/convertfont2char"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://life.chacuo.net/convertfont2char
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p></description></item></channel></rss>