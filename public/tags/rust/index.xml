<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on caoyang 2002</title>
    <link>https://caoyang2002.xyz/tags/rust/</link>
    <description>Recent content in Rust on caoyang 2002</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 22 Jan 2025 22:41:30 +0800</lastBuildDate>
    <atom:link href="https://caoyang2002.xyz/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简述 Rust 中的闭包</title>
      <link>https://caoyang2002.xyz/post/2025/01/rust_closure_brief/</link>
      <pubDate>Wed, 15 Jan 2025 13:22:26 +0800</pubDate>
      <guid>https://caoyang2002.xyz/post/2025/01/rust_closure_brief/</guid>
      <description>&lt;h1 id=&#34;为什么需要闭包&#34;&gt;为什么需要闭包？&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 问题1：函数复用&#xA;// 没有闭包时，需要传入所有参数&#xA;fn add(x: i32, base: i32) -&amp;gt; i32 { x &amp;#43; base }&#xA;&#xA;// 有了闭包，可以部分应用&#xA;let base = 5;&#xA;let add_five = |x| x &amp;#43; base;&#xA;&#xA;// 问题2：函数式编程需求&#xA;vec![1, 2, 3].iter().map(|x| x * 2);  // 更简洁&#xA;vec![1, 2, 3].iter().map(multiply);    // 需要单独定义函数&#xA;&#xA;// 问题3：上下文捕获&#xA;// 没有闭包时很难处理&#xA;struct Context { value: i32 }&#xA;let ctx = Context { value: 42 };&#xA;let use_context = || println!(&amp;#34;{}&amp;#34;, ctx.value);&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;controls&#34;&gt;&#xA;        &lt;button class=&#34;run-button&#34;&gt;&#xA;            &lt;span style=&#34;display: flex; align-items: center; gap: 4px&#34;&#xA;                &gt;运行&lt;svg&#xA;                    t=&#34;1737473351499&#34;&#xA;                    class=&#34;icon&#34;&#xA;                    viewBox=&#34;0 0 1024 1024&#34;&#xA;                    version=&#34;1.1&#34;&#xA;                    xmlns=&#34;http://www.w3.org/2000/svg&#34;&#xA;                    p-id=&#34;11262&#34;&#xA;                    width=&#34;16&#34;&#xA;                    height=&#34;16&#34;&#xA;                &gt;&#xA;                    &lt;path&#xA;                        d=&#34;M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z&#34;&#xA;                        p-id=&#34;11263&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                    &lt;path&#xA;                        d=&#34;M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z&#34;&#xA;                        p-id=&#34;11264&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                &lt;/svg&gt;&#xA;            &lt;/span&gt;&#xA;        &lt;/button&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;output&#34; style=&#34;display: none&#34;&gt;&#xA;        &lt;pre class=&#34;output-content&#34;&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;闭包是什么&#34;&gt;闭包是什么？&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;闭包是可以捕获其环境的匿名函数&lt;/li&gt;&#xA;&lt;li&gt;它&amp;quot;封闭&amp;quot;了其定义时的环境，故称&amp;quot;闭包&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;闭包 = 函数 + 环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;闭包的优势&#34;&gt;闭包的优势&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 1. 简洁的语法&#xA;let add = |a, b| a &amp;#43; b;  // vs fn add(a: i32, b: i32) -&amp;gt; i32&#xA;&#xA;// 2. 灵活的环境捕获&#xA;let multiplier = 2;&#xA;let double = |x| x * multiplier;  // 捕获 multiplier&#xA;&#xA;// 3. 支持函数式编程&#xA;let numbers: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3, 4, 5];&#xA;let even_numbers: Vec&amp;lt;i32&amp;gt; = numbers&#xA;    .into_iter()&#xA;    .filter(|x| x % 2 == 0)&#xA;    .collect();&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;controls&#34;&gt;&#xA;        &lt;button class=&#34;run-button&#34;&gt;&#xA;            &lt;span style=&#34;display: flex; align-items: center; gap: 4px&#34;&#xA;                &gt;运行&lt;svg&#xA;                    t=&#34;1737473351499&#34;&#xA;                    class=&#34;icon&#34;&#xA;                    viewBox=&#34;0 0 1024 1024&#34;&#xA;                    version=&#34;1.1&#34;&#xA;                    xmlns=&#34;http://www.w3.org/2000/svg&#34;&#xA;                    p-id=&#34;11262&#34;&#xA;                    width=&#34;16&#34;&#xA;                    height=&#34;16&#34;&#xA;                &gt;&#xA;                    &lt;path&#xA;                        d=&#34;M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z&#34;&#xA;                        p-id=&#34;11263&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                    &lt;path&#xA;                        d=&#34;M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z&#34;&#xA;                        p-id=&#34;11264&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                &lt;/svg&gt;&#xA;            &lt;/span&gt;&#xA;        &lt;/button&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;output&#34; style=&#34;display: none&#34;&gt;&#xA;        &lt;pre class=&#34;output-content&#34;&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;理解闭包&#34;&gt;理解闭包&lt;/h1&gt;&#xA;&lt;p&gt;我用 Python 和 TypeScript 的概念来解释 Rust 的闭包：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust 中的引用</title>
      <link>https://caoyang2002.xyz/post/2025/01/rust_ref/</link>
      <pubDate>Wed, 15 Jan 2025 11:57:02 +0800</pubDate>
      <guid>https://caoyang2002.xyz/post/2025/01/rust_ref/</guid>
      <description>&lt;h1 id=&#34;引用你的快递地址和包裹&#34;&gt;引用：你的快递地址和包裹&lt;/h1&gt;&#xA;&lt;p&gt;想象这样一个场景：你在网上买了个漂亮的花瓶，快递公司需要把它送到你家。快递员需要知道两个信息：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;你家的地址（引用）&lt;/li&gt;&#xA;&lt;li&gt;花瓶本身（值）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;为什么我们需要引用&#34;&gt;为什么我们需要引用？&lt;/h2&gt;&#xA;&lt;p&gt;让我们看一个具体的问题：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;fn calculate_length(s: String) -&amp;gt; usize {&#xA;    s.len()&#xA;}&#xA;&#xA;let s = String::from(&amp;#34;hello&amp;#34;);&#xA;let len = calculate_length(s);&#xA;println!(&amp;#34;{}&amp;#34;, s); // 编译错误！s 已经被转移了所有权&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;controls&#34;&gt;&#xA;        &lt;button class=&#34;run-button&#34;&gt;&#xA;            &lt;span style=&#34;display: flex; align-items: center; gap: 4px&#34;&#xA;                &gt;运行&lt;svg&#xA;                    t=&#34;1737473351499&#34;&#xA;                    class=&#34;icon&#34;&#xA;                    viewBox=&#34;0 0 1024 1024&#34;&#xA;                    version=&#34;1.1&#34;&#xA;                    xmlns=&#34;http://www.w3.org/2000/svg&#34;&#xA;                    p-id=&#34;11262&#34;&#xA;                    width=&#34;16&#34;&#xA;                    height=&#34;16&#34;&#xA;                &gt;&#xA;                    &lt;path&#xA;                        d=&#34;M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z&#34;&#xA;                        p-id=&#34;11263&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                    &lt;path&#xA;                        d=&#34;M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z&#34;&#xA;                        p-id=&#34;11264&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                &lt;/svg&gt;&#xA;            &lt;/span&gt;&#xA;        &lt;/button&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;output&#34; style=&#34;display: none&#34;&gt;&#xA;        &lt;pre class=&#34;output-content&#34;&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;这就像你把花瓶（值）直接给了快递员（函数），花瓶就不再属于你了。但很多时候，我们只是想让快递员看看花瓶，而不是把它拿走。&lt;/p&gt;</description>
    </item>
    <item>
      <title>rust 闭包</title>
      <link>https://caoyang2002.xyz/post/2025/01/rust_closure/</link>
      <pubDate>Wed, 15 Jan 2025 11:29:27 +0800</pubDate>
      <guid>https://caoyang2002.xyz/post/2025/01/rust_closure/</guid>
      <description>&lt;h2 id=&#34;从一个常见问题说起&#34;&gt;从一个常见问题说起&lt;/h2&gt;&#xA;&lt;p&gt;假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;let numbers = vec![1, 2, 3, 4, 5];&#xA;// 如何优雅地复用过滤逻辑？&#xA;let even_numbers = ??? // 这里怎么写&#xA;let multiplied_numbers = ??? // 这里怎么写&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;controls&#34;&gt;&#xA;        &lt;button class=&#34;run-button&#34;&gt;&#xA;            &lt;span style=&#34;display: flex; align-items: center; gap: 4px&#34;&#xA;                &gt;运行&lt;svg&#xA;                    t=&#34;1737473351499&#34;&#xA;                    class=&#34;icon&#34;&#xA;                    viewBox=&#34;0 0 1024 1024&#34;&#xA;                    version=&#34;1.1&#34;&#xA;                    xmlns=&#34;http://www.w3.org/2000/svg&#34;&#xA;                    p-id=&#34;11262&#34;&#xA;                    width=&#34;16&#34;&#xA;                    height=&#34;16&#34;&#xA;                &gt;&#xA;                    &lt;path&#xA;                        d=&#34;M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z&#34;&#xA;                        p-id=&#34;11263&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                    &lt;path&#xA;                        d=&#34;M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z&#34;&#xA;                        p-id=&#34;11264&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                &lt;/svg&gt;&#xA;            &lt;/span&gt;&#xA;        &lt;/button&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;output&#34; style=&#34;display: none&#34;&gt;&#xA;        &lt;pre class=&#34;output-content&#34;&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;闭包的本质&#34;&gt;闭包的本质&lt;/h2&gt;&#xA;&lt;p&gt;Rust 的闭包本质上是一种特殊的数据结构，它包含：&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入解释 Rust 中的 Result 和 Option 这两个核心类型</title>
      <link>https://caoyang2002.xyz/post/2025/01/rust_result_option/</link>
      <pubDate>Wed, 15 Jan 2025 11:26:02 +0800</pubDate>
      <guid>https://caoyang2002.xyz/post/2025/01/rust_result_option/</guid>
      <description>&lt;h1 id=&#34;从一个实际问题开始&#34;&gt;从一个实际问题开始&lt;/h1&gt;&#xA;&lt;p&gt;假设我们在写一个文件处理程序：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;fn read_config_file(path: &amp;amp;str) -&amp;gt; String {&#xA;    std::fs::read_to_string(path)  // 这里会返回什么？&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;controls&#34;&gt;&#xA;        &lt;button class=&#34;run-button&#34;&gt;&#xA;            &lt;span style=&#34;display: flex; align-items: center; gap: 4px&#34;&#xA;                &gt;运行&lt;svg&#xA;                    t=&#34;1737473351499&#34;&#xA;                    class=&#34;icon&#34;&#xA;                    viewBox=&#34;0 0 1024 1024&#34;&#xA;                    version=&#34;1.1&#34;&#xA;                    xmlns=&#34;http://www.w3.org/2000/svg&#34;&#xA;                    p-id=&#34;11262&#34;&#xA;                    width=&#34;16&#34;&#xA;                    height=&#34;16&#34;&#xA;                &gt;&#xA;                    &lt;path&#xA;                        d=&#34;M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z&#34;&#xA;                        p-id=&#34;11263&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                    &lt;path&#xA;                        d=&#34;M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z&#34;&#xA;                        p-id=&#34;11264&#34;&#xA;                    &gt;&lt;/path&gt;&#xA;                &lt;/svg&gt;&#xA;            &lt;/span&gt;&#xA;        &lt;/button&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;output&#34; style=&#34;display: none&#34;&gt;&#xA;        &lt;pre class=&#34;output-content&#34;&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;这段代码看似简单，但隐藏着两个基本问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;文件可能不存在&lt;/li&gt;&#xA;&lt;li&gt;即使文件存在，读取过程也可能失败&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这就是为什么 Rust 引入了 &lt;code&gt;Result&lt;/code&gt; 和 &lt;code&gt;Option&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
