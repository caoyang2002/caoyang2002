<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on caoyang2002</title>
    <link>http://localhost:1313/en/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on caoyang2002</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 23 Jan 2025 01:00:04 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/en/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mac 汇编笔记</title>
      <link>http://localhost:1313/en/post/2025/01/mac_assembly/</link>
      <pubDate>Sat, 18 Jan 2025 11:35:14 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/mac_assembly/</guid>
      <description>&lt;p&gt;&#xA;&lt;a href=&#34;https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;h1 id=&#34;梦开始的地方&#34;&gt;梦开始的地方&lt;/h1&gt;&#xA;&lt;h1 id=&#34;简单的-asm&#34;&gt;简单的 asm&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;null.s&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;.section    __TEXT,__text&#xA;.globl  _main&#xA;.p2align    2&#xA;_main:&#xA;mov    w0, #0&#xA;ret&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;int main() {&#xA;    return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;as null.s -o null.o # 汇编&#xA;ld null.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o null # 链接（由于在 macOS 上不能创建静态链接的可执行文件，因此在链接时必须使用 -lSystem 动态链接上系统库。）&#xA;./null # 运行&#xA;&#xA;# or&#xA;clang null.s -o null&#xA;&#xA;# or&#xA;gcc null.s -o null&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;as&lt;/code&gt; 是 LLVM 的汇编器, &lt;code&gt;lldb&lt;/code&gt; 是 LLVM 的调试器。&#xA;&lt;code&gt;GCC&lt;/code&gt; 套件是 GNU 操作系统的一个部分，GNU 是开源的、社区驱动的。而 LLVM 项目也是开源的，现在主要是 Apple 在投资运行。因此，既然在 macOS 上，我就主要用的是 LLVM 系的工具。&lt;/p&gt;</description>
    </item>
    <item>
      <title>简述 Rust 中的闭包</title>
      <link>http://localhost:1313/en/post/2025/01/rust_closure_brief/</link>
      <pubDate>Wed, 15 Jan 2025 13:22:26 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_closure_brief/</guid>
      <description>&lt;h1 id=&#34;为什么需要闭包&#34;&gt;为什么需要闭包？&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 问题1：函数复用&#xA;// 没有闭包时，需要传入所有参数&#xA;fn add(x: i32, base: i32) -&amp;gt; i32 { x &amp;#43; base }&#xA;&#xA;// 有了闭包，可以部分应用&#xA;let base = 5;&#xA;let add_five = |x| x &amp;#43; base;&#xA;&#xA;// 问题2：函数式编程需求&#xA;vec![1, 2, 3].iter().map(|x| x * 2);  // 更简洁&#xA;vec![1, 2, 3].iter().map(multiply);    // 需要单独定义函数&#xA;&#xA;// 问题3：上下文捕获&#xA;// 没有闭包时很难处理&#xA;struct Context { value: i32 }&#xA;let ctx = Context { value: 42 };&#xA;let use_context = || println!(&amp;#34;{}&amp;#34;, ctx.value);&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;闭包是什么&#34;&gt;闭包是什么？&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;闭包是可以捕获其环境的匿名函数&lt;/li&gt;&#xA;&lt;li&gt;它&amp;quot;封闭&amp;quot;了其定义时的环境，故称&amp;quot;闭包&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;闭包 = 函数 + 环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;闭包的优势&#34;&gt;闭包的优势&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 1. 简洁的语法&#xA;let add = |a, b| a &amp;#43; b;  // vs fn add(a: i32, b: i32) -&amp;gt; i32&#xA;&#xA;// 2. 灵活的环境捕获&#xA;let multiplier = 2;&#xA;let double = |x| x * multiplier;  // 捕获 multiplier&#xA;&#xA;// 3. 支持函数式编程&#xA;let numbers: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3, 4, 5];&#xA;let even_numbers: Vec&amp;lt;i32&amp;gt; = numbers&#xA;    .into_iter()&#xA;    .filter(|x| x % 2 == 0)&#xA;    .collect();&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;理解闭包&#34;&gt;理解闭包&lt;/h1&gt;&#xA;&lt;p&gt;我用 Python 和 TypeScript 的概念来解释 Rust 的闭包：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust 中的引用</title>
      <link>http://localhost:1313/en/post/2025/01/rust_ref/</link>
      <pubDate>Wed, 15 Jan 2025 11:57:02 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_ref/</guid>
      <description>&lt;h1 id=&#34;引用你的快递地址和包裹&#34;&gt;引用：你的快递地址和包裹&lt;/h1&gt;&#xA;&lt;p&gt;想象这样一个场景：你在网上买了个漂亮的花瓶，快递公司需要把它送到你家。快递员需要知道两个信息：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;你家的地址（引用）&lt;/li&gt;&#xA;&lt;li&gt;花瓶本身（值）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;为什么我们需要引用&#34;&gt;为什么我们需要引用？&lt;/h2&gt;&#xA;&lt;p&gt;让我们看一个具体的问题：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;fn calculate_length(s: String) -&amp;gt; usize {&#xA;    s.len()&#xA;}&#xA;&#xA;let s = String::from(&amp;#34;hello&amp;#34;);&#xA;let len = calculate_length(s);&#xA;println!(&amp;#34;{}&amp;#34;, s); // 编译错误！s 已经被转移了所有权&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;这就像你把花瓶（值）直接给了快递员（函数），花瓶就不再属于你了。但很多时候，我们只是想让快递员看看花瓶，而不是把它拿走。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust 函数式编程</title>
      <link>http://localhost:1313/en/post/2025/01/rust_programming/</link>
      <pubDate>Wed, 15 Jan 2025 11:48:53 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_programming/</guid>
      <description>&lt;p&gt;让我用这种方式来讲解 Rust 的函数式编程概念：&lt;/p&gt;&#xA;&lt;h1 id=&#34;引入问题&#34;&gt;引入问题&lt;/h1&gt;&#xA;&lt;p&gt;想象这样一个场景：你需要处理一个电商系统的订单数据。要求：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;过滤出金额大于 100 的订单&lt;/li&gt;&#xA;&lt;li&gt;计算这些订单的总金额&lt;/li&gt;&#xA;&lt;li&gt;给每个订单加上 10% 的折扣&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;传统的命令式编程可能是这样：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;let mut total = 0;&#xA;for order in orders {&#xA;    if order.amount &amp;gt; 100 {&#xA;        total &amp;#43;= order.amount * 0.9;&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;这段代码有什么问题？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可读性不高：逻辑分散在循环中&lt;/li&gt;&#xA;&lt;li&gt;难以修改：如果要改变处理逻辑，需要修改循环内部&lt;/li&gt;&#xA;&lt;li&gt;难以复用：这段逻辑很难在其他地方重用&lt;/li&gt;&#xA;&lt;li&gt;易出错：可变状态(total)增加了出错风险&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;问题模型&#34;&gt;问题模型&lt;/h1&gt;&#xA;&lt;p&gt;我们需要一种方式能够：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust 生命周期</title>
      <link>http://localhost:1313/en/post/2025/01/rust_cyc/</link>
      <pubDate>Wed, 15 Jan 2025 11:41:27 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_cyc/</guid>
      <description>&lt;p&gt;让我系统地分析 Rust 的生命周期：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;问题场景：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 考虑这个场景：我们需要返回一个引用&#xA;fn longest(x: &amp;amp;str, y: &amp;amp;str) -&amp;gt; &amp;amp;str {&#xA;    if x.len() &amp;gt; y.len() {&#xA;        x&#xA;    } else {&#xA;        y&#xA;    }&#xA;}&#xA;// 编译错误：missing lifetime specifier&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;这个特性是什么：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生命周期是 Rust 的类型系统中用于确保引用有效性的一种机制&lt;/li&gt;&#xA;&lt;li&gt;它通过标注来告诉编译器多个引用之间的生命周期关系&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;导致这个特性出现的问题：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 问题1：悬垂引用&#xA;let r;&#xA;{&#xA;    let x = 5;&#xA;    r = &amp;amp;x;  // x 在这里就会被销毁&#xA;}&#xA;println!(&amp;#34;{}&amp;#34;, r);  // r 引用了已经无效的内存&#xA;&#xA;// 问题2：引用的有效期不明确&#xA;struct Person&amp;lt;&amp;#39;a&amp;gt; {&#xA;    name: &amp;amp;&amp;#39;a str  // 没有生命周期标注时，不知道这个引用能活多久&#xA;}&#xA;&#xA;// 问题3：函数返回引用时的所有权问题&#xA;fn return_ref(data: &amp;amp;str) -&amp;gt; &amp;amp;str {  // 返回引用时需要明确它的有效期&#xA;    data&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;解决方案分析：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 方案1：完全避免使用引用，使用所有权&#xA;struct Person {&#xA;    name: String  // 而不是 &amp;amp;str&#xA;}&#xA;// 优点：安全&#xA;// 缺点：性能开销，不够灵活&#xA;&#xA;// 方案2：生命周期标注&#xA;struct Person&amp;lt;&amp;#39;a&amp;gt; {&#xA;    name: &amp;amp;&amp;#39;a str&#xA;}&#xA;// 优点：既安全又灵活&#xA;// 缺点：语法复杂度增加&#xA;&#xA;// 方案3：使用智能指针&#xA;struct Person {&#xA;    name: Rc&amp;lt;String&amp;gt;&#xA;}&#xA;// 优点：灵活性高&#xA;// 缺点：运行时开销&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;最佳解决方案 - 生命周期标注：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 1. 函数中的生命周期标注&#xA;fn longest&amp;lt;&amp;#39;a&amp;gt;(x: &amp;amp;&amp;#39;a str, y: &amp;amp;&amp;#39;a str) -&amp;gt; &amp;amp;&amp;#39;a str {&#xA;    if x.len() &amp;gt; y.len() {&#xA;        x&#xA;    } else {&#xA;        y&#xA;    }&#xA;}&#xA;&#xA;// 2. 结构体中的生命周期标注&#xA;struct Book&amp;lt;&amp;#39;a&amp;gt; {&#xA;    title: &amp;amp;&amp;#39;a str,&#xA;    author: &amp;amp;&amp;#39;a str,&#xA;}&#xA;&#xA;// 3. impl 块中的生命周期标注&#xA;impl&amp;lt;&amp;#39;a&amp;gt; Book&amp;lt;&amp;#39;a&amp;gt; {&#xA;    fn get_title(&amp;amp;self) -&amp;gt; &amp;amp;str {&#xA;        self.title&#xA;    }&#xA;}&#xA;&#xA;// 4. 多个生命周期参数&#xA;fn complex&amp;lt;&amp;#39;a, &amp;#39;b&amp;gt;(x: &amp;amp;&amp;#39;a str, y: &amp;amp;&amp;#39;b str) -&amp;gt; &amp;amp;&amp;#39;a str {&#xA;    x&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;生命周期最佳实践：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 1. 生命周期省略规则&#xA;fn first_word(s: &amp;amp;str) -&amp;gt; &amp;amp;str {  // 隐含 &amp;lt;&amp;#39;a&amp;gt;&#xA;    // ...&#xA;}&#xA;&#xA;// 2. 静态生命周期&#xA;let static_str: &amp;amp;&amp;#39;static str = &amp;#34;I live forever&amp;#34;;&#xA;&#xA;// 3. 生命周期约束&#xA;fn print_type&amp;lt;T: Display &amp;#43; &amp;#39;static&amp;gt;(t: T) {&#xA;    println!(&amp;#34;{}&amp;#34;, t);&#xA;}&#xA;&#xA;// 4. 正确使用 &amp;#39;static&#xA;// 好的做法&#xA;const HELLO: &amp;amp;&amp;#39;static str = &amp;#34;Hello, world!&amp;#34;;&#xA;&#xA;// 避免过度使用 &amp;#39;static&#xA;// 不好的做法&#xA;fn bad_practice(data: &amp;amp;&amp;#39;static str) -&amp;gt; &amp;amp;&amp;#39;static str {&#xA;    data&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;结论总结：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生命周期是 Rust 独特的解决内存安全的机制&lt;/li&gt;&#xA;&lt;li&gt;它在编译时就能发现潜在的内存问题&lt;/li&gt;&#xA;&lt;li&gt;主要用途：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;防止悬垂引用&lt;/li&gt;&#xA;&lt;li&gt;确保引用的有效性&lt;/li&gt;&#xA;&lt;li&gt;管理数据的生存期&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用建议：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;优先使用生命周期省略规则&lt;/li&gt;&#xA;&lt;li&gt;需要时才显式标注&lt;/li&gt;&#xA;&lt;li&gt;谨慎使用 &amp;lsquo;static&lt;/li&gt;&#xA;&lt;li&gt;理解借用检查器的错误信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;通过这个特性，Rust 在编译时就能保证内存安全，而不需要运行时垃圾回收，这是它的一个重要优势。虽然生命周期标注增加了一些代码复杂度，但这是为了内存安全付出的必要成本。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解 Rust 所有权机制</title>
      <link>http://localhost:1313/en/post/2025/01/rust_ownership/</link>
      <pubDate>Wed, 15 Jan 2025 11:38:20 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_ownership/</guid>
      <description>&lt;h1 id=&#34;从一个常见问题说起&#34;&gt;从一个常见问题说起&lt;/h1&gt;&#xA;&lt;p&gt;看这段在其他语言中很普通的代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;fn main() {&#xA;    let data = vec![1, 2, 3];&#xA;    process_data(data);&#xA;    println!(&amp;#34;{:?}&amp;#34;, data);  // 编译错误！&#xA;}&#xA;&#xA;fn process_data(v: Vec&amp;lt;i32&amp;gt;) {&#xA;    println!(&amp;#34;Processing: {:?}&amp;#34;, v);&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;为什么这段代码在Rust中会报错？这就涉及到 Rust 最独特的特性：所有权系统。&lt;/p&gt;&#xA;&lt;h2 id=&#34;所有权的三条核心规则&#34;&gt;所有权的三条核心规则&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;每个值只能有一个所有者&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;所有者离开作用域，值将被丢弃&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;一个值同一时刻只能有一个所有者&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;让我们通过代码详细理解这些规则：&lt;/p&gt;&#xA;&lt;h3 id=&#34;规则1单一所有权&#34;&gt;规则1：单一所有权&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;let s1 = String::from(&amp;#34;hello&amp;#34;);&#xA;let s2 = s1;  // 所有权从s1转移到s2&#xA;// println!(&amp;#34;{}&amp;#34;, s1);  // 编译错误：s1已经失效&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;内存布局变化：&lt;/p&gt;</description>
    </item>
    <item>
      <title>rust 闭包</title>
      <link>http://localhost:1313/en/post/2025/01/rust_closure/</link>
      <pubDate>Wed, 15 Jan 2025 11:29:27 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_closure/</guid>
      <description>&lt;h2 id=&#34;从一个常见问题说起&#34;&gt;从一个常见问题说起&lt;/h2&gt;&#xA;&lt;p&gt;假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;let numbers = vec![1, 2, 3, 4, 5];&#xA;// 如何优雅地复用过滤逻辑？&#xA;let even_numbers = ??? // 这里怎么写&#xA;let multiplied_numbers = ??? // 这里怎么写&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;闭包的本质&#34;&gt;闭包的本质&lt;/h2&gt;&#xA;&lt;p&gt;Rust 的闭包本质上是一种特殊的数据结构，它包含：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;函数逻辑&lt;/li&gt;&#xA;&lt;li&gt;捕获的环境变量&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;让我们通过反编译来看闭包的真实面目：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;// 表面上的闭包&#xA;let multiplier = 2;&#xA;let closure = |x| x * multiplier;&#xA;&#xA;// 编译器实际生成的结构（简化版）&#xA;struct Closure {&#xA;    multiplier: i32,&#xA;}&#xA;&#xA;impl Closure {&#xA;    fn call(&amp;amp;self, x: i32) -&amp;gt; i32 {&#xA;        x * self.multiplier&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;闭包的三种类型&#34;&gt;闭包的三种类型&lt;/h2&gt;&#xA;&lt;p&gt;通过具体案例来理解三种闭包 trait：&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入解释 Rust 中的 Result 和 Option 这两个核心类型</title>
      <link>http://localhost:1313/en/post/2025/01/rust_result_option/</link>
      <pubDate>Wed, 15 Jan 2025 11:26:02 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_result_option/</guid>
      <description>&lt;h1 id=&#34;从一个实际问题开始&#34;&gt;从一个实际问题开始&lt;/h1&gt;&#xA;&lt;p&gt;假设我们在写一个文件处理程序：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;fn read_config_file(path: &amp;amp;str) -&amp;gt; String {&#xA;    std::fs::read_to_string(path)  // 这里会返回什么？&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;这段代码看似简单，但隐藏着两个基本问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;文件可能不存在&lt;/li&gt;&#xA;&lt;li&gt;即使文件存在，读取过程也可能失败&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这就是为什么 Rust 引入了 &lt;code&gt;Result&lt;/code&gt; 和 &lt;code&gt;Option&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;option处理有与没有&#34;&gt;&lt;code&gt;Option&lt;/code&gt;：处理&amp;quot;有&amp;quot;与&amp;quot;没有&amp;quot;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;option-的本质&#34;&gt;&lt;code&gt;Option&lt;/code&gt; 的本质&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;enum Option&amp;lt;T&amp;gt; {&#xA;    Some(T),    // 有值&#xA;    None,       // 没有值&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;让我们看一个实际例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;fn find_user(id: u32) -&amp;gt; Option&amp;lt;User&amp;gt; {&#xA;    if id == 0 {&#xA;        None                    // 用户不存在&#xA;    } else {&#xA;        Some(User { id, ... })  // 用户存在&#xA;    }&#xA;}&#xA;&#xA;// 使用方式&#xA;match find_user(1) {&#xA;    Some(user) =&amp;gt; println!(&amp;#34;Found user: {}&amp;#34;, user.name),&#xA;    None =&amp;gt; println!(&amp;#34;User not found&amp;#34;),&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;h3 id=&#34;option-的常用方法&#34;&gt;&lt;code&gt;Option&lt;/code&gt; 的常用方法&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;let x: Option&amp;lt;i32&amp;gt; = Some(5);&#xA;&#xA;// 方法1：unwrap - 危险操作&#xA;let value1 = x.unwrap();  // 如果是 None 会 panic&#xA;&#xA;// 方法2：unwrap_or - 提供默认值&#xA;let value2 = x.unwrap_or(0);  // None 时返回0&#xA;&#xA;// 方法3：map - 变换内部值&#xA;let value3 = x.map(|n| n * 2);  // Some(5) -&amp;gt; Some(10)&#xA;&#xA;// 方法4：and_then - 链式操作&#xA;let value4 = x.and_then(|n| if n &amp;gt; 0 { Some(n) } else { None });&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;result处理成功与失败&#34;&gt;&lt;code&gt;Result&lt;/code&gt;：处理“成功”与“失败”&lt;/h2&gt;&#xA;&lt;h3 id=&#34;result-的本质&#34;&gt;&lt;code&gt;Result&lt;/code&gt; 的本质&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;enum Result&amp;lt;T, E&amp;gt; {&#xA;    Ok(T),    // 成功，包含值 T&#xA;    Err(E),   // 错误，包含错误 E&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;实际应用示例：&lt;/p&gt;</description>
    </item>
    <item>
      <title>rust 中的属性宏</title>
      <link>http://localhost:1313/en/post/2025/01/rust_macro/</link>
      <pubDate>Wed, 15 Jan 2025 11:16:52 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/rust_macro/</guid>
      <description>&lt;h1 id=&#34;deriveclone-debug-serialize-deserialize-eq-partialeq&#34;&gt;&lt;code&gt;#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]&lt;/code&gt;&lt;/h1&gt;&#xA;&lt;p&gt;这是 Rust 语言中的属性宏(attribute macro)声明，用于自动为数据结构实现一些常用的特性(traits)。让我详细解释每个部分：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;derive&lt;/code&gt; - 这是 Rust 的派生宏，用于自动生成特定 trait 的实现&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;括号里的每个特性具体作用是：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Clone&lt;/code&gt; - 允许类型创建自身的深拷贝&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Debug&lt;/code&gt; - 实现格式化调试输出，使用 &lt;code&gt;{:?}&lt;/code&gt; 格式说明符可以打印该类型&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Serialize&lt;/code&gt; - 来自 serde 库，使类型可以被序列化(比如转换成 JSON)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Deserialize&lt;/code&gt; - 也来自 serde 库，使类型可以被反序列化(比如从 JSON 转换回来)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Eq&lt;/code&gt; - 实现完全相等比较&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;PartialEq&lt;/code&gt; - 实现部分相等比较，允许使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种写法可以让我们避免手动实现这些特性，编译器会自动为我们生成实现代码。这在定义数据结构时非常常用，特别是在需要序列化/反序列化数据的场景中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Wasm 打印输出和浏览器特性等最佳实践</title>
      <link>http://localhost:1313/en/post/2025/01/wasm_print/</link>
      <pubDate>Wed, 15 Jan 2025 00:31:17 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/wasm_print/</guid>
      <description>&lt;p&gt;在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;web_sys&lt;/code&gt; 和 &lt;code&gt;wasm_bindgen&lt;/code&gt; 进行浏览器 API 调用：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;use wasm_bindgen::prelude::*;&#xA;use web_sys::{console, window};&#xA;&#xA;pub fn move_test(name: &amp;amp;str) {&#xA;    // 控制台打印&#xA;    console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;move test: {}&amp;#34;, name)));&#xA;&#xA;    // 使用 console.warn&#xA;    console::warn_1(&amp;amp;JsValue::from_str(&amp;#34;This is a warning&amp;#34;));&#xA;&#xA;    // 使用 console.error&#xA;    console::error_1(&amp;amp;JsValue::from_str(&amp;#34;This is an error&amp;#34;));&#xA;&#xA;    // 浏览器 alert&#xA;    if let Some(window) = window() {&#xA;        window&#xA;            .alert_with_message(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;, name))&#xA;            .expect(&amp;#34;alert failed&amp;#34;);&#xA;    }&#xA;&#xA;    // 确认对话框&#xA;    if let Some(window) = window() {&#xA;        if window&#xA;            .confirm_with_message(&amp;#34;Do you want to continue?&amp;#34;)&#xA;            .expect(&amp;#34;confirm failed&amp;#34;)&#xA;        {&#xA;            console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked OK&amp;#34;));&#xA;        } else {&#xA;            console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked Cancel&amp;#34;));&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;在 Cargo.toml 中需要添加必要的依赖：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;[dependencies]&#xA;wasm-bindgen = &amp;#34;0.2&amp;#34;&#xA;web-sys = { version = &amp;#34;0.3&amp;#34;, features = [&#xA;    &amp;#34;console&amp;#34;,&#xA;    &amp;#34;Window&amp;#34;,&#xA;    &amp;#34;Document&amp;#34;,&#xA;    &amp;#34;Element&amp;#34;,&#xA;    &amp;#34;HtmlElement&amp;#34;,&#xA;    &amp;#34;Node&amp;#34;,&#xA;    &amp;#34;Location&amp;#34;&#xA;]}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;如果需要格式化打印，可以使用 &lt;code&gt;console::log!&lt;/code&gt; 宏：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;use web_sys::console;&#xA;&#xA;// 需要引入宏&#xA;#[macro_export]&#xA;macro_rules! console_log {&#xA;    ($($t:tt)*) =&amp;gt; (console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!($($t)*))))&#xA;}&#xA;&#xA;pub fn move_test(name: &amp;amp;str) {&#xA;    console_log!(&amp;#34;Testing move with name: {}&amp;#34;, name);&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;操作 DOM 示例：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;use wasm_bindgen::prelude::*;&#xA;use web_sys::{Document, Element, HtmlElement, window};&#xA;&#xA;pub fn move_test(name: &amp;amp;str) {&#xA;    // 获取 document&#xA;    let window = window().expect(&amp;#34;no global window exists&amp;#34;);&#xA;    let document = window.document().expect(&amp;#34;no document exists&amp;#34;);&#xA;&#xA;    // 创建新元素&#xA;    if let Some(div) = document.get_element_by_id(&amp;#34;test-input&amp;#34;) {&#xA;        // 修改输入框的值&#xA;        if let Some(input) = div.dyn_ref::&amp;lt;HtmlElement&amp;gt;() {&#xA;            input.set_inner_text(&amp;amp;format!(&amp;#34;New value: {}&amp;#34;, name));&#xA;        }&#xA;    }&#xA;&#xA;    // 创建新元素&#xA;    let new_div = document.create_element(&amp;#34;div&amp;#34;).unwrap();&#xA;    new_div.set_text_content(Some(&amp;amp;format!(&amp;#34;Hello {}&amp;#34;, name)));&#xA;&#xA;    // 添加到 body&#xA;    if let Some(body) = document.body() {&#xA;        body.append_child(&amp;amp;new_div).unwrap();&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;处理错误和 Result：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {&#xA;    // 使用 ? 运算符处理错误&#xA;    let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;&#xA;    let document = window.document().ok_or(&amp;#34;no document exists&amp;#34;)?;&#xA;&#xA;    // 处理可能的错误&#xA;    match document.get_element_by_id(&amp;#34;test-input&amp;#34;) {&#xA;        Some(element) =&amp;gt; {&#xA;            console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Found element: {}&amp;#34;, name)));&#xA;            Ok(())&#xA;        },&#xA;        None =&amp;gt; Err(JsValue::from_str(&amp;#34;Element not found&amp;#34;))&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;使用本地存储：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;rust&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-rust&#34;&gt;use web_sys::Storage;&#xA;&#xA;pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {&#xA;    let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;&#xA;&#xA;    // 获取 localStorage&#xA;    if let Some(storage) = window.local_storage()? {&#xA;        // 存储数据&#xA;        storage.set_item(&amp;#34;user_name&amp;#34;, name)?;&#xA;&#xA;        // 读取数据&#xA;        if let Ok(Some(saved_name)) = storage.get_item(&amp;#34;user_name&amp;#34;) {&#xA;            console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Saved name: {}&amp;#34;, saved_name)));&#xA;        }&#xA;    }&#xA;&#xA;    Ok(())&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 &amp;ldquo;Storage&amp;rdquo; feature：&lt;/p&gt;</description>
    </item>
    <item>
      <title>更好的 vim 配置</title>
      <link>http://localhost:1313/en/post/2025/01/vim_config/</link>
      <pubDate>Tue, 07 Jan 2025 13:48:33 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/vim_config/</guid>
      <description>&lt;p&gt;~ ⌚ 13:47:21&#xA;$ cat .vimrc&#xA;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/p&gt;&#xA;&lt;p&gt;&amp;quot; 显示相关&lt;/p&gt;&#xA;&lt;p&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;set shortmess=atI   &amp;quot; 启动的时候不显示那个援助乌干达儿童的提示&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;winpos 5 5          &amp;quot; 设定窗口位置&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;set lines=40 columns=155    &amp;quot; 设定窗口大小&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;set nu              &amp;quot; 显示行号&lt;/p&gt;&#xA;&lt;p&gt;set go=             &amp;quot; 不要图形按钮&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;color asmanian2     &amp;quot; 设置背景主题&lt;/p&gt;&#xA;&lt;p&gt;set guifont=Courier_New:h10:cANSI   &amp;quot; 设置字体&lt;/p&gt;&#xA;&lt;p&gt;syntax on           &amp;quot; 语法高亮&lt;/p&gt;&#xA;&lt;p&gt;autocmd InsertLeave * se nocul  &amp;quot; 用浅色高亮当前行&lt;/p&gt;&#xA;&lt;p&gt;autocmd InsertEnter * se cul    &amp;quot; 用浅色高亮当前行&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;set ruler           &amp;quot; 显示标尺&lt;/p&gt;&#xA;&lt;p&gt;set showcmd         &amp;quot; 输入的命令显示出来，看的清楚些&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;set cmdheight=1     &amp;quot; 命令行（在状态行下）的高度，设置为1&lt;/p&gt;</description>
    </item>
    <item>
      <title>更好的 zsh 配置</title>
      <link>http://localhost:1313/en/post/2025/01/ssh_config_best/</link>
      <pubDate>Tue, 07 Jan 2025 13:33:19 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/ssh_config_best/</guid>
      <description>&lt;h1 id=&#34;zsh-配置&#34;&gt;zsh 配置&lt;/h1&gt;&#xA;&lt;h2 id=&#34;安装-oh-my-zsh&#34;&gt;安装 oh my zsh&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sh -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;配置 &lt;code&gt;.zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&#xA;# If you come from bash you might have to change your $PATH.&#xA;# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH&#xA;&#xA;# Path to your Oh My Zsh installation.&#xA;export ZSH=&amp;#34;$HOME/.oh-my-zsh&amp;#34;&#xA;&#xA;# Set name of the theme to load --- if set to &amp;#34;random&amp;#34;, it will&#xA;# load a random theme each time Oh My Zsh is loaded, in which case,&#xA;# to know which specific one was loaded, run: echo $RANDOM_THEME&#xA;# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&#xA;# ZSH_THEME=&amp;#34;robbyrussell&amp;#34;&#xA;ZSH_THEME=&amp;#34;amuse&amp;#34;&#xA;# theme:&#xA;# git: xiong-chiamiov-plus amuse powerlevel10k&#xA;# time: crunch&#xA;&#xA;# Set list of themes to pick from when loading at random&#xA;# Setting this variable when ZSH_THEME=random will cause zsh to load&#xA;# a theme from this variable instead of looking in $ZSH/themes/&#xA;# If set to an empty array, this variable will have no effect.&#xA;# ZSH_THEME_RANDOM_CANDIDATES=( &amp;#34;robbyrussell&amp;#34; &amp;#34;agnoster&amp;#34; )&#xA;&#xA;# Uncomment the following line to use case-sensitive completion.&#xA;# CASE_SENSITIVE=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line to use hyphen-insensitive completion.&#xA;# Case-sensitive completion must be off. _ and - will be interchangeable.&#xA;# HYPHEN_INSENSITIVE=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment one of the following lines to change the auto-update behavior&#xA;# zstyle &amp;#39;:omz:update&amp;#39; mode disabled  # disable automatic updates&#xA;# zstyle &amp;#39;:omz:update&amp;#39; mode auto      # update automatically without asking&#xA;# zstyle &amp;#39;:omz:update&amp;#39; mode reminder  # just remind me to update when it&amp;#39;s time&#xA;&#xA;# Uncomment the following line to change how often to auto-update (in days).&#xA;# zstyle &amp;#39;:omz:update&amp;#39; frequency 13&#xA;&#xA;# Uncomment the following line if pasting URLs and other text is messed up.&#xA;# DISABLE_MAGIC_FUNCTIONS=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line to disable colors in ls.&#xA;# DISABLE_LS_COLORS=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line to disable auto-setting terminal title.&#xA;# DISABLE_AUTO_TITLE=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line to enable command auto-correction.&#xA;# ENABLE_CORRECTION=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line to display red dots whilst waiting for completion.&#xA;# You can also set it to another string to have that shown instead of the default red dots.&#xA;# e.g. COMPLETION_WAITING_DOTS=&amp;#34;%F{yellow}waiting...%f&amp;#34;&#xA;# Caution: this setting can cause issues with multiline prompts in zsh &amp;lt; 5.7.1 (see #5765)&#xA;# COMPLETION_WAITING_DOTS=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line if you want to disable marking untracked files&#xA;# under VCS as dirty. This makes repository status check for large repositories&#xA;# much, much faster.&#xA;# DISABLE_UNTRACKED_FILES_DIRTY=&amp;#34;true&amp;#34;&#xA;&#xA;# Uncomment the following line if you want to change the command execution time&#xA;# stamp shown in the history command output.&#xA;# You can set one of the optional three formats:&#xA;# &amp;#34;mm/dd/yyyy&amp;#34;|&amp;#34;dd.mm.yyyy&amp;#34;|&amp;#34;yyyy-mm-dd&amp;#34;&#xA;# or set a custom format using the strftime function format specifications,&#xA;# see &amp;#39;man strftime&amp;#39; for details.&#xA;# HIST_STAMPS=&amp;#34;mm/dd/yyyy&amp;#34;&#xA;&#xA;# Would you like to use another custom folder than $ZSH/custom?&#xA;# ZSH_CUSTOM=/path/to/new-custom-folder&#xA;&#xA;# Which plugins would you like to load?&#xA;# Standard plugins can be found in $ZSH/plugins/&#xA;# Custom plugins may be added to $ZSH_CUSTOM/plugins/&#xA;# Example format: plugins=(rails git textmate ruby lighthouse)&#xA;# Add wisely, as too many plugins slow down shell startup.&#xA;plugins=(&#xA;  git&#xA;  extract&#xA;  autojump&#xA;  zsh-autosuggestions&#xA;  zsh-syntax-highlighting&#xA;)&#xA;&#xA;source $ZSH/oh-my-zsh.sh&#xA;&#xA;# User configuration&#xA;&#xA;# export MANPATH=&amp;#34;/usr/local/man:$MANPATH&amp;#34;&#xA;&#xA;# You may need to manually set your language environment&#xA;# export LANG=en_US.UTF-8&#xA;&#xA;export EDITOR=&amp;#39;vim&amp;#39;&#xA;&#xA;# Preferred editor for local and remote sessions&#xA;# if [[ -n $SSH_CONNECTION ]]; then&#xA;#   export EDITOR=&amp;#39;vim&amp;#39;&#xA;# else&#xA;#   export EDITOR=&amp;#39;nvim&amp;#39;&#xA;# fi&#xA;&#xA;# Compilation flags&#xA;# export ARCHFLAGS=&amp;#34;-arch $(uname -m)&amp;#34;&#xA;&#xA;# Set personal aliases, overriding those provided by Oh My Zsh libs,&#xA;# plugins, and themes. Aliases can be placed here, though Oh My Zsh&#xA;# users are encouraged to define aliases within a top-level file in&#xA;# the $ZSH_CUSTOM folder, with .zsh extension. Examples:&#xA;# - $ZSH_CUSTOM/aliases.zsh&#xA;# - $ZSH_CUSTOM/macos.zsh&#xA;# For a full list of active aliases, run `alias`.&#xA;#&#xA;# Example aliases&#xA;# alias zshconfig=&amp;#34;mate ~/.zshrc&amp;#34;&#xA;# alias ohmyzsh=&amp;#34;mate ~/.oh-my-zsh&amp;#34;&#xA;&#xA;&#xA;# IDEA path&#xA;#&#xA;&#xA;# PATH env&#xA;source &amp;#34;$HOME/.cargo/env&amp;#34;&#xA;# for autojump https://github.com/wting/autojump&#xA;[ -f /opt/homebrew/etc/profile.d/autojump.sh ] &amp;amp;&amp;amp; . /opt/homebrew/etc/profile.d/autojump.sh&#xA;&#xA;# fnm&#xA;# fnm&#xA;FNM_PATH=&amp;#34;$HOME/.local/share/fnm&amp;#34;&#xA;if [ -d &amp;#34;$FNM_PATH&amp;#34; ]; then&#xA;  export PATH=&amp;#34;$FNM_PATH:$PATH&amp;#34;&#xA;  eval &amp;#34;`fnm env`&amp;#34;&#xA;fi&#xA;&#xA;# IDEA path&#xA;export PATH=&amp;#34;/Applications/IntelliJ IDEA CE.app/Contents/MacOS:$PATH&amp;#34;&#xA;export PATH=&amp;#34;/opt/homebrew/opt/dotnet@6/bin:$PATH&amp;#34;&#xA;export PATH=&amp;#34;/home/simons/.local/bin:$PATH&amp;#34;&#xA;export PATH=&amp;#34;/Users/simons/.yarn/bin:/Users/simons/.config/yarn/global:$PATH&amp;#34;&#xA;&#xA;# pnpm&#xA;export PNPM_HOME=&amp;#34;/Users/simons/Library/pnpm&amp;#34;&#xA;case &amp;#34;:$PATH:&amp;#34; in&#xA;  *&amp;#34;:$PNPM_HOME:&amp;#34;*) ;;&#xA;  *) export PATH=&amp;#34;$PNPM_HOME:$PATH&amp;#34; ;;&#xA;esac&#xA;# pnpm end&#xA;#&#xA;#&#xA;&#xA;# poetry&#xA;export PATH=&amp;#34;$HOME/.local/bin:$PATH&amp;#34;&#xA;&#xA;# go&#xA;export PATH=&amp;#34;$PATH:$GOPATH/bin&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;配置-github&#34;&gt;配置 Github&lt;/h1&gt;&#xA;&lt;h2 id=&#34;生成密钥对&#34;&gt;生成密钥对&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# 生成一对 SSH 密钥&#xA;ssh-keygen -t ed25519 -C &amp;#34;your_email@example.com&amp;#34; # 输入邮箱&#xA;# 启动 SSH 代理，用于管理 SSH 密钥&#xA;eval &amp;#34;$(ssh-agent -s)&amp;#34;&#xA;# 将 SSH 私钥添加到 SSH 代理&#xA;ssh-add ~/.ssh/id_ed25519&#xA;# 显示公钥内容&#xA;cat ~/.ssh/id_ed25519.pub&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;配置-ssh-密钥&#34;&gt;配置 SSH 密钥：&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将公钥内容复制并添加到 GitHub 的 SSH 密钥设置中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Wasm</title>
      <link>http://localhost:1313/en/post/2025/01/wasm/</link>
      <pubDate>Sun, 05 Jan 2025 12:41:17 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2025/01/wasm/</guid>
      <description>&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cargo build&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;webassembly-核心技术剖析&#34;&gt;WebAssembly 核心技术剖析&lt;/h1&gt;&#xA;&lt;p&gt;让我用一个具体场景开始：你正在用 JavaScript 开发一个视频编码器，却发现即使用上了 Web Worker，处理 4K 视频时依然卡得厉害。为什么？问题出在哪里？&lt;/p&gt;&#xA;&lt;h2 id=&#34;深入理解-wasm-的本质&#34;&gt;深入理解 WASM 的本质&lt;/h2&gt;&#xA;&lt;p&gt;首先，我们需要理解 WASM 的核心 - 它的内存模型和执行模型。&lt;/p&gt;&#xA;&lt;h3 id=&#34;内存模型解析&#34;&gt;内存模型解析&lt;/h3&gt;&#xA;&lt;p&gt;让我们看一段具体代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;cpp&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-cpp&#34;&gt;// C&amp;#43;&amp;#43; 代码&#xA;int* buffer = new int[1024];  // 分配4KB内存&#xA;buffer[0] = 42;&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;编译成 WASM 后：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 最佳实践</title>
      <link>http://localhost:1313/en/post/2024/12/go/</link>
      <pubDate>Sun, 29 Dec 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/12/go/</guid>
      <description>&lt;p&gt;在 Go 项目架构中，有一些重要的设计原则和规则。我来详细说明：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;接口定义规则：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：接口定义在使用方(调用方)包中&#xA;package handler&#xA;type UserService interface {&#xA;    Create(ctx context.Context, user *User) error&#xA;}&#xA;&#xA;// ❌ 错误：接口定义在实现方包中&#xA;package service&#xA;type UserService interface {&#xA;    Create(ctx context.Context, user *User) error&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;依赖方向：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确的依赖方向&#xA;handler -&amp;gt; service -&amp;gt; repository -&amp;gt; database&#xA;&#xA;// ❌ 错误：不应该出现反向依赖&#xA;service -&amp;gt; handler&#xA;repository -&amp;gt; service&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;数据模型定义：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：每层使用自己的数据模型&#xA;package handler&#xA;type CreateUserRequest struct {  // API层模型&#xA;    Username string `json:&amp;#34;username&amp;#34;`&#xA;}&#xA;&#xA;package service&#xA;type UserDTO struct {  // 业务层模型&#xA;    ID       uint64&#xA;    Username string&#xA;}&#xA;&#xA;package repository&#xA;type UserDO struct {  // 数据层模型&#xA;    ID        uint64 `gorm:&amp;#34;primaryKey&amp;#34;`&#xA;    Username  string&#xA;    CreatedAt time.Time&#xA;}&#xA;&#xA;// ❌ 错误：直接在所有层使用相同的模型&#xA;type User struct {&#xA;    ID        uint64 `json:&amp;#34;id&amp;#34; gorm:&amp;#34;primaryKey&amp;#34;`&#xA;    Username  string `json:&amp;#34;username&amp;#34;`&#xA;    CreatedAt time.Time `json:&amp;#34;created_at&amp;#34;`&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;错误处理层级：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：每层对错误进行适当包装&#xA;package repository&#xA;func (r *UserRepo) Create(user *UserDO) error {&#xA;    return fmt.Errorf(&amp;#34;database error: %w&amp;#34;, err)&#xA;}&#xA;&#xA;package service&#xA;func (s *UserService) Create(user *UserDTO) error {&#xA;    return fmt.Errorf(&amp;#34;business error: %w&amp;#34;, err)&#xA;}&#xA;&#xA;package handler&#xA;func (h *UserHandler) Create(c *gin.Context) {&#xA;    if err := h.service.Create(user); err != nil {&#xA;        c.JSON(getErrorStatus(err), ErrorResponse{err.Error()})&#xA;        return&#xA;    }&#xA;}&#xA;&#xA;// ❌ 错误：直接暴露底层错误&#xA;if err := db.Create(&amp;amp;user).Error; err != nil {&#xA;    c.JSON(500, err.Error())&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;包的组织：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-&#34; data-lang=&#34;&#34;&gt;✅ 正确的包组织：&#xA;project/&#xA;  ├── api/&#xA;  │   └── handler/       # HTTP 处理层&#xA;  ├── internal/&#xA;  │   ├── service/      # 业务逻辑层&#xA;  │   ├── repository/   # 数据访问层&#xA;  │   └── model/        # 内部数据模型&#xA;  ├── pkg/&#xA;  │   └── util/         # 公共工具函数&#xA;  └── main.go&#xA;&#xA;❌ 错误的包组织：&#xA;project/&#xA;  ├── handlers/&#xA;  ├── services/&#xA;  ├── models/&#xA;  └── main.go&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;依赖注入：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：通过构造函数注入依赖&#xA;func NewUserHandler(service UserService) *UserHandler {&#xA;    return &amp;amp;UserHandler{service: service}&#xA;}&#xA;&#xA;// ❌ 错误：全局变量或直接初始化&#xA;var userService = &amp;amp;UserService{}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;接口隔离：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：小接口，职责单一&#xA;type UserReader interface {&#xA;    GetUser(id uint64) (*User, error)&#xA;}&#xA;&#xA;type UserWriter interface {&#xA;    CreateUser(user *User) error&#xA;}&#xA;&#xA;// ❌ 错误：大接口，职责过多&#xA;type UserService interface {&#xA;    GetUser(id uint64) (*User, error)&#xA;    CreateUser(user *User) error&#xA;    UpdateUser(user *User) error&#xA;    DeleteUser(id uint64) error&#xA;    ListUsers() ([]*User, error)&#xA;    SearchUsers(query string) ([]*User, error)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;配置管理：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：集中管理配置&#xA;package config&#xA;&#xA;type Config struct {&#xA;    Server ServerConfig&#xA;    DB     DatabaseConfig&#xA;    Redis  RedisConfig&#xA;}&#xA;&#xA;// ❌ 错误：分散的配置或硬编码&#xA;var serverPort = 8080&#xA;var dbConnection = &amp;#34;root:password@tcp(localhost:3306)/db&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;9&#34;&gt;&#xA;&lt;li&gt;上下文传递：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：统一使用 context 传递请求上下文&#xA;func (h *Handler) Create(c *gin.Context) {&#xA;    ctx := c.Request.Context()&#xA;    err := h.service.Create(ctx, req)&#xA;}&#xA;&#xA;// ❌ 错误：不传递上下文或使用不一致的上下文&#xA;func (h *Handler) Create(c *gin.Context) {&#xA;    err := h.service.Create(req)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;ol start=&#34;10&#34;&gt;&#xA;&lt;li&gt;测试组织：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;go&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-go&#34;&gt;// ✅ 正确：测试文件与源文件对应&#xA;package handler&#xA;&#xA;func TestUserHandler_Create(t *testing.T) {&#xA;    // 单元测试&#xA;}&#xA;&#xA;// ❌ 错误：测试代码与源码混合或测试覆盖不全&#xA;func TestAll(t *testing.T) {&#xA;    // 混合测试多个功能&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;遵循这些规则可以使代码：&lt;/p&gt;</description>
    </item>
    <item>
      <title>shell mac 教程</title>
      <link>http://localhost:1313/en/post/2024/11/shell_mac_pop/</link>
      <pubDate>Sat, 09 Nov 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/11/shell_mac_pop/</guid>
      <description>&lt;p&gt;&#xA;&lt;a href=&#34;https://juejin.cn/post/6921144388802641933&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   原文&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-as&#34; data-lang=&#34;as&#34;&gt;#!/bin/bash&#xA;&#xA;# 1. 自定义通知消息&#xA;# 传参 $1:消息描述 $2:通知标题 $3:通知副标题&#xA;function showNoteMessage(){&#xA;  osascript -e &amp;#34;display notification \&amp;#34;${1}\&amp;#34; with title \&amp;#34;${2}\&amp;#34; subtitle \&amp;#34;${3}\&amp;#34; sound name \&amp;#34;Funk\&amp;#34;&amp;#34;&#xA;}&#xA;#test case:&#xA;#showNoteMessage &amp;#34;消息内容&amp;#34; &amp;#34;通知&amp;#34; &amp;#34;通知副标题&amp;#34;&#xA;&#xA;# 2. 自定义弹窗(统一通用方法)&#xA;# 传参$1 弹窗消息内容&#xA;# 传参$2 弹窗标题&#xA;# 传参$3 按钮标题,多个用英文逗号隔开&#xA;# 传参$4 默认选中的按钮标题或者按钮数字下标&#xA;# 传参$5 是否为输入框类型 传&amp;#34;0&amp;#34;或者&amp;#34;1&amp;#34; 默认&amp;#34;0&amp;#34;&#xA;# 传参$6 输入框默认占位内容,传不传无所谓,默认为空字符串 &amp;#34;&amp;#34;&#xA;# 传参$7 默认图标note/stop/caution 或者自定义文件路径(:格式路径可以通过choose file获取)&#xA;# tips: 重要! 如果为输入框模式,那么输出结果就是{button returned:button,text returned:text} 否则只有按钮或者false&#xA;function showCustomAlertMessage(){&#xA;&#xA;if [[ -n &amp;#34;$4&amp;#34; ]]; then&#xA;&#xA;&#x9;if [[ ${4} == *[!0-9]* ]]; then&#xA;     &#x9;defaultButton=&amp;#34;default button \&amp;#34;${4}\&amp;#34;&amp;#34;&#xA;     &#x9;else&#xA;     &#x9;defaultButton=&amp;#34;default button ${4}&amp;#34;&#xA;&#x9;fi&#xA;else&#xA;&#x9;defaultButton=&amp;#34;&amp;#34;&#xA;fi&#xA;&#xA;#是否为输入框模式&#xA;if [[ &amp;#34;$5&amp;#34; = &amp;#34;1&amp;#34; ]]; then&#xA;&#x9;IS_InputMode=&amp;#34;default answer \&amp;#34;${6}\&amp;#34;&amp;#34;&#xA;&#x9;ReturnValue=&amp;#34;get result&amp;#34;&#xA;else&#xA;&#x9;IS_InputMode=&amp;#34;&amp;#34;&#xA;&#x9;ReturnValue=&amp;#34;get the button returned of the result&amp;#34;&#xA;fi&#xA;&#xA;if [[ -n &amp;#34;$7&amp;#34; ]]; then&#xA;  case ${7} in&#xA;&#x9;note)&#xA;&#x9;ICON=&amp;#34;with icon note&amp;#34;&#xA;&#x9;;;&#xA;&#x9;stop)&#xA;&#x9;ICON=&amp;#34;with icon stop&amp;#34;&#xA;&#x9;;;&#xA;&#x9;caution)&#xA;&#x9;ICON=&amp;#34;with icon caution&amp;#34;&#xA;&#x9;;;&#xA;&#x9;*)&#xA;&#x9;ICON=&amp;#34;with icon file \&amp;#34;${7}\&amp;#34;&amp;#34;&#xA;&#x9;;;&#xA; esac&#xA;else&#xA; ICON=&amp;#34;with icon file \&amp;#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\&amp;#34;&amp;#34;&#xA;fi&#xA;&#xA;osascript &amp;lt;&amp;lt;EOF&#xA;&#x9;set buttonStr to &amp;#34;${3}&amp;#34;&#xA;&#x9;set oldDelimiters to AppleScript&amp;#39;s text item delimiters&#xA;&#x9;set AppleScript&amp;#39;s text item delimiters to &amp;#34;,&amp;#34;&#xA;&#x9;set buttonList to every text item of buttonStr&#xA;&#x9;set AppleScript&amp;#39;s text item delimiters to oldDelimiters&#xA;&#x9;get buttonList&#xA;&#x9;set btns to buttonList&#xA;&#x9;display dialog &amp;#34;${1}&amp;#34; with title &amp;#34;${2}&amp;#34; buttons btns ${IS_InputMode} ${defaultButton} ${ICON}&#xA;&#x9;${ReturnValue}&#xA;EOF&#xA;}&#xA;&#xA;# showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34;  &amp;#34;1&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;note&amp;#34;&#xA;# showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; 2  &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;note&amp;#34;&#xA;#showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;stop&amp;#34;&#xA;#showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns&amp;#34;&#xA;&#xA;# 普通弹窗 一个ok就够了 就是一个确认的那种&#xA;function onlyConfirmButton(){&#xA;&#x9;showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;温馨提示&amp;#34; &amp;#34;好的&amp;#34; 1&#xA;}&#xA;#onlyConfirmButton &amp;#34;登录成功!\n弹窗成功!&amp;#34;&#xA;&#xA;# 多按钮弹窗 最多三个按钮 多了会报错&#xA;function mostButtons(){&#xA;&#x9;showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;温馨提示&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮3&amp;#34;&#xA;}&#xA;#mostButtons &amp;#34;最多只能定义三个按钮哦&amp;#34;&#xA;&#xA;# 输入框弹窗&#xA;function showInputAlertMessage(){&#xA;&#x9;showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;$2&amp;#34; &amp;#34;取消,确认&amp;#34; 2 &amp;#34;1&amp;#34; &amp;#34;&amp;#34;&#xA;}&#xA;showInputAlertMessage &amp;#34;请输入密码&amp;#34; &amp;#34;登录验证&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>C 语言字符画</title>
      <link>http://localhost:1313/en/post/2024/06/c_shar/</link>
      <pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/06/c_shar/</guid>
      <description>&lt;blockquote&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;3&#xA;* * *&#xA;*   *&#xA;* * *&#xA;&#xA;4&#xA;* * * *&#xA;*     *&#xA;*     *&#xA;* * * *&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非多组输入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;//行定位&#xA;int main() {&#xA;    int n = 0;&#xA;    scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);&#xA;    for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {&#xA;        if (i == 0 || i == n - 1) {//首尾行输出一行*&#xA;            for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {&#xA;                printf(&amp;#34;* &amp;#34;);&#xA;            }&#xA;        } else {&#xA;            for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//其它行首尾输出*&#xA;                if(j==0 || j == n-1)&#xA;                    printf(&amp;#34;* &amp;#34;);&#xA;                else&#xA;                    printf(&amp;#34;  &amp;#34;);&#xA;            }&#xA;        }&#xA;        printf(&amp;#34;\n&amp;#34;);//换行&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;// 3 ---- n&#xA;// * * *  --- 1行每个位置都输出 一共n个&#xA;// *   *  --- 其它行1和n位置输出 一共2个&#xA;// * * *  --- n行每个位置都输出 一共n个&#xA;// 思路：&#xA;// 使用for 和 if&#xA;// 判断是不吃首尾行 是则输出一行* 不是则输出首尾*&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多组输入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;//行和列定位&#xA;int main() {&#xA;    int n = 0;&#xA;    while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) == 1){//输入的数量为1&#xA;        for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {//控制行&#xA;            for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//控制列&#xA;                if(i == 0 || i == n-1 || j == 0 || j == n-1)//第0行，第n-1行，第0列，第n-1列输出 *_,其它位置输出 __&#xA;                    printf(&amp;#34;* &amp;#34;);&#xA;                else&#xA;                    printf(&amp;#34;  &amp;#34;);&#xA;            }&#xA;            printf(&amp;#34;\n&amp;#34;);&#xA;        }&#xA;    }&#xA;    return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>如何生成 dll 文件</title>
      <link>http://localhost:1313/en/post/2024/06/dl/</link>
      <pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/06/dl/</guid>
      <description>&lt;h1 id=&#34;如何生成-dll文件&#34;&gt;如何生成 .dll文件&lt;/h1&gt;&#xA;&lt;p&gt;生成dll文件同时会生成lib文件&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在VS开始界面，搜索dll，创建dll动态链接库&lt;/li&gt;&#xA;&lt;li&gt;创建一个类（右键创建类，会自动包含需要的文件） 以查询目录下的文件为例&#xA;创建的文件可以不用管&#xA;&lt;code&gt;.cpp&lt;/code&gt;文件 输入自己的代码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;code-playground&#34; data-language=&#34;cpp&#34;&gt;&#xA;    &#xA;    &lt;div&gt;&#xA;        &lt;pre&gt;&#xA;                &lt;code class=&#34;language-cpp&#34;&gt;#include &amp;#34;pch.h&amp;#34;&#xA;#include &amp;#34;check_repository.h&amp;#34;&#xA;namespace fs = std::filesystem;&#xA;    int Check::CheckRepository() {&#xA;        std::string folderName = &amp;#34;.Rysigy&amp;#34;;&#xA;        fs::path currentPath = fs::current_path();&#xA;        fs::path folderPath = currentPath / folderName;&#xA;&#xA;        if (fs::exists(folderPath) &amp;amp;&amp;amp; fs::is_directory(folderPath)) {&#xA;            std::cout &amp;lt;&amp;lt; &amp;#34;存储库 &amp;#39;.Rysigy&amp;#39; 文件夹存在\n&amp;#34; &amp;lt;&amp;lt; std::endl;&#xA;        }&#xA;        else {&#xA;            std::cout &amp;lt;&amp;lt; &amp;#34;[错误]\t存储库 &amp;#39;.Rysigy&amp;#39; 文件夹不存在\n请在右键菜单中点击 &amp;#39;创建存储库&amp;#39;\n&amp;#34; &amp;lt;&amp;lt; std::endl;&#xA;        }&#xA;        std::cout &amp;lt;&amp;lt; &amp;#34;点击任意按键退出...&amp;#34; &amp;lt;&amp;lt; std::endl;&#xA;        _getch();&#xA;        return 0;&#xA;};&lt;/code&gt;&lt;/pre&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;    &#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;.h&lt;/code&gt;文件&lt;/p&gt;</description>
    </item>
    <item>
      <title>删除错误提交到GitHub仓库中的文件</title>
      <link>http://localhost:1313/en/post/2024/06/git_delete_file/</link>
      <pubDate>Wed, 19 Jun 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/06/git_delete_file/</guid>
      <description>&lt;p&gt;如果你需要删除错误提交到GitHub仓库中的文件，你可以通过以下步骤来创建一个新的提交来撤销之前的更改：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;在本地仓库中删除文件&lt;/strong&gt;：&#xA;首先，在你的本地仓库中删除该文件：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;这里 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 是你想要从仓库中删除的文件名。&lt;code&gt;--cached&lt;/code&gt; 参数意味着仅从Git的跟踪中删除文件，而不删除工作目录中的文件。&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86 教程</title>
      <link>http://localhost:1313/en/post/2024/05/x86/</link>
      <pubDate>Thu, 02 May 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/05/x86/</guid>
      <description>&lt;p&gt;作者： &#xA;&lt;a href=&#34;http://www.ruanyifeng.com/&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   阮一峰&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;日期： &#xA;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2018/01/&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   2018年1月21日&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;学习编程其实就是学高级语言，即那些为人类设计的计算机语言。&lt;/p&gt;&#xA;&lt;p&gt;但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/bg2018012204.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。&lt;/p&gt;</description>
    </item>
    <item>
      <title>SQL 教程</title>
      <link>http://localhost:1313/en/post/2024/04/sql/</link>
      <pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/04/sql/</guid>
      <description>&lt;p style=color:red;&gt; 在idea中分号并不是必须加的, 在执行多条语句才必须加, 在控制台使用的时候必须加&lt;p&gt;&#xA;&lt;h1 id=&#34;数据库相关的操作&#34;&gt;数据库相关的操作&lt;/h1&gt;&#xA;&lt;p&gt;查询数据库&#x9; &lt;code&gt;SHOW DATABASES&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;创建数据库&#xA;&lt;code&gt;CREATE DATABASE 数据库名&lt;/code&gt;&#xA;&lt;code&gt;CREATE DATABASE mydatabase&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;查看数据库信息&#xA;&lt;code&gt;SHOW CREATE DATABASE 数据库名&lt;/code&gt;&#xA;&lt;code&gt;SHOW CREATE DATABASE database&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;删除数据库&#xA;&lt;code&gt;DROP DATABASE 数据库名&lt;/code&gt;&#xA;&lt;code&gt;DROP DATABASE mydatabase&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用数据库&#xA;&lt;code&gt;USE 数据库名&lt;/code&gt;&#xA;&lt;code&gt;USE mydatabase&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;ddl语句-数据定义语言&#34;&gt;DDL语句&#x9; 数据定义语言&lt;/h1&gt;&#xA;&lt;p&gt;创建表&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;CREATE TABLE 表名(&#xA;   列名1 类型[长度] [DEFAULT 默认值] [约束条件]&#xA;   列名2 类型&#xA;   ……&#xA;);&#xA;&#xA;CREATE TABLE userinfo(&#xA;   id INT&#xA;   username VARCHAR(32)&#xA;   password VARCHAR(32)&#xA;   nickname VARCHAR(32)&#xA;   age INT(3)&#xA;);&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;查看当前数据库创建的所有表&#xA;&lt;code&gt;SHOW TABLES;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>什么是 SimHash</title>
      <link>http://localhost:1313/en/post/2024/04/simhash/</link>
      <pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/04/simhash/</guid>
      <description>&lt;h1 id=&#34;一什么是simhash&#34;&gt;一、什么是SimHash&lt;/h1&gt;&#xA;&lt;p&gt;SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。&lt;/p&gt;&#xA;&lt;p&gt;对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。&#xA;比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JWT 解析</title>
      <link>http://localhost:1313/en/post/2024/04/jwt/</link>
      <pubDate>Fri, 12 Apr 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/04/jwt/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;&#34; alt=&#34;JWT&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/86937325&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   原文一&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/weixin_39779004/article/details/110801387&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   原文二&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://b23.tv/3f7Yrct&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   视频&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;h1 id=&#34;一什么是-jwt&#34;&gt;一、什么是 JWT&lt;/h1&gt;&#xA;&lt;p&gt;JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。&lt;/p&gt;&#xA;&lt;h1 id=&#34;二设计目标&#34;&gt;二、设计目标&lt;/h1&gt;&#xA;&lt;p&gt;不需要服务器端存储状态，安全地传递非敏感信息&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/OIP-C-20240424140338352.jpeg&#34; alt=&#34;JWT认证方案讲解-阿里云开发者社区&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;三-json-web-token-的结构是什么样的&#34;&gt;三、 JSON Web Token 的结构是什么样的&lt;/h1&gt;&#xA;&lt;p&gt;JSON Web Token由三部分组成，例如&lt;code&gt;dafdsafdwfefeqwad.oijhdaffweqtgfdhfdws.dhshfsghhhhhwfsdke&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Quartz 教程</title>
      <link>http://localhost:1313/en/post/2024/02/quartz/</link>
      <pubDate>Thu, 29 Feb 2024 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2024/02/quartz/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://quartz.jzhao.xyz&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   原作者&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;a href=&#34;https://www.chyraw.com&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   个人配置&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;下载&#34;&gt;下载&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/caoyang2002/quartz-obsidian-webside.git&#xA;cd quartz-obsidian-webside&#xA;npm i&#xA;npx quartz build --serve&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;&#xA;&lt;h2 id=&#34;布局&#34;&gt;布局&lt;/h2&gt;&#xA;&lt;p&gt;某些 emitters 可能还会输出HTML文件。为了方便定制，这些 emitters 允许您完全重新排列页面的布局。&#xA;默认页面布局可以在 &lt;code&gt;quartz.layout.ts&lt;/code&gt; 中找到。&lt;/p&gt;&#xA;&lt;p&gt;每个页面由多个不同的部分组成，这些部分包含 &lt;code&gt;QuartzComponents&lt;/code&gt;。以下代码片段列出了您可以向其中添加组件的所有有效部分：&lt;/p&gt;</description>
    </item>
    <item>
      <title>群晖开发</title>
      <link>http://localhost:1313/en/post/2023/08/synology/</link>
      <pubDate>Tue, 29 Aug 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/08/synology/</guid>
      <description>&lt;p&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/christmans/article/details/129641264&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   原文链接&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;h1 id=&#34;查看-cpu-架构&#34;&gt;查看 CPU 架构&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;uname -m：该命令会输出当前系统的CPU架构，如x86_64、i386、armv7l等。&#xA;arch：该命令可以查看Linux系统的CPU架构。&#xA;cat /proc/version：该命令可以查看系统内核的版本信息。&#xA;cat /proc/cpuinfo：该命令可以查看CPU信息，如每个物理CPU中core的个数、逻辑CPU的个数、CPU型号等。&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;http://ipkg.nslu2-linux.org/optware-ng/bootstrap/&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   脚本目录&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>浮点数的存储</title>
      <link>http://localhost:1313/en/post/2023/07/float_at_mem/</link>
      <pubDate>Sat, 29 Jul 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/07/float_at_mem/</guid>
      <description>&lt;h1 id=&#34;浮点数的存储&#34;&gt;浮点数的存储&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;IEEE745 国际标准：&lt;/p&gt;&#xA;&lt;p&gt;任意一个二进制的浮点数可以表示为下面的形式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;V = (-1)^s^ * M * 2^E^&lt;/li&gt;&#xA;&lt;li&gt;(-1)^s^表示符号位，当S=0的时候V为正数，当S=1的时候V为负数&lt;/li&gt;&#xA;&lt;li&gt;M表示有效数字，大于等于1，小于2;   1&amp;lt;= M &amp;lt;2&lt;/li&gt;&#xA;&lt;li&gt;2^E^：E表示指数位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;科学计数法：123.45 = 1.2345 * 10^2^&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;V = 5.0 f&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;二进制：101.0&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;科学计数法：1.01 * 2^2^&lt;/p&gt;</description>
    </item>
    <item>
      <title>函数栈帧的创建和销毁</title>
      <link>http://localhost:1313/en/post/2023/07/function_stack/</link>
      <pubDate>Sat, 15 Jul 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/07/function_stack/</guid>
      <description>&lt;p&gt;&lt;code&gt;C/C++&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;函数栈帧的创建和销毁&lt;/p&gt;&#xA;&lt;p&gt;在学习最基础的C语言程序的语法与使用时，但你是否有疑问？&lt;/p&gt;&#xA;&lt;p&gt;比如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;函数的作用域是怎么形成的呢？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;局部变量是如何创建的？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为什么未初始化的局部变量的值是随机值或是乱码呢？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;函数是如何传参的？&lt;/p&gt;&#xA;&lt;p&gt;传参的顺序又是怎么样的呢？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;形参和实参的关系是什么？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;函数的调用是怎么实现的呢？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;函数调用结束后是怎么返回的呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>C 语言数学</title>
      <link>http://localhost:1313/en/post/2023/06/c_number/</link>
      <pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/06/c_number/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;暴力算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;时间复杂度过大&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;malloc/_malloc.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;errno.h&amp;gt;&#xA;// 最大公约数&#xA;// 最小公倍数&#xA;//计算最小公倍数和最大公约数的和&#xA;int main(){&#xA;    int n = 0;&#xA;    int m = 0;&#xA;    while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m) == 2){//读取两个数&#xA;        int min = n &amp;lt; m ? n : m;&#xA;        int max = n &amp;gt; m ? n : m;&#xA;        int i = min;//最大公约数&#xA;        int j = max;//最小公倍数&#xA;        while(1){&#xA;            if(n%i == 0 &amp;amp;&amp;amp; m%i == 0){&#xA;                break;&#xA;            }&#xA;            i--;&#xA;        }&#xA;        // i就是最大公约数&#xA;        while(1){&#xA;            if(j%n == 0 &amp;amp;&amp;amp; j%m == 0){&#xA;                break;&#xA;            }&#xA;            j&amp;#43;&amp;#43;;&#xA;        }&#xA;        // j就是最大公倍数&#xA;&#xA;        printf(&amp;#34;最大公倍数 %d &amp;#43; 最小公约数 %d = %d\n&amp;#34;,j,i,j&amp;#43;i);&#xA;    }&#xA;    return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;辗转相除法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;两个数的&lt;em&gt;&lt;strong&gt;最大公约数&lt;/strong&gt;&lt;/em&gt;等于其中较小的数字和二者之间余数的最大公约数&lt;/p&gt;</description>
    </item>
    <item>
      <title>C 语言结构体</title>
      <link>http://localhost:1313/en/post/2023/06/c_struct/</link>
      <pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/06/c_struct/</guid>
      <description>&lt;h1 id=&#34;结构体内存对齐&#34;&gt;结构体内存对齐&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div&gt;&#xA;    &lt;pre&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;struct S1{&#xA;    char c1;//1&#xA;    int i;//4&#xA;    char c2;//1&#xA;};&#xA;&#xA;struct S2{&#xA;    char c1;//1&#xA;    char c2;//1&#xA;    int i;//4&#xA;};&#xA;int main(){&#xA;    printf(&amp;#34;%d\n&amp;#34;,sizeof(struct S1));//12&#xA;    printf(&amp;#34;%d\n&amp;#34;,sizeof(struct S2));//8&#xA;    return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;对齐规则：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;第一个成员在与结构体变量偏移量为0的地址处&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处&#xA;对齐数 = 编译默认的一个对齐数与该成员大小的&lt;strong&gt;较小值&lt;/strong&gt;。    vs中默认是8&lt;/p&gt;&#xA;&lt;p&gt;(即：第二个成员和编译器的默认对齐数比较大小,第三个成员和编译器的默认对齐数比较大小,第四个成员和编译器的默认对齐数比较大小&amp;hellip;..)&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 命名规范</title>
      <link>http://localhost:1313/en/post/2023/05/cpp_named/</link>
      <pubDate>Mon, 29 May 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/05/cpp_named/</guid>
      <description>&lt;p&gt;&#xA;&lt;a href=&#34;https://codeif.xinke.org.cn&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   codeif&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;h1 id=&#34;文件命名&#34;&gt;文件命名&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;所有文件&lt;/p&gt;&#xA;&lt;p&gt;头文件和原文件成对出现&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;全部小写, 可是使用下划线&amp;quot;_&amp;quot;(默认)或连字符&amp;quot;-&amp;quot;, 称完整, 不要有歧义&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;system_file.c  &amp;amp; system_file.h&lt;/li&gt;&#xA;&lt;li&gt;item_name.c&lt;/li&gt;&#xA;&lt;li&gt;item-name.c&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;类型命名&#34;&gt;类型命名&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;每个单词首字母大写, 不使用下划线&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Number&lt;/li&gt;&#xA;&lt;li&gt;Timer&lt;/li&gt;&#xA;&lt;li&gt;File&lt;/li&gt;&#xA;&lt;li&gt;Name&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;变量命名&#34;&gt;变量命名&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;变量, 函数参数, 数据成员名&lt;/p&gt;</description>
    </item>
    <item>
      <title>mermaid 教程</title>
      <link>http://localhost:1313/en/post/2023/03/marmaid/</link>
      <pubDate>Sun, 19 Mar 2023 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2023/03/marmaid/</guid>
      <description>&lt;p&gt;mermaid可以在主流的markdown工具中使用&#xA;下面是几个常用的图示类型&lt;/p&gt;&#xA;&lt;h4 id=&#34;1思维导图&#34;&gt;1.思维导图&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;空格敏感&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;mermaid&#34;&gt;mindmap&#xA;  root((思维导图))&#xA;    节点一&#xA;      记录1.1&#xA;      ::icon(fa fa-book)&#xA;      节点1.1&#xA;        记录1.1.1&#xA;    节点二&#xA;      记录2.1&#xA;      记录2.2&#xA;        节点2.1&#xA;            记录2.1.1&#xA;      &#x9;&#x9;&#x9;记录2.1.2&#xA;          &#x9;记录2.1.3&#xA;    节点三&#xA;      记录3.1&#xA;      记录3.2&lt;/div&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基础&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;语法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;形状&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;默认&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;mermaid&#34;&gt;mindmap&#xA;    I am the default shape&lt;/div&gt;&#xA;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;[]&lt;/code&gt;矩形&lt;/p&gt;</description>
    </item>
    <item>
      <title>字符图片</title>
      <link>http://localhost:1313/en/post/2022/07/chart_image/</link>
      <pubDate>Fri, 29 Jul 2022 09:31:37 +0800</pubDate>
      <guid>http://localhost:1313/en/post/2022/07/chart_image/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://www.caoyang2002.top/usr/uploads/2023/10/958002088.jpg&#34; alt=&#34;beautiful.jpg&#34;&gt;&#xA;&lt;img src=&#34;https://www.caoyang2002.top/usr/uploads/2023/10/1324992575.jpg&#34; alt=&#34;cool.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;http://patorjk.com/software/taag&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   http://patorjk.com/software/taag&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;a href=&#34;http://www.network-science.de/ascii/&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   http://www.network-science.de/ascii/&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;a href=&#34;http://www.degraeve.com/img2txt.php&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   http://www.degraeve.com/img2txt.php&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;a href=&#34;http://life.chacuo.net/convertfont2char&#34;&#xA;   &#xA;   &#xA;     target=&#34;_blank&#34;&#xA;     rel=&#34;noopener noreferrer&#34;&#xA;     class=&#34;external-link&#34;&#xA;   &gt;&#xA;   http://life.chacuo.net/convertfont2char&#xA;   &#xA;     &lt;span class=&#34;external-icon&#34;&gt;↗&lt;/span&gt;&#xA;   &#xA;&lt;/a&gt;&#xA;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
