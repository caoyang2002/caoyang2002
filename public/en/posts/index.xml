<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on caoyang2002</title><link>https://caoyang2002.xyz/en/posts/</link><description>Recent content in Posts on caoyang2002</description><generator>Hugo</generator><language>en-US</language><atom:link href="https://caoyang2002.xyz/en/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>公告</title><link>https://caoyang2002.xyz/en/post/2024/03/notice/</link><pubDate>Thu, 21 Mar 2024 15:04:05 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/03/notice/</guid><description>&lt;p>&lt;img src="https://caoyang2002.xyz/images/cover/blue.jpg" alt="image">&lt;/p></description></item><item><title>Hugo-Focus 主题介绍</title><link>https://caoyang2002.xyz/en/post/2025/01/hugo-focus-info/</link><pubDate>Tue, 21 Jan 2025 01:53:21 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/hugo-focus-info/</guid><description>&lt;h1 id="一简述">一、简述&lt;/h1>
&lt;p>这是一个专注于编程的 Hugo 博客主题。&lt;/p>
&lt;p>参考了我此前为 &lt;code>Typora&lt;/code> 开发的 
&lt;a href="https://github.com/caoyang2002/Typora-Themes-Thompsgo"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 &lt;code>Thompsgo&lt;/code> 主题
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="二特性">二、特性&lt;/h1>
&lt;h2 id="1-运行代码">1. 运行代码&lt;/h2>
&lt;p>&lt;strong>支持的语言：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>python (wasm)&lt;/code>&lt;/li>
&lt;li>&lt;code>lisp (JavaScript 实现的 Common Lisp (JSCL) 解释器)&lt;/code>&lt;/li>
&lt;li>&lt;code>cpp (playground)&lt;/code>&lt;/li>
&lt;li>&lt;code>rust (playground)&lt;/code>&lt;/li>
&lt;li>&lt;code>go (playground)&lt;/code>&lt;/li>
&lt;li>&lt;code>ts (TypeScript 的 JavaScript 实现)&lt;/code>&lt;/li>
&lt;li>&lt;code>js (原生)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>短时间不会支持的语言（主要是没有找到 wasm 或 playground 支持）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>swift&lt;/code>&lt;/li>
&lt;li>&lt;code>ruby&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2-代码运行示例">2. 代码运行示例&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>Rust&lt;/strong>&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">fn main() {
 println!(&amp;#34;Hello from Rust!&amp;#34;);
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;strong>Go&lt;/strong>&lt;/p></description></item><item><title>作为独立开发者，你真的需要设计师吗？</title><link>https://caoyang2002.xyz/en/post/2025/01/do_you_really_need_a_designer/</link><pubDate>Mon, 20 Jan 2025 01:09:21 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/do_you_really_need_a_designer/</guid><description>&lt;blockquote>
&lt;p>有时候独立开发者想做一个产品，总觉得缺个 UI/UX 设计师，但囊中羞涩，想了想自己八字挺硬，于是做起了设计。&lt;/p>
&lt;p>但是，你为什么觉得自己需要一个设计师？&lt;/p>
&lt;p>我认为这是作为一个独立项目开发者需要想明白的问题。&lt;/p>
&lt;p>有时候，甚至是大多数时候你都不需要设计师。&lt;/p>
&lt;p>相反你应该花更多的时间想想这个产品为什么而存在。但这不是一篇教你挖掘需求或者产品设计的文章。所有的方法都只是设计的见解。&lt;/p></description></item><item><title>mac 汇编笔记</title><link>https://caoyang2002.xyz/en/post/2025/01/mac_assembly/</link><pubDate>Sat, 18 Jan 2025 11:35:14 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/mac_assembly/</guid><description>&lt;p>
&lt;a href="https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/index.html
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="梦开始的地方">梦开始的地方&lt;/h1>
&lt;h1 id="简单的-asm">简单的 asm&lt;/h1>
&lt;p>&lt;code>null.s&lt;/code>&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-asm" data-lang="asm">.section __TEXT,__text
.globl _main
.p2align 2
_main:
mov w0, #0
ret&lt;/code>&lt;/pre>
&lt;/div>









&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">int main() {
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div>









&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">as null.s -o null.o # 汇编
ld null.o -lSystem -L $(xcrun --show-sdk-path -sdk macosx)/usr/lib -o null # 链接（由于在 macOS 上不能创建静态链接的可执行文件，因此在链接时必须使用 -lSystem 动态链接上系统库。）
./null # 运行

# or
clang null.s -o null

# or
gcc null.s -o null&lt;/code>&lt;/pre>
&lt;/div>

&lt;blockquote>
&lt;p>&lt;code>as&lt;/code> 是 LLVM 的汇编器, &lt;code>lldb&lt;/code> 是 LLVM 的调试器。
&lt;code>GCC&lt;/code> 套件是 GNU 操作系统的一个部分，GNU 是开源的、社区驱动的。而 LLVM 项目也是开源的，现在主要是 Apple 在投资运行。因此，既然在 macOS 上，我就主要用的是 LLVM 系的工具。&lt;/p></description></item><item><title>简述 Rust 中的闭包</title><link>https://caoyang2002.xyz/en/post/2025/01/rust_closure_brief/</link><pubDate>Wed, 15 Jan 2025 13:22:26 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/rust_closure_brief/</guid><description>&lt;h1 id="为什么需要闭包">为什么需要闭包？&lt;/h1>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">// 问题1：函数复用
// 没有闭包时，需要传入所有参数
fn add(x: i32, base: i32) -&amp;gt; i32 { x &amp;#43; base }

// 有了闭包，可以部分应用
let base = 5;
let add_five = |x| x &amp;#43; base;

// 问题2：函数式编程需求
vec![1, 2, 3].iter().map(|x| x * 2); // 更简洁
vec![1, 2, 3].iter().map(multiply); // 需要单独定义函数

// 问题3：上下文捕获
// 没有闭包时很难处理
struct Context { value: i32 }
let ctx = Context { value: 42 };
let use_context = || println!(&amp;#34;{}&amp;#34;, ctx.value);&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;h1 id="闭包是什么">闭包是什么？&lt;/h1>
&lt;ul>
&lt;li>闭包是可以捕获其环境的匿名函数&lt;/li>
&lt;li>它&amp;quot;封闭&amp;quot;了其定义时的环境，故称&amp;quot;闭包&amp;quot;&lt;/li>
&lt;li>闭包 = 函数 + 环境&lt;/li>
&lt;/ul>
&lt;h1 id="闭包的优势">闭包的优势&lt;/h1>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">// 1. 简洁的语法
let add = |a, b| a &amp;#43; b; // vs fn add(a: i32, b: i32) -&amp;gt; i32

// 2. 灵活的环境捕获
let multiplier = 2;
let double = |x| x * multiplier; // 捕获 multiplier

// 3. 支持函数式编程
let numbers: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3, 4, 5];
let even_numbers: Vec&amp;lt;i32&amp;gt; = numbers
 .into_iter()
 .filter(|x| x % 2 == 0)
 .collect();&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;h1 id="理解闭包">理解闭包&lt;/h1>
&lt;p>我用 Python 和 TypeScript 的概念来解释 Rust 的闭包：&lt;/p></description></item><item><title>Rust 中的引用</title><link>https://caoyang2002.xyz/en/post/2025/01/rust_ref/</link><pubDate>Wed, 15 Jan 2025 11:57:02 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/rust_ref/</guid><description>&lt;h1 id="引用你的快递地址和包裹">引用：你的快递地址和包裹&lt;/h1>
&lt;p>想象这样一个场景：你在网上买了个漂亮的花瓶，快递公司需要把它送到你家。快递员需要知道两个信息：&lt;/p>
&lt;ol>
&lt;li>你家的地址（引用）&lt;/li>
&lt;li>花瓶本身（值）&lt;/li>
&lt;/ol>
&lt;h2 id="为什么我们需要引用">为什么我们需要引用？&lt;/h2>
&lt;p>让我们看一个具体的问题：&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">fn calculate_length(s: String) -&amp;gt; usize {
 s.len()
}

let s = String::from(&amp;#34;hello&amp;#34;);
let len = calculate_length(s);
println!(&amp;#34;{}&amp;#34;, s); // 编译错误！s 已经被转移了所有权&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>这就像你把花瓶（值）直接给了快递员（函数），花瓶就不再属于你了。但很多时候，我们只是想让快递员看看花瓶，而不是把它拿走。&lt;/p></description></item><item><title>rust 闭包</title><link>https://caoyang2002.xyz/en/post/2025/01/rust_closure/</link><pubDate>Wed, 15 Jan 2025 11:29:27 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/rust_closure/</guid><description>&lt;h2 id="从一个常见问题说起">从一个常见问题说起&lt;/h2>
&lt;p>假设你正在开发一个数据处理系统，需要对集合中的数据进行灵活的过滤和转换：&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">let numbers = vec![1, 2, 3, 4, 5];
// 如何优雅地复用过滤逻辑？
let even_numbers = ??? // 这里怎么写
let multiplied_numbers = ??? // 这里怎么写&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;h2 id="闭包的本质">闭包的本质&lt;/h2>
&lt;p>Rust 的闭包本质上是一种特殊的数据结构，它包含：&lt;/p></description></item><item><title>深入解释 Rust 中的 Result 和 Option 这两个核心类型</title><link>https://caoyang2002.xyz/en/post/2025/01/rust_result_option/</link><pubDate>Wed, 15 Jan 2025 11:26:02 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/rust_result_option/</guid><description>&lt;h1 id="从一个实际问题开始">从一个实际问题开始&lt;/h1>
&lt;p>假设我们在写一个文件处理程序：&lt;/p>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">fn read_config_file(path: &amp;amp;str) -&amp;gt; String {
 std::fs::read_to_string(path) // 这里会返回什么？
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>这段代码看似简单，但隐藏着两个基本问题：&lt;/p>
&lt;ol>
&lt;li>文件可能不存在&lt;/li>
&lt;li>即使文件存在，读取过程也可能失败&lt;/li>
&lt;/ol>
&lt;p>这就是为什么 Rust 引入了 &lt;code>Result&lt;/code> 和 &lt;code>Option&lt;/code>。&lt;/p></description></item><item><title>Wasm 打印输出和浏览器特性等最佳实践</title><link>https://caoyang2002.xyz/en/post/2025/01/wasm_print/</link><pubDate>Wed, 15 Jan 2025 00:31:17 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/wasm_print/</guid><description>&lt;p>在 Rust WASM 中，有几种方式可以实现打印输出和调用浏览器特性：&lt;/p>
&lt;ol>
&lt;li>使用 &lt;code>web_sys&lt;/code> 和 &lt;code>wasm_bindgen&lt;/code> 进行浏览器 API 调用：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use wasm_bindgen::prelude::*;
use web_sys::{console, window};

pub fn move_test(name: &amp;amp;str) {
 // 控制台打印
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;move test: {}&amp;#34;, name)));

 // 使用 console.warn
 console::warn_1(&amp;amp;JsValue::from_str(&amp;#34;This is a warning&amp;#34;));

 // 使用 console.error
 console::error_1(&amp;amp;JsValue::from_str(&amp;#34;This is an error&amp;#34;));

 // 浏览器 alert
 if let Some(window) = window() {
 window
 .alert_with_message(&amp;amp;format!(&amp;#34;Hello, {}!&amp;#34;, name))
 .expect(&amp;#34;alert failed&amp;#34;);
 }

 // 确认对话框
 if let Some(window) = window() {
 if window
 .confirm_with_message(&amp;#34;Do you want to continue?&amp;#34;)
 .expect(&amp;#34;confirm failed&amp;#34;)
 {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked OK&amp;#34;));
 } else {
 console::log_1(&amp;amp;JsValue::from_str(&amp;#34;User clicked Cancel&amp;#34;));
 }
 }
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="2">
&lt;li>在 Cargo.toml 中需要添加必要的依赖：&lt;/li>
&lt;/ol>








&lt;div>
 &lt;pre>&lt;code class="language-toml" data-lang="toml">[dependencies]
wasm-bindgen = &amp;#34;0.2&amp;#34;
web-sys = { version = &amp;#34;0.3&amp;#34;, features = [
 &amp;#34;console&amp;#34;,
 &amp;#34;Window&amp;#34;,
 &amp;#34;Document&amp;#34;,
 &amp;#34;Element&amp;#34;,
 &amp;#34;HtmlElement&amp;#34;,
 &amp;#34;Node&amp;#34;,
 &amp;#34;Location&amp;#34;
]}&lt;/code>&lt;/pre>
&lt;/div>

&lt;ol start="3">
&lt;li>如果需要格式化打印，可以使用 &lt;code>console::log!&lt;/code> 宏：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use web_sys::console;

// 需要引入宏
#[macro_export]
macro_rules! console_log {
 ($($t:tt)*) =&amp;gt; (console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!($($t)*))))
}

pub fn move_test(name: &amp;amp;str) {
 console_log!(&amp;#34;Testing move with name: {}&amp;#34;, name);
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="4">
&lt;li>操作 DOM 示例：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, window};

pub fn move_test(name: &amp;amp;str) {
 // 获取 document
 let window = window().expect(&amp;#34;no global window exists&amp;#34;);
 let document = window.document().expect(&amp;#34;no document exists&amp;#34;);

 // 创建新元素
 if let Some(div) = document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 // 修改输入框的值
 if let Some(input) = div.dyn_ref::&amp;lt;HtmlElement&amp;gt;() {
 input.set_inner_text(&amp;amp;format!(&amp;#34;New value: {}&amp;#34;, name));
 }
 }

 // 创建新元素
 let new_div = document.create_element(&amp;#34;div&amp;#34;).unwrap();
 new_div.set_text_content(Some(&amp;amp;format!(&amp;#34;Hello {}&amp;#34;, name)));

 // 添加到 body
 if let Some(body) = document.body() {
 body.append_child(&amp;amp;new_div).unwrap();
 }
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="5">
&lt;li>处理错误和 Result：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 // 使用 ? 运算符处理错误
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;
 let document = window.document().ok_or(&amp;#34;no document exists&amp;#34;)?;

 // 处理可能的错误
 match document.get_element_by_id(&amp;#34;test-input&amp;#34;) {
 Some(element) =&amp;gt; {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Found element: {}&amp;#34;, name)));
 Ok(())
 },
 None =&amp;gt; Err(JsValue::from_str(&amp;#34;Element not found&amp;#34;))
 }
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="6">
&lt;li>使用本地存储：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="rust">
 &lt;div>
 &lt;pre>
 &lt;code class="language-rust">use web_sys::Storage;

pub fn move_test(name: &amp;amp;str) -&amp;gt; Result&amp;lt;(), JsValue&amp;gt; {
 let window = window().ok_or(&amp;#34;no global window exists&amp;#34;)?;

 // 获取 localStorage
 if let Some(storage) = window.local_storage()? {
 // 存储数据
 storage.set_item(&amp;#34;user_name&amp;#34;, name)?;

 // 读取数据
 if let Ok(Some(saved_name)) = storage.get_item(&amp;#34;user_name&amp;#34;) {
 console::log_1(&amp;amp;JsValue::from_str(&amp;amp;format!(&amp;#34;Saved name: {}&amp;#34;, saved_name)));
 }
 }

 Ok(())
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>记住在使用任何 web-sys 功能时，需要在 Cargo.toml 中启用相应的 feature。例如，如果要使用 localStorage，需要添加 &amp;ldquo;Storage&amp;rdquo; feature：&lt;/p></description></item><item><title>Hugo 主题创建方法及简单说明</title><link>https://caoyang2002.xyz/en/post/2025/01/create_hugo_theme/</link><pubDate>Fri, 03 Jan 2025 11:11:07 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2025/01/create_hugo_theme/</guid><description>&lt;h1 id="参考">参考：&lt;/h1>
&lt;p>中文文档 
&lt;a href="https://hugo.opendocs.io/getting-started/quick-start/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://hugo.opendocs.io/getting-started/quick-start/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>博客：&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://blog.gujiakai.top/2023/03/hugo-theme-development-diary"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://blog.gujiakai.top/2023/03/hugo-theme-development-diary
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;li>
&lt;a href="https://juejin.cn/post/7151253414427492382"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://juejin.cn/post/7151253414427492382
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;/ul>
&lt;h1 id="一个简单的-hugo-主题">一个简单的 Hugo 主题&lt;/h1>
&lt;h2 id="创建一个空的网站模版">创建一个空的网站模版&lt;/h2>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">hugo new site demo&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>这会在当前目录创建一个名为 &lt;code>demo&lt;/code> 的目录，然后初始化 &lt;code>hugo&lt;/code> 的目录结构，&lt;/p>
&lt;h2 id="创建一个空的主题模版">创建一个空的主题模版&lt;/h2>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">cd demo
hugo new theme hugo-zero&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>得到输出信息：&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-" data-lang="">Creating theme at /hugo/demo/themes/hugo-zero&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>一开始的目录结构如下图所示：&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">hugo-zero（hugo主题）
├── archetypes（hugo主题文章模板）
├── layouts（hugo主题布局文件）
├── static（hugo主题的静态文件）
├── LICENSE（hugo主题的许可证信息）
└── themes.toml（hugo主题的元数据信息）&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>其中，重点关注layouts文件夹。剩余的文件可以慢慢补充。&lt;/p></description></item><item><title>Go 最佳实践</title><link>https://caoyang2002.xyz/en/post/2024/12/go/</link><pubDate>Sun, 29 Dec 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/12/go/</guid><description>&lt;p>在 Go 项目架构中，有一些重要的设计原则和规则。我来详细说明：&lt;/p>
&lt;ol>
&lt;li>接口定义规则：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：接口定义在使用方(调用方)包中
package handler
type UserService interface {
 Create(ctx context.Context, user *User) error
}

// ❌ 错误：接口定义在实现方包中
package service
type UserService interface {
 Create(ctx context.Context, user *User) error
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="2">
&lt;li>依赖方向：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确的依赖方向
handler -&amp;gt; service -&amp;gt; repository -&amp;gt; database

// ❌ 错误：不应该出现反向依赖
service -&amp;gt; handler
repository -&amp;gt; service&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="3">
&lt;li>数据模型定义：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：每层使用自己的数据模型
package handler
type CreateUserRequest struct { // API层模型
 Username string `json:&amp;#34;username&amp;#34;`
}

package service
type UserDTO struct { // 业务层模型
 ID uint64
 Username string
}

package repository
type UserDO struct { // 数据层模型
 ID uint64 `gorm:&amp;#34;primaryKey&amp;#34;`
 Username string
 CreatedAt time.Time
}

// ❌ 错误：直接在所有层使用相同的模型
type User struct {
 ID uint64 `json:&amp;#34;id&amp;#34; gorm:&amp;#34;primaryKey&amp;#34;`
 Username string `json:&amp;#34;username&amp;#34;`
 CreatedAt time.Time `json:&amp;#34;created_at&amp;#34;`
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="4">
&lt;li>错误处理层级：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：每层对错误进行适当包装
package repository
func (r *UserRepo) Create(user *UserDO) error {
 return fmt.Errorf(&amp;#34;database error: %w&amp;#34;, err)
}

package service
func (s *UserService) Create(user *UserDTO) error {
 return fmt.Errorf(&amp;#34;business error: %w&amp;#34;, err)
}

package handler
func (h *UserHandler) Create(c *gin.Context) {
 if err := h.service.Create(user); err != nil {
 c.JSON(getErrorStatus(err), ErrorResponse{err.Error()})
 return
 }
}

// ❌ 错误：直接暴露底层错误
if err := db.Create(&amp;amp;user).Error; err != nil {
 c.JSON(500, err.Error())
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="5">
&lt;li>包的组织：&lt;/li>
&lt;/ol>








&lt;div>
 &lt;pre>&lt;code class="language-" data-lang="">✅ 正确的包组织：
project/
 ├── api/
 │ └── handler/ # HTTP 处理层
 ├── internal/
 │ ├── service/ # 业务逻辑层
 │ ├── repository/ # 数据访问层
 │ └── model/ # 内部数据模型
 ├── pkg/
 │ └── util/ # 公共工具函数
 └── main.go

❌ 错误的包组织：
project/
 ├── handlers/
 ├── services/
 ├── models/
 └── main.go&lt;/code>&lt;/pre>
&lt;/div>

&lt;ol start="6">
&lt;li>依赖注入：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：通过构造函数注入依赖
func NewUserHandler(service UserService) *UserHandler {
 return &amp;amp;UserHandler{service: service}
}

// ❌ 错误：全局变量或直接初始化
var userService = &amp;amp;UserService{}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="7">
&lt;li>接口隔离：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：小接口，职责单一
type UserReader interface {
 GetUser(id uint64) (*User, error)
}

type UserWriter interface {
 CreateUser(user *User) error
}

// ❌ 错误：大接口，职责过多
type UserService interface {
 GetUser(id uint64) (*User, error)
 CreateUser(user *User) error
 UpdateUser(user *User) error
 DeleteUser(id uint64) error
 ListUsers() ([]*User, error)
 SearchUsers(query string) ([]*User, error)
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="8">
&lt;li>配置管理：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：集中管理配置
package config

type Config struct {
 Server ServerConfig
 DB DatabaseConfig
 Redis RedisConfig
}

// ❌ 错误：分散的配置或硬编码
var serverPort = 8080
var dbConnection = &amp;#34;root:password@tcp(localhost:3306)/db&amp;#34;&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="9">
&lt;li>上下文传递：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：统一使用 context 传递请求上下文
func (h *Handler) Create(c *gin.Context) {
 ctx := c.Request.Context()
 err := h.service.Create(ctx, req)
}

// ❌ 错误：不传递上下文或使用不一致的上下文
func (h *Handler) Create(c *gin.Context) {
 err := h.service.Create(req)
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;ol start="10">
&lt;li>测试组织：&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="go">
 &lt;div>
 &lt;pre>
 &lt;code class="language-go">// ✅ 正确：测试文件与源文件对应
package handler

func TestUserHandler_Create(t *testing.T) {
 // 单元测试
}

// ❌ 错误：测试代码与源码混合或测试覆盖不全
func TestAll(t *testing.T) {
 // 混合测试多个功能
}&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>遵循这些规则可以使代码：&lt;/p></description></item><item><title>营销</title><link>https://caoyang2002.xyz/en/post/2024/12/decision_paralysis/</link><pubDate>Sun, 29 Dec 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/12/decision_paralysis/</guid><description>&lt;h1 id="决策瘫痪">决策瘫痪&lt;/h1>
&lt;p>同行的朋友都觉得这样的菜单隐隐让自己很不舒服，不知道该选什么。但他们都让老板推荐了几个菜之后开始吃起来，忘记了刚刚“不舒服”的选择过程。而我却无法容忍这种模糊的感觉，希望探究一下背后的道理。然后想着想着，突然想到了很久之前看过的一个心理学实验：&lt;/p>
&lt;p>研究人员随机找了 2 组消费者，在两组面前都呈现了一系列昂贵的果酱，并且给他们提供试吃机会和优惠券。不同的是A组消费者面前摆着 6 款不同的果酱，B 组消费者面前摆着 24 种不同的果酱。&lt;/p></description></item><item><title>资源</title><link>https://caoyang2002.xyz/en/post/2024/12/resource/</link><pubDate>Sun, 29 Dec 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/12/resource/</guid><description>&lt;h1 id="如何找资源">如何找资源&lt;/h1>
&lt;blockquote>
&lt;p>下载

&lt;a href="https://www.pansou.vip/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 盘搜
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;a href="https://pansoso.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 盘搜搜
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;li>
&lt;a href="https://www.dashengpan.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 大圣盘
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;li>
&lt;a href="https://t.me/jisou"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 TG机器人
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;li>
&lt;a href="https://aliso.cc/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 阿里搜
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;/ul>
&lt;h1 id="一我维护的其他站">一、我维护的其他站&lt;/h1>
&lt;h2 id="move-学习">Move 学习&lt;/h2>
&lt;p>
&lt;a href="http://43.138.107.218/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 move
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="二编程相关内容">二、编程相关内容&lt;/h1>
&lt;h2 id="各种镜像收录">各种镜像收录&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;p>iframe src=&amp;ldquo;
&lt;a href="http://www.yishimei.cn/%22"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://www.yishimei.cn/"
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
 width=&amp;ldquo;100%&amp;rdquo; height=&amp;ldquo;600&amp;rdquo;&amp;gt;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>NPS: http://101.43.125.94:20002/
DS220j-SSH: http://101.43.125.94:20010/
DS220j-DSM: http://101.43.125.94:20011/&lt;/p>
&lt;p>Windows10: http://101.43.125.94:20020/&lt;/p></description></item><item><title>hugo 配置</title><link>https://caoyang2002.xyz/en/post/2024/12/about_hugo_config/</link><pubDate>Sun, 22 Dec 2024 18:12:52 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/12/about_hugo_config/</guid><description>&lt;div>
 &lt;pre>&lt;code class="language-toml" data-lang="toml"># 基础优化配置
enableGitInfo = true # 启用 Git 信息,可以显示文章的最后修改时间
hasCJKLanguage = true # 启用中日韩文字支持,能准确统计字数
summaryLength = 140 # 文章摘要长度

# SEO 优化
[params]
keywords = [&amp;#34;博客&amp;#34;,&amp;#34;技术&amp;#34;,&amp;#34;编程&amp;#34;] # 网站关键词
description = &amp;#34;个人技术博客&amp;#34; # 网站描述
images = [&amp;#34;site-feature-image.jpg&amp;#34;] # 默认社交媒体分享图片
# 自定义 Open Graph 信息
[params.og]
title = &amp;#34;我的博客&amp;#34;
type = &amp;#34;website&amp;#34;
images = [&amp;#34;og-image.jpg&amp;#34;]

# 性能优化
[minify]
 disableCSS = false # 启用 CSS 压缩
 disableHTML = false # 启用 HTML 压缩
 disableJS = false # 启用 JS 压缩
 disableJSON = false # 启用 JSON 压缩
 minifyOutput = true # 压缩 HTML 输出

# 图片处理
[imaging]
 quality = 75 # JPEG 图片质量
 resampleFilter = &amp;#34;Lanczos&amp;#34; # 图片重采样过滤器
 anchor = &amp;#34;Smart&amp;#34; # 图片裁剪锚点

# 内容安全策略
[params.csp]
 childsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 fontsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;, &amp;#34;https://fonts.gstatic.com&amp;#34;, &amp;#34;https://cdn.jsdelivr.net&amp;#34;]
 formaction = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 framesrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 imgsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;]
 objectsrc = [&amp;#34;&amp;#39;none&amp;#39;&amp;#34;]
 stylesrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;, &amp;#34;&amp;#39;unsafe-inline&amp;#39;&amp;#34;]
 scriptsrc = [&amp;#34;&amp;#39;self&amp;#39;&amp;#34;, &amp;#34;&amp;#39;unsafe-inline&amp;#39;&amp;#34;, &amp;#34;&amp;#39;unsafe-eval&amp;#39;&amp;#34;]

# 文章配置
[permalinks]
 posts = &amp;#34;/post/:year/:month/:slug/&amp;#34; # 自定义文章 URL 结构

# 自定义输出格式
[outputs]
 home = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;, &amp;#34;JSON&amp;#34;] # 支持 JSON API 输出
 section = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;]
 taxonomy = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;]
 term = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;]

# RSS 订阅配置
[params.rss]
 limit = 20 # RSS 文章数量限制
 fullContent = true # RSS 包含完整文章内容

# 站内搜索配置
[outputs]
 home = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;, &amp;#34;JSON&amp;#34;, &amp;#34;SearchIndex&amp;#34;]
[outputFormats.SearchIndex]
 mediaType = &amp;#34;application/json&amp;#34;
 baseName = &amp;#34;searchindex&amp;#34;
 isPlainText = true
 notAlternative = true

# 文章目录配置
[markup.tableOfContents]
 endLevel = 3 # 目录最大深度
 ordered = false # 使用无序列表
 startLevel = 2 # 目录开始层级

# 代码高亮配置
[markup.highlight]
 codeFences = true # 启用代码围栏
 guessSyntax = true # 自动推测代码语言
 lineNoStart = 1 # 起始行号
 lineNos = true # 显示行号
 lineNumbersInTable = true # 使用表格式行号
 tabWidth = 4 # 制表符宽度
 style = &amp;#34;monokai&amp;#34; # 代码高亮主题&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>一些重要的最佳实践建议：&lt;/p></description></item><item><title>从 Hexo 迁移至 Hugo</title><link>https://caoyang2002.xyz/en/post/2024/12/my-first-post/</link><pubDate>Sun, 22 Dec 2024 18:12:52 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/12/my-first-post/</guid><description>&lt;h1 id="再见hexo从hexo迁移至hugo">再见Hexo——从Hexo迁移至Hugo&lt;/h1>
&lt;p>16 年的时候，博客使用的虚拟主机需要做迁移，当时所使用的 Typecho 是一个依赖于数据库的 PHP 博客系统，数据导出过程很艰辛。彼时 Gihub Pages 正大火，我也就跟风转投了静态博客系统 Hexo 。七年过去了，博客还在，但折腾 Hexo 的人是越来越少了。如今我也要和 Hexo 说声再见，拥抱 Hugo 的怀抱了。&lt;/p>
&lt;h2 id="为什么改用hugo">为什么改用Hugo&lt;/h2>
&lt;h3 id="依赖管理问题">依赖管理问题&lt;/h3>
&lt;p>在
&lt;a href="https://easonyang.com/2021/07/10/how-to-sync-and-backup-a-static-blog/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 静态博客的同步和备份方案
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
一文中，我分享了基于 Github 和 iCloud 的同步备份方案，期望在保证数据安全的同时，写作环境可以在我的两台电脑上无缝切换。&lt;/p></description></item><item><title>使用 Hexo+GitHub+Vercel 搭建个人免费博客的最佳实践</title><link>https://caoyang2002.xyz/en/post/2024/12/hexo/</link><pubDate>Sun, 22 Dec 2024 18:12:52 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/12/hexo/</guid><description>&lt;p>我的博客之前是在云服务器上部署的java服务，现在把博客迁移到了github托管，使用
&lt;a href="https://hexo.io/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 Hexo
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
以及主题
&lt;a href="https://theme-next.js.org/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 Theme NexT
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
，
在源码仓库通过hexo会生成静态html文件，通过github action部署到网站仓库。网站仓库自动部署到
&lt;a href="https://vercel.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 vercel
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>作为一个把Hexo、NexT官网的文档看了一个遍的人，我想我可以写一篇文章总结一下。&lt;/p></description></item><item><title>shell mac 教程</title><link>https://caoyang2002.xyz/en/post/2024/11/shell_mac_pop/</link><pubDate>Sat, 09 Nov 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/11/shell_mac_pop/</guid><description>&lt;p>
&lt;a href="https://juejin.cn/post/6921144388802641933"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-as" data-lang="as">#!/bin/bash

# 1. 自定义通知消息
# 传参 $1:消息描述 $2:通知标题 $3:通知副标题
function showNoteMessage(){
 osascript -e &amp;#34;display notification \&amp;#34;${1}\&amp;#34; with title \&amp;#34;${2}\&amp;#34; subtitle \&amp;#34;${3}\&amp;#34; sound name \&amp;#34;Funk\&amp;#34;&amp;#34;
}
#test case:
#showNoteMessage &amp;#34;消息内容&amp;#34; &amp;#34;通知&amp;#34; &amp;#34;通知副标题&amp;#34;

# 2. 自定义弹窗(统一通用方法)
# 传参$1 弹窗消息内容
# 传参$2 弹窗标题
# 传参$3 按钮标题,多个用英文逗号隔开
# 传参$4 默认选中的按钮标题或者按钮数字下标
# 传参$5 是否为输入框类型 传&amp;#34;0&amp;#34;或者&amp;#34;1&amp;#34; 默认&amp;#34;0&amp;#34;
# 传参$6 输入框默认占位内容,传不传无所谓,默认为空字符串 &amp;#34;&amp;#34;
# 传参$7 默认图标note/stop/caution 或者自定义文件路径(:格式路径可以通过choose file获取)
# tips: 重要! 如果为输入框模式,那么输出结果就是{button returned:button,text returned:text} 否则只有按钮或者false
function showCustomAlertMessage(){

if [[ -n &amp;#34;$4&amp;#34; ]]; then

	if [[ ${4} == *[!0-9]* ]]; then
 	defaultButton=&amp;#34;default button \&amp;#34;${4}\&amp;#34;&amp;#34;
 	else
 	defaultButton=&amp;#34;default button ${4}&amp;#34;
	fi
else
	defaultButton=&amp;#34;&amp;#34;
fi

#是否为输入框模式
if [[ &amp;#34;$5&amp;#34; = &amp;#34;1&amp;#34; ]]; then
	IS_InputMode=&amp;#34;default answer \&amp;#34;${6}\&amp;#34;&amp;#34;
	ReturnValue=&amp;#34;get result&amp;#34;
else
	IS_InputMode=&amp;#34;&amp;#34;
	ReturnValue=&amp;#34;get the button returned of the result&amp;#34;
fi

if [[ -n &amp;#34;$7&amp;#34; ]]; then
 case ${7} in
	note)
	ICON=&amp;#34;with icon note&amp;#34;
	;;
	stop)
	ICON=&amp;#34;with icon stop&amp;#34;
	;;
	caution)
	ICON=&amp;#34;with icon caution&amp;#34;
	;;
	*)
	ICON=&amp;#34;with icon file \&amp;#34;${7}\&amp;#34;&amp;#34;
	;;
 esac
else
 ICON=&amp;#34;with icon file \&amp;#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns\&amp;#34;&amp;#34;
fi

osascript &amp;lt;&amp;lt;EOF
	set buttonStr to &amp;#34;${3}&amp;#34;
	set oldDelimiters to AppleScript&amp;#39;s text item delimiters
	set AppleScript&amp;#39;s text item delimiters to &amp;#34;,&amp;#34;
	set buttonList to every text item of buttonStr
	set AppleScript&amp;#39;s text item delimiters to oldDelimiters
	get buttonList
	set btns to buttonList
	display dialog &amp;#34;${1}&amp;#34; with title &amp;#34;${2}&amp;#34; buttons btns ${IS_InputMode} ${defaultButton} ${ICON}
	${ReturnValue}
EOF
}

# showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;1&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;note&amp;#34;
# showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; 2 &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;note&amp;#34;
#showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;stop&amp;#34;
#showCustomAlertMessage &amp;#34;弹窗消息内容&amp;#34; &amp;#34;弹窗标题&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮2&amp;#34; &amp;#34;0&amp;#34; &amp;#34;占位内容&amp;#34; &amp;#34;Macintosh HD:Applications:Xcode.app:Contents:Resources:Xcode.icns&amp;#34;

# 普通弹窗 一个ok就够了 就是一个确认的那种
function onlyConfirmButton(){
	showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;温馨提示&amp;#34; &amp;#34;好的&amp;#34; 1
}
#onlyConfirmButton &amp;#34;登录成功!\n弹窗成功!&amp;#34;

# 多按钮弹窗 最多三个按钮 多了会报错
function mostButtons(){
	showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;温馨提示&amp;#34; &amp;#34;按钮1,按钮2,按钮3&amp;#34; &amp;#34;按钮3&amp;#34;
}
#mostButtons &amp;#34;最多只能定义三个按钮哦&amp;#34;

# 输入框弹窗
function showInputAlertMessage(){
	showCustomAlertMessage &amp;#34;$1&amp;#34; &amp;#34;$2&amp;#34; &amp;#34;取消,确认&amp;#34; 2 &amp;#34;1&amp;#34; &amp;#34;&amp;#34;
}
showInputAlertMessage &amp;#34;请输入密码&amp;#34; &amp;#34;登录验证&amp;#34;&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>谷歌账号注册的问题</title><link>https://caoyang2002.xyz/en/post/2024/07/google_account/</link><pubDate>Wed, 17 Jul 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/07/google_account/</guid><description>&lt;p>参考：&lt;/p>
&lt;ol>
&lt;li>
&lt;a href="https://www.gmail777.com/archives/69"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 中州西鹿
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;li>
&lt;a href="https://blog.csdn.net/huayanhuicui/article/details/137236352"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 多图详细教你注册Google（Gmail）新账号，常见问题和注意事项
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;li>
&lt;a href="https://uzbox.com/usa/google-add-tel.html"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 此电话号码已用过太多次，此电话号码无法用于进行验证 谷歌账号无法注册解决方法
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/li>
&lt;/ol>
&lt;h1 id="谷歌账号注册的问题">谷歌账号注册的问题&lt;/h1>
&lt;h2 id="注册">注册&lt;/h2>
&lt;p>通过google主页或直接访问 Gmail 主页，选择登录，在登录的时候选择“创建账号”，一般选个人用途就可以了。选好了以后点击下一步。耗时3秒&lt;/p></description></item><item><title>C 语言字符画</title><link>https://caoyang2002.xyz/en/post/2024/06/c_shar/</link><pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/06/c_shar/</guid><description>&lt;blockquote>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">3
* * *
* *
* * *

4
* * * *
* *
* *
* * * *&lt;/code>&lt;/pre>
&lt;/div>

&lt;/blockquote>
&lt;ul>
&lt;li>非多组输入&lt;/li>
&lt;/ul>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
//行定位
int main() {
 int n = 0;
 scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);
 for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {
 if (i == 0 || i == n - 1) {//首尾行输出一行*
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {
 printf(&amp;#34;* &amp;#34;);
 }
 } else {
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//其它行首尾输出*
 if(j==0 || j == n-1)
 printf(&amp;#34;* &amp;#34;);
 else
 printf(&amp;#34; &amp;#34;);
 }
 }
 printf(&amp;#34;\n&amp;#34;);//换行
 }

 return 0;
}

// 3 ---- n
// * * * --- 1行每个位置都输出 一共n个
// * * --- 其它行1和n位置输出 一共2个
// * * * --- n行每个位置都输出 一共n个
// 思路：
// 使用for 和 if
// 判断是不吃首尾行 是则输出一行* 不是则输出首尾*&lt;/code>&lt;/pre>
&lt;/div>

&lt;hr>
&lt;ul>
&lt;li>多组输入&lt;/li>
&lt;/ul>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
//行和列定位
int main() {
 int n = 0;
 while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) == 1){//输入的数量为1
 for (int i = 0; i &amp;lt; n; &amp;#43;&amp;#43;i) {//控制行
 for (int j = 0; j &amp;lt; n; &amp;#43;&amp;#43;j) {//控制列
 if(i == 0 || i == n-1 || j == 0 || j == n-1)//第0行，第n-1行，第0列，第n-1列输出 *_,其它位置输出 __
 printf(&amp;#34;* &amp;#34;);
 else
 printf(&amp;#34; &amp;#34;);
 }
 printf(&amp;#34;\n&amp;#34;);
 }
 }
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>如何生成 dll 文件</title><link>https://caoyang2002.xyz/en/post/2024/06/dl/</link><pubDate>Sat, 29 Jun 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/06/dl/</guid><description>&lt;h1 id="如何生成-dll文件">如何生成 .dll文件&lt;/h1>
&lt;p>生成dll文件同时会生成lib文件&lt;/p>
&lt;ol>
&lt;li>在VS开始界面，搜索dll，创建dll动态链接库&lt;/li>
&lt;li>创建一个类（右键创建类，会自动包含需要的文件） 以查询目录下的文件为例
创建的文件可以不用管
&lt;code>.cpp&lt;/code>文件 输入自己的代码&lt;/li>
&lt;/ol>







&lt;div class="code-playground" data-language="cpp">
 &lt;div>
 &lt;pre>
 &lt;code class="language-cpp">#include &amp;#34;pch.h&amp;#34;
#include &amp;#34;check_repository.h&amp;#34;
namespace fs = std::filesystem;
 int Check::CheckRepository() {
 std::string folderName = &amp;#34;.Rysigy&amp;#34;;
 fs::path currentPath = fs::current_path();
 fs::path folderPath = currentPath / folderName;

 if (fs::exists(folderPath) &amp;amp;&amp;amp; fs::is_directory(folderPath)) {
 std::cout &amp;lt;&amp;lt; &amp;#34;存储库 &amp;#39;.Rysigy&amp;#39; 文件夹存在\n&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 else {
 std::cout &amp;lt;&amp;lt; &amp;#34;[错误]\t存储库 &amp;#39;.Rysigy&amp;#39; 文件夹不存在\n请在右键菜单中点击 &amp;#39;创建存储库&amp;#39;\n&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 std::cout &amp;lt;&amp;lt; &amp;#34;点击任意按键退出...&amp;#34; &amp;lt;&amp;lt; std::endl;
 _getch();
 return 0;
};&lt;/code>&lt;/pre>
 &lt;/div>
 &lt;div class="controls">
 &lt;button class="run-button">
 &lt;span style="display: flex; align-items: center; gap: 4px"
 >运行&lt;svg
 t="1737473351499"
 class="icon"
 viewBox="0 0 1024 1024"
 version="1.1"
 xmlns="http://www.w3.org/2000/svg"
 p-id="11262"
 width="16"
 height="16"
 >
 &lt;path
 d="M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
 p-id="11263"
 >&lt;/path>
 &lt;path
 d="M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
 p-id="11264"
 >&lt;/path>
 &lt;/svg>
 &lt;/span>
 &lt;/button>
 &lt;/div>
 &lt;div class="output" style="display: none">
 &lt;pre class="output-content">&lt;/pre>
 &lt;/div>
&lt;/div>

&lt;p>&lt;code>.h&lt;/code>文件&lt;/p></description></item><item><title>删除错误提交到GitHub仓库中的文件</title><link>https://caoyang2002.xyz/en/post/2024/06/git_delete_file/</link><pubDate>Wed, 19 Jun 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/06/git_delete_file/</guid><description>&lt;p>如果你需要删除错误提交到GitHub仓库中的文件，你可以通过以下步骤来创建一个新的提交来撤销之前的更改：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>在本地仓库中删除文件&lt;/strong>：
首先，在你的本地仓库中删除该文件：&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-sh" data-lang="sh">git rm --cached &amp;lt;file&amp;gt;&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>这里 &lt;code>&amp;lt;file&amp;gt;&lt;/code> 是你想要从仓库中删除的文件名。&lt;code>--cached&lt;/code> 参数意味着仅从Git的跟踪中删除文件，而不删除工作目录中的文件。&lt;/p></description></item><item><title>TG 下载器</title><link>https://caoyang2002.xyz/en/post/2024/05/download_telegram/</link><pubDate>Wed, 29 May 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/05/download_telegram/</guid><description>&lt;h1 id="软件">软件&lt;/h1>
&lt;p>
&lt;a href="https://github.com/tangyoha/telegram_media_downloader/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://github.com/tangyoha/telegram_media_downloader/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h2 id="在-elease-里面下载可执行程序">在 elease 里面下载可执行程序&lt;/h2>
&lt;h1 id="win">Win&lt;/h1>
&lt;p>&lt;img src="https://www.caoyang2002.top/usr/uploads/2024/03/348142121.png" alt="">&lt;/p>
&lt;p>
&lt;a href="https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.3/tdl-v2.2.3-win64.zip"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.3/tdl-v2.2.3-win64.zip
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="linux-x86_64">Linux （x86_64)&lt;/h1>
&lt;p>&lt;img src="https://www.caoyang2002.top/usr/uploads/2024/03/4255088993.png" alt="">&lt;/p>
&lt;p>
&lt;a href="https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-linux-amd64.zip"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-linux-amd64.zip
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="mac">mac&lt;/h1>
&lt;p>没有测试

&lt;a href="https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-macos.zip"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://github.com/tangyoha/telegram_media_downloader/releases/download/v2.2.1/tdl-v2.2.1-macos.zip
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="配置">配置&lt;/h1>
&lt;p>所有配置都通过 config.yaml 文件传递​​给 &lt;code>Telegram Media Downloader&lt;/code>。&lt;/p>
&lt;p>&lt;strong>获取您的 API 密钥：&lt;/strong>
第一步需要您获得有效的 Telegram API 密钥（API id/hash pair）：&lt;/p>
&lt;ol>
&lt;li>访问 
&lt;a href="https://my.telegram.org/apps"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://my.telegram.org/apps
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
 并使用您的 Telegram 帐户登录。&lt;/li>
&lt;li>填写表格以注册新的 Telegram 应用程序。&lt;/li>
&lt;li>完成！ API 密钥由两部分组成：&lt;strong>api_id&lt;/strong> 和&lt;strong>api_hash&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>获取聊天ID：&lt;/strong>&lt;/p></description></item><item><title>x86 教程</title><link>https://caoyang2002.xyz/en/post/2024/05/x86/</link><pubDate>Thu, 02 May 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/05/x86/</guid><description>&lt;p>作者： 
&lt;a href="http://www.ruanyifeng.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 阮一峰
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>日期： 
&lt;a href="http://www.ruanyifeng.com/blog/2018/01/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 2018年1月21日
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。&lt;/p>
&lt;p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。&lt;/p>
&lt;p>&lt;img src="https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/bg2018012204.png" alt="img">&lt;/p>
&lt;p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。&lt;/p></description></item><item><title>SQL 教程</title><link>https://caoyang2002.xyz/en/post/2024/04/sql/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/04/sql/</guid><description>&lt;!-- raw HTML omitted -->
&lt;h1 id="数据库相关的操作">数据库相关的操作&lt;/h1>
&lt;p>查询数据库	 &lt;code>SHOW DATABASES&lt;/code>&lt;/p>
&lt;p>创建数据库
&lt;code>CREATE DATABASE 数据库名&lt;/code>
&lt;code>CREATE DATABASE mydatabase&lt;/code>&lt;/p>
&lt;p>查看数据库信息
&lt;code>SHOW CREATE DATABASE 数据库名&lt;/code>
&lt;code>SHOW CREATE DATABASE database&lt;/code>&lt;/p>
&lt;p>删除数据库
&lt;code>DROP DATABASE 数据库名&lt;/code>
&lt;code>DROP DATABASE mydatabase&lt;/code>&lt;/p>
&lt;p>使用数据库
&lt;code>USE 数据库名&lt;/code>
&lt;code>USE mydatabase&lt;/code>&lt;/p>
&lt;h1 id="ddl语句-数据定义语言">DDL语句	 数据定义语言&lt;/h1>
&lt;p>创建表&lt;/p>








&lt;div>
 &lt;pre>&lt;code class="language-sql" data-lang="sql">CREATE TABLE 表名(
 列名1 类型[长度] [DEFAULT 默认值] [约束条件]
 列名2 类型
 ……
);

CREATE TABLE userinfo(
 id INT
 username VARCHAR(32)
 password VARCHAR(32)
 nickname VARCHAR(32)
 age INT(3)
);&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>查看当前数据库创建的所有表
&lt;code>SHOW TABLES;&lt;/code>&lt;/p></description></item><item><title>什么是 SimHash</title><link>https://caoyang2002.xyz/en/post/2024/04/simhash/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/04/simhash/</guid><description>&lt;h1 id="一什么是simhash">一、什么是SimHash&lt;/h1>
&lt;p>SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。&lt;/p>
&lt;p>对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。
比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。&lt;/p></description></item><item><title>创建一个远程编译环境</title><link>https://caoyang2002.xyz/en/post/2024/04/a_code_env/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/04/a_code_env/</guid><description>&lt;blockquote>
&lt;p>我使用的是 Mac，所以以下都是 Mac 的说明&lt;/p>
&lt;/blockquote>
&lt;h1 id="一前端tsreact">一、前端（ts、react）&lt;/h1>
&lt;blockquote>
&lt;p>前端配置：TypeScript、React
依赖项：axios、codemirror、react-codemirror2&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-初始化模板">1. 初始化模板&lt;/h2>
&lt;blockquote>
&lt;p>任意选一个就行&lt;/p>
&lt;/blockquote>
&lt;h3 id="11-交互式">1.1 交互式&lt;/h3>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">npm init vite&lt;/code>&lt;/pre>
&lt;/div>

&lt;blockquote>
&lt;p>可能需要先安装
&lt;code>npm install vite --save-dev&lt;/code>&lt;/p>
&lt;/blockquote>








&lt;div>
 &lt;pre>&lt;code class="language-" data-lang="">caoyang@cccy del % npm init vite
# 使用 上下键 选择
✔ Project name: … playground # playground 是项目名称，它会创建一个该名称的文件夹作为项目根目录
✔ Select a framework: › React # 使用 React 库
✔ Select a variant: › TypeScript # 使用 TS 语言开发

Scaffolding project in /Users/caoyang/Documents/Aptos/del/playground...

Done. Now run:

# 需要先运行以下代码
 cd playground
 npm install
 npm run dev&lt;/code>&lt;/pre>
&lt;/div>

&lt;h3 id="12-一键创建">1.2 一键创建&lt;/h3>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">npm init vite playground -- --template react-ts&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>或者&lt;/p></description></item><item><title>报税记账</title><link>https://caoyang2002.xyz/en/post/2024/04/compent/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/04/compent/</guid><description>&lt;blockquote>
&lt;p>以下是我回忆的, 所以没有截图教程&lt;/p>
&lt;/blockquote>
&lt;h1 id="报税网址">报税网址&lt;/h1>
&lt;h2 id="四川省电子税务局">四川省电子税务局&lt;/h2>
&lt;blockquote>
&lt;p>这个主要是企业报税用的&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;a href="https://etax.sichuan.chinatax.gov.cn/loginb/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://etax.sichuan.chinatax.gov.cn/loginb/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h2 id="自然人电子税务局">自然人电子税务局&lt;/h2>
&lt;blockquote>
&lt;p>这个主要是给法人报税用的&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;a href="https://etax.chinatax.gov.cn"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://etax.chinatax.gov.cn
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="关于注销">关于注销&lt;/h1>
&lt;blockquote>
&lt;p>税务申报方面需要仔细一点, 然后就是一些文件里面的项, 我啥也不懂, 就没有改, 发现需要再缴 500, 不知道是什么, 就缴了,&lt;/p>
&lt;/blockquote>
&lt;p>去注销企业的时候遇到的一些问题:&lt;/p>
&lt;p>我使用的是 &amp;ldquo;简易注销&amp;rdquo;, 这个比较方便, 是一站式的, 办理完后需要等待 20 天的公示期,公示期结束后继续办理注销流程&lt;/p></description></item><item><title>设计资料：样机</title><link>https://caoyang2002.xyz/en/post/2024/04/design/</link><pubDate>Mon, 29 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/04/design/</guid><description>&lt;p>&lt;img src="https://www.caoyang2002.top/usr/uploads/2024/04/2720746638.png" alt="样机">&lt;/p>
&lt;h1 id="样机">样机&lt;/h1>
&lt;p>
&lt;a href="https://bannermockup.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://bannermockup.com/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://mockupplanet.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://mockupplanet.com/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://www.anthonyboyd.graphics/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://www.anthonyboyd.graphics/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://www.pixeden.com/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://www.pixeden.com/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://www.ls.graphics"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://www.ls.graphics
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h2 id="条件">条件&lt;/h2>
&lt;h3 id="登录">登录&lt;/h3>
&lt;p>grapicpear&lt;/p>
&lt;h1 id="插画">插画&lt;/h1>
&lt;p>
&lt;a href="https://dotown.maeda-design-room.net/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://dotown.maeda-design-room.net/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://www.opendoodles.com"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 https://www.opendoodles.com
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>设计师必备 50 款免费可商用图库网站：照片、插画、纹理一网打尽&lt;/p>
&lt;p>免费素材图像素材工具推荐
Angel Wang・2022-10-13
大家好，本周我为大家准备了超全面的免费可商用高清图库，可能是全网最全的总结，推荐的图库类型有：照片图库、博物馆艺术品图库、图片生成器、纹理图库、插画图库、图标库，总有一种你用得到！&lt;/p></description></item><item><title>JWT 解析</title><link>https://caoyang2002.xyz/en/post/2024/04/jwt/</link><pubDate>Fri, 12 Apr 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/04/jwt/</guid><description>&lt;p>&lt;img src="" alt="JWT">&lt;/p>
&lt;p>
&lt;a href="https://zhuanlan.zhihu.com/p/86937325"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文一
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://blog.csdn.net/weixin_39779004/article/details/110801387"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文二
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>
&lt;a href="https://b23.tv/3f7Yrct"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 视频
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="一什么是-jwt">一、什么是 JWT&lt;/h1>
&lt;p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。&lt;/p>
&lt;h1 id="二设计目标">二、设计目标&lt;/h1>
&lt;p>不需要服务器端存储状态，安全地传递非敏感信息&lt;/p>
&lt;p>&lt;img src="https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/OIP-C-20240424140338352.jpeg" alt="JWT认证方案讲解-阿里云开发者社区">&lt;/p>
&lt;h1 id="三-json-web-token-的结构是什么样的">三、 JSON Web Token 的结构是什么样的&lt;/h1>
&lt;p>JSON Web Token由三部分组成，例如&lt;code>dafdsafdwfefeqwad.oijhdaffweqtgfdhfdws.dhshfsghhhhhwfsdke&lt;/code>&lt;/p></description></item><item><title>搭建 NPS</title><link>https://caoyang2002.xyz/en/post/2024/03/docker_pns/</link><pubDate>Fri, 29 Mar 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/03/docker_pns/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://github.com/ehang-io/nps/tree/master"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 github
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>
&lt;a href="https://ehang-io.github.io/nps/#/install"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 官方文档
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;/blockquote>
&lt;p>其实所有的配置都不推荐修改，但是如果改了一个配置一定要理解为什么改，以及会影响到什么，请务必打开服务器的端口（防火墙）。&lt;/p>
&lt;p>以下不一定能用，因为我搞了许久才发现是我没打开服务器防火墙，而导致无法访问。
简单说：服务器的配置建议改一下，主要是你服务器可能把8080端口占用了，其余的所有都可以不用改。又不是不能用。&lt;/p></description></item><item><title>小米 4a 路由器刷机</title><link>https://caoyang2002.xyz/en/post/2024/03/xiaomi_4a/</link><pubDate>Sun, 24 Mar 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/03/xiaomi_4a/</guid><description>&lt;p>
&lt;a href="https://blog.csdn.net/yilovexing/article/details/129688708"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 查看原文
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="一获取原厂固件的-ssh-登录权限">一、获取原厂固件的 ssh 登录权限&lt;/h1>
&lt;p>有些厂商的路由器会提供原厂固件的 ssh 登录权限，有些则需要通过原厂固件漏洞等方式来获取路由器后台登录权限，比如：小米路由器就需要先通过 OpenWRTInvasion 破解路由登录权限。&lt;/p>
&lt;p>小米路由器4A千兆版是利用 2.28.62 版本固件的一个 Shell 命令注入的漏洞，所以要想刷机成功就必须得降级到这个版本（2.28.62 之后的新版本应该是将这个漏洞修复了，我再次通过 OpenWRTInvasion 没获取到 ssh 登录权，所有刷的时候尽量在 2.28.62 这个固件版本下刷机）。&lt;/p></description></item><item><title>小米 4c 路由器刷机</title><link>https://caoyang2002.xyz/en/post/2024/03/xiaomi_4c_router/</link><pubDate>Sat, 23 Mar 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/03/xiaomi_4c_router/</guid><description>&lt;p>
&lt;a href="https://blog.csdn.net/xingman510/article/details/127174713"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;p>介绍一下配置：&lt;/p>
&lt;ul>
&lt;li>wifi 全程不用连网&lt;/li>
&lt;li>win系统电脑刷机，需要下载一个刷机包&lt;/li>
&lt;li>windows 有 python 程序，查看方法：在命令提示符窗口输入 &lt;code>python --version&lt;/code>，会输出版本号&lt;/li>
&lt;/ul>
&lt;p>Breed也被称为“不死鸟”，顾名思义刷入Breed后即使后续为路由器刷固件失败，也不至于让路由器变砖，并且对于以后更换固件非常友好，强烈建议刷Breed。&lt;/p></description></item><item><title>小米路由器</title><link>https://caoyang2002.xyz/en/post/2024/03/xiaomi_router/</link><pubDate>Fri, 22 Mar 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/03/xiaomi_router/</guid><description>&lt;p>{bs-font color=&amp;quot;#FF0000&amp;quot;}刷机有风险，如果能用，请不要为了不一样而刷机，又不是不能用！{/bs-font}&lt;/p>
&lt;p>现在你的路由器和小米已经没有任何关系了，恭喜你上了贼船！&lt;/p>
&lt;p>基本介绍：
OpenWrt 是一个开源的路由系统，开放、自由的特性让这个路由系统深受欢迎！
几乎所有的商业路由器品牌都是封闭的，可以操作的空间非常小，往往需要为一些小的功能，而增加几十几百甚至上千的费用。 OpenWrt很好地解决了这个问题。&lt;/p></description></item><item><title>Quartz 教程</title><link>https://caoyang2002.xyz/en/post/2024/02/quartz/</link><pubDate>Thu, 29 Feb 2024 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2024/02/quartz/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://quartz.jzhao.xyz"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原作者
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="https://www.chyraw.com"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 个人配置
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;/blockquote>
&lt;h1 id="下载">下载&lt;/h1>








&lt;div>
 &lt;pre>&lt;code class="language-bash" data-lang="bash">git clone https://github.com/caoyang2002/quartz-obsidian-webside.git
cd quartz-obsidian-webside
npm i
npx quartz build --serve&lt;/code>&lt;/pre>
&lt;/div>

&lt;h1 id="配置">配置&lt;/h1>
&lt;h2 id="布局">布局&lt;/h2>
&lt;p>某些 emitters 可能还会输出HTML文件。为了方便定制，这些 emitters 允许您完全重新排列页面的布局。
默认页面布局可以在 &lt;code>quartz.layout.ts&lt;/code> 中找到。&lt;/p>
&lt;p>每个页面由多个不同的部分组成，这些部分包含 &lt;code>QuartzComponents&lt;/code>。以下代码片段列出了您可以向其中添加组件的所有有效部分：&lt;/p></description></item><item><title>C 语言推荐书籍</title><link>https://caoyang2002.xyz/en/post/2023/11/c_book/</link><pubDate>Wed, 29 Nov 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/11/c_book/</guid><description>&lt;h1 id="c语言系列">C语言系列&lt;/h1>
&lt;ol>
&lt;li>《C漏洞与缺陷》&lt;/li>
&lt;li>《C语言深度解剖》&lt;/li>
&lt;li>《C和指针》&lt;/li>
&lt;li>《明解C语言》&lt;/li>
&lt;/ol>
&lt;h1 id="c系列">C++系列&lt;/h1>
&lt;ol>
&lt;li>《高质量的C/C++编程》&lt;/li>
&lt;li>《程序员的自我修养》&lt;/li>
&lt;/ol>
&lt;h1 id="java系列">java系列&lt;/h1>
&lt;ol>
&lt;li>《java编程思想》&lt;/li>
&lt;/ol>
&lt;h1 id="计算机系列">计算机系列&lt;/h1>
&lt;ol>
&lt;li>深入理解计算机系统&lt;/li>
&lt;/ol>
&lt;h1 id="数据结构">数据结构&lt;/h1>
&lt;ol>
&lt;li>《大话数据结构》&lt;/li>
&lt;/ol>
&lt;h1 id="内存">内存&lt;/h1>
&lt;ol>
&lt;li>《地址的故事》&lt;/li>
&lt;/ol>
&lt;h1 id="编程">编程&lt;/h1>
&lt;ol>
&lt;li>《程序员编程故事》&lt;/li>
&lt;/ol>
&lt;h1 id="算法">算法&lt;/h1>
&lt;ol>
&lt;li>《剑指offer》&lt;/li>
&lt;/ol></description></item><item><title>左耳朵耗子：技术领导力</title><link>https://caoyang2002.xyz/en/post/2023/11/houle/</link><pubDate>Wed, 29 Nov 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/11/houle/</guid><description>&lt;h1 id="技术领导力">技术领导力&lt;/h1>
&lt;ul>
&lt;li>《C语言程序设计（第二版）》&lt;/li>
&lt;li>《深入理解计算机系统》&lt;/li>
&lt;li>《UNIX环境高级编程》&lt;/li>
&lt;li>《UNIX网络编程》&lt;/li>
&lt;li>《Windows核心编程》&lt;/li>
&lt;li>《TCP/IP详解》&lt;/li>
&lt;/ul>
&lt;h1 id="每个程序员都应该要读的书">每个程序员都应该要读的书&lt;/h1>
&lt;ul>
&lt;li>《Code Complete (2nd edition) 》《代码大全》&lt;/li>
&lt;li>《The Pragmatic Programmer》 《程序员修炼之道》&lt;/li>
&lt;li>《Structure and interpretation of Computer Programs》&lt;/li>
&lt;li>《The C Programming Language》&lt;/li>
&lt;li>《Introduction to Algorithms 》&lt;/li>
&lt;li>《Design Patterns》&lt;/li>
&lt;li>《Refactoring: Improving the Design of Exsting Code》&lt;/li>
&lt;li>《The Mythical Man Month》&lt;/li>
&lt;li>《The Art of Computer Programming》&lt;/li>
&lt;li>《Compilers: Principles, Techniques and Tool》&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="推荐">推荐&lt;/h2>
&lt;ul>
&lt;li>《代码大全》&lt;/li>
&lt;li>《程序员修炼之道》&lt;/li>
&lt;li>《计算机的构造和解释》&lt;/li>
&lt;li>《算法导论》&lt;/li>
&lt;li>《设计模式》&lt;/li>
&lt;li>《重构》&lt;/li>
&lt;li>《人月神话》&lt;/li>
&lt;li>《代码整洁之道》&lt;/li>
&lt;li>《Effective C++》/《More Effective C++》&lt;/li>
&lt;li>《Unix编程艺术》《Unix高级环境编程》&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h1 id="经典文章">经典文章&lt;/h1>
&lt;ul>
&lt;li>《What every computer science major should know》&lt;/li>
&lt;li>《LinkedIn&amp;rsquo;s Tips for Highly Effective Code Review》&lt;/li>
&lt;li>《A Large-Scale Study of Programming Language and Code Quality in Github》&lt;/li>
&lt;li>《Optimizing Software in C++ - Agner Fog》&lt;/li>
&lt;/ul></description></item><item><title>OpenWRT 教程</title><link>https://caoyang2002.xyz/en/post/2023/10/openwrt/</link><pubDate>Sun, 29 Oct 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/10/openwrt/</guid><description>&lt;p>
&lt;a href="https://lidrive.vip/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 OpenWRT下载地址
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="下载">下载&lt;/h1>
&lt;p>&lt;img src="https://www.caoyang2002.top/usr/uploads/2023/12/3668705269.png" alt="版本">&lt;/p>
&lt;h1 id="制作启动盘">制作启动盘&lt;/h1>
&lt;p>将PE系统写入到U盘，window：rufus，macOS：balenaEtcher
将OpenWRT镜像、rufus（在PE系统上写盘会需要）拷贝到写完的U盘里（也可以用另一个U盘）&lt;/p>
&lt;h1 id="进入bios">进入BIOS&lt;/h1>
&lt;p>将U盘插入至路由器，根据硬件选择启动顺序为U盘，笔者的路由器是F12&lt;/p>
&lt;h1 id="删除设备的磁盘分区">删除设备的磁盘分区&lt;/h1>
&lt;p>进入PE系统之后，打开rufus（按Ctrl-Alt-F开启内部磁盘的识别），选择OpenWRT镜像并将其写入到内置的磁盘&lt;/p></description></item><item><title>左耳朵耗子：程序员</title><link>https://caoyang2002.xyz/en/post/2023/09/coder/</link><pubDate>Fri, 29 Sep 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/09/coder/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>本质上来说，程序员就是个手艺人，有手艺的人就能做出别人做不出来的东西，而付费就是一件很自然的事了。&lt;/p>
&lt;h1 id="提升方法">提升方法&lt;/h1>
&lt;ul>
&lt;li>要去经历大多数人经历不到的， 要把时间花在那些比较难的地方。&lt;/li>
&lt;li>要写文章就写没有人写过的，或者是别人写过，但是自己能写得更好的。&lt;/li>
&lt;li>更重要的是， 技术和知识是完全可以变现的。&lt;/li>
&lt;/ul>
&lt;h1 id="如何变现">如何变现&lt;/h1>
&lt;h2 id="一积累">一、积累&lt;/h2>
&lt;p>千里之行，积于跬步。任何一件事都是通过小成功达到的，所以你得确保自己有一个一个的小成功，具体来说，你得让你身边的人 有求于你，或是向别人推荐你，这就需要你能够掌握大多数人不能掌握的技术，需要你更多地去学习，并要更多的别人没有的经验和经历。&lt;/p></description></item><item><title>群晖开发</title><link>https://caoyang2002.xyz/en/post/2023/08/synology/</link><pubDate>Tue, 29 Aug 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/08/synology/</guid><description>&lt;p>
&lt;a href="https://blog.csdn.net/christmans/article/details/129641264"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 原文链接
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="查看-cpu-架构">查看 CPU 架构&lt;/h1>








&lt;div>
 &lt;pre>&lt;code class="language-shell" data-lang="shell">uname -m：该命令会输出当前系统的CPU架构，如x86_64、i386、armv7l等。
arch：该命令可以查看Linux系统的CPU架构。
cat /proc/version：该命令可以查看系统内核的版本信息。
cat /proc/cpuinfo：该命令可以查看CPU信息，如每个物理CPU中core的个数、逻辑CPU的个数、CPU型号等。&lt;/code>&lt;/pre>
&lt;/div>

&lt;blockquote>
&lt;p>
&lt;a href="http://ipkg.nslu2-linux.org/optware-ng/bootstrap/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 脚本目录
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p></description></item><item><title>浮点数的存储</title><link>https://caoyang2002.xyz/en/post/2023/07/float_at_mem/</link><pubDate>Sat, 29 Jul 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/07/float_at_mem/</guid><description>&lt;h1 id="浮点数的存储">浮点数的存储&lt;/h1>
&lt;blockquote>
&lt;p>IEEE745 国际标准：&lt;/p>
&lt;p>任意一个二进制的浮点数可以表示为下面的形式：&lt;/p>
&lt;ul>
&lt;li>V = (-1)^s^ * M * 2^E^&lt;/li>
&lt;li>(-1)^s^表示符号位，当S=0的时候V为正数，当S=1的时候V为负数&lt;/li>
&lt;li>M表示有效数字，大于等于1，小于2; 1&amp;lt;= M &amp;lt;2&lt;/li>
&lt;li>2^E^：E表示指数位&lt;/li>
&lt;/ul>
&lt;p>科学计数法：123.45 = 1.2345 * 10^2^&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>举例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>V = 5.0 f&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二进制：101.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>科学计数法：1.01 * 2^2^&lt;/p></description></item><item><title>函数栈帧的创建和销毁</title><link>https://caoyang2002.xyz/en/post/2023/07/function_stack/</link><pubDate>Sat, 15 Jul 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/07/function_stack/</guid><description>&lt;p>&lt;code>C/C++&lt;/code>&lt;/p>
&lt;p>函数栈帧的创建和销毁&lt;/p>
&lt;p>在学习最基础的C语言程序的语法与使用时，但你是否有疑问？&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>函数的作用域是怎么形成的呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>局部变量是如何创建的？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为什么未初始化的局部变量的值是随机值或是乱码呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数是如何传参的？&lt;/p>
&lt;p>传参的顺序又是怎么样的呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>形参和实参的关系是什么？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数的调用是怎么实现的呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数调用结束后是怎么返回的呢？&lt;/p></description></item><item><title>C 语言数学</title><link>https://caoyang2002.xyz/en/post/2023/06/c_number/</link><pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/06/c_number/</guid><description>&lt;ul>
&lt;li>暴力算法&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>时间复杂度过大&lt;/p>
&lt;/blockquote>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc/_malloc.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
// 最大公约数
// 最小公倍数
//计算最小公倍数和最大公约数的和
int main(){
 int n = 0;
 int m = 0;
 while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m) == 2){//读取两个数
 int min = n &amp;lt; m ? n : m;
 int max = n &amp;gt; m ? n : m;
 int i = min;//最大公约数
 int j = max;//最小公倍数
 while(1){
 if(n%i == 0 &amp;amp;&amp;amp; m%i == 0){
 break;
 }
 i--;
 }
 // i就是最大公约数
 while(1){
 if(j%n == 0 &amp;amp;&amp;amp; j%m == 0){
 break;
 }
 j&amp;#43;&amp;#43;;
 }
 // j就是最大公倍数

 printf(&amp;#34;最大公倍数 %d &amp;#43; 最小公约数 %d = %d\n&amp;#34;,j,i,j&amp;#43;i);
 }
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div>

&lt;hr>
&lt;ul>
&lt;li>辗转相除法&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>两个数的&lt;em>&lt;strong>最大公约数&lt;/strong>&lt;/em>等于其中较小的数字和二者之间余数的最大公约数&lt;/p></description></item><item><title>C 语言结构体</title><link>https://caoyang2002.xyz/en/post/2023/06/c_struct/</link><pubDate>Thu, 29 Jun 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/06/c_struct/</guid><description>&lt;h1 id="结构体内存对齐">结构体内存对齐&lt;/h1>








&lt;div>
 &lt;pre>&lt;code class="language-c" data-lang="c">#include &amp;lt;stdio.h&amp;gt;
struct S1{
 char c1;//1
 int i;//4
 char c2;//1
};

struct S2{
 char c1;//1
 char c2;//1
 int i;//4
};
int main(){
 printf(&amp;#34;%d\n&amp;#34;,sizeof(struct S1));//12
 printf(&amp;#34;%d\n&amp;#34;,sizeof(struct S2));//8
 return 0;
}&lt;/code>&lt;/pre>
&lt;/div>

&lt;p>对齐规则：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>第一个成员在与结构体变量偏移量为0的地址处&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处
对齐数 = 编译默认的一个对齐数与该成员大小的&lt;strong>较小值&lt;/strong>。 vs中默认是8&lt;/p>
&lt;p>(即：第二个成员和编译器的默认对齐数比较大小,第三个成员和编译器的默认对齐数比较大小,第四个成员和编译器的默认对齐数比较大小&amp;hellip;..)&lt;/p></description></item><item><title>C++ 命名规范</title><link>https://caoyang2002.xyz/en/post/2023/05/cpp_named/</link><pubDate>Mon, 29 May 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/05/cpp_named/</guid><description>&lt;p>
&lt;a href="https://codeif.xinke.org.cn"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 codeif
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p>
&lt;h1 id="文件命名">文件命名&lt;/h1>
&lt;blockquote>
&lt;p>所有文件&lt;/p>
&lt;p>头文件和原文件成对出现&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>全部小写, 可是使用下划线&amp;quot;_&amp;quot;(默认)或连字符&amp;quot;-&amp;quot;, 称完整, 不要有歧义&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>system_file.c &amp;amp; system_file.h&lt;/li>
&lt;li>item_name.c&lt;/li>
&lt;li>item-name.c&lt;/li>
&lt;/ul>
&lt;h1 id="类型命名">类型命名&lt;/h1>
&lt;blockquote>
&lt;p>类, 结构体, 类型定义(Typedef), 枚举, 类型模板参数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>每个单词首字母大写, 不使用下划线&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Number&lt;/li>
&lt;li>Timer&lt;/li>
&lt;li>File&lt;/li>
&lt;li>Name&lt;/li>
&lt;/ul>
&lt;h1 id="变量命名">变量命名&lt;/h1>
&lt;blockquote>
&lt;p>变量, 函数参数, 数据成员名&lt;/p></description></item><item><title>mermaid 教程</title><link>https://caoyang2002.xyz/en/post/2023/03/marmaid/</link><pubDate>Sun, 19 Mar 2023 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2023/03/marmaid/</guid><description>&lt;p>mermaid可以在主流的markdown工具中使用
下面是几个常用的图示类型&lt;/p>
&lt;h4 id="1思维导图">1.思维导图&lt;/h4>
&lt;ul>
&lt;li>空格敏感&lt;/li>
&lt;/ul>







&lt;div class="mermaid">mindmap
 root((思维导图))
 节点一
 记录1.1
 ::icon(fa fa-book)
 节点1.1
 记录1.1.1
 节点二
 记录2.1
 记录2.2
 节点2.1
 记录2.1.1
 			记录2.1.2
 	记录2.1.3
 节点三
 记录3.1
 记录3.2&lt;/div>

&lt;ul>
&lt;li>
&lt;p>基础&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语法&lt;/p>
&lt;ul>
&lt;li>
&lt;p>形状&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认&lt;/p>







&lt;div class="mermaid">mindmap
 I am the default shape&lt;/div>

&lt;/li>
&lt;li>
&lt;p>&lt;code>[]&lt;/code>矩形&lt;/p></description></item><item><title>字符图片</title><link>https://caoyang2002.xyz/en/post/2022/07/chart_image/</link><pubDate>Fri, 29 Jul 2022 09:31:37 +0800</pubDate><guid>https://caoyang2002.xyz/en/post/2022/07/chart_image/</guid><description>&lt;p>&lt;img src="https://www.caoyang2002.top/usr/uploads/2023/10/958002088.jpg" alt="beautiful.jpg">
&lt;img src="https://www.caoyang2002.top/usr/uploads/2023/10/1324992575.jpg" alt="cool.jpg">&lt;/p>
&lt;p>
&lt;a href="http://patorjk.com/software/taag"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://patorjk.com/software/taag
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="http://www.network-science.de/ascii/"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://www.network-science.de/ascii/
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="http://www.degraeve.com/img2txt.php"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://www.degraeve.com/img2txt.php
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>


&lt;a href="http://life.chacuo.net/convertfont2char"
 
 
 target="_blank"
 rel="noopener noreferrer"
 class="external-link"
 >
 http://life.chacuo.net/convertfont2char
 
 &lt;span class="external-icon">↗&lt;/span>
 
&lt;/a>
&lt;/p></description></item></channel></rss>